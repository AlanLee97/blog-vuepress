{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Blog | AlanLee",
  "home_page_url": "http://blog.alanlee.top/blog-vuepress/",
  "feed_url": "http://blog.alanlee.top/blog-vuepress/feed.json",
  "description": "If the short cut to learning, it also must be diligent.",
  "author": {
    "name": "AlanLee"
  },
  "items": [
    {
      "title": "关于我",
      "url": "http://blog.alanlee.top/blog-vuepress/about/",
      "id": "http://blog.alanlee.top/blog-vuepress/about/",
      "content_html": "<h1 id=\"关于我\"> 关于我</h1>\n<img style=\"width: 30%\" :src=\"$withBase=('/note_images/AlanLee.jpg')\"/>\n<h2 id=\"姓名\"> 姓名</h2>\n<p>中文名 | 李步官</p>\n<p>英文名 | AlanLee</p>\n<h2 id=\"学历\"> 学历</h2>\n<p>学校 | 中山大学新华学院 (2017-2021)</p>\n<p>学历 | 本科</p>\n<p>专业 | 软件工程</p>\n<h2 id=\"生日\"> 生日</h2>\n<p>出生年月 | 1997.04</p>\n<h2 id=\"喜欢\"> 喜欢</h2>\n<p>风景 | 蔚蓝的大海 | 蓝天白云 | 晨曦 | 晚霞</p>\n<p>水果 | 苹果 | 葡萄 | 哈密瓜</p>\n<p>运动 | 跑步 | 家庭健身</p>\n<p>动漫 | 火影忍者</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Java",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/",
      "content_html": "<h1 id=\"java\"> Java</h1>\n<img :src=\"$withBase=('/note_images/java.jpg')\"/>\n<p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程  。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "SpringBoot+Vue前后端分离集成JWT",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/demo/SpringBoot+Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%9B%86%E6%88%90JWT/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/demo/SpringBoot+Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%9B%86%E6%88%90JWT/",
      "content_html": "<h1 id=\"springboot-vue前后端分离集成jwt\"> SpringBoot+Vue前后端分离集成JWT</h1>\n<blockquote>\n<p>源代码：https://github.com/AlanLee97/code-demos/tree/master/jwt</p>\n</blockquote>\n<h2 id=\"一、搭建springboot项目\"> 一、搭建SpringBoot项目</h2>\n<ol>\n<li>\n<p>添加jwt依赖</p>\n<div><pre><code><span>&lt;!-- ======BEGIN jwt ====== --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.auth0<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>java-jwt<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>3.10.3<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>io.jsonwebtoken<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>jjwt<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>0.9.1<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n<span>&lt;!-- ======END jwt ====== --></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>\n<li>\n<p>编码</p>\n</li>\n</ol>\n<p>目录结构</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200906223514064-1599405347357.png\" alt=\"image-20200906223514064\" /></p>\n<p>JwtConfigProperties.java</p>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>config</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>boot<span>.</span>context<span>.</span>properties<span>.</span></span><span>ConfigurationProperties</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>stereotype<span>.</span></span><span>Component</span><span>;</span>\n\n<span>/**\n * 配置属性类\n */</span>\n<span>@Component</span>\n<span>@ConfigurationProperties</span><span>(</span>prefix <span>=</span> <span>\"jwt\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>JwtConfigProperties</span><span>{</span>\n    <span>private</span> <span>long</span> expire<span>;</span>\n    <span>private</span> <span>String</span> secret<span>;</span>\n\n    <span>public</span> <span>JwtConfigProperties</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>public</span> <span>JwtConfigProperties</span><span>(</span><span>long</span> expire<span>,</span> <span>String</span> secret<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>expire <span>=</span> expire<span>;</span>\n        <span>this</span><span>.</span>secret <span>=</span> secret<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>long</span> <span>getExpire</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> expire<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setExpire</span><span>(</span><span>long</span> expire<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>expire <span>=</span> expire<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>getSecret</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> secret<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setSecret</span><span>(</span><span>String</span> secret<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>secret <span>=</span> secret<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"JwtConfigProperties{\"</span> <span>+</span>\n                <span>\"expire=\"</span> <span>+</span> expire <span>+</span>\n                <span>\", secret='\"</span> <span>+</span> secret <span>+</span> <span>'\\''</span> <span>+</span>\n                <span>'}'</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>JwtConfigProperties是自定义的配置类，创建了这个类之后就可以在application.yml添加配置了</p>\n<div><pre><code><span># 自定义的jwt配置</span>\n<span>jwt</span><span>:</span>\n  <span># 过期时间：2小时</span>\n  <span>expire</span><span>:</span> <span>7200000</span>\n  <span># 密钥</span>\n  <span>secret</span><span>:</span> 6Dx8SIuaHXJYnpsG18SSpjPs50lZcT52\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>JWTUtil.java</p>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>util</span><span>;</span>\n\n<span>import</span> <span>com<span>.</span>auth0<span>.</span>jwt<span>.</span></span>JWT<span>;</span>\n<span>import</span> <span>com<span>.</span>auth0<span>.</span>jwt<span>.</span>algorithms<span>.</span></span><span>Algorithm</span><span>;</span>\n<span>import</span> <span>com<span>.</span>auth0<span>.</span>jwt<span>.</span>exceptions<span>.</span></span><span>JWTDecodeException</span><span>;</span>\n<span>import</span> <span>com<span>.</span>auth0<span>.</span>jwt<span>.</span>exceptions<span>.</span></span><span>SignatureVerificationException</span><span>;</span>\n<span>import</span> <span>com<span>.</span>auth0<span>.</span>jwt<span>.</span>exceptions<span>.</span></span><span>TokenExpiredException</span><span>;</span>\n<span>import</span> <span>com<span>.</span>auth0<span>.</span>jwt<span>.</span>interfaces<span>.</span></span><span>DecodedJWT</span><span>;</span>\n<span>import</span> <span>com<span>.</span>auth0<span>.</span>jwt<span>.</span>interfaces<span>.</span></span><span>JWTVerifier</span><span>;</span>\n<span>import</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>config<span>.</span></span><span>JwtConfigProperties</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Date</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>JWTUtil</span> <span>{</span>\n    <span>/**\n     * 校验token是否正确\n     * @param token 密钥\n     * @return 是否正确\n     */</span>\n    <span>public</span> <span>static</span> <span>boolean</span> <span>verify</span><span>(</span><span>String</span> token<span>,</span> <span>JwtConfigProperties</span> jwtConfigProperties<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>Algorithm</span> algorithm <span>=</span> <span>Algorithm</span><span>.</span><span>HMAC256</span><span>(</span>jwtConfigProperties<span>.</span><span>getSecret</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>JWTVerifier</span> verifier <span>=</span> JWT<span>.</span><span>require</span><span>(</span>algorithm<span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n            <span>DecodedJWT</span> jwt <span>=</span> verifier<span>.</span><span>verify</span><span>(</span>token<span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>jwt<span>)</span><span>;</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>TokenExpiredException</span> tokenExpiredException<span>)</span><span>{</span>\n            <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>JwtVerifyConst</span><span>.</span>EXPIRED<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>SignatureVerificationException</span> signatureVerificationException<span>)</span><span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"token验证失败\"</span><span>)</span><span>;</span>\n            <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>JwtVerifyConst</span><span>.</span>SIGNATURE_VERIFICATION<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>JWTDecodeException</span> jwtDecodeException<span>)</span><span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"token解析失败\"</span><span>)</span><span>;</span>\n            <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>JwtVerifyConst</span><span>.</span>DECODE_ERROR<span>)</span><span>;</span>\n        <span>}</span>\n        <span>catch</span> <span>(</span><span>Exception</span> exception<span>)</span> <span>{</span>\n            exception<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>JwtVerifyConst</span><span>.</span>NOT_LOGIN<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     * 获得token中的信息无需secret解密也能获得\n     * @return token中包含的用户名\n     */</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>getUsername</span><span>(</span><span>String</span> token<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>DecodedJWT</span> jwt <span>=</span> JWT<span>.</span><span>decode</span><span>(</span>token<span>)</span><span>;</span>\n            <span>return</span> jwt<span>.</span><span>getClaim</span><span>(</span><span>\"username\"</span><span>)</span><span>.</span><span>asString</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>JWTDecodeException</span> e<span>)</span> <span>{</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     * 生成签名,5min后过期\n     * @param username 用户名\n     * @return 加密的token\n     */</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>sign</span><span>(</span><span>String</span> username<span>,</span> <span>JwtConfigProperties</span> jwtConfigProperties<span>)</span> <span>{</span>\n        <span>Date</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>+</span>jwtConfigProperties<span>.</span><span>getExpire</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Algorithm</span> algorithm <span>=</span> <span>Algorithm</span><span>.</span><span>HMAC256</span><span>(</span>jwtConfigProperties<span>.</span><span>getSecret</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 附带username信息</span>\n        <span>return</span> JWT<span>.</span><span>create</span><span>(</span><span>)</span>\n                <span>.</span><span>withClaim</span><span>(</span><span>\"username\"</span><span>,</span> username<span>)</span>\n                <span>.</span><span>withExpiresAt</span><span>(</span>date<span>)</span>\n                <span>.</span><span>sign</span><span>(</span>algorithm<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>/**\n * 验证结果常量\n */</span>\n<span>class</span> <span>JwtVerifyConst</span><span>{</span>\n    <span>public</span> <span>static</span> <span>String</span> SUCCESS <span>=</span> <span>\"token验证成功\"</span><span>;</span>\n    <span>public</span> <span>static</span> <span>String</span> EXPIRED <span>=</span> <span>\"token已过期\"</span><span>;</span>\n    <span>public</span> <span>static</span> <span>String</span> SIGNATURE_VERIFICATION <span>=</span> <span>\"token签名失败\"</span><span>;</span>\n    <span>public</span> <span>static</span> <span>String</span> DECODE_ERROR <span>=</span> <span>\"token解析失败，请重新登录获取token\"</span><span>;</span>\n    <span>public</span> <span>static</span> <span>String</span> NOT_LOGIN <span>=</span> <span>\"未登录\"</span><span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br></div></div><p>JwtInterceptor.java</p>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>interceptor</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span>factory<span>.</span></span><span>BeanFactory</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span>factory<span>.</span>annotation<span>.</span></span><span>Autowired</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>http<span>.</span></span><span>HttpMethod</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>context<span>.</span>support<span>.</span></span><span>WebApplicationContextUtils</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>servlet<span>.</span>handler<span>.</span></span><span>HandlerInterceptorAdapter</span><span>;</span>\n<span>import</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>config<span>.</span></span><span>JwtConfigProperties</span><span>;</span>\n<span>import</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>util<span>.</span></span><span>JWTUtil</span><span>;</span>\n<span>import</span> <span>javax<span>.</span>servlet<span>.</span>http<span>.</span></span><span>HttpServletRequest</span><span>;</span>\n<span>import</span> <span>javax<span>.</span>servlet<span>.</span>http<span>.</span></span><span>HttpServletResponse</span><span>;</span>\n<span>import</span> <span>java<span>.</span>net<span>.</span></span><span>URLEncoder</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>JwtInterceptor</span> <span>extends</span> <span>HandlerInterceptorAdapter</span> <span>{</span>\n    <span>@Autowired</span>\n    <span>private</span> <span>JwtConfigProperties</span> jwtConfigProperties<span>;</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>boolean</span> <span>preHandle</span><span>(</span><span>HttpServletRequest</span> request<span>,</span> <span>HttpServletResponse</span> response<span>,</span> <span>Object</span> handler<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>// 这里是个坑，因为带请求带headers时，ajax会发送两次请求，</span>\n        <span>// 第一次会发送OPTIONS请求，第二次才会发生get/post请求，所以要放行OPTIONS请求</span>\n        <span>// 如果是OPTIONS请求，让其响应一个 200状态码，说明可以正常访问</span>\n        <span>if</span> <span>(</span><span>HttpMethod</span><span>.</span>OPTIONS<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span>request<span>.</span><span>getMethod</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            response<span>.</span><span>setStatus</span><span>(</span><span>HttpServletResponse</span><span>.</span>SC_OK<span>)</span><span>;</span>\n            <span>// 放行OPTIONS请求</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n\n        <span>// JwtConfigProperties通过@Autowired的值为null，所以需要通过以下方法获取bean</span>\n        <span>if</span><span>(</span>jwtConfigProperties <span>==</span> <span>null</span><span>)</span><span>{</span>\n            <span>BeanFactory</span> factory <span>=</span> <span>WebApplicationContextUtils</span><span>.</span><span>getRequiredWebApplicationContext</span><span>(</span>request<span>.</span><span>getServletContext</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            jwtConfigProperties <span>=</span> <span>(</span><span>JwtConfigProperties</span><span>)</span> factory<span>.</span><span>getBean</span><span>(</span><span>\"jwtConfigProperties\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>boolean</span> verify <span>=</span> <span>false</span><span>;</span>\n        <span>String</span> errMsg <span>=</span> <span>\"\"</span><span>;</span>\n        <span>// 获取header中的token</span>\n        <span>String</span> token <span>=</span> request<span>.</span><span>getHeader</span><span>(</span><span>\"Authorization\"</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            verify <span>=</span> <span>JWTUtil</span><span>.</span><span>verify</span><span>(</span>token<span>,</span> jwtConfigProperties<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            errMsg <span>=</span> e<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>;</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 验证token，如果验证失败就重定向到未登录页面</span>\n        <span>if</span> <span>(</span><span>!</span>verify<span>)</span><span>{</span>\n            errMsg <span>=</span> <span>URLEncoder</span><span>.</span><span>encode</span><span>(</span>errMsg<span>,</span> <span>\"UTF-8\"</span><span>)</span><span>;</span>\n            <span>//这里是个坑，在重定向这里需要设置跨域，不然vue前端会报跨域问题</span>\n            response<span>.</span><span>setHeader</span><span>(</span><span>\"Access-Control-Allow-Origin\"</span><span>,</span> <span>\"*\"</span><span>)</span><span>;</span>\n            <span>// 重定向到未登录提示页面</span>\n            response<span>.</span><span>sendRedirect</span><span>(</span><span>\"/user/unlogin?msg=\"</span> <span>+</span> errMsg<span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><p>WebConfig.java</p>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>config</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span>annotation<span>.</span></span><span>Configuration</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>servlet<span>.</span>config<span>.</span>annotation<span>.</span></span><span>CorsRegistry</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>servlet<span>.</span>config<span>.</span>annotation<span>.</span></span><span>InterceptorRegistration</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>servlet<span>.</span>config<span>.</span>annotation<span>.</span></span><span>InterceptorRegistry</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>servlet<span>.</span>config<span>.</span>annotation<span>.</span></span><span>WebMvcConfigurer</span><span>;</span>\n<span>import</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>interceptor<span>.</span></span><span>JwtInterceptor</span><span>;</span>\n\n<span>@Configuration</span>\n<span>public</span> <span>class</span> <span>WebConfig</span> <span>implements</span> <span>WebMvcConfigurer</span> <span>{</span>\n\n    <span>//配置跨域请求</span>\n    <span>public</span> <span>void</span> <span>addCorsMappings</span><span>(</span><span>CorsRegistry</span> registry<span>)</span> <span>{</span>\n        registry<span>.</span><span>addMapping</span><span>(</span><span>\"/**\"</span><span>)</span>\n                <span>.</span><span>allowedOrigins</span><span>(</span><span>\"*\"</span><span>)</span>\n                <span>.</span><span>allowedHeaders</span><span>(</span><span>\"*\"</span><span>)</span>\n                <span>.</span><span>allowedMethods</span><span>(</span><span>\"*\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>addInterceptors</span><span>(</span><span>InterceptorRegistry</span> registry<span>)</span> <span>{</span>\n        <span>InterceptorRegistration</span> interceptorRegistration <span>=</span> registry<span>.</span><span>addInterceptor</span><span>(</span><span>new</span> <span>JwtInterceptor</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 需拦截的路径</span>\n        interceptorRegistration<span>.</span><span>addPathPatterns</span><span>(</span><span>\"/**\"</span><span>)</span><span>;</span>\n        <span>// 需放行的路径</span>\n        interceptorRegistration<span>.</span><span>excludePathPatterns</span><span>(</span><span>\"/**/login\"</span><span>,</span> <span>\"/**/unlogin\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>UserController.java</p>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>controller</span><span>;</span>\n\n<span>import</span> <span>io<span>.</span>swagger<span>.</span>annotations<span>.</span></span><span>Api</span><span>;</span>\n<span>import</span> <span>io<span>.</span>swagger<span>.</span>annotations<span>.</span></span><span>ApiOperation</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span>factory<span>.</span>annotation<span>.</span></span><span>Autowired</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span>factory<span>.</span>annotation<span>.</span></span><span>Value</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>GetMapping</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>PostMapping</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RequestMapping</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RestController</span><span>;</span>\n<span>import</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>config<span>.</span></span><span>JwtConfigProperties</span><span>;</span>\n<span>import</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>dto<span>.</span></span><span>ApiJson</span><span>;</span>\n<span>import</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>entity<span>.</span></span><span>User</span><span>;</span>\n<span>import</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>service<span>.</span>impl<span>.</span></span><span>UserServiceImpl</span><span>;</span>\n<span>import</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>util<span>.</span></span><span>JWTUtil</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>UnsupportedEncodingException</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>List</span><span>;</span>\n\n<span>@RestController</span>\n<span>@RequestMapping</span><span>(</span><span>\"/user\"</span><span>)</span>\n<span>@Api</span><span>(</span>value <span>=</span> <span>\"/user\"</span><span>,</span> tags <span>=</span> <span>\"用户接口\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>UserController</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>UserServiceImpl</span> userService<span>;</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>JwtConfigProperties</span> jwtConfigProperties<span>;</span>\n\n\n    <span>@PostMapping</span><span>(</span><span>\"/login\"</span><span>)</span>\n    <span>public</span> <span>ApiJson</span> <span>login</span><span>(</span><span>String</span> username<span>,</span> <span>String</span> password<span>)</span><span>{</span>\n        <span>User</span> user <span>=</span> userService<span>.</span><span>login</span><span>(</span>username<span>,</span> password<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>user <span>!=</span> <span>null</span><span>)</span><span>{</span>\n            <span>// 登录成功，返回token</span>\n            <span>return</span> <span>ApiJson</span><span>.</span><span>ok</span><span>(</span><span>\"登录成功\"</span><span>,</span> <span>JWTUtil</span><span>.</span><span>sign</span><span>(</span>username<span>,</span> jwtConfigProperties<span>)</span><span>)</span><span>;</span>\n        <span>}</span><span>else</span> <span>{</span>\n            <span>return</span> <span>ApiJson</span><span>.</span><span>error</span><span>(</span><span>\"登录失败\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     * 未登录，没有token会重定向到这个方法来\n     * @param msg\n     * @return\n     * @throws UnsupportedEncodingException\n     */</span>\n    <span>@GetMapping</span><span>(</span><span>\"/unlogin\"</span><span>)</span>\n    <span>public</span> <span>ApiJson</span> <span>unlogin</span><span>(</span><span>String</span> msg<span>)</span> <span>throws</span> <span>UnsupportedEncodingException</span> <span>{</span>\n        <span>return</span> <span>ApiJson</span><span>.</span><span>error</span><span>(</span><span>new</span> <span>String</span><span>(</span>msg<span>.</span><span>getBytes</span><span>(</span><span>)</span><span>,</span> <span>\"UTF-8\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 获取所有用户，返回json数据，访问时需要在header中带上token（headers加上Authorization: token内容）\n     * @return 返回json数据\n     */</span>\n    <span>@RequestMapping</span><span>(</span><span>\"/get/all\"</span><span>)</span>\n    <span>@ApiOperation</span><span>(</span>value <span>=</span> <span>\"查询所有用户\"</span><span>)</span>\n    <span>public</span> <span>ApiJson</span> <span>getAllUsers</span><span>(</span><span>)</span><span>{</span>\n        <span>List</span><span><span>&lt;</span><span>User</span><span>></span></span> allUsers <span>=</span> userService<span>.</span><span>getAll</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> allUsers <span>!=</span> <span>null</span> <span>?</span> <span>ApiJson</span><span>.</span><span>ok</span><span>(</span>allUsers<span>)</span> <span>:</span> <span>ApiJson</span><span>.</span><span>error</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br></div></div><ol start=\"3\">\n<li>总结下流程</li>\n</ol>\n<ul>\n<li>用户为未登录的情况下访问需认证的模块</li>\n<li>我们设置了jwt拦截器，会把用户拦截下来进行jwt的认证</li>\n<li>第一次访问，用户没有token，后端会转发到未登录的页面<code>/user/unlogin</code>中，并提示相关信息</li>\n<li>用户根据提示去登录</li>\n<li>登录成功之后，后端会颁发token给用户</li>\n<li>用户拿到token之后，在前端把token存储起来（存到<code>localStorage</code>）</li>\n<li>用户再次访问需认证的模块时，在headers中带上token就可以访问数据</li>\n</ul>\n<p>二、搭建vue前端项目</p>\n<ol>\n<li>\n<p>目录结构</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200906225440478.png\" alt=\"image-20200906225440478\" /></p>\n</li>\n<li>\n<p>编码</p>\n</li>\n</ol>\n<p>index.js</p>\n<div><pre><code><span>&lt;</span>template<span>></span>\n  <span>&lt;</span>div<span>></span>\n    <span>&lt;</span>img src<span>=</span><span>\"../assets/logo.png\"</span> alt<span>=</span><span>\"logo\"</span> width<span>=</span><span>\"100px\"</span> height<span>=</span><span>\"100px\"</span><span>></span>\n\n    <span>&lt;</span>h1<span>></span><span>JWT</span> Demo<span>&lt;</span><span>/</span>h1<span>></span>\n\n    <span>&lt;</span>div <span>class</span><span>=</span><span>\"al-flex-justify-space-around\"</span><span>></span>\n      <span>&lt;</span>div <span>class</span><span>=</span><span>\"al-p-20px al-box-container al-box-pretty\"</span> style<span>=</span><span>\"width: 500px; height: 300px\"</span><span>></span>\n        <span>&lt;</span>p style<span>=</span><span>\"word-break: break-all; padding: 0 10px; height: 250px\"</span> <span>></span><span>{</span><span>{</span>result <span>===</span> <span>null</span> <span>?</span> <span>\"无结果\"</span> <span>:</span> result<span>}</span><span>}</span><span>&lt;</span><span>/</span>p<span>></span>\n\n        <span>&lt;</span>el<span>-</span>button @click<span>=</span><span>\"getNetworkData\"</span><span>></span>发起网络请求（需认证）<span>&lt;</span><span>/</span>el<span>-</span>button<span>></span>\n      <span>&lt;</span><span>/</span>div<span>></span>\n\n      <span>&lt;</span>div <span>class</span><span>=</span><span>\"al-p-20px al-box-container al-box-pretty\"</span> style<span>=</span><span>\"width: 500px; height: 300px\"</span><span>></span>\n        <span>&lt;</span>h3<span>></span>登录<span>&lt;</span><span>/</span>h3<span>></span>\n        <span>&lt;</span>div <span>class</span><span>=</span><span>\"al-flex-container al-flex-direction-col\"</span><span>></span>\n          <span>&lt;</span>div <span>class</span><span>=</span><span>\"al-flex-container al-flex-container-center-v\"</span><span>></span>\n            <span>&lt;</span>div style<span>=</span><span>\"width: 60px\"</span><span>></span>帐号：<span>&lt;</span><span>/</span>div<span>></span>\n            <span>&lt;</span>el<span>-</span>input v<span>-</span>model<span>=</span><span>\"formData.username\"</span><span>/</span><span>></span>\n          <span>&lt;</span><span>/</span>div<span>></span>\n          <span>&lt;</span>div style<span>=</span><span>\"height: 20px\"</span><span>></span><span>&lt;</span><span>/</span>div<span>></span>\n          <span>&lt;</span>div <span>class</span><span>=</span><span>\"al-flex-container al-flex-container-center-v\"</span><span>></span>\n            <span>&lt;</span>div style<span>=</span><span>\"width: 60px\"</span><span>></span>密码：<span>&lt;</span><span>/</span>div<span>></span>\n            <span>&lt;</span>el<span>-</span>input v<span>-</span>model<span>=</span><span>\"formData.password\"</span><span>/</span><span>></span>\n          <span>&lt;</span><span>/</span>div<span>></span>\n        <span>&lt;</span><span>/</span>div<span>></span>\n        <span>&lt;</span>el<span>-</span>button @click<span>=</span><span>\"login\"</span> type<span>=</span><span>\"primary\"</span><span>></span>登录<span>&lt;</span><span>/</span>el<span>-</span>button<span>></span>\n      <span>&lt;</span><span>/</span>div<span>></span>\n    <span>&lt;</span><span>/</span>div<span>></span>\n\n  <span>&lt;</span><span>/</span>div<span>></span>\n<span>&lt;</span><span>/</span>template<span>></span>\n\n<span>&lt;</span>script<span>></span>\n  <span>import</span> <span>{</span>request<span>}</span> <span>from</span> <span>\"@/util/network/request\"</span><span>;</span>\n  <span>import</span> qs <span>from</span> <span>\"qs\"</span><span>;</span>\n\n  <span>export</span> <span>default</span> <span>{</span>\n    name<span>:</span> <span>\"Index\"</span><span>,</span>\n    <span>//组件</span>\n    components<span>:</span> <span>{</span><span>}</span><span>,</span>\n    <span>//属性</span>\n    props<span>:</span> <span>{</span><span>}</span><span>,</span>\n\n    <span>//数据</span>\n    <span>data</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>{</span>\n        result<span>:</span> <span>null</span><span>,</span>\n        formData<span>:</span> <span>{</span>\n          username<span>:</span> <span>\"\"</span><span>,</span>\n          password<span>:</span> <span>\"\"</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span><span>,</span>\n\n    <span>//挂载完成时</span>\n    <span>mounted</span><span>(</span><span>)</span> <span>{</span>\n      <span>//this.getNetworkData();</span>\n      localStorage<span>.</span><span>setItem</span><span>(</span><span>\"token\"</span><span>,</span> <span>\"\"</span><span>)</span>\n    <span>}</span><span>,</span>\n\n    <span>//方法</span>\n    methods<span>:</span> <span>{</span>\n      <span>getNetworkData</span><span>(</span><span>)</span> <span>{</span>\n        <span>request</span><span>(</span><span>{</span>\n          url<span>:</span> <span>\"http://localhost:8080/user/get/all\"</span><span>,</span>\n          data<span>:</span> qs<span>.</span><span>stringify</span><span>(</span><span>this</span><span>.</span>data<span>)</span><span>,</span>\n          headers<span>:</span><span>{</span>\n            <span>\"Authorization\"</span><span>:</span> localStorage<span>.</span><span>getItem</span><span>(</span><span>\"token\"</span><span>)</span>\n          <span>}</span>\n        <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>\n          console<span>.</span><span>log</span><span>(</span>res<span>)</span><span>;</span>\n          <span>this</span><span>.</span>result <span>=</span> res<span>.</span>data<span>;</span>\n        <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>\n          console<span>.</span><span>log</span><span>(</span>err<span>)</span>\n        <span>}</span><span>)</span>\n      <span>}</span><span>,</span>\n\n      <span>login</span><span>(</span><span>)</span><span>{</span>\n        <span>let</span> data <span>=</span> <span>{</span>\n          username<span>:</span> <span>this</span><span>.</span>formData<span>.</span>username<span>,</span>\n          password<span>:</span> <span>this</span><span>.</span>formData<span>.</span>password<span>,</span>\n        <span>}</span>\n        console<span>.</span><span>log</span><span>(</span>data<span>)</span><span>;</span>\n\n        <span>request</span><span>(</span><span>{</span>\n          url<span>:</span> <span>\"http://localhost:8080/user/login\"</span><span>,</span>\n          method<span>:</span> <span>'post'</span><span>,</span>\n          data<span>:</span> qs<span>.</span><span>stringify</span><span>(</span>data<span>)</span>\n        <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>\n          console<span>.</span><span>log</span><span>(</span>res<span>)</span><span>;</span>\n          <span>this</span><span>.</span>result <span>=</span> res<span>.</span>data<span>;</span>\n          localStorage<span>.</span><span>setItem</span><span>(</span><span>\"token\"</span><span>,</span> res<span>.</span>data<span>.</span>data<span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>\n          console<span>.</span><span>log</span><span>(</span>err<span>)</span>\n        <span>}</span><span>)</span>\n      <span>}</span>\n    <span>}</span><span>,</span>\n\n    <span>//计算属性</span>\n    computed<span>:</span> <span>{</span><span>}</span><span>,</span>\n\n    <span>//监听</span>\n    watch<span>:</span> <span>{</span><span>}</span>\n  <span>}</span>\n<span>&lt;</span><span>/</span>script<span>></span>\n\n<span>&lt;</span>style scoped<span>></span>\n\n<span>&lt;</span><span>/</span>style<span>></span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br></div></div><p>网络请求用axios</p>\n<p>request.js</p>\n<div><pre><code><span>import</span> axios <span>from</span> <span>'axios'</span><span>;</span>\n\n<span>let</span> ip <span>=</span> <span>\"localhost\"</span><span>;</span>\n<span>let</span> port <span>=</span> <span>\"8080\"</span><span>;</span>\n<span>let</span> prefix <span>=</span> <span>\"http://\"</span> <span>+</span> ip <span>+</span> <span>\":\"</span> <span>+</span> port <span>+</span> <span>\"/\"</span><span>;</span>\n\n<span>export</span> <span>function</span> <span>request</span><span>(</span><span>config</span><span>)</span> <span>{</span>\n  <span>const</span> instance <span>=</span> axios<span>.</span><span>create</span><span>(</span><span>{</span>\n    baseURL<span>:</span> prefix<span>,</span>\n    timeout<span>:</span> <span>100000</span>\n  <span>}</span><span>)</span><span>;</span>\n\n  <span>return</span> <span>instance</span><span>(</span>config<span>)</span><span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ol start=\"3\">\n<li>前端界面</li>\n</ol>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200906225756774.png\" alt=\"image-20200906225756774\" /></p>\n<p>三、测试</p>\n<ol>\n<li>未登录情况下进行发起网络请求</li>\n</ol>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200906230059220.png\" alt=\"image-20200906230059220\" /></p>\n<ol start=\"2\">\n<li>登录获取token</li>\n</ol>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200906230441571.png\" alt=\"image-20200906230441571\" /></p>\n<ol start=\"3\">\n<li>再次点击发起网络请求，就可以获取到数据了</li>\n</ol>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200906230649729.png\" alt=\"image-20200906230649729\" /></p>\n<p>需要在headers中带上Authorization：token内容</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200906230833875.png\" alt=\"image-20200906230833875\" /></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200906231047636.png\" alt=\"image-20200906231047636\" /></p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200906223514064-1599405347357.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring Boot集成Shiro（前后端分离）",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/demo/Spring%20Boot%E9%9B%86%E6%88%90Shiro%EF%BC%88%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%EF%BC%89/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/demo/Spring%20Boot%E9%9B%86%E6%88%90Shiro%EF%BC%88%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%EF%BC%89/",
      "content_html": "<h1 id=\"spring-boot集成shiro-前后端分离\"> Spring Boot集成Shiro（前后端分离）</h1>\n<h2 id=\"添加依赖\"> 添加依赖</h2>\n<div><pre><code><span>&lt;!-- ======BEGIN shiro ====== --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n<span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.shiro<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n<span><span><span>&lt;</span>artifactId</span><span>></span></span>shiro-spring<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n<span><span><span>&lt;</span>version</span><span>></span></span>1.5.3<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n<span>&lt;!-- ======END shiro ====== --></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"创建数据表\"> 创建数据表</h2>\n<h3 id=\"用户表-t-user\"> 用户表 t_user</h3>\n<div><pre><code><span>SET</span> NAMES utf8mb4<span>;</span>\n<span>SET</span> FOREIGN_KEY_CHECKS <span>=</span> <span>0</span><span>;</span>\n\n<span>-- ----------------------------</span>\n<span>-- Table structure for t_user</span>\n<span>-- ----------------------------</span>\n<span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> <span>`</span>t_user<span>`</span><span>;</span>\n<span>CREATE</span> <span>TABLE</span> <span>`</span>t_user<span>`</span>  <span>(</span>\n  <span>`</span>id<span>`</span> <span>int</span><span>(</span><span>11</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>AUTO_INCREMENT</span> <span>COMMENT</span> <span>'id'</span><span>,</span>\n  <span>`</span>username<span>`</span> <span>varchar</span><span>(</span><span>16</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>COLLATE</span> utf8mb4_general_ci <span>NOT</span> <span>NULL</span> <span>COMMENT</span> <span>'用户名'</span><span>,</span>\n  <span>`</span>password<span>`</span> <span>varchar</span><span>(</span><span>64</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>COLLATE</span> utf8mb4_general_ci <span>NULL</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'密码'</span><span>,</span>\n  <span>`</span>nickname<span>`</span> <span>varchar</span><span>(</span><span>40</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>COLLATE</span> utf8mb4_general_ci <span>NULL</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'昵称'</span><span>,</span>\n  <span>`</span>avatar<span>`</span> <span>varchar</span><span>(</span><span>255</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>COLLATE</span> utf8mb4_general_ci <span>NULL</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'头像'</span><span>,</span>\n  <span>`</span>phone<span>`</span> <span>varchar</span><span>(</span><span>11</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>COLLATE</span> utf8mb4_general_ci <span>NULL</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'手机'</span><span>,</span>\n  <span>`</span>email<span>`</span> <span>varchar</span><span>(</span><span>60</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>COLLATE</span> utf8mb4_general_ci <span>NULL</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'邮箱'</span><span>,</span>\n  <span>`</span>create_time<span>`</span> <span>datetime</span><span>(</span><span>0</span><span>)</span> <span>NULL</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'创建时间'</span><span>,</span>\n  <span>`</span>update_time<span>`</span> <span>datetime</span><span>(</span><span>0</span><span>)</span> <span>NULL</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'更新时间'</span><span>,</span>\n  <span>`</span>role_id<span>`</span> <span>int</span><span>(</span><span>11</span><span>)</span> <span>NULL</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'角色id'</span><span>,</span>\n  <span>PRIMARY</span> <span>KEY</span> <span>(</span><span>`</span>id<span>`</span><span>)</span> <span>USING</span> <span>BTREE</span>\n<span>)</span> <span>ENGINE</span> <span>=</span> <span>InnoDB</span> <span>AUTO_INCREMENT</span> <span>=</span> <span>4</span> <span>CHARACTER</span> <span>SET</span> <span>=</span> utf8mb4 <span>COLLATE</span> <span>=</span> utf8mb4_general_ci ROW_FORMAT <span>=</span> Dynamic<span>;</span>\n\n<span>-- ----------------------------</span>\n<span>-- Records of t_user</span>\n<span>-- ----------------------------</span>\n<span>INSERT</span> <span>INTO</span> <span>`</span>t_user<span>`</span> <span>VALUES</span> <span>(</span><span>1</span><span>,</span> <span>'admin'</span><span>,</span> <span>'123456'</span><span>,</span> <span>'AlanLee'</span><span>,</span> <span>'https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/images/2019-12-10/666a1a1f72c5eae973ca0f0977adca58b89a119f236a1-3vh1WC_fw658.jpg'</span><span>,</span> <span>'12345678901'</span><span>,</span> <span>'123456@qq.com'</span><span>,</span> <span>'2020-04-13 16:49:37'</span><span>,</span> <span>'2020-04-13 16:49:41'</span><span>,</span> <span>1</span><span>)</span><span>;</span>\n<span>INSERT</span> <span>INTO</span> <span>`</span>t_user<span>`</span> <span>VALUES</span> <span>(</span><span>2</span><span>,</span> <span>'test'</span><span>,</span> <span>'123456'</span><span>,</span> <span>'用户_test'</span><span>,</span> <span>'http://b-ssl.duitang.com/uploads/item/201608/07/20160807214159_TxhRk.thumb.700_0.jpeg'</span><span>,</span> <span>'11122233345'</span><span>,</span> <span>'test@qq.com'</span><span>,</span> <span>'2020-04-13 16:57:19'</span><span>,</span> <span>'2020-04-13 16:57:21'</span><span>,</span> <span>2</span><span>)</span><span>;</span>\n<span>INSERT</span> <span>INTO</span> <span>`</span>t_user<span>`</span> <span>VALUES</span> <span>(</span><span>3</span><span>,</span> <span>'vistor'</span><span>,</span> <span>'123456'</span><span>,</span> <span>'Admin'</span><span>,</span> <span>NULL</span><span>,</span> <span>NULL</span><span>,</span> <span>NULL</span><span>,</span> <span>'2020-05-10 23:08:35'</span><span>,</span> <span>NULL</span><span>,</span> <span>3</span><span>)</span><span>;</span>\n\n<span>SET</span> FOREIGN_KEY_CHECKS <span>=</span> <span>1</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"角色表-t-role\"> 角色表 t_role</h3>\n<div><pre><code><span>SET</span> NAMES utf8mb4<span>;</span>\n<span>SET</span> FOREIGN_KEY_CHECKS <span>=</span> <span>0</span><span>;</span>\n\n<span>-- ----------------------------</span>\n<span>-- Table structure for t_role</span>\n<span>-- ----------------------------</span>\n<span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> <span>`</span>t_role<span>`</span><span>;</span>\n<span>CREATE</span> <span>TABLE</span> <span>`</span>t_role<span>`</span>  <span>(</span>\n  <span>`</span>id<span>`</span> <span>int</span><span>(</span><span>11</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>AUTO_INCREMENT</span> <span>COMMENT</span> <span>'id'</span><span>,</span>\n  <span>`</span>role_name<span>`</span> <span>varchar</span><span>(</span><span>30</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>COLLATE</span> utf8mb4_general_ci <span>NULL</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'角色名称'</span><span>,</span>\n  <span>PRIMARY</span> <span>KEY</span> <span>(</span><span>`</span>id<span>`</span><span>)</span> <span>USING</span> <span>BTREE</span>\n<span>)</span> <span>ENGINE</span> <span>=</span> <span>InnoDB</span> <span>AUTO_INCREMENT</span> <span>=</span> <span>4</span> <span>CHARACTER</span> <span>SET</span> <span>=</span> utf8mb4 <span>COLLATE</span> <span>=</span> utf8mb4_general_ci ROW_FORMAT <span>=</span> Dynamic<span>;</span>\n\n<span>-- ----------------------------</span>\n<span>-- Records of t_role</span>\n<span>-- ----------------------------</span>\n<span>INSERT</span> <span>INTO</span> <span>`</span>t_role<span>`</span> <span>VALUES</span> <span>(</span><span>1</span><span>,</span> <span>'admin'</span><span>)</span><span>;</span>\n<span>INSERT</span> <span>INTO</span> <span>`</span>t_role<span>`</span> <span>VALUES</span> <span>(</span><span>2</span><span>,</span> <span>'teacher'</span><span>)</span><span>;</span>\n<span>INSERT</span> <span>INTO</span> <span>`</span>t_role<span>`</span> <span>VALUES</span> <span>(</span><span>3</span><span>,</span> <span>'student'</span><span>)</span><span>;</span>\n\n<span>SET</span> FOREIGN_KEY_CHECKS <span>=</span> <span>1</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"权限表\"> 权限表</h3>\n<div><pre><code><span>SET</span> NAMES utf8mb4<span>;</span>\n<span>SET</span> FOREIGN_KEY_CHECKS <span>=</span> <span>0</span><span>;</span>\n\n<span>-- ----------------------------</span>\n<span>-- Table structure for t_permission</span>\n<span>-- ----------------------------</span>\n<span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> <span>`</span>t_permission<span>`</span><span>;</span>\n<span>CREATE</span> <span>TABLE</span> <span>`</span>t_permission<span>`</span>  <span>(</span>\n  <span>`</span>id<span>`</span> <span>int</span><span>(</span><span>11</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>AUTO_INCREMENT</span> <span>COMMENT</span> <span>'id'</span><span>,</span>\n  <span>`</span>permission_name<span>`</span> <span>varchar</span><span>(</span><span>30</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>COLLATE</span> utf8mb4_general_ci <span>NULL</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'权限名称'</span><span>,</span>\n  <span>`</span>role_id<span>`</span> <span>int</span><span>(</span><span>11</span><span>)</span> <span>NULL</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'角色id'</span><span>,</span>\n  <span>PRIMARY</span> <span>KEY</span> <span>(</span><span>`</span>id<span>`</span><span>)</span> <span>USING</span> <span>BTREE</span>\n<span>)</span> <span>ENGINE</span> <span>=</span> <span>InnoDB</span> <span>AUTO_INCREMENT</span> <span>=</span> <span>3</span> <span>CHARACTER</span> <span>SET</span> <span>=</span> utf8mb4 <span>COLLATE</span> <span>=</span> utf8mb4_general_ci ROW_FORMAT <span>=</span> Dynamic<span>;</span>\n\n<span>-- ----------------------------</span>\n<span>-- Records of t_permission</span>\n<span>-- ----------------------------</span>\n<span>INSERT</span> <span>INTO</span> <span>`</span>t_permission<span>`</span> <span>VALUES</span> <span>(</span><span>1</span><span>,</span> <span>'admin:*'</span><span>,</span> <span>1</span><span>)</span><span>;</span>\n<span>INSERT</span> <span>INTO</span> <span>`</span>t_permission<span>`</span> <span>VALUES</span> <span>(</span><span>2</span><span>,</span> <span>'user:*'</span><span>,</span> <span>2</span><span>)</span><span>;</span>\n\n<span>SET</span> FOREIGN_KEY_CHECKS <span>=</span> <span>1</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id=\"创建实体类\"> 创建实体类</h2>\n<p>User.java</p>\n<div><pre><code><span>public</span> <span>class</span> <span>User</span> <span>implements</span> <span>Serializable</span> <span>{</span>\n    <span>private</span> <span>int</span> id<span>;</span>\n    <span>private</span> <span>String</span> username<span>;</span>\n    <span>private</span> <span>String</span> password<span>;</span>\n    <span>private</span> <span>String</span> nickname<span>;</span>\n    <span>private</span> <span>String</span> avatar<span>;</span>\n    <span>private</span> <span>String</span> phone<span>;</span>\n    <span>private</span> <span>String</span> email<span>;</span>\n    <span>private</span> <span>String</span> create_time<span>;</span>\n    <span>private</span> <span>String</span> update_time<span>;</span>\n    <span>private</span> <span>Set</span><span><span>&lt;</span><span>Role</span><span>></span></span> roleSet<span>;</span>\n\n    <span>public</span> <span>User</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>public</span> <span>User</span><span>(</span><span>int</span> id<span>,</span> <span>String</span> username<span>,</span> <span>String</span> password<span>,</span> <span>String</span> nickname<span>,</span> <span>String</span> avatar<span>,</span> <span>String</span> phone<span>,</span> <span>String</span> email<span>,</span> <span>String</span> create_time<span>,</span> <span>String</span> update_time<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>id <span>=</span> id<span>;</span>\n        <span>this</span><span>.</span>username <span>=</span> username<span>;</span>\n        <span>this</span><span>.</span>password <span>=</span> password<span>;</span>\n        <span>this</span><span>.</span>nickname <span>=</span> nickname<span>;</span>\n        <span>this</span><span>.</span>avatar <span>=</span> avatar<span>;</span>\n        <span>this</span><span>.</span>phone <span>=</span> phone<span>;</span>\n        <span>this</span><span>.</span>email <span>=</span> email<span>;</span>\n        <span>this</span><span>.</span>create_time <span>=</span> create_time<span>;</span>\n        <span>this</span><span>.</span>update_time <span>=</span> update_time<span>;</span>\n    <span>}</span>\n\n    <span>//省略setter、getter</span>\n    <span>//...</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>Role.java</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Role</span> <span>{</span>\n    <span>private</span> <span>int</span> id<span>;</span>\n    <span>private</span> <span>String</span> user<span>;</span>\n    <span>private</span> <span>String</span> admin<span>;</span>\n    <span>private</span> <span>Set</span><span><span>&lt;</span><span>Permissions</span><span>></span></span> permissionsSet<span>;</span>\n\n    <span>public</span> <span>Role</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>public</span> <span>Role</span><span>(</span><span>int</span> id<span>,</span> <span>String</span> user<span>,</span> <span>String</span> admin<span>,</span> <span>Set</span><span><span>&lt;</span><span>Permissions</span><span>></span></span> permissionsSet<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>id <span>=</span> id<span>;</span>\n        <span>this</span><span>.</span>user <span>=</span> user<span>;</span>\n        <span>this</span><span>.</span>admin <span>=</span> admin<span>;</span>\n        <span>this</span><span>.</span>permissionsSet <span>=</span> permissionsSet<span>;</span>\n    <span>}</span>\n    \n    <span>//省略setter、getter</span>\n    <span>//...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>Permissions.java</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Permissions</span> <span>{</span>\n    <span>private</span> <span>int</span> id<span>;</span>\n    <span>private</span> <span>String</span> user<span>;</span>\n    <span>private</span> <span>String</span> admin<span>;</span>\n\n    <span>public</span> <span>Permissions</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>public</span> <span>Permissions</span><span>(</span><span>int</span> id<span>,</span> <span>String</span> user<span>,</span> <span>String</span> admin<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>id <span>=</span> id<span>;</span>\n        <span>this</span><span>.</span>user <span>=</span> user<span>;</span>\n        <span>this</span><span>.</span>admin <span>=</span> admin<span>;</span>\n    <span>}</span>\n    \n    <span>//省略setter、getter</span>\n    <span>//...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"自定义realm\"> 自定义Realm</h2>\n<p>新建shiro.realm包，在该包下创建自定义的UserRealm.java</p>\n<div><pre><code><span>public</span> <span>class</span> <span>UserRealm</span> <span>extends</span> <span>AuthorizingRealm</span> <span>{</span>\n\n    <span>/**\n     * 注入service\n     */</span>\n    <span>@Resource</span>\n    <span>private</span> <span>UserServiceImpl</span> userService<span>;</span>\n\n    <span>/**\n     * 授权\n     * @param principalCollection\n     * @return\n     */</span>\n    <span>@Override</span>\n    <span>protected</span> <span>AuthorizationInfo</span> <span>doGetAuthorizationInfo</span><span>(</span><span>PrincipalCollection</span> principalCollection<span>)</span> <span>{</span>\n        <span>String</span> username <span>=</span> <span>(</span><span>String</span><span>)</span> principalCollection<span>.</span><span>getPrimaryPrincipal</span><span>(</span><span>)</span><span>;</span>\n        <span>SimpleAuthorizationInfo</span> authorizationInfo <span>=</span> <span>new</span> <span>SimpleAuthorizationInfo</span><span>(</span><span>)</span><span>;</span>\n        authorizationInfo<span>.</span><span>setRoles</span><span>(</span>userService<span>.</span><span>getRoles</span><span>(</span>username<span>)</span><span>)</span><span>;</span>\n        authorizationInfo<span>.</span><span>setStringPermissions</span><span>(</span>userService<span>.</span><span>getPermissions</span><span>(</span>username<span>)</span><span>)</span><span>;</span>\n        <span>return</span> authorizationInfo<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 认证\n     * @param authenticationToken\n     * @return\n     * @throws AuthenticationException\n     */</span>\n    <span>@Override</span>\n    <span>protected</span> <span>AuthenticationInfo</span> <span>doGetAuthenticationInfo</span><span>(</span><span>AuthenticationToken</span> authenticationToken<span>)</span> <span>throws</span> <span>AuthenticationException</span> <span>{</span>\n        <span>String</span> username <span>=</span> <span>(</span><span>String</span><span>)</span> authenticationToken<span>.</span><span>getPrincipal</span><span>(</span><span>)</span><span>;</span>\n        <span>//从数据库中查询该用户</span>\n        <span>User</span> user <span>=</span> userService<span>.</span><span>getOneByUsernameAndPassword</span><span>(</span>userService<span>.</span><span>getUserByUsername</span><span>(</span>username<span>)</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>user <span>!=</span> <span>null</span><span>)</span><span>{</span>\n            <span>SecurityUtils</span><span>.</span><span>getSubject</span><span>(</span><span>)</span><span>.</span><span>getSession</span><span>(</span><span>)</span><span>.</span><span>setAttribute</span><span>(</span><span>\"user\"</span><span>,</span> user<span>)</span><span>;</span>\n            <span>AuthenticationInfo</span> authenticationInfo <span>=</span> \n                    <span>new</span> <span>SimpleAuthenticationInfo</span><span>(</span>user<span>.</span><span>getUsername</span><span>(</span><span>)</span><span>,</span> user<span>.</span><span>getPassword</span><span>(</span><span>)</span><span>,</span> <span>\"userRealm\"</span><span>)</span><span>;</span>\n            <span>return</span> authenticationInfo<span>;</span>\n        <span>}</span>\n        <span>return</span> <span>null</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>自定义的Realm需要实现AuthorizingRealm接口，并重写<code>doGetAuthorizationInfo</code> 和 <code>doGetAuthenticationInfo</code>方法</p>\n<h2 id=\"配置shiro\"> 配置Shiro</h2>\n<p>创建config，在该包下创建ShiroConfig.java</p>\n<div><pre><code><span>@Configuration</span>\n<span>public</span> <span>class</span> <span>ShiroConfig</span> <span>{</span>\n    <span>private</span> <span>Logger</span> logger <span>=</span> <span>LoggerFactory</span><span>.</span><span>getLogger</span><span>(</span><span>ShiroConfig</span><span>.</span><span>class</span><span>)</span><span>;</span>\n\n    <span>/**\n     * 注册自定义Realm\n     * @return\n     */</span>\n    <span>@Bean</span>\n    <span>public</span> <span>UserRealm</span> <span>userRealm</span><span>(</span><span>)</span><span>{</span>\n        <span>UserRealm</span> userRealm <span>=</span> <span>new</span> <span>UserRealm</span><span>(</span><span>)</span><span>;</span>\n        logger<span>.</span><span>info</span><span>(</span><span>\"=====userRealm构建完成\"</span><span>)</span><span>;</span>\n        <span>return</span> userRealm<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 配置安全管理器\n     * @return\n     */</span>\n    <span>@Bean</span>\n    <span>public</span> <span>SecurityManager</span> <span>securityManager</span><span>(</span><span>)</span><span>{</span>\n        <span>DefaultWebSecurityManager</span> securityManager <span>=</span> <span>new</span> <span>DefaultWebSecurityManager</span><span>(</span><span>userRealm</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        logger<span>.</span><span>info</span><span>(</span><span>\"=====securityManager构建完成\"</span><span>)</span><span>;</span>\n        <span>return</span> securityManager<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * Shiro过滤器\n     * @param securityManager\n     * @return\n     */</span>\n    <span>@Bean</span>\n    <span>public</span> <span>ShiroFilterFactoryBean</span> <span>shiroFilterFactoryBean</span><span>(</span><span>SecurityManager</span> securityManager<span>)</span><span>{</span>\n        <span>ShiroFilterFactoryBean</span> filterFactoryBean <span>=</span> <span>new</span> <span>ShiroFilterFactoryBean</span><span>(</span><span>)</span><span>;</span>\n        filterFactoryBean<span>.</span><span>setSecurityManager</span><span>(</span>securityManager<span>)</span><span>;</span>\n        filterFactoryBean<span>.</span><span>setLoginUrl</span><span>(</span><span>\"/user/unlogin\"</span><span>)</span><span>;</span>\n        <span>//todo</span>\n        filterFactoryBean<span>.</span><span>setSuccessUrl</span><span>(</span><span>\"/user/info\"</span><span>)</span><span>;</span>\n        filterFactoryBean<span>.</span><span>setUnauthorizedUrl</span><span>(</span><span>\"/unauth\"</span><span>)</span><span>;</span>\n\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> filterChainMap <span>=</span> <span>new</span> <span>LinkedHashMap</span><span>(</span><span>)</span><span>;</span>\n        <span>//放行</span>\n        filterChainMap<span>.</span><span>put</span><span>(</span><span>\"/login\"</span><span>,</span> <span>\"anon\"</span><span>)</span><span>;</span>\n        filterChainMap<span>.</span><span>put</span><span>(</span><span>\"/index\"</span><span>,</span> <span>\"anon\"</span><span>)</span><span>;</span>\n\n        <span>//认证授权才放行</span>\n        <span>//开启身份认证</span>\n        filterChainMap<span>.</span><span>put</span><span>(</span><span>\"/user/admin*\"</span><span>,</span> <span>\"authc\"</span><span>)</span><span>;</span>\n        <span>//开启角色认证</span>\n        filterChainMap<span>.</span><span>put</span><span>(</span><span>\"/user/student*/**\"</span><span>,</span> <span>\"roles[admin]\"</span><span>)</span><span>;</span>\n        <span>//开启权限认证</span>\n        filterChainMap<span>.</span><span>put</span><span>(</span><span>\"/user/teacher*/**\"</span><span>,</span> <span>\"perms[\\\"user:create\\\"]\"</span><span>)</span><span>;</span>\n\n        <span>//配置退出登录过滤器</span>\n        filterChainMap<span>.</span><span>put</span><span>(</span><span>\"/user/logout/*\"</span><span>,</span> <span>\"logout\"</span><span>)</span><span>;</span>\n\n        filterFactoryBean<span>.</span><span>setFilterChainDefinitionMap</span><span>(</span>filterChainMap<span>)</span><span>;</span>\n\n        logger<span>.</span><span>info</span><span>(</span><span>\"=====filterFactoryBean构建完成\"</span><span>)</span><span>;</span>\n\n        <span>return</span> filterFactoryBean<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><h2 id=\"配置mybatis查询\"> 配置Mybatis查询</h2>\n<p>UserMapper.java</p>\n<div><pre><code><span>@Mapper</span>\n<span>@Repository</span>\n<span>public</span> <span>interface</span> <span>UserMapper</span><span>{</span>\n    <span>//通过用户名和密码查询用户</span>\n    <span>User</span> <span>getOneByUsernameAndPassword</span><span>(</span><span>User</span> user<span>)</span><span>;</span>\n\n    <span>//通过用户名查询用户</span>\n    <span>User</span> <span>getUserByUsername</span><span>(</span><span>String</span> username<span>)</span><span>;</span>\n\n    <span>//通过用户名查询角色</span>\n    <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>getRoles</span><span>(</span><span>String</span> username<span>)</span><span>;</span>\n\n    <span>//通过用户名查询权限</span>\n    <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>getPermissions</span><span>(</span><span>String</span> username<span>)</span><span>;</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>UserMapper.xml</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?></span>\n<span><span>&lt;!</span><span>DOCTYPE</span> <span>mapper</span> <span>PUBLIC</span> <span>\"-//mybatis.org//DTD Mapper 3.0//EN\"</span>\n        <span>\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span><span>></span></span>\n<span><span><span>&lt;</span>mapper</span> <span>namespace</span><span><span>=</span><span>\"</span>top.alanlee.miaosha.mapper.UserMapper<span>\"</span></span><span>></span></span>\n\n    <span>&lt;!-- 通过用户名和密码查询用户 --></span>\n    <span><span><span>&lt;</span>select</span> <span>id</span><span><span>=</span><span>\"</span>getOneByUsernameAndPassword<span>\"</span></span>\n            <span>parameterType</span><span><span>=</span><span>\"</span>top.alanlee.miaosha.entity.User<span>\"</span></span>\n            <span>resultType</span><span><span>=</span><span>\"</span>top.alanlee.miaosha.entity.User<span>\"</span></span><span>></span></span>\n        SELECT *\n        FROM t_user\n        WHERE t_user.username = #{username} and t_user.password = #{password}\n    <span><span><span>&lt;/</span>select</span><span>></span></span>\n\n    <span>&lt;!-- 通过用户名查询用户 --></span>\n    <span><span><span>&lt;</span>select</span> <span>id</span><span><span>=</span><span>\"</span>getUserByUsername<span>\"</span></span>\n            <span>parameterType</span><span><span>=</span><span>\"</span>java.lang.String<span>\"</span></span>\n            <span>resultType</span><span><span>=</span><span>\"</span>top.alanlee.miaosha.entity.User<span>\"</span></span><span>></span></span>\n        SELECT *\n        FROM t_user\n        WHERE t_user.username = #{username}\n    <span><span><span>&lt;/</span>select</span><span>></span></span>\n\n    <span>&lt;!-- 通过用户名查询角色 --></span>\n    <span><span><span>&lt;</span>select</span> <span>id</span><span><span>=</span><span>\"</span>getRoles<span>\"</span></span>\n            <span>parameterType</span><span><span>=</span><span>\"</span>java.lang.String<span>\"</span></span>\n            <span>resultType</span><span><span>=</span><span>\"</span>java.lang.String<span>\"</span></span><span>></span></span>\n        SELECT t_role.role_name\n        FROM t_user, t_role\n        WHERE t_user.username = #{username} AND t_user.role_id = t_role.id\n    <span><span><span>&lt;/</span>select</span><span>></span></span>\n\n    <span>&lt;!-- 通过用户名查询权限 --></span>\n    <span><span><span>&lt;</span>select</span> <span>id</span><span><span>=</span><span>\"</span>getPermissions<span>\"</span></span>\n            <span>parameterType</span><span><span>=</span><span>\"</span>java.lang.String<span>\"</span></span>\n            <span>resultType</span><span><span>=</span><span>\"</span>java.lang.String<span>\"</span></span><span>></span></span>\n        SELECT t_permission.permission_name\n        FROM t_user, t_role, t_permission\n        WHERE t_user.username = #{username} AND t_user.role_id = t_role.id AND t_permission.role_id = t_role.id\n    <span><span><span>&lt;/</span>select</span><span>></span></span>\n<span><span><span>&lt;/</span>mapper</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id=\"配置controller\"> 配置Controller</h2>\n<p>service层的代码省略，请自行配置</p>\n<p>UserController.java</p>\n<div><pre><code><span>@RestController</span>\n<span>@RequestMapping</span><span>(</span><span>\"/user\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>UserController</span> <span>{</span>\n    <span>@Autowired</span>\n    <span>private</span> <span>UserServiceImpl</span> userService<span>;</span>\n\n\n    <span>/**\n     * 登录\n     * @return\n     */</span>\n    <span>@PostMapping</span><span>(</span><span>\"/login\"</span><span>)</span>\n    <span>public</span> <span>ApiJson</span> <span>login</span><span>(</span><span>User</span> user<span>,</span> <span>HttpSession</span> session<span>)</span><span>{</span>\n        <span>//根据用户名和密码创建Token</span>\n        <span>UsernamePasswordToken</span> token <span>=</span>\n                <span>new</span> <span>UsernamePasswordToken</span><span>(</span>user<span>.</span><span>getUsername</span><span>(</span><span>)</span><span>,</span> user<span>.</span><span>getPassword</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>//获取主体</span>\n        <span>Subject</span> subject <span>=</span> <span>SecurityUtils</span><span>.</span><span>getSubject</span><span>(</span><span>)</span><span>;</span>\n\n        <span>try</span> <span>{</span>\n            <span>//开始认证，这里会跳转到自定义的Realm中</span>\n            subject<span>.</span><span>login</span><span>(</span>token<span>)</span><span>;</span>\n            session<span>.</span><span>setAttribute</span><span>(</span>user<span>.</span><span>getUsername</span><span>(</span><span>)</span><span>,</span> user<span>)</span><span>;</span>\n            <span>return</span> <span>ApiJson</span><span>.</span><span>ok</span><span>(</span>userService<span>.</span><span>getOneByUsernameAndPassword</span><span>(</span>user<span>)</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>AuthenticationException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            session<span>.</span><span>setAttribute</span><span>(</span>user<span>.</span><span>getUsername</span><span>(</span><span>)</span><span>,</span> user<span>)</span><span>;</span>\n            session<span>.</span><span>setAttribute</span><span>(</span><span>\"error\"</span><span>,</span> <span>\"用户名或密码错误\"</span><span>)</span><span>;</span>\n            <span>return</span> <span>ApiJson</span><span>.</span><span>error</span><span>(</span><span>\"用户名或密码错误\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     * 未登录\n     */</span>\n    <span>@GetMapping</span><span>(</span><span>\"/unlogin\"</span><span>)</span>\n    <span>public</span> <span>ApiJson</span> <span>unlogin</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> <span>ApiJson</span><span>.</span><span>error</span><span>(</span><span>\"未登录，请先登录\"</span><span>,</span> <span>\"user/login\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 退出登录\n     * @param username\n     * @param session\n     * @return\n     */</span>\n    <span>@GetMapping</span><span>(</span><span>\"/logout/{username}\"</span><span>)</span>\n    <span>public</span> <span>ApiJson</span> <span>logout</span><span>(</span><span>@PathVariable</span> <span>String</span> username<span>,</span> <span>HttpSession</span> session<span>)</span><span>{</span>\n        session<span>.</span><span>removeAttribute</span><span>(</span>username<span>)</span><span>;</span>\n        <span>return</span> <span>ApiJson</span><span>.</span><span>ok</span><span>(</span><span>\"退出成功\"</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 测试身份认证\n     * @param request\n     * @return\n     */</span>\n    <span>@RequestMapping</span><span>(</span><span>\"/admin\"</span><span>)</span>\n    <span>public</span> <span>ApiJson</span> <span>testAuthc</span><span>(</span><span>HttpServletRequest</span> request<span>)</span><span>{</span>\n        <span>Object</span> user <span>=</span> request<span>.</span><span>getSession</span><span>(</span><span>)</span><span>.</span><span>getAttribute</span><span>(</span><span>\"user\"</span><span>)</span><span>;</span>\n        <span>return</span> user <span>!=</span> <span>null</span> <span>?</span> <span>ApiJson</span><span>.</span><span>ok</span><span>(</span><span>\"认证成功\"</span><span>)</span> <span>:</span> <span>ApiJson</span><span>.</span><span>error</span><span>(</span><span>\"认证失败\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 测试角色认证\n     * @param request\n     * @return\n     */</span>\n    <span>@RequestMapping</span><span>(</span><span>\"/student\"</span><span>)</span>\n    <span>public</span> <span>ApiJson</span> <span>testRole</span><span>(</span><span>HttpServletRequest</span> request<span>)</span><span>{</span>\n        <span>return</span> <span>ApiJson</span><span>.</span><span>ok</span><span>(</span><span>\"ok\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 测试权限认证\n     * @param request\n     * @return\n     */</span>\n    <span>@RequestMapping</span><span>(</span><span>\"/teacher\"</span><span>)</span>\n    <span>public</span> <span>ApiJson</span> <span>testPermission</span><span>(</span><span>HttpServletRequest</span> request<span>)</span><span>{</span>\n        <span>return</span> <span>ApiJson</span><span>.</span><span>ok</span><span>(</span><span>\"ok\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br></div></div><p>TipController.java</p>\n<div><pre><code><span>@RestController</span>\n<span>public</span> <span>class</span> <span>IndexController</span> <span>{</span>\n\n    <span>@GetMapping</span><span>(</span><span>\"/unauth\"</span><span>)</span>\n    <span>public</span> <span>ApiJson</span> <span>unauth</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> <span>ApiJson</span><span>.</span><span>error</span><span>(</span><span>\"未认证授权，禁止访问\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"测试\"> 测试</h2>\n<table>\n<thead>\n<tr>\n<th>帐号</th>\n<th>角色</th>\n<th>权限</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>admin</td>\n<td>admin</td>\n<td>admin:*</td>\n</tr>\n<tr>\n<td>test</td>\n<td>teacher</td>\n<td>user:*</td>\n</tr>\n<tr>\n<td>vistor</td>\n<td>student</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>测试5个接口地址</p>\n<ul>\n<li>http://localhost:8080/user/admin</li>\n<li>http://localhost:8080/user/login</li>\n<li>http://localhost:8080/user/logout/username</li>\n<li>http://localhost:8080/user/student</li>\n<li>http://localhost:8080/user/teacher</li>\n</ul>\n<p>先访问admin，此时未登录，自动跳转到/user/unlogin，输出提示信息和登录的接口地址，前端可根据输出的信息自行处理</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200511123931178.png\" alt=\"image-20200511123931178\" /></p>\n<p>试试访问/user/student和再访问/user/teacher</p>\n<p>结果与上图相同</p>\n<p>使用admin的帐号，通过/user/login登录接口登录后，再次访问/user/admin</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200511124117247.png\" alt=\"image-20200511124117247\" /></p>\n<p>访问/user/student</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200511124553286.png\" alt=\"image-20200511124553286\" /></p>\n<p>访问/user/teacher，此时会跳转到unauth接口</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200511124620645.png\" alt=\"image-20200511124620645\" /></p>\n<p>因为在ShiroConfig中的配置为</p>\n<div><pre><code><span>//开启权限认证</span>\nfilterChainMap<span>.</span><span>put</span><span>(</span><span>\"/user/teacher*/**\"</span><span>,</span> <span>\"perms[\\\"user:create\\\"]\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>teacher接口下的权限设定为user:开头的才可以访问这个接口。而admin帐号的权限是admin:开头的</p>\n<p>使用test帐号登录，再次访问/user/teacher，此时可以访问了</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200511125731571.png\" alt=\"image-20200511125731571\" /></p>\n<p>再次访问/user/student，此时已无法访问，自动跳转到/unauth</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200511124620645.png\" alt=\"image-20200511124620645\" /></p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200511123931178.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "SpringBoot中使用AOP",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/demo/SpringBoot%E4%B8%AD%E4%BD%BF%E7%94%A8AOP/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/demo/SpringBoot%E4%B8%AD%E4%BD%BF%E7%94%A8AOP/",
      "content_html": "<h1 id=\"springboot中使用aop\"> SpringBoot中使用AOP</h1>\n<blockquote>\n<p>参考文章：https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/SpringInterviewQuestions?id=_41-谈谈自己对于-spring-ioc-和-aop-的理解</p>\n<p>参考文章：https://blog.csdn.net/Luck_ZZ/article/details/79504900</p>\n</blockquote>\n<h2 id=\"一、概述\"> 一、概述</h2>\n<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>\n<p><strong>Spring AOP是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/SpringAOPProcess.jpg\" alt=\"SpringAOPProcess\" /></p>\n<p>当然也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>\n<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>\n<p>AOP是Spring框架的重要特性。</p>\n<p>通知类型有：前置通知、后置最终通知、后置返回通知、后置异常通知、环绕通知</p>\n<h2 id=\"二、添加maven依赖\"> 二、添加maven依赖</h2>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-aop<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>2.2.6.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"三、创建aspect切面类\"> 三、创建Aspect切面类</h2>\n<p>在top.alanlee.template.aop包下创建切面类WebAspect</p>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>aop</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>aspectj<span>.</span>lang<span>.</span></span><span>JoinPoint</span><span>;</span>\n<span>import</span> <span>org<span>.</span>aspectj<span>.</span>lang<span>.</span></span><span>ProceedingJoinPoint</span><span>;</span>\n<span>import</span> <span>org<span>.</span>aspectj<span>.</span>lang<span>.</span></span><span>Signature</span><span>;</span>\n<span>import</span> <span>org<span>.</span>aspectj<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>*</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>stereotype<span>.</span></span><span>Component</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Arrays</span><span>;</span>\n\n<span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>WebAspect</span> <span>{</span>\n\n    <span>/**\n     * 切入点\n     * 匹配top.alanlee.template.controller包及其子包下的所有类的所有方法\n     */</span>\n    <span>@Pointcut</span><span>(</span><span>\"execution(* top.alanlee.template.controller.*.*(..))\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>pointCut</span><span>(</span><span>)</span><span>{</span>\n\n    <span>}</span>\n\n    <span>/**\n     * 前置通知，目标方法调用前被调用\n     */</span>\n    <span>@Before</span><span>(</span><span>\"pointCut()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeAdvice</span><span>(</span><span>JoinPoint</span> joinPoint<span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"----------- 前置通知 -----------\"</span><span>)</span><span>;</span>\n        <span>Signature</span> signature <span>=</span> joinPoint<span>.</span><span>getSignature</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"返回目标方法的签名：\"</span> <span>+</span> signature<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"代理的是哪一个方法：\"</span> <span>+</span> signature<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Object</span><span>[</span><span>]</span> args <span>=</span> joinPoint<span>.</span><span>getArgs</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"获取目标方法的参数信息：\"</span> <span>+</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span>args<span>)</span><span>)</span><span>;</span>\n\n    <span>}</span>\n\n    <span>/**\n     * 最终通知，目标方法执行完之后执行\n     */</span>\n    <span>@After</span><span>(</span><span>\"pointCut()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>afterAdvice</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"----------- 最终通知 -----------\"</span><span>)</span><span>;</span>\n\n    <span>}</span>\n\n    <span>/**\n     * 后置返回通知\n     * 如果参数中的第一个参数为JoinPoint，则第二个参数为返回值的信息\n     * 如果参数中的第一个参数不为JoinPoint，则第一个参数为returning中对应的参数\n     * returning 只有目标方法返回值与通知方法相应参数类型时才能执行后置返回通知，否则不执行\n     * @param joinPoint\n     * @param keys\n     */</span>\n    <span>@AfterReturning</span><span>(</span>value <span>=</span> <span>\"execution(* top.alanlee.template.controller..*.*(..))\"</span><span>,</span> returning <span>=</span> <span>\"keys\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>afterReturningAdvice</span><span>(</span><span>JoinPoint</span> joinPoint<span>,</span> <span>String</span> keys<span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"----------- 后置返回通知 -----------\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"后置返回通知的返回值：\"</span> <span>+</span> keys<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 后置异常通知\n     * 定义一个名字，该名字用于匹配通知实现方法的一个参数名，当目标方法抛出异常返回后，将把目标方法抛出的异常传给通知方法；\n     * throwing 只有目标方法抛出的异常与通知方法相应参数异常类型时才能执行后置异常通知，否则不执行，\n     * @param joinPoint\n     * @param e\n     */</span>\n    <span>@AfterThrowing</span><span>(</span>value <span>=</span> <span>\"pointCut()\"</span><span>,</span> throwing <span>=</span> <span>\"e\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>afterThrowingAdvice</span><span>(</span><span>JoinPoint</span> joinPoint<span>,</span> <span>NullPointerException</span> e<span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"----------- 后置异常通知 -----------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 环绕通知\n     * 环绕通知非常强大，可以决定目标方法是否执行，什么时候执行，执行时是否需要替换方法参数，执行完毕是否需要替换返回值。\n     * 环绕通知第一个参数必须是org.aspectj.lang.ProceedingJoinPoint类型\n     * @param proceedingJoinPoint\n     */</span>\n    <span>@Around</span><span>(</span><span>\"execution(* top.alanlee.template.controller.AopController.testAround(..))\"</span><span>)</span>\n    <span>public</span> <span>Object</span> <span>aroundAdvice</span><span>(</span><span>ProceedingJoinPoint</span> proceedingJoinPoint<span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"----------- 环绕通知 -----------\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"环绕通知的目标方法名：\"</span> <span>+</span> proceedingJoinPoint<span>.</span><span>getSignature</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>try</span> <span>{</span>\n            <span>Object</span> proceed <span>=</span> proceedingJoinPoint<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> proceed<span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> throwable<span>)</span> <span>{</span>\n            throwable<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span><span>finally</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"---------- 环绕通知结束 -------------\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>null</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br></div></div><h3 id=\"_1-pointcut是创建切入点\"> 1.@Pointcut是创建切入点</h3>\n<p>切入点方法不用写代码，返回类型为void</p>\n<p><strong>execution:用于匹配表达式</strong></p>\n<p><code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)throws-pattern?)</code></p>\n<ul>\n<li>\n<p>修饰符匹配（modifier-pattern?）</p>\n</li>\n<li>\n<p>返回值匹配（ret-type-pattern）可以为*表示任何返回值,全路径的类名等</p>\n</li>\n<li>\n<p>类路径匹配（declaring-type-pattern?）</p>\n</li>\n<li>\n<p>方法名匹配（name-pattern）可以指定方法名 或者 <em>代表所有, set</em> 代表以set开头的所有方法</p>\n</li>\n<li>\n<p>参数匹配（(param-pattern)）可以指定具体的参数类型，多个参数间用“<code>,</code>”隔开，各个参数也可以用“<code>*</code>”来表示匹配任意类型的参数，如(String)表示匹配一个String参数的方法；<code>(*,String)</code>表示匹配有两个参数的方法，第一个参数可以是任意类型，而第二个参数是String类型；可以用<code>(..)</code>表示零个或多个任意参数</p>\n</li>\n<li>\n<p>异常类型匹配 <code>（throws-pattern?）</code> 其中后面跟  着“<code>?</code>”的是可选项</p>\n<ul>\n<li>\n<p><code>execution(* *(..))</code>  表示匹配所有方法</p>\n</li>\n<li>\n<p><code>execution(public * com. example.controller.*(..))</code> 表示匹配com. example.controller中所有的public方法</p>\n</li>\n<li>\n<p><code>execution(* com. example.controller..*.*(..))</code>  表示匹配com. example.controller包及其子包下的所有方法</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_2-joinpoint\"> 2.JoinPoint</h3>\n<p>除@Around外，每个方法里都可以加或者不加参数JoinPoint。</p>\n<p>JoinPoint包含了类名、被切面的方法名、参数等属性。</p>\n<p>@Around参数必须为ProceedingJoinPoint。</p>\n<h2 id=\"四、创建controller类\"> 四、创建Controller类</h2>\n<p>在top.alanlee.template.controller包下创建Controller类AopController。</p>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>template<span>.</span>controller</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RequestMapping</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RestController</span><span>;</span>\n\n<span>@RestController</span>\n<span>@RequestMapping</span><span>(</span><span>\"/aop\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>AopController</span> <span>{</span>\n\n    <span>@RequestMapping</span><span>(</span><span>\"/test\"</span><span>)</span>\n    <span>public</span> <span>String</span> <span>testAop</span><span>(</span><span>String</span> key<span>)</span><span>{</span>\n        <span>return</span> <span>\"testAop: key = \"</span> <span>+</span> key<span>;</span>\n    <span>}</span>\n\n    <span>@RequestMapping</span><span>(</span><span>\"testAfterThrowing\"</span><span>)</span>\n    <span>public</span> <span>String</span> <span>testAfterThrowing</span><span>(</span><span>String</span> key<span>)</span><span>{</span>\n        <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span>key<span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>@RequestMapping</span><span>(</span><span>\"/testAround\"</span><span>)</span>\n    <span>public</span> <span>String</span> <span>testAround</span><span>(</span><span>String</span> key<span>)</span><span>{</span>\n        <span>return</span> <span>\"环绕通知：key = \"</span> <span>+</span> key<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id=\"五、测试\"> 五、测试</h2>\n<p>以浏览器来测试</p>\n<h3 id=\"测试testaop\"> 测试testAop()</h3>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200601073521813.png\" alt=\"image-20200601073521813\" /></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200601073439533.png\" alt=\"image-20200601073439533\" /></p>\n<h3 id=\"测试testafterthrowing\"> 测试testAfterThrowing()</h3>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200601073831666.png\" alt=\"image-20200601073831666\" /></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200601073922609.png\" alt=\"image-20200601073922609\" /></p>\n<h3 id=\"测试testaround\"> 测试testAround()</h3>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200601074008647.png\" alt=\"image-20200601074008647\" /></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200601074027851.png\" alt=\"image-20200601074027851\" /></p>\n<h2 id=\"六、一些面试问题\"> 六、一些面试问题</h2>\n<h3 id=\"spring-aop-和-aspectj-aop-有什么区别\"> Spring AOP 和 AspectJ AOP 有什么区别？</h3>\n<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong></p>\n<p>Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>\n<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>\n<p>AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>\n<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/SpringAOPProcess.jpg",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring 事务中@Transactional 的使用",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/demo/Spring%20%E4%BA%8B%E5%8A%A1%E4%B8%AD@Transactional%20%E7%9A%84%E4%BD%BF%E7%94%A8/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/demo/Spring%20%E4%BA%8B%E5%8A%A1%E4%B8%AD@Transactional%20%E7%9A%84%E4%BD%BF%E7%94%A8/",
      "content_html": "<h1 id=\"spring-事务中-transactional-的使用\"> Spring 事务中@Transactional 的使用</h1>\n<blockquote>\n<p>原文链接：https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html</p>\n<p>参考文章：https://blog.csdn.net/qq_32867467/article/details/82944473</p>\n</blockquote>\n<p>事务管理是应用系统开发中必不可少的一部分。Spring 为事务管理提供了丰富的功能支持。Spring 事务管理分为编码式和声明式的两种方式。编程式事务指的是通过编码方式实现事务；声明式事务基于 AOP,将具体业务逻辑与事务处理解耦。声明式事务管理使业务代码逻辑不受污染, 因此在实际使用中声明式事务用的比较多。声明式事务有两种方式，一种是在配置文件（xml）中做相关的事务规则声明，另一种是基于@Transactional 注解的方式。</p>\n<h2 id=\"一、-transactional-注解管理事务的实现步骤\"> 一、@Transactional 注解管理事务的实现步骤</h2>\n<p>使用@Transactional 注解管理事务的实现步骤分为两步。</p>\n<p>第一步，在 xml 配置文件中添加如清单 1 的事务配置信息。除了用配置文件的方式，@EnableTransactionManagement 注解也可以启用事务管理功能。这里以简单的 DataSourceTransactionManager 为例。</p>\n<div><pre><code><span><span><span>&lt;</span><span>tx:</span>annotation-driven</span> <span>/></span></span>\n<span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>transactionManager<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>org.springframework.jdbc.datasource.DataSourceTransactionManager<span>\"</span></span><span>></span></span>\n\t<span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>dataSource<span>\"</span></span> <span>ref</span><span><span>=</span><span>\"</span>dataSource<span>\"</span></span> <span>/></span></span>\n<span><span><span>&lt;/</span>bean</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第二步，将@Transactional 注解添加到合适的方法上，并设置合适的属性信息。@Transactional 注解的属性信息如表 1 展示。</p>\n<blockquote>\n<p>在Spring Boot中，当使用spring-boot-starter-jdbc或spring-boot-starter-data-jpa依赖的时候，框架会自动默认分别注入DataSourceTransactionManager或JpaTransactionManager，所以<strong>可以直接使用@Transactional 注解</strong>，无需做任何配置</p>\n</blockquote>\n<h5 id=\"transactional-注解的属性信息\"> @Transactional 注解的属性信息</h5>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性名</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">name</td>\n<td style=\"text-align:left\">当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">propagation</td>\n<td style=\"text-align:left\">事务的传播行为，默认值为 REQUIRED。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">isolation</td>\n<td style=\"text-align:left\">事务的隔离度，默认值采用 DEFAULT。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">timeout</td>\n<td style=\"text-align:left\">事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">read-only</td>\n<td style=\"text-align:left\">指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">rollback-for</td>\n<td style=\"text-align:left\">用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">no-rollback- for</td>\n<td style=\"text-align:left\">抛出 no-rollback-for 指定的异常类型，不回滚事务。</td>\n</tr>\n</tbody>\n</table>\n<p>除此以外，@Transactional 注解也可以添加到类级别上。当把@Transactional 注解放在类级别时，表示所有该类的公共方法都配置相同的事务属性信息。当类级别配置了@Transactional，方法级别也配置了@Transactional，应用程序会以方法级别的事务属性信息来管理事务，换言之，方法级别的事务属性信息会覆盖类级别的相关配置信息。</p>\n<p><strong>优先级顺序为方法 &gt; 实现类 &gt; 接口</strong></p>\n<h5 id=\"事务属性\"> 事务属性</h5>\n<p>事务属性包含以下五个方面：隔离级别、传播行为、回滚规则、事务超时、只读。</p>\n<h5 id=\"事务隔离级别\"> 事务隔离级别</h5>\n<p>隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>\n<table>\n<thead>\n<tr>\n<th>隔离级别常量</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TransactionDefinition.ISOLATION_DEFAULT</td>\n<td>这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED</td>\n</tr>\n<tr>\n<td>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</td>\n<td>该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。</td>\n</tr>\n<tr>\n<td>TransactionDefinition.ISOLATION_READ_COMMITTED</td>\n<td>该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</td>\n</tr>\n<tr>\n<td>TransactionDefinition.ISOLATION_REPEATABLE_READ</td>\n<td>该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。</td>\n</tr>\n<tr>\n<td>TransactionDefinition.ISOLATION_SERIALIZABLE</td>\n<td>所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"事务传播行为\"> 事务传播行为</h5>\n<p>所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</p>\n<table>\n<thead>\n<tr>\n<th>传播行为常量</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TransactionDefinition.PROPAGATION_REQUIRED</td>\n<td>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_REQUIRES_NEW</td>\n<td>创建一个新的事务，如果当前存在事务，则把当前事务挂起。</td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_SUPPORTS</td>\n<td>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</td>\n<td>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_NEVER</td>\n<td>以非事务方式运行，如果当前存在事务，则抛出异常。</td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_MANDATORY</td>\n<td>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_NESTED</td>\n<td>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"事务超时\"> 事务超时</h5>\n<p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。\n默认设置为底层事务系统的超时值，如果底层数据库事务系统没有设置超时值，那么就是none，没有超时限制。</p>\n<h5 id=\"事务只读属性\"> 事务只读属性</h5>\n<p>只读事务用于客户代码只读但不修改数据的情形，只读事务用于特定情景下的优化，比如使用Hibernate的时候。\n默认为读写事务。</p>\n<h4 id=\"实例\"> 实例</h4>\n<div><pre><code><span>@Service</span>\n<span>public</span> <span>class</span> <span>UserServiceImpl</span> <span>implements</span> <span>UserService</span> <span>{</span>\n    <span>@Autowired</span>\n    <span>UserMapper</span> userMapper<span>;</span>\n\n    <span>@Transactional</span>\n    <span>public</span> <span>int</span> <span>testTxAdd</span><span>(</span><span>)</span> <span>{</span>\n        <span>int</span> i <span>=</span> <span>0</span><span>;</span>\n        i <span>=</span> userMapper<span>.</span><span>add</span><span>(</span><span>new</span> <span>User</span><span>(</span><span>\"tx_test1\"</span><span>,</span> <span>\"2020-06-01 09:40:10\"</span><span>)</span><span>)</span><span>;</span>\n        i <span>=</span> userMapper<span>.</span><span>add</span><span>(</span><span>new</span> <span>User</span><span>(</span><span>\"tx_test2\"</span><span>,</span> <span>\"2020-06-01 09:40:10\"</span><span>)</span><span>)</span><span>;</span>\n        i <span>=</span> userMapper<span>.</span><span>add</span><span>(</span><span>new</span> <span>User</span><span>(</span><span>\"tx_test3\"</span><span>,</span> <span>\"abc\"</span><span>)</span><span>)</span><span>;</span>\n        i <span>=</span> userMapper<span>.</span><span>add</span><span>(</span><span>new</span> <span>User</span><span>(</span><span>\"tx_test4\"</span><span>,</span> <span>\"2020-06-01 09:40:10\"</span><span>)</span><span>)</span><span>;</span>\n        i <span>=</span> userMapper<span>.</span><span>add</span><span>(</span><span>new</span> <span>User</span><span>(</span><span>\"tx_test4\"</span><span>,</span> <span>\"2020-06-01 09:40:10\"</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> i<span>;</span>\n    <span>}</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>i = userMapper.add(new User(&quot;tx_test3&quot;, &quot;abc&quot;));这一行代码会发生错误，第二个参数无法转换成时间，所以加入事务控制之后，所有的添加用户的操作都会回滚。</p>\n<h2 id=\"二、spring-的注解方式的事务实现机制\"> 二、Spring 的注解方式的事务实现机制</h2>\n<p>在应用系统调用声明@Transactional 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，根据@Transactional 的属性配置信息，这个代理对象决定该声明@Transactional 的目标方法是否由拦截器 TransactionInterceptor 来使用拦截，在 TransactionInterceptor 拦截时，会在在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器(图 2 有相关介绍)AbstractPlatformTransactionManager 操作数据源 DataSource 提交或回滚事务, 如图 1 所示。</p>\n<h5 id=\"图-1-spring-事务实现机制\"> 图 1. Spring 事务实现机制</h5>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image001.jpg\" alt=\"img\" /></p>\n<p>Spring AOP 代理有 CglibAopProxy 和 JdkDynamicAopProxy 两种，图 1 是以 CglibAopProxy 为例，对于 CglibAopProxy，需要调用其内部类的 DynamicAdvisedInterceptor 的 intercept 方法。对于 JdkDynamicAopProxy，需要调用其 invoke 方法。</p>\n<p>正如上文提到的，事务管理的框架是由抽象事务管理器 AbstractPlatformTransactionManager 来提供的，而具体的底层事务处理实现，由 PlatformTransactionManager 的具体实现类来实现，如事务管理器 DataSourceTransactionManager。不同的事务管理器管理不同的数据资源 DataSource，比如 DataSourceTransactionManager 管理 JDBC 的 Connection。</p>\n<p>PlatformTransactionManager，AbstractPlatformTransactionManager 及具体实现类关系如图 2 所示。</p>\n<h5 id=\"图-2-transactionmanager-类结构\"> 图 2. TransactionManager 类结构</h5>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image002.jpg\" alt=\"img\" /></p>\n<h2 id=\"三、注解方式的事务使用注意事项\"> 三、注解方式的事务使用注意事项</h2>\n<p>对 Spring 的基于注解方式的实现步骤和事务内在实现机制有较好的理解之后，就会更好的使用注解方式的事务管理，避免当系统抛出异常，数据不能回滚的问题。</p>\n<h3 id=\"正确的设置-transactional-的-propagation-属性\"> 正确的设置@Transactional 的 propagation 属性</h3>\n<p>需要注意下面三种 propagation 可以不启动事务。本来期望目标方法进行事务管理，但若是错误的配置这三种 propagation，事务将不会发生回滚。</p>\n<ol>\n<li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>\n<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>\n<li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li>\n</ol>\n<h3 id=\"正确的设置-transactional-的-rollbackfor-属性\"> 正确的设置@Transactional 的 rollbackFor 属性</h3>\n<p>默认情况下，如果在事务中抛出了未检查异常（继承自 RuntimeException 的异常）或者 Error，则 Spring 将回滚事务；除此之外，Spring 不会回滚事务。</p>\n<p>如果在事务中抛出其他类型的异常，并期望 Spring 能够回滚事务，可以指定 rollbackFor。例：</p>\n<p>@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class)</p>\n<p>通过分析 Spring 源码可以知道，若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。</p>\n<h5 id=\"rollbackruleattribute-的-getdepth-方法\"> RollbackRuleAttribute 的 getDepth 方法</h5>\n<div><pre><code><span>private</span> <span>int</span> <span>getDepth</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> exceptionClass<span>,</span> <span>int</span> depth<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>exceptionClass<span>.</span><span>getName</span><span>(</span><span>)</span><span>.</span><span>contains</span><span>(</span><span>this</span><span>.</span>exceptionName<span>)</span><span>)</span> <span>{</span>\n        <span>// Found it!</span>\n        <span>return</span> depth<span>;</span>\n    <span>}</span>\n    <span>// If we've gone as far as we can go and haven't found it...</span>\n    <span>if</span> <span>(</span>exceptionClass <span>==</span> <span>Throwable</span><span>.</span><span>class</span><span>)</span> <span>{</span>\n        <span>return</span> <span>-</span><span>1</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>getDepth</span><span>(</span>exceptionClass<span>.</span><span>getSuperclass</span><span>(</span><span>)</span><span>,</span> depth <span>+</span> <span>1</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"transactional-只能应用到-public-方法才有效\"> @Transactional 只能应用到 public 方法才有效</h3>\n<p>只有@Transactional 注解应用到 public 方法，才能进行事务管理。这是因为在使用 Spring AOP 代理时，Spring 在调用在图 1 中的 TransactionInterceptor 在目标方法执行前后进行拦截之前，DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的的 intercept 方法或 JdkDynamicAopProxy 的 invoke 方法会间接调用 AbstractFallbackTransactionAttributeSource（Spring 通过这个类获取表 1. @Transactional 注解的事务属性配置属性信息）的 computeTransactionAttribute 方法。</p>\n<h4 id=\"abstractfallbacktransactionattributesource\"> AbstractFallbackTransactionAttributeSource</h4>\n<div><pre><code><span>protected</span> <span>TransactionAttribute</span> <span>computeTransactionAttribute</span><span>(</span><span>Method</span> method<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> targetClass<span>)</span> <span>{</span>\n    <span>// Don't allow no-public methods as required.</span>\n    <span>if</span> <span>(</span><span>allowPublicMethodsOnly</span><span>(</span><span>)</span> <span>&amp;&amp;</span> <span>!</span><span>Modifier</span><span>.</span><span>isPublic</span><span>(</span>method<span>.</span><span>getModifiers</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n\t\t<span>return</span> <span>null</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这个方法会检查目标方法的修饰符是不是 public，若不是 public，就不会获取@Transactional 的属性配置信息，最终会造成不会用 TransactionInterceptor 来拦截该目标方法进行事务管理。</p>\n<h3 id=\"避免-spring-的-aop-的自调用问题\"> 避免 Spring 的 AOP 的自调用问题</h3>\n<p>在 Spring 的 AOP 代理下，只有目标方法由外部调用，目标方法由 Spring 生成的代理对象来管理，这会造成自调用问题。若同一类中的其他没有@Transactional 注解的方法内部调用有@Transactional 注解的方法，有@Transactional 注解的方法的事务被忽略，不会发生回滚。见举例代码展示。</p>\n<div><pre><code><span>@Service</span>\n<span>public</span> <span>class</span> <span>OrderService</span> <span>{</span>\n    <span>private</span> <span>void</span> <span>insert</span><span>(</span><span>)</span> <span>{</span>\n    \t<span>insertOrder</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n\t<span>@Transactional</span>\n    <span>public</span> <span>void</span> <span>insertOrder</span><span>(</span><span>)</span> <span>{</span>\n        <span>//insert log info</span>\n        <span>//insertOrder</span>\n        <span>//updateAccount</span>\n       <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>insertOrder 尽管有@Transactional 注解，但它被内部方法 insert 调用，事务被忽略，出现异常事务不会发生回滚。</p>\n<p>上面的两个问题@Transactional 注解只应用到 public 方法和自调用问题，是由于使用 Spring AOP 代理造成的。为解决这两个问题，使用 AspectJ 取代 Spring AOP 代理。</p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image001.jpg",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring Boot集成Swagger2",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/demo/%E9%9B%86%E6%88%90Swagger2/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/demo/%E9%9B%86%E6%88%90Swagger2/",
      "content_html": "<h1 id=\"spring-boot集成swagger2\"> Spring Boot集成Swagger2</h1>\n<h2 id=\"添加依赖\"> 添加依赖</h2>\n<div><pre><code><span>&lt;!-- API文档 springfox-swagger --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>io.springfox<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>springfox-swagger2<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>2.9.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n<span>&lt;!-- API文档 springfox-swagger-ui --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>io.springfox<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>springfox-swagger-ui<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>2.9.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"配置swagger\"> 配置Swagger</h2>\n<ol>\n<li>新建一个类SwaggerConfig.java文件</li>\n</ol>\n<div><pre><code><span>@Configuration</span>\n<span>@EnableSwagger2</span>\n<span>public</span> <span>class</span> <span>SwaggerConfig</span> <span>{</span>\n\n    <span>@Bean</span>\n    <span>public</span> <span>Docket</span> <span>api</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> <span>new</span> <span>Docket</span><span>(</span><span>DocumentationType</span><span>.</span>SWAGGER_2<span>)</span>\n                <span>.</span><span>apiInfo</span><span>(</span><span>getApiInfo</span><span>(</span><span>)</span><span>)</span>\n                <span>.</span><span>select</span><span>(</span><span>)</span>\n                <span>.</span><span>apis</span><span>(</span><span>RequestHandlerSelectors</span><span>.</span><span>basePackage</span><span>(</span><span>\"top.alanlee.template.controller\"</span><span>)</span><span>)</span>\n                <span>.</span><span>paths</span><span>(</span><span>PathSelectors</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span>\n                <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>ApiInfo</span> <span>getApiInfo</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> <span>new</span> <span>ApiInfoBuilder</span><span>(</span><span>)</span>\n                <span>.</span><span>title</span><span>(</span><span>\"大标题\"</span><span>)</span>\n                <span>.</span><span>description</span><span>(</span><span>\"小标题\"</span><span>)</span>\n                <span>.</span><span>version</span><span>(</span><span>\"1.0\"</span><span>)</span>\n                <span>.</span><span>license</span><span>(</span><span>\"Apache 2.0\"</span><span>)</span>\n                <span>.</span><span>licenseUrl</span><span>(</span><span>\"http://www.apache.org/licenses/LICENSE-2.0\"</span><span>)</span>\n                <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><ol start=\"2\">\n<li>在Controller类中配置接口信息</li>\n</ol>\n<ul>\n<li>\n<p>在Controller类上添加@Api注解</p>\n</li>\n<li>\n<p>在方法上添加@ApiOperation注解</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200518172339513.png\" alt=\"image-20200518172339513\" /></p>\n</li>\n</ul>\n<h2 id=\"测试\"> 测试</h2>\n<p>浏览器输入地址http://localhost:8080/swagger-ui.html</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200518172715646.png\" alt=\"image-20200518172715646\" /></p>\n<h2 id=\"一些注解的使用\"> 一些注解的使用</h2>\n<p>@Api：用在类上，说明该类的作用</p>\n<p>@ApiOperation：用在方法上，说明方法的作用，标注在具体请求上，value和notes的作用差不多，都是对请求进行说明；tags则是对请求进行分类的，比如你有好几个controller，分别属于不同的功能模块，那这里我们就可以使用tags来区分了，看上去很有条理</p>\n<p>@ApiImplicitParams：用在方法上包含一组参数说明</p>\n<p>@ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面</p>\n<p>paramType：参数放在哪个地方</p>\n<p>header 请求参数的获取：@RequestHeader</p>\n<p>query 请求参数的获取：@RequestParam</p>\n<p>path（用于restful接口） 请求参数的获取：@PathVariable</p>\n<p>body（不常用）</p>\n<p>form（不常用）</p>\n<p>name：参数名</p>\n<p>dataType：参数类型</p>\n<p>required：参数是否必须传</p>\n<p>value：参数的意思</p>\n<p>defaultValue：参数的默认值</p>\n<p>@ApiResponses：用于表示一组响应</p>\n<p>@ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息</p>\n<p>code：数字，例如400</p>\n<p>message：信息，例如”请求参数没填好”</p>\n<p>response：抛出异常的类</p>\n<p>@ApiModel：描述一个Model的信息（这种一般用在post创建的时候，使用@RequestBody这样的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候）表明这是一个被swagger框架管理的model，用于class上\n@ApiModel：使用在实体类上，描述实体类。\n@ApiModelProperty ：使用在实体类上的成员变量上，描述成员变量的含义。</p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200518172339513.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "JavaEE",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/",
      "content_html": "<h1 id=\"javaee\"> JavaEE</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "SSM - 02 - 获取bean的方式",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/SSM/SSM-02-%E8%8E%B7%E5%8F%96bean%E7%9A%84%E6%96%B9%E5%BC%8F/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/SSM/SSM-02-%E8%8E%B7%E5%8F%96bean%E7%9A%84%E6%96%B9%E5%BC%8F/",
      "content_html": "<h1 id=\"ssm-02-获取bean的方式\"> SSM - 02 - 获取bean的方式</h1>\n<h3 id=\"_1-通过id获取bean\"> 1. 通过id获取bean</h3>\n<div><pre><code><span>//通过id获取bean</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>testIoC1</span><span>(</span><span>)</span><span>{</span>\n    <span>Object</span> person <span>=</span> applicationContext<span>.</span><span>getBean</span><span>(</span><span>\"person\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>person<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_2-通过类型获取bean\"> 2. 通过类型获取bean</h3>\n<div><pre><code><span>//通过类型获取bean</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>testIoC2</span><span>(</span><span>)</span><span>{</span>\n    <span>Person</span> person <span>=</span> applicationContext<span>.</span><span>getBean</span><span>(</span><span>Person</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    person<span>.</span><span>say</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>\n<p>通过类型获取bean，在xml文件中<strong>只能配置一个该类型的bean</strong>，否则会报错</p>\n</blockquote>\n<div><pre><code><span>No</span> qualifying bean of type <span>'top.alanlee.study.spring.ioc.bean.Person'</span> available<span>:</span> expected single matching bean but found <span>2</span><span>:</span> person<span>,</span>person1\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "SSM - 01 - 搭建Spring项目",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/SSM/SSM-01-%E6%90%AD%E5%BB%BASpring%E9%A1%B9%E7%9B%AE/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/SSM/SSM-01-%E6%90%AD%E5%BB%BASpring%E9%A1%B9%E7%9B%AE/",
      "content_html": "<h1 id=\"ssm-01-搭建spring项目\"> SSM - 01 - 搭建Spring项目</h1>\n<h2 id=\"创建maven项目\"> 创建Maven项目</h2>\n<p><strong>1. 添加Spring依赖</strong></p>\n<p>在pom.xml文件中添加如下依赖</p>\n<div><pre><code><span>&lt;!-- ====== Spring 依赖 ====== --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-context<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>5.1.5.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n<span>&lt;!-- ====== Junit 依赖 ====== --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>junit<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>junit<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>4.12<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;</span>scope</span><span>></span></span>compile<span><span><span>&lt;/</span>scope</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>spring-context包含了spring的核心依赖包，如图</p>\n<p><strong>2. 创建目录结构</strong></p>\n<p><strong>3. 编写java类</strong></p>\n<p>Person.java</p>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>study<span>.</span>spring<span>.</span>ioc<span>.</span>bean</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>Person</span> <span>{</span>\n    <span>String</span> name<span>;</span>\n    <span>int</span> age<span>;</span>\n    <span>String</span> gender<span>;</span>\n\n    <span>public</span> <span>void</span> <span>say</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Hello, 我是\"</span> <span>+</span> name<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>say</span><span>(</span><span>String</span> name<span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Hello, 我是\"</span> <span>+</span> name<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>,</span> <span>String</span> gender<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n        <span>this</span><span>.</span>gender <span>=</span> gender<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>Person</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> age<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>getGender</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> gender<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setGender</span><span>(</span><span>String</span> gender<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>gender <span>=</span> gender<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"Person{\"</span> <span>+</span>\n                <span>\"name='\"</span> <span>+</span> name <span>+</span> <span>'\\''</span> <span>+</span>\n                <span>\", age=\"</span> <span>+</span> age <span>+</span>\n                <span>\", gender='\"</span> <span>+</span> gender <span>+</span> <span>'\\''</span> <span>+</span>\n                <span>'}'</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><p>Main.java</p>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>study<span>.</span>spring<span>.</span>ioc<span>.</span>bean</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span></span><span>ApplicationContext</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span>support<span>.</span></span><span>ClassPathXmlApplicationContext</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>//加载配置文件</span>\n        <span>ApplicationContext</span> applicationContext <span>=</span>\n                <span>new</span> <span>ClassPathXmlApplicationContext</span><span>(</span><span>\"applicationContext.xml\"</span><span>)</span><span>;</span>\n\n        <span>//获取bean</span>\n        <span>Person</span> person <span>=</span> applicationContext<span>.</span><span>getBean</span><span>(</span><span>Person</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        person<span>.</span><span>say</span><span>(</span><span>)</span><span>;</span>\n        person<span>.</span><span>say</span><span>(</span><span>\"AlanLee\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>4. 编写spring配置文件</strong></p>\n<p>applicationContext.xml</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span><span>&lt;</span>beans</span> <span>xmlns</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/beans<span>\"</span></span>\n       <span><span>xmlns:</span>xsi</span><span><span>=</span><span>\"</span>http://www.w3.org/2001/XMLSchema-instance<span>\"</span></span>\n       <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span>\"</span></span><span>></span></span>\n\n    <span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>person<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>top.alanlee.study.spring.ioc.bean.Person<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>name<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>Alan<span>\"</span></span> <span>/></span></span>\n        <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>age<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>18<span>\"</span></span> <span>/></span></span>\n        <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>gender<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>男<span>\"</span></span> <span>/></span></span>\n    <span><span><span>&lt;/</span>bean</span><span>></span></span>\n\n<span><span><span>&lt;/</span>beans</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>applicationContext.xml的文件名可随意取，但是一般是这个名字。</p>\n<p><strong>5. 运行Main类的main方法</strong></p>\n<p>输出结果</p>\n<div><pre><code><span>Hello</span><span>,</span> 我是<span>Alan</span>\n<span>Hello</span><span>,</span> 我是<span>AlanLee</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "SSM - 03 - 依赖注入的3种方式",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/SSM/SSM-03-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/SSM/SSM-03-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/",
      "content_html": "<h1 id=\"ssm-03-依赖注入的3种方式\"> SSM - 03 - 依赖注入的3种方式</h1>\n<h2 id=\"构造器注入\"> 构造器注入</h2>\n<p>在applicationContext.xml文件中加入</p>\n<div><pre><code><span>&lt;!-- ====== 构造器注入 ====== --></span>\n<span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>person1<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>top.alanlee.study.spring.ioc.bean.Person<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>constructor-arg</span> <span>index</span><span><span>=</span><span>\"</span>0<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>AlanLee<span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;</span>constructor-arg</span> <span>index</span><span><span>=</span><span>\"</span>1<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>23<span>\"</span></span> <span>/></span></span>\n    <span><span><span>&lt;</span>constructor-arg</span> <span>index</span><span><span>=</span><span>\"</span>2<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>男<span>\"</span></span><span>/></span></span>\n<span><span><span>&lt;/</span>bean</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"setter注入\"> setter注入</h2>\n<p>在applicationContext.xml文件中加入</p>\n<div><pre><code><span>&lt;!-- ====== setter注入 ====== --></span>\n<span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>person2<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>top.alanlee.study.spring.ioc.bean.Person<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>name<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>Alan<span>\"</span></span> <span>/></span></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>age<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>18<span>\"</span></span> <span>/></span></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>gender<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>男<span>\"</span></span> <span>/></span></span>\n<span><span><span>&lt;/</span>bean</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"接口注入\"> 接口注入</h2>\n<p>略</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "SSM - 04 - 装配Bean - XML方式",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/SSM/SSM-04-%E8%A3%85%E9%85%8DBean-XML%E6%96%B9%E5%BC%8F/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/SSM/SSM-04-%E8%A3%85%E9%85%8DBean-XML%E6%96%B9%E5%BC%8F/",
      "content_html": "<h1 id=\"ssm-04-装配bean-xml方式\"> SSM - 04 - 装配Bean - XML方式</h1>\n<h2 id=\"_1-装配普通值\"> 1. 装配普通值</h2>\n<div><pre><code><span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>person<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>top.alanlee.study.spring.ioc.bean.Person<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>name<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>Alan<span>\"</span></span> <span>/></span></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>age<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>18<span>\"</span></span> <span>/></span></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>gender<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>男<span>\"</span></span> <span>/></span></span>\n<span><span><span>&lt;/</span>bean</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"_2-装配集合\"> 2. 装配集合</h2>\n<p>编写一个java类</p>\n<p>ComplexAssembly.java</p>\n<div><pre><code><span>/**\n * 装配集合等复杂的属性\n */</span>\n<span>public</span> <span>class</span> <span>ComplexAssembly</span> <span>{</span>\n    <span>private</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list<span>;</span>\n    <span>private</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map<span>;</span>\n    <span>private</span> <span>Properties</span> properties<span>;</span>\n    <span>private</span> <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> set<span>;</span>\n    <span>private</span> <span>String</span><span>[</span><span>]</span> array<span>;</span>\n\n\t<span>//省略getter setter</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>xml配置</p>\n<div><pre><code><span>&lt;!-- ====== 装配集合 ====== --></span>\n<span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>complexAssembly<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>top.alanlee.study.spring.ioc.bean.ComplexAssembly<span>\"</span></span><span>></span></span>\n    <span>&lt;!-- 装配List --></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>list<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>list</span><span>></span></span>\n            <span><span><span>&lt;</span>value</span><span>></span></span>list-1<span><span><span>&lt;/</span>value</span><span>></span></span>\n            <span><span><span>&lt;</span>value</span><span>></span></span>list-2<span><span><span>&lt;/</span>value</span><span>></span></span>\n        <span><span><span>&lt;/</span>list</span><span>></span></span>\n    <span><span><span>&lt;/</span>property</span><span>></span></span>\n\n    <span>&lt;!-- 装配Map --></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>map<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>map</span><span>></span></span>\n            <span><span><span>&lt;</span>entry</span> <span>key</span><span><span>=</span><span>\"</span>key1<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>map-1<span>\"</span></span> <span>/></span></span>\n            <span><span><span>&lt;</span>entry</span> <span>key</span><span><span>=</span><span>\"</span>key2<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>map-2<span>\"</span></span> <span>/></span></span>\n        <span><span><span>&lt;/</span>map</span><span>></span></span>\n    <span><span><span>&lt;/</span>property</span><span>></span></span>\n\n    <span>&lt;!-- 装配Set --></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>set<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>set</span><span>></span></span>\n            <span><span><span>&lt;</span>value</span><span>></span></span>set-1<span><span><span>&lt;/</span>value</span><span>></span></span>\n            <span><span><span>&lt;</span>value</span><span>></span></span>set-2<span><span><span>&lt;/</span>value</span><span>></span></span>\n        <span><span><span>&lt;/</span>set</span><span>></span></span>\n    <span><span><span>&lt;/</span>property</span><span>></span></span>\n\n    <span>&lt;!-- 装配Properties --></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>properties<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>props</span><span>></span></span>\n            <span><span><span>&lt;</span>prop</span> <span>key</span><span><span>=</span><span>\"</span>prop1<span>\"</span></span><span>></span></span>prop-1<span><span><span>&lt;/</span>prop</span><span>></span></span>\n            <span><span><span>&lt;</span>prop</span> <span>key</span><span><span>=</span><span>\"</span>prop2<span>\"</span></span><span>></span></span>prop-2<span><span><span>&lt;/</span>prop</span><span>></span></span>\n        <span><span><span>&lt;/</span>props</span><span>></span></span>\n    <span><span><span>&lt;/</span>property</span><span>></span></span>\n\n    <span>&lt;!-- 装配Array --></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>array<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>array</span><span>></span></span>\n            <span><span><span>&lt;</span>value</span><span>></span></span>array-1<span><span><span>&lt;/</span>value</span><span>></span></span>\n            <span><span><span>&lt;</span>value</span><span>></span></span>array-2<span><span><span>&lt;/</span>value</span><span>></span></span>\n        <span><span><span>&lt;/</span>array</span><span>></span></span>\n    <span><span><span>&lt;/</span>property</span><span>></span></span>\n\n<span><span><span>&lt;/</span>bean</span><span>></span></span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p>测试</p>\n<div><pre><code><span>//装配集合类</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>testIoC3</span><span>(</span><span>)</span><span>{</span>\n    <span>Object</span> complexAssembly <span>=</span> applicationContext<span>.</span><span>getBean</span><span>(</span><span>\"complexAssembly\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>complexAssembly<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>输出结果</p>\n<div><pre><code><span>ComplexAssembly</span><span>{</span>list<span>=</span><span>[</span>list<span>-</span><span>1</span><span>,</span> list<span>-</span><span>2</span><span>]</span><span>,</span> map<span>=</span><span>{</span>key1<span>=</span>map<span>-</span><span>1</span><span>,</span> key2<span>=</span>map<span>-</span><span>2</span><span>}</span><span>,</span> properties<span>=</span><span>{</span>prop2<span>=</span>prop<span>-</span><span>2</span><span>,</span> prop1<span>=</span>prop<span>-</span><span>1</span><span>}</span><span>,</span> set<span>=</span><span>[</span>set<span>-</span><span>1</span><span>,</span> set<span>-</span><span>2</span><span>]</span><span>,</span> array<span>=</span><span>[</span>array<span>-</span><span>1</span><span>,</span> array<span>-</span><span>2</span><span>]</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"_3-通过命名空间装配\"> 3. 通过命名空间装配</h2>\n<h3 id=\"引入命名空间\"> 引入命名空间</h3>\n<p>xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\nxmlns:p=&quot;http://www.springframework.org/schema/p&quot;</p>\n<h3 id=\"命名空间装配-构造方法\"> 命名空间装配：构造方法</h3>\n<p>c_n:代表构造方法，n为数字，0为第一个参数，以此类推</p>\n<div><pre><code><span>&lt;!-- ====== 命名空间装配：构造方法 ====== --></span>\n<span>&lt;!-- c_n:代表构造方法，n为数字，0为第一个参数，以此类推--></span>\n<span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>person3<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>top.alanlee.study.spring.ioc.bean.Person<span>\"</span></span>\n      <span><span>c:</span>_0</span><span><span>=</span><span>\"</span>AlanLee-3<span>\"</span></span> <span><span>c:</span>_1</span><span><span>=</span><span>\"</span>23<span>\"</span></span> <span><span>c:</span>_2</span><span><span>=</span><span>\"</span>男<span>\"</span></span> <span>/></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"命名空间装配-装配属性\"> 命名空间装配：装配属性</h3>\n<p>p:代表属性</p>\n<div><pre><code><span>&lt;!-- ====== 命名空间装配：装配属性 ====== --></span>\n<span>&lt;!-- p:代表属性--></span>\n<span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>person4<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>top.alanlee.study.spring.ioc.bean.Person<span>\"</span></span>\n      <span><span>p:</span>name</span><span><span>=</span><span>\"</span>AlanLee-4<span>\"</span></span> <span><span>p:</span>age</span><span><span>=</span><span>\"</span>23<span>\"</span></span> <span><span>p:</span>gender</span><span><span>=</span><span>\"</span>男<span>\"</span></span> <span>/></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"测试\"> 测试</h3>\n<p>测试方法</p>\n<div><pre><code><span>//命令空间装配</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>testIoC4</span><span>(</span><span>)</span><span>{</span>\n    <span>//命令空间装配：构造方法</span>\n    <span>Object</span> person3 <span>=</span> applicationContext<span>.</span><span>getBean</span><span>(</span><span>\"person3\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"命令空间装配：构造方法\"</span> <span>+</span> person3<span>)</span><span>;</span>\n\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"---------------------\"</span><span>)</span><span>;</span>\n\n    <span>//命令空间装配：属性</span>\n    <span>Object</span> person4 <span>=</span> applicationContext<span>.</span><span>getBean</span><span>(</span><span>\"person4\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"命令空间装配：属性\"</span> <span>+</span> person4<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>结果</p>\n<div><pre><code>命令空间装配：构造方法<span>Person</span><span>{</span>name<span>=</span><span>'AlanLee-3'</span><span>,</span> age<span>=</span><span>23</span><span>,</span> gender<span>=</span><span>'男'</span><span>}</span>\n<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>\n命令空间装配：属性<span>Person</span><span>{</span>name<span>=</span><span>'AlanLee-4'</span><span>,</span> age<span>=</span><span>23</span><span>,</span> gender<span>=</span><span>'男'</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "SSM - 05 - 装配Bean - 注解方式",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/SSM/SSM-05-%E8%A3%85%E9%85%8DBean-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/SSM/SSM-05-%E8%A3%85%E9%85%8DBean-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/",
      "content_html": "<h1 id=\"ssm-05-装配bean-注解方式\"> SSM - 05 - 装配Bean - 注解方式</h1>\n<h2 id=\"使用注解前的准备\"> 使用注解前的准备</h2>\n<h3 id=\"编写实体类\"> 编写实体类</h3>\n<p>User.java</p>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>study<span>.</span>spring<span>.</span>ioc<span>.</span>bean</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>User</span> <span>{</span>\n    <span>private</span> <span>int</span> id<span>;</span>\n    <span>private</span> <span>String</span> username<span>;</span>\n    <span>private</span> <span>String</span> password<span>;</span>\n\n    <span>public</span> <span>User</span><span>(</span><span>int</span> id<span>,</span> <span>String</span> username<span>,</span> <span>String</span> password<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>id <span>=</span> id<span>;</span>\n        <span>this</span><span>.</span>username <span>=</span> username<span>;</span>\n        <span>this</span><span>.</span>password <span>=</span> password<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>User</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> id<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setId</span><span>(</span><span>int</span> id<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>id <span>=</span> id<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>getUsername</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> username<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setUsername</span><span>(</span><span>String</span> username<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>username <span>=</span> username<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>getPassword</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> password<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setPassword</span><span>(</span><span>String</span> password<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>password <span>=</span> password<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"User{\"</span> <span>+</span>\n                <span>\"id=\"</span> <span>+</span> id <span>+</span>\n                <span>\", username='\"</span> <span>+</span> username <span>+</span> <span>'\\''</span> <span>+</span>\n                <span>\", password='\"</span> <span>+</span> password <span>+</span> <span>'\\''</span> <span>+</span>\n                <span>'}'</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h3 id=\"开启注解的方式\"> 开启注解的方式</h3>\n<h4 id=\"在xml文件中启用注解方式\"> 在xml文件中启用注解方式</h4>\n<div><pre><code><span>&lt;!-- ====== 开启注解方式装配Bean ====== --></span>\n<span><span><span>&lt;</span><span>context:</span>component-scan</span> <span>base-package</span><span><span>=</span><span>\"</span>top.alanlee.study.spring.ioc<span>\"</span></span> <span>/></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>base-package指定扫描哪个包</p>\n<blockquote>\n<p><code>top.alanlee.study.spring.ioc</code> 表示扫描本包</p>\n<p><code>top.alanlee.study.spring.ioc.*</code> 表示扫描本包下的子包</p>\n<p><code>top.alanlee.study.spring.ioc.**</code> 表示扫描本包以及本包下的子包</p>\n</blockquote>\n<h4 id=\"使用java配置开启注解\"> 使用java配置开启注解</h4>\n<p>在要扫描的包下创建一个java配置类，加上@ComponentScan注解即可，无需编写逻辑。此时Spring可以扫描到本包中的Bean。</p>\n<p>ComponentScanConfig.java</p>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>study<span>.</span>spring<span>.</span>ioc<span>.</span>bean</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span>annotation<span>.</span></span><span>ComponentScan</span><span>;</span>\n\n<span>@ComponentScan</span>\n<span>public</span> <span>class</span> <span>ComponentScanConfig</span> <span>{</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_1-使用-component方式装配bean\"> 1. 使用@Component方式装配Bean</h2>\n<h4 id=\"装配bean\"> 装配Bean</h4>\n<ul>\n<li>\n<p>在类名上面添加@Component注解，将该类注册到Spring容器中，默认bean的id为类名首字母小写</p>\n</li>\n<li>\n<p>在属性上添加@Value注解，通过该注解给属性赋值</p>\n</li>\n</ul>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>User</span> <span>{</span>\n    <span>@Value</span><span>(</span><span>\"1\"</span><span>)</span>\n    <span>private</span> <span>int</span> id<span>;</span>\n    <span>@Value</span><span>(</span><span>\"AlanLee\"</span><span>)</span>\n    <span>private</span> <span>String</span> username<span>;</span>\n    <span>@Value</span><span>(</span><span>\"123456\"</span><span>)</span>\n    <span>private</span> <span>String</span> password<span>;</span>\n \n    <span>//省略getter setter</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id=\"测试\"> 测试</h4>\n<p>测试代码</p>\n<div><pre><code><span>//基于注解的方式装配Bean</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>testIoC5</span><span>(</span><span>)</span><span>{</span>\n    <span>Object</span> user <span>=</span> applicationContext<span>.</span><span>getBean</span><span>(</span><span>\"user\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>user<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>结果</p>\n<div><pre><code><span>User</span><span>{</span>id<span>=</span><span>1</span><span>,</span> username<span>=</span><span>'AlanLee'</span><span>,</span> password<span>=</span><span>'123456'</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"给bean指定名称\"> 给bean指定名称</h4>\n<p>在@Component注解后面加上名称即可。</p>\n<div><pre><code><span>@Component</span><span>(</span><span>\"alan\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>User</span> <span>{</span>\n    <span>@Value</span><span>(</span><span>\"1\"</span><span>)</span>\n    <span>private</span> <span>int</span> id<span>;</span>\n    <span>@Value</span><span>(</span><span>\"AlanLee\"</span><span>)</span>\n    <span>private</span> <span>String</span> username<span>;</span>\n    <span>@Value</span><span>(</span><span>\"123456\"</span><span>)</span>\n    <span>private</span> <span>String</span> password<span>;</span>\n \n    <span>//省略getter setter</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id=\"测试-2\"> 测试</h4>\n<p>测试代码</p>\n<div><pre><code><span>//基于注解的方式装配Bean</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>testIoC5</span><span>(</span><span>)</span><span>{</span>\n    <span>Object</span> user <span>=</span> applicationContext<span>.</span><span>getBean</span><span>(</span><span>\"alan\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>user<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>结果</p>\n<div><pre><code><span>User</span><span>{</span>id<span>=</span><span>1</span><span>,</span> username<span>=</span><span>'AlanLee'</span><span>,</span> password<span>=</span><span>'123456'</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<h4 id=\"使用java配置类的方式\"> 使用java配置类的方式</h4>\n<p>这里创建IoC容器时，使用AnnotationConfigApplicationContext方式，参数为java配置类的字节码文件</p>\n<p>测试代码</p>\n<div><pre><code><span>//基于注解的方式装配Bean - java类配置</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>testIoC6</span><span>(</span><span>)</span><span>{</span>\n    <span>ApplicationContext</span> applicationContext <span>=</span>\n        <span>new</span> <span>AnnotationConfigApplicationContext</span><span>(</span><span>ComponentScanConfig</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    <span>Object</span> user <span>=</span> applicationContext<span>.</span><span>getBean</span><span>(</span><span>\"user\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>user<span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>结果</p>\n<div><pre><code><span>User</span><span>{</span>id<span>=</span><span>1</span><span>,</span> username<span>=</span><span>'AlanLee'</span><span>,</span> password<span>=</span><span>'123456'</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div></blockquote>\n<h3 id=\"其他注解\"> 其他注解</h3>\n<p>除了@Component注解，之外还有其他注解，如Web开发中的常用注解</p>\n<ul>\n<li>@Controller 表示这是控制器层</li>\n<li>@Service 表示这是业务层</li>\n<li>@Repository 表示这是数据访问层</li>\n</ul>\n<p>这3个注解与@Component注解效果一样，只是在名字上区分，让程序员一眼就能看出来这是哪一层</p>\n<h2 id=\"_2-使用-autowired自动装配bean\"> 2. 使用@Autowired自动装配Bean</h2>\n<p>@Autowired注解是用在属性上的，比如我要在Controller层中注入Service类，在Service类中注入Dao类，就可以使用@Autowired注解。@Autowired注解可以让Spring去扫描该类的每一个属性。</p>\n<h4 id=\"创建3个java类\"> 创建3个java类</h4>\n<p>分别创建Controller、Service、Dao三层的类</p>\n<p>UserController.java</p>\n<div><pre><code><span>@Controller</span>\n<span>public</span> <span>class</span> <span>UserController</span> <span>{</span>\n    <span>@Autowired</span>\n    <span>private</span> <span>UserService</span> userService<span>;</span>\n\n    <span>public</span> <span>void</span> <span>save</span><span>(</span><span>)</span><span>{</span>\n        userService<span>.</span><span>save</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>UserService.java</p>\n<div><pre><code><span>@Service</span>\n<span>public</span> <span>class</span> <span>UserService</span> <span>{</span>\n    <span>@Autowired</span>\n    <span>private</span> <span>UserDao</span> userDao<span>;</span>\n\n    <span>public</span> <span>void</span> <span>save</span><span>(</span><span>)</span><span>{</span>\n        userDao<span>.</span><span>save</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>UserDao.java</p>\n<div><pre><code><span>@Repository</span>\n<span>public</span> <span>class</span> <span>UserDao</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>save</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"UserDao 保存数据到数据库\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id=\"测试-3\"> 测试</h4>\n<p>测试代码</p>\n<div><pre><code><span>//使用Autowired注解自动装配Bean</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>testIoC7</span><span>(</span><span>)</span><span>{</span>\n    <span>UserController</span> userController <span>=</span> applicationContext<span>.</span><span>getBean</span><span>(</span><span>UserController</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    userController<span>.</span><span>save</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>运行结果</p>\n<div><pre><code><span>UserDao</span> 保存数据到数据库\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200411141348-669694.png\" alt=\"image-20200411141344361\" /></p>\n<h4 id=\"其他\"> 其他</h4>\n<p>@Autowired注解也可以用在参数上，如</p>\n<div><pre><code><span>void</span> <span>func</span><span>(</span><span>@Autowired</span> <span>UserService</span> userService<span>)</span><span>{</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"_3-autowired注解引发的问题\"> 3. @Autowired注解引发的问题</h2>\n<p>在实际项目中，我们通常会把Service层的代码写成接口和实现类的方式，那么，如果一个接口有多个实现类的话，@Autowired就会出现问题，因为有多个实现类，它不知道该注入哪个实现类。为了解决该问题Spring提供了@Qulifier和@Primary注解来解决这个问题。</p>\n<h3 id=\"出现的问题\"> 出现的问题</h3>\n<p><strong>创建1个UserService接口，2个UserService的实现类</strong></p>\n<p>UserService2.java</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>UserService2</span> <span>{</span>\n    <span>void</span> <span>save</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>UserServiceImpl1.java</p>\n<div><pre><code><span>@Service</span>\n<span>public</span> <span>class</span> <span>UserServiceImpl1</span> <span>implements</span> <span>UserService2</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>save</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"UserServiceImpl ----- 1\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>UserServiceImpl2.java</p>\n<div><pre><code><span>@Service</span>\n<span>public</span> <span>class</span> <span>UserServiceImpl2</span> <span>implements</span> <span>UserService2</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>save</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"UserServiceImpl ----- 2\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>在UserController类中使用@Autowired注入UserService2接口</strong></p>\n<p>出现问题</p>\n<h3 id=\"解决方法\"> 解决方法</h3>\n<h4 id=\"方法1-使用-primary注解\"> 方法1：使用@Primary注解</h4>\n<p>在其中一个实现类中添加@Primary注解，该注解表示在有多个实现类时，优先使用本类装配Bean。</p>\n<p>例如，我在UserServiceImpl1中加入@Primary注解</p>\n<div><pre><code><span>@Service</span>\n<span>@Primary</span>\n<span>public</span> <span>class</span> <span>UserServiceImpl1</span> <span>implements</span> <span>UserService2</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>save</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"UserServiceImpl ----- 1\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>现在，UserController中的代码不会报错了</p>\n<p>测试代码</p>\n<div><pre><code><span>//解决多个bean时无法使用Autowired注解的问题</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>testIoC8</span><span>(</span><span>)</span><span>{</span>\n    <span>UserController</span> userController <span>=</span> applicationContext<span>.</span><span>getBean</span><span>(</span><span>UserController</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    userController<span>.</span><span>save</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>结果</p>\n<div><pre><code><span>UserServiceImpl</span> <span>--</span><span>--</span><span>-</span> <span>1</span>\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"方法2-使用-qualifier注解\"> 方法2：使用@Qualifier注解</h4>\n<p>@Qualifier注解表示选择一个合格的Bean进行装配</p>\n<p>在UserController中的@Autowired注解下面追加一个@Qualifier注解，同时指定Bean的名称，表示需要装配这个名字的Bean</p>\n<div><pre><code><span>@Controller</span>\n<span>public</span> <span>class</span> <span>UserController</span> <span>{</span>\n    <span>@Autowired</span>\n    <span>@Qualifier</span><span>(</span><span>\"userServiceImpl1\"</span><span>)</span>\n    <span>private</span> <span>UserService2</span> userService2<span>;</span>\n\n    <span>public</span> <span>void</span> <span>save</span><span>(</span><span>)</span><span>{</span>\n        userService2<span>.</span><span>save</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>测试代码</p>\n<div><pre><code><span>//解决多个bean时无法使用Autowired注解的问题</span>\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>testIoC8</span><span>(</span><span>)</span><span>{</span>\n    <span>UserController</span> userController <span>=</span> applicationContext<span>.</span><span>getBean</span><span>(</span><span>UserController</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    userController<span>.</span><span>save</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>结果</p>\n<div><pre><code><span>UserServiceImpl</span> <span>--</span><span>--</span><span>-</span> <span>1</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"_4-使用-bean装配bean\"> 4. 使用@Bean装配Bean</h2>\n<p>@Bean注解用在方法上，比如我们有时候要用到第三方包，但没有源码，不能使用直接使用@Component注解作用到类上，所以Spring提供了@Bean注解，可以给方法添加注解，该方法返回的对象作为Spring的Bean，保存到IoC容器中。</p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200411141348-669694.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring Boot",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/springboot/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/springboot/",
      "content_html": "<h1 id=\"spring-boot\"> Spring Boot</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "整合SSM",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/SSM/%E6%95%B4%E5%90%88SSM/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javaee/SSM/%E6%95%B4%E5%90%88SSM/",
      "content_html": "<h1 id=\"整合ssm\"> 整合SSM</h1>\n<blockquote>\n<p>SSM整合模板，我个人感觉整合SSM还是比较麻烦的，所以自己做个了整合好了的模板，下次创建SSM项目时可以直接使用该模板。</p>\n</blockquote>\n<h2 id=\"整合spring\"> 整合Spring</h2>\n<h3 id=\"添加spring的依赖\"> 添加Spring的依赖</h3>\n<p>在pom.xml文件中添加如下依赖</p>\n<div><pre><code><span>&lt;!-- ======BEGIN 单元测试 ====== --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>junit<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>junit<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>4.12<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n<span>&lt;!-- ======END 单元测试 ====== --></span>\n\n\n<span>&lt;!-- ======BEGIN Spring ====== --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-context<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>5.1.5.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n<span>&lt;!-- ======END Spring ====== --></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"添加spring配置文件applicationcontext-xml\"> 添加Spring配置文件applicationContext.xml</h3>\n<p>在resources文件夹下添加applicationContext.xml</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span><span>&lt;</span>beans</span> <span>xmlns</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/beans<span>\"</span></span>\n       <span><span>xmlns:</span>xsi</span><span><span>=</span><span>\"</span>http://www.w3.org/2001/XMLSchema-instance<span>\"</span></span>\n       <span><span>xmlns:</span>context</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/context<span>\"</span></span>\n       <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd<span>\"</span></span><span>></span></span>\n\n\n<span><span><span>&lt;/</span>beans</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>暂时不配置bean</p>\n<h3 id=\"修改web-xml-配置上下文参数-加载spring配置文件\"> 修改web.xml，配置上下文参数，加载Spring配置文件</h3>\n<p>在web.xml文件下添加如下配置</p>\n<div><pre><code><span>&lt;!-- 配置上下文参数，加载Spring配置文件 --></span>\n<span><span><span>&lt;</span>context-param</span><span>></span></span>\n    <span><span><span>&lt;</span>param-name</span><span>></span></span>contextConfigLocation<span><span><span>&lt;/</span>param-name</span><span>></span></span>\n    <span><span><span>&lt;</span>param-value</span><span>></span></span>classpath:applicationContext.xml<span><span><span>&lt;/</span>param-value</span><span>></span></span>\n<span><span><span>&lt;/</span>context-param</span><span>></span></span>\n\n<span><span><span>&lt;</span>welcome-file-list</span><span>></span></span>\n    <span><span><span>&lt;</span>welcome-file</span><span>></span></span>index.jsp<span><span><span>&lt;/</span>welcome-file</span><span>></span></span>\n<span><span><span>&lt;/</span>welcome-file-list</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"整合spring-mvc\"> 整合Spring MVC</h2>\n<h3 id=\"添加springmvc的依赖\"> 添加SpringMVC的依赖</h3>\n<p>在pom.xml文件中添加如下依赖</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-webmvc<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>5.1.5.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"配置转发servlet\"> 配置转发Servlet</h3>\n<p>在web.xml文件下添加如下配置</p>\n<div><pre><code><span><span><span>&lt;</span>listener</span><span>></span></span>\n    <span><span><span>&lt;</span>listener-class</span><span>></span></span>org.springframework.web.context.ContextLoaderListener<span><span><span>&lt;/</span>listener-class</span><span>></span></span>\n<span><span><span>&lt;/</span>listener</span><span>></span></span>\n\n<span><span><span>&lt;</span>servlet</span><span>></span></span>\n    <span><span><span>&lt;</span>servlet-name</span><span>></span></span>dispatcher<span><span><span>&lt;/</span>servlet-name</span><span>></span></span>\n    <span><span><span>&lt;</span>servlet-class</span><span>></span></span>org.springframework.web.servlet.DispatcherServlet<span><span><span>&lt;/</span>servlet-class</span><span>></span></span>\n<span><span><span>&lt;/</span>servlet</span><span>></span></span>\n\n<span><span><span>&lt;</span>servlet-mapping</span><span>></span></span>\n    <span><span><span>&lt;</span>servlet-name</span><span>></span></span>dispatcher<span><span><span>&lt;/</span>servlet-name</span><span>></span></span>\n    <span><span><span>&lt;</span>url-pattern</span><span>></span></span>/<span><span><span>&lt;/</span>url-pattern</span><span>></span></span>\n<span><span><span>&lt;/</span>servlet-mapping</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>在WEB-INF文件夹下创建dispatcher-servlet.xml，配置如下</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span><span>&lt;</span>beans</span> <span>xmlns</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/beans<span>\"</span></span>\n       <span><span>xmlns:</span>xsi</span><span><span>=</span><span>\"</span>http://www.w3.org/2001/XMLSchema-instance<span>\"</span></span> <span><span>xmlns:</span>mvc</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/mvc<span>\"</span></span>\n       <span><span>xmlns:</span>context</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/context<span>\"</span></span>\n       <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd<span>\"</span></span><span>></span></span>\n\n    <span>&lt;!-- 配置Spring扫描组件的包路径 --></span>\n    <span><span><span>&lt;</span><span>context:</span>component-scan</span> <span>base-package</span><span><span>=</span><span>\"</span>top.alanlee.pam.*<span>\"</span></span> <span>/></span></span>\n\n    <span>&lt;!-- 启用注解配置 --></span>\n    <span><span><span>&lt;</span><span>mvc:</span>annotation-driven</span> <span>/></span></span>\n    \n    <span>&lt;!-- 配置视图解析器 --></span>\n    <span><span><span>&lt;</span>bean</span> <span>class</span><span><span>=</span><span>\"</span>org.springframework.web.servlet.view.InternalResourceViewResolver<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>prefix<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>/WEB-INF/jsp/<span>\"</span></span> <span>/></span></span>\n        <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>suffix<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>.jsp<span>\"</span></span> <span>/></span></span>\n    <span><span><span>&lt;/</span>bean</span><span>></span></span>\n\n<span><span><span>&lt;/</span>beans</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><blockquote>\n<p>如果需要在需要返回json数据，则需要配置消息转换器，采用如下配置</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span><span>&lt;</span>beans</span> <span>xmlns</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/beans<span>\"</span></span>\n    <span><span>xmlns:</span>xsi</span><span><span>=</span><span>\"</span>http://www.w3.org/2001/XMLSchema-instance<span>\"</span></span> <span><span>xmlns:</span>mvc</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/mvc<span>\"</span></span>\n    <span><span>xmlns:</span>context</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/context<span>\"</span></span>\n    <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd<span>\"</span></span><span>></span></span>\n\n <span>&lt;!-- 配置Spring扫描组件的包路径 --></span>\n <span><span><span>&lt;</span><span>context:</span>component-scan</span> <span>base-package</span><span><span>=</span><span>\"</span>top.alanlee.pam.*<span>\"</span></span> <span>/></span></span>\n\n <span>&lt;!-- 启用注解配置 --></span>\n <span>&lt;!-- Start: 配置json消息转换器 &amp; 参数解析--></span>\n <span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>objectMapper<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>com.fasterxml.jackson.databind.ObjectMapper<span>\"</span></span><span>></span></span>\n     <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>dateFormat<span>\"</span></span><span>></span></span>\n         <span><span><span>&lt;</span>bean</span> <span>class</span><span><span>=</span><span>\"</span>java.text.SimpleDateFormat<span>\"</span></span><span>></span></span>\n             <span><span><span>&lt;</span>constructor-arg</span> <span>index</span><span><span>=</span><span>\"</span>0<span>\"</span></span> <span>type</span><span><span>=</span><span>\"</span>java.lang.String<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>yyyy-MM-dd HH:mm:ss<span>\"</span></span><span>/></span></span>\n         <span><span><span>&lt;/</span>bean</span><span>></span></span>\n     <span><span><span>&lt;/</span>property</span><span>></span></span>\n <span><span><span>&lt;/</span>bean</span><span>></span></span>\n <span><span><span>&lt;</span><span>mvc:</span>annotation-driven</span><span>></span></span>\n     <span><span><span>&lt;</span><span>mvc:</span>message-converters</span> <span>register-defaults</span><span><span>=</span><span>\"</span>true<span>\"</span></span><span>></span></span>\n         <span><span><span>&lt;</span>bean</span> <span>class</span><span><span>=</span><span>\"</span>org.springframework.http.converter.json.MappingJackson2HttpMessageConverter<span>\"</span></span><span>></span></span>\n             <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>supportedMediaTypes<span>\"</span></span><span>></span></span>\n                 <span><span><span>&lt;</span>list</span><span>></span></span>\n                     <span><span><span>&lt;</span>value</span><span>></span></span>application/json; charset=UTF-8<span><span><span>&lt;/</span>value</span><span>></span></span>\n                 <span><span><span>&lt;/</span>list</span><span>></span></span>\n             <span><span><span>&lt;/</span>property</span><span>></span></span>\n             <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>prettyPrint<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>true<span>\"</span></span><span>/></span></span>\n             <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>objectMapper<span>\"</span></span> <span>ref</span><span><span>=</span><span>\"</span>objectMapper<span>\"</span></span><span>/></span></span>\n         <span><span><span>&lt;/</span>bean</span><span>></span></span>\n     <span><span><span>&lt;/</span><span>mvc:</span>message-converters</span><span>></span></span>\n <span><span><span>&lt;/</span><span>mvc:</span>annotation-driven</span><span>></span></span>\n <span>&lt;!-- End: 配置json消息转换器 &amp; 参数解析 --></span>\n\n <span>&lt;!-- 配置视图解析器 --></span>\n <span><span><span>&lt;</span>bean</span> <span>class</span><span><span>=</span><span>\"</span>org.springframework.web.servlet.view.InternalResourceViewResolver<span>\"</span></span><span>></span></span>\n     <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>prefix<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>/WEB-INF/jsp/<span>\"</span></span> <span>/></span></span>\n     <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>suffix<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>.jsp<span>\"</span></span> <span>/></span></span>\n <span><span><span>&lt;/</span>bean</span><span>></span></span>\n\n<span><span><span>&lt;/</span>beans</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>同时还需要在pom.xml中加上jackson的依赖</p>\n<div><pre><code><span>&lt;!-- ======BEGIN 处理json ====== --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.fasterxml.jackson.core<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>jackson-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>2.9.9<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.fasterxml.jackson.core<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>jackson-annotations<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>2.9.9<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.fasterxml.jackson.core<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>jackson-databind<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>2.9.9<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n<span>&lt;!-- ======END 处理json ====== --></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></blockquote>\n<p>在WEB-INF文件夹下创建jsp的文件夹（用来存放jsp文件）</p>\n<h2 id=\"整合mybatis\"> 整合MyBatis</h2>\n<h3 id=\"添加相关依赖\"> 添加相关依赖</h3>\n<p>在pom.xml文件中添加如下依赖</p>\n<div><pre><code><span>&lt;!-- ======BEGIN MyBatis ====== --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mybatis<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>mybatis<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>3.4.6<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mybatis<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>mybatis-spring<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>1.3.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n<span>&lt;!-- ======END MyBatis ====== --></span>\n\n<span>&lt;!-- ======BEGIN 数据库相关 ====== --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>mysql<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>mysql-connector-java<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>5.1.47<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.alibaba<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>druid<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>1.1.21<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-tx<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>5.1.5.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-jdbc<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>5.1.5.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n<span>&lt;!-- ======END 数据库相关 ====== --></span>\n\n<span>&lt;!-- ======BEGIN 日志 ====== --></span>\n<span>&lt;!-- MyBatis 依赖log4j --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>log4j<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>log4j<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>1.2.17<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n<span>&lt;!-- ======END 日志 ====== --></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><h3 id=\"添加mybatis配置文件mybatis-config-xml\"> 添加MyBatis配置文件mybatis-config.xml</h3>\n<p>在resources文件夹下创建mybatis-config.xml，配置如下</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?></span>\n<span><span>&lt;!</span><span>DOCTYPE</span> <span>configuration</span>\n        <span>PUBLIC</span> <span>\"-//mybatis.org//DTD Config 3.0//EN\"</span>\n        <span>\"http://mybatis.org/dtd/mybatis-3-config.dtd\"</span><span>></span></span>\n<span><span><span>&lt;</span>configuration</span><span>></span></span>\n    <span><span><span>&lt;</span>settings</span><span>></span></span>\n        <span><span><span>&lt;</span>setting</span> <span>name</span><span><span>=</span><span>\"</span>logImpl<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>LOG4J<span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;/</span>settings</span><span>></span></span>\n<span><span><span>&lt;/</span>configuration</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"添加log4f配置文件log4j-properties\"> 添加log4f配置文件log4j.properties</h3>\n<p>在resources文件夹下创建log4j.properties，内容如下</p>\n<div><pre><code><span>log4j.rootLogger</span><span>=</span><span>INFO,DEBUG,CONSOLE,file</span>\n<span>log4j.logger.com.jingze</span><span>=</span><span>debug</span>\n<span>log4j.logger.com.ibatis</span><span>=</span><span>info </span>\n<span>log4j.logger.com.ibatis.common.jdbc.SimpleDataSource</span><span>=</span><span>info </span>\n<span>log4j.logger.com.ibatis.common.jdbc.ScriptRunner</span><span>=</span><span>info </span>\n<span>log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate</span><span>=</span><span>info </span>\n<span>log4j.logger.java.sql.Connection</span><span>=</span><span>info </span>\n<span>log4j.logger.java.sql.Statement</span><span>=</span><span>info </span>\n<span>log4j.logger.java.sql.PreparedStatement</span><span>=</span><span>info </span>\n<span>log4j.logger.java.sql.ResultSet</span><span>=</span><span>info</span>\n\n<span>log4j.appender.CONSOLE</span><span>=</span><span>org.apache.log4j.ConsoleAppender</span>\n<span>log4j.appender.Threshold</span><span>=</span><span>error</span>\n<span>log4j.appender.CONSOLE.Target</span><span>=</span><span>System.out</span>\n<span>log4j.appender.CONSOLE.layout</span><span>=</span><span>org.apache.log4j.PatternLayout</span>\n<span>log4j.appender.CONSOLE.layout.ConversionPattern</span><span>=</span> <span>%-d{yyyy-MM-dd HH:mm:ss} [%5p]-[%.10t]-[%.20C] - %m%n</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"添加jdbc配置文件jdbc-properties\"> 添加jdbc配置文件jdbc.properties</h3>\n<p>在resources文件夹下创建jdbc.properties，内容如下</p>\n<div><pre><code><span>jdbc.user</span><span>=</span><span>root</span>\n<span>jdbc.password</span><span>=</span><span>123456</span>\n<span>jdbc.driver</span><span>=</span><span>com.mysql.jdbc.Driver</span>\n<span>jdbc.url</span><span>=</span><span>jdbc:mysql://localhost:3306/ssm_template?useUnicode=true&amp;characterEncoding=utf-8</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"将mybatis集成到spring中\"> 将MyBatis集成到Spring中</h3>\n<p>在applicationContext.xml中的beans节点下添加如下配置</p>\n<div><pre><code><span>&lt;!-- 加载properties配置文件 --></span>\n<span><span><span>&lt;</span><span>context:</span>property-placeholder</span> <span>location</span><span><span>=</span><span>\"</span>classpath:jdbc.properties<span>\"</span></span> <span>/></span></span>\n\n<span>&lt;!-- 配置数据源 --></span>\n<span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>dataSource<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>com.alibaba.druid.pool.DruidDataSource<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>url<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>${jdbc.url}<span>\"</span></span> <span>/></span></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>username<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>${jdbc.user}<span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>password<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>${jdbc.password}<span>\"</span></span><span>/></span></span>\n<span><span><span>&lt;/</span>bean</span><span>></span></span>\n\n<span>&lt;!-- 配置SessionFactory --></span>\n<span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>sqlSessionFactory<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>org.mybatis.spring.SqlSessionFactoryBean<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>dataSource<span>\"</span></span> <span>ref</span><span><span>=</span><span>\"</span>dataSource<span>\"</span></span> <span>/></span></span>\n    <span>&lt;!-- 配置 xxxMapper.xml 文件的路径 --></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>mapperLocations<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>classpath*:/mapper/*Mapper.xml<span>\"</span></span> <span>/></span></span>\n    <span>&lt;!-- 配置 MyBatis配置文件 mybatis-config.xml 的路径--></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>configLocation<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>classpath:mybatis-config.xml<span>\"</span></span> <span>/></span></span>\n<span><span><span>&lt;/</span>bean</span><span>></span></span>\n\n<span>&lt;!-- Mapper扫描配置 --></span>\n<span><span><span>&lt;</span>bean</span> <span>class</span><span><span>=</span><span>\"</span>org.mybatis.spring.mapper.MapperScannerConfigurer<span>\"</span></span><span>></span></span>\n    <span>&lt;!-- 配置XxxMapper.java的路径 --></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>basePackage<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>top.alanlee.pam.mapper.**<span>\"</span></span> <span>/></span></span>\n    <span>&lt;!-- 配置sqlSessionFactoryBeanName --></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>sqlSessionFactoryBeanName<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>sqlSessionFactory<span>\"</span></span> <span>/></span></span>\n<span><span><span>&lt;/</span>bean</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id=\"添加xxxmapper-java文件\"> 添加XxxMapper.java文件</h3>\n<p>在src源码目录中添加UserMapper.java</p>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>pam<span>.</span>mapper</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>apache<span>.</span>ibatis<span>.</span>annotations<span>.</span></span><span>Mapper</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>stereotype<span>.</span></span><span>Repository</span><span>;</span>\n<span>import</span> <span>top<span>.</span>alanlee<span>.</span>pam<span>.</span>entity<span>.</span></span><span>User</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>List</span><span>;</span>\n\n<span>@Mapper</span>\n<span>@Repository</span>\n<span>public</span> <span>interface</span> <span>UserMapper</span> <span>{</span>\n\n    <span>List</span><span><span>&lt;</span><span>User</span><span>></span></span> <span>getAllUsers</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"添加xxxmapper-xml文件\"> 添加XxxMapper.xml文件</h3>\n<p>在resource目录中创建mapper文件夹，在mapper文件夹中添加UserMapper.xml，内容如下</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?></span>\n<span><span>&lt;!</span><span>DOCTYPE</span> <span>mapper</span> <span>PUBLIC</span> <span>\"-//mybatis.org//DTD Mapper 3.0//EN\"</span>\n        <span>\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span><span>></span></span>\n<span><span><span>&lt;</span>mapper</span> <span>namespace</span><span><span>=</span><span>\"</span>top.alanlee.pam.mapper.UserMapper<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>select</span> <span>id</span><span><span>=</span><span>\"</span>getAllUsers<span>\"</span></span>\n            <span>resultType</span><span><span>=</span><span>\"</span>top.alanlee.pam.entity.User<span>\"</span></span><span>></span></span>\n        SELECT *\n        FROM t_user\n    <span><span><span>&lt;/</span>select</span><span>></span></span>\n<span><span><span>&lt;/</span>mapper</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"完整的配置文件\"> 完整的配置文件</h2>\n<h3 id=\"pom-xml\"> pom.xml</h3>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n\n<span><span><span>&lt;</span>project</span> <span>xmlns</span><span><span>=</span><span>\"</span>http://maven.apache.org/POM/4.0.0<span>\"</span></span> <span><span>xmlns:</span>xsi</span><span><span>=</span><span>\"</span>http://www.w3.org/2001/XMLSchema-instance<span>\"</span></span>\n  <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>\"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>modelVersion</span><span>></span></span>4.0.0<span><span><span>&lt;/</span>modelVersion</span><span>></span></span>\n\n  <span><span><span>&lt;</span>groupId</span><span>></span></span>pam.alanlee.top<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n  <span><span><span>&lt;</span>artifactId</span><span>></span></span>ssm-personal-account-management<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n  <span><span><span>&lt;</span>version</span><span>></span></span>1.0-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>\n  <span><span><span>&lt;</span>packaging</span><span>></span></span>war<span><span><span>&lt;/</span>packaging</span><span>></span></span>\n\n  <span><span><span>&lt;</span>name</span><span>></span></span>ssm-personal-account-management<span><span><span>&lt;/</span>name</span><span>></span></span>\n\n\n  <span><span><span>&lt;</span>properties</span><span>></span></span>\n    <span><span><span>&lt;</span>project.build.sourceEncoding</span><span>></span></span>UTF-8<span><span><span>&lt;/</span>project.build.sourceEncoding</span><span>></span></span>\n    <span><span><span>&lt;</span>maven.compiler.source</span><span>></span></span>1.8<span><span><span>&lt;/</span>maven.compiler.source</span><span>></span></span>\n    <span><span><span>&lt;</span>maven.compiler.target</span><span>></span></span>1.8<span><span><span>&lt;/</span>maven.compiler.target</span><span>></span></span>\n  <span><span><span>&lt;/</span>properties</span><span>></span></span>\n\n  <span><span><span>&lt;</span>dependencies</span><span>></span></span>\n    <span>&lt;!-- ======BEGIN 单元测试 ====== --></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>junit<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>junit<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>version</span><span>></span></span>4.12<span><span><span>&lt;/</span>version</span><span>></span></span>\n      <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n    <span>&lt;!-- ======END 单元测试 ====== --></span>\n\n\n    <span>&lt;!-- ======BEGIN Spring ====== --></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-context<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>version</span><span>></span></span>5.1.5.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-tx<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>version</span><span>></span></span>5.1.5.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-jdbc<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>version</span><span>></span></span>5.1.5.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-webmvc<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>version</span><span>></span></span>5.1.5.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n    <span>&lt;!-- ======END Spring ====== --></span>\n\n\n    <span>&lt;!-- ======BEGIN MyBatis ====== --></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mybatis<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>mybatis<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>version</span><span>></span></span>3.4.6<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mybatis<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>mybatis-spring<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>version</span><span>></span></span>1.3.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n    <span>&lt;!-- ======END MyBatis ====== --></span>\n\n\n    <span>&lt;!-- ======BEGIN 日志 ====== --></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>log4j<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>log4j<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>version</span><span>></span></span>1.2.17<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n    <span>&lt;!-- ======END 日志 ====== --></span>\n\n\n    <span>&lt;!-- ======BEGIN 数据库相关 ====== --></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>mysql<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>mysql-connector-java<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>version</span><span>></span></span>5.1.47<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>com.alibaba<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>druid<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>version</span><span>></span></span>1.1.21<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n    <span>&lt;!-- ======END 数据库相关 ====== --></span>\n\n    <span>&lt;!-- ======BEGIN 处理json ====== --></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>com.alibaba<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>fastjson<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>version</span><span>></span></span>1.2.62<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>com.fasterxml.jackson.core<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>jackson-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>version</span><span>></span></span>2.9.9<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>com.fasterxml.jackson.core<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>jackson-annotations<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>version</span><span>></span></span>2.9.9<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>com.fasterxml.jackson.core<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>jackson-databind<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>version</span><span>></span></span>2.9.9<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n    <span>&lt;!-- ======END 处理json ====== --></span>\n\n  <span><span><span>&lt;/</span>dependencies</span><span>></span></span>\n\n  <span><span><span>&lt;</span>build</span><span>></span></span>\n    <span><span><span>&lt;</span>finalName</span><span>></span></span>ssm-personal-account-management<span><span><span>&lt;/</span>finalName</span><span>></span></span>\n    <span><span><span>&lt;</span>pluginManagement</span><span>></span></span><span>&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --></span>\n      <span><span><span>&lt;</span>plugins</span><span>></span></span>\n        <span><span><span>&lt;</span>plugin</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-clean-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>3.1.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span>&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --></span>\n        <span><span><span>&lt;</span>plugin</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-resources-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>3.0.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;</span>plugin</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-compiler-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>3.8.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;</span>plugin</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-surefire-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>2.22.1<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;</span>plugin</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-war-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>3.2.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;</span>plugin</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-install-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>2.5.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;</span>plugin</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-deploy-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>2.8.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n      <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n    <span><span><span>&lt;/</span>pluginManagement</span><span>></span></span>\n    <span><span><span>&lt;</span>resources</span><span>></span></span>\n      <span><span><span>&lt;</span>resource</span><span>></span></span>\n        <span><span><span>&lt;</span>directory</span><span>></span></span>\n          src/main/java\n        <span><span><span>&lt;/</span>directory</span><span>></span></span>\n        <span><span><span>&lt;</span>includes</span><span>></span></span>\n          <span><span><span>&lt;</span>include</span><span>></span></span>**/*.xml<span><span><span>&lt;/</span>include</span><span>></span></span>\n        <span><span><span>&lt;/</span>includes</span><span>></span></span>\n      <span><span><span>&lt;/</span>resource</span><span>></span></span>\n\n      <span><span><span>&lt;</span>resource</span><span>></span></span>\n        <span><span><span>&lt;</span>directory</span><span>></span></span>src/main/resources<span><span><span>&lt;/</span>directory</span><span>></span></span>\n      <span><span><span>&lt;/</span>resource</span><span>></span></span>\n    <span><span><span>&lt;/</span>resources</span><span>></span></span>\n  <span><span><span>&lt;/</span>build</span><span>></span></span>\n<span><span><span>&lt;/</span>project</span><span>></span></span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br></div></div><h3 id=\"web-xml\"> web.xml</h3>\n<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>web-app</span> <span>PUBLIC</span>\n <span>\"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"</span>\n <span>\"http://java.sun.com/dtd/web-app_2_3.dtd\"</span> <span>></span></span>\n\n<span><span><span>&lt;</span>web-app</span><span>></span></span>\n    <span>&lt;!-- 配置上下文参数，加载Spring配置文件 --></span>\n    <span><span><span>&lt;</span>context-param</span><span>></span></span>\n        <span><span><span>&lt;</span>param-name</span><span>></span></span>contextConfigLocation<span><span><span>&lt;/</span>param-name</span><span>></span></span>\n        <span><span><span>&lt;</span>param-value</span><span>></span></span>classpath:applicationContext.xml<span><span><span>&lt;/</span>param-value</span><span>></span></span>\n    <span><span><span>&lt;/</span>context-param</span><span>></span></span>\n\n    <span>&lt;!-- 配置上下文加载监听器 --></span>\n    <span><span><span>&lt;</span>listener</span><span>></span></span>\n        <span><span><span>&lt;</span>listener-class</span><span>></span></span>org.springframework.web.context.ContextLoaderListener<span><span><span>&lt;/</span>listener-class</span><span>></span></span>\n    <span><span><span>&lt;/</span>listener</span><span>></span></span>\n\n    <span>&lt;!-- 配置DispatcherServlet --></span>\n    <span><span><span>&lt;</span>servlet</span><span>></span></span>\n        <span><span><span>&lt;</span>servlet-name</span><span>></span></span>dispatcher<span><span><span>&lt;/</span>servlet-name</span><span>></span></span>\n        <span><span><span>&lt;</span>servlet-class</span><span>></span></span>org.springframework.web.servlet.DispatcherServlet<span><span><span>&lt;/</span>servlet-class</span><span>></span></span>\n    <span><span><span>&lt;/</span>servlet</span><span>></span></span>\n    <span><span><span>&lt;</span>servlet-mapping</span><span>></span></span>\n        <span><span><span>&lt;</span>servlet-name</span><span>></span></span>dispatcher<span><span><span>&lt;/</span>servlet-name</span><span>></span></span>\n        <span><span><span>&lt;</span>url-pattern</span><span>></span></span>/<span><span><span>&lt;/</span>url-pattern</span><span>></span></span>\n    <span><span><span>&lt;/</span>servlet-mapping</span><span>></span></span>\n    \n    <span><span><span>&lt;</span>welcome-file-list</span><span>></span></span>\n        <span><span><span>&lt;</span>welcome-file</span><span>></span></span>index.jsp<span><span><span>&lt;/</span>welcome-file</span><span>></span></span>\n    <span><span><span>&lt;/</span>welcome-file-list</span><span>></span></span>\n<span><span><span>&lt;/</span>web-app</span><span>></span></span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h3 id=\"applicationcontext-xml\"> applicationContext.xml</h3>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span><span>&lt;</span>beans</span> <span>xmlns</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/beans<span>\"</span></span>\n       <span><span>xmlns:</span>xsi</span><span><span>=</span><span>\"</span>http://www.w3.org/2001/XMLSchema-instance<span>\"</span></span>\n       <span><span>xmlns:</span>context</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/context<span>\"</span></span>\n       <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>\"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd<span>\"</span></span><span>></span></span>\n\n    <span>&lt;!-- 加载properties配置文件 --></span>\n    <span><span><span>&lt;</span><span>context:</span>property-placeholder</span> <span>location</span><span><span>=</span><span>\"</span>classpath:jdbc.properties<span>\"</span></span> <span>/></span></span>\n\n    <span>&lt;!-- 配置数据源 --></span>\n    <span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>dataSource<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>com.alibaba.druid.pool.DruidDataSource<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>url<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>${jdbc.url}<span>\"</span></span> <span>/></span></span>\n        <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>username<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>${jdbc.user}<span>\"</span></span><span>/></span></span>\n        <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>password<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>${jdbc.password}<span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;/</span>bean</span><span>></span></span>\n\n    <span>&lt;!-- 配置SessionFactory --></span>\n    <span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>sqlSessionFactory<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>org.mybatis.spring.SqlSessionFactoryBean<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>dataSource<span>\"</span></span> <span>ref</span><span><span>=</span><span>\"</span>dataSource<span>\"</span></span> <span>/></span></span>\n        <span>&lt;!-- 配置 xxxMapper.xml 文件的路径 --></span>\n        <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>mapperLocations<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>classpath*:/mapper/*Mapper.xml<span>\"</span></span> <span>/></span></span>\n        <span>&lt;!-- 配置 MyBatis配置文件 mybatis-config.xml 的路径--></span>\n        <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>configLocation<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>classpath:mybatis-config.xml<span>\"</span></span> <span>/></span></span>\n    <span><span><span>&lt;/</span>bean</span><span>></span></span>\n\n    <span>&lt;!-- Mapper扫描配置 --></span>\n    <span><span><span>&lt;</span>bean</span> <span>class</span><span><span>=</span><span>\"</span>org.mybatis.spring.mapper.MapperScannerConfigurer<span>\"</span></span><span>></span></span>\n        <span>&lt;!-- 配置XxxMapper.java的路径 --></span>\n        <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>basePackage<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>top.alanlee.pam.mapper.**<span>\"</span></span> <span>/></span></span>\n        <span>&lt;!-- 配置sqlSessionFactoryBeanName --></span>\n        <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>sqlSessionFactoryBeanName<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>sqlSessionFactory<span>\"</span></span> <span>/></span></span>\n    <span><span><span>&lt;/</span>bean</span><span>></span></span>\n\n<span><span><span>&lt;/</span>beans</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h3 id=\"mybatis-config-xml\"> mybatis-config.xml</h3>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?></span>\n<span><span>&lt;!</span><span>DOCTYPE</span> <span>configuration</span>\n        <span>PUBLIC</span> <span>\"-//mybatis.org//DTD Config 3.0//EN\"</span>\n        <span>\"http://mybatis.org/dtd/mybatis-3-config.dtd\"</span><span>></span></span>\n<span><span><span>&lt;</span>configuration</span><span>></span></span>\n    <span><span><span>&lt;</span>settings</span><span>></span></span>\n        <span><span><span>&lt;</span>setting</span> <span>name</span><span><span>=</span><span>\"</span>logImpl<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>LOG4J<span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;/</span>settings</span><span>></span></span>\n    <span><span><span>&lt;</span>typeAliases</span><span>></span></span>\n        <span>&lt;!-- 包别名 --></span>\n        <span><span><span>&lt;</span>package</span> <span>name</span><span><span>=</span><span>\"</span>top.alanlee.pam.entity<span>\"</span></span> <span>/></span></span>\n    <span><span><span>&lt;/</span>typeAliases</span><span>></span></span>\n<span><span><span>&lt;/</span>configuration</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"jdbc-properties\"> jdbc.properties</h3>\n<div><pre><code><span>jdbc.user</span><span>=</span><span>root</span>\n<span>jdbc.password</span><span>=</span><span>123456</span>\n<span>jdbc.driver</span><span>=</span><span>com.mysql.jdbc.Driver</span>\n<span>jdbc.url</span><span>=</span><span>jdbc:mysql://localhost:3306/ssm_template?useUnicode=true&amp;characterEncoding=utf-8</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"log4j-properties\"> log4j.properties</h3>\n<div><pre><code>log4j.rootLogger=INFO,DEBUG,CONSOLE,file\nlog4j.logger.com.jingze=debug\nlog4j.logger.com.ibatis=info \nlog4j.logger.com.ibatis.common.jdbc.SimpleDataSource=info \nlog4j.logger.com.ibatis.common.jdbc.ScriptRunner=info \nlog4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=info \nlog4j.logger.java.sql.Connection=info \nlog4j.logger.java.sql.Statement=info \nlog4j.logger.java.sql.PreparedStatement=info \nlog4j.logger.java.sql.ResultSet=info\n\nlog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\nlog4j.appender.Threshold=error\nlog4j.appender.CONSOLE.Target=System.out\nlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\nlog4j.appender.CONSOLE.layout.ConversionPattern= %-d{yyyy-MM-dd HH:mm:ss} [%5p]-[%.10t]-[%.20C] - %m%n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"运行\"> 运行</h2>\n<h3 id=\"导入sql\"> 导入sql</h3>\n<p>将resource/sql目录下的sql脚本ssm_template.sql导入自己的数据库</p>\n<h3 id=\"idea配置启动参数\"> IDEA配置启动参数</h3>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200413170714-647525.png\" alt=\"image-20200413170712565\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200413221220-515093.png\" alt=\"image-20200413170803452\" /></p>\n<h3 id=\"浏览器输入http-localhost-8081-ssm\"> 浏览器输入http://localhost:8081/ssm/</h3>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200413170139-593578.png\" alt=\"image-20200413170139159\" /></p>\n<h3 id=\"浏览器输入http-localhost-8081-ssm-user-get-all-输出json数据\"> 浏览器输入http://localhost:8081/ssm/user/get/all，输出json数据</h3>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200413170419-946799.png\" alt=\"image-20200413170412413\" /></p>\n<h2 id=\"仓库链接\"> 仓库链接</h2>\n<p>github： https://github.com/AlanLee97/ssm-template\n码云：https://gitee.com/AlanLee97/ssm-template</p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200413170714-647525.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "JavaSE",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/",
      "content_html": "<h1 id=\"javase\"> JavaSE</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "JDK1.8新特性 - Lambda表达式",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/",
      "content_html": "<h1 id=\"jdk1-8新特性-lambda表达式\"> JDK1.8新特性 - Lambda表达式</h1>\n<h2 id=\"知识点\"> 知识点</h2>\n<h3 id=\"简介\"> 简介</h3>\n<p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p>\n<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>\n<p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p>\n<h3 id=\"语法\"> 语法</h3>\n<div><pre><code><span>(</span>参数<span>)</span> <span>-></span> 表达式\n或 \n<span>(</span>参数<span>)</span> <span>-></span><span>{</span> 语句 <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"特征\"> 特征</h3>\n<ul>\n<li>**可选类型声明：**不需要声明参数类型，编译器可以统一识别参数值。</li>\n<li>**可选的参数圆括号：**一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>\n<li>**可选的大括号：**如果主体包含了一个语句，就不需要使用大括号。</li>\n<li>**可选的返回关键字：**如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>\n</ul>\n<h3 id=\"使用范围\"> 使用范围</h3>\n<p>Lambda表达式只能在 <strong>函数式接口</strong> 中使用</p>\n<p><strong>函数式接口</strong></p>\n<p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p>\n<p>函数式接口可以被隐式转换为 lambda 表达式。</p>\n<h3 id=\"变量作用域\"> 变量作用域</h3>\n<p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p>\n<h2 id=\"实例\"> 实例</h2>\n<p>创建一个<code>MyMessage</code>接口类，定义一个<code>say()</code>方法，输出<code>Hello AlanLee</code></p>\n<h3 id=\"未使用lambda表达式的例子\"> 未使用Lambda表达式的例子</h3>\n<p><strong>代码</strong></p>\n<div><pre><code><span>interface</span> <span>MyMessage</span><span>{</span>\n    <span>void</span> <span>say</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>LambdaDemo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>MyMessage</span> msg <span>=</span> <span>new</span> <span>MyMessage</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>say</span><span>(</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Hello AlanLee\"</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>;</span>\n        msg<span>.</span><span>say</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code><span>Hello</span> <span>AlanLee</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"使用lambda表达式之后的例子\"> 使用Lambda表达式之后的例子</h3>\n<p><strong>代码</strong></p>\n<div><pre><code><span>interface</span> <span>MyMessage</span><span>{</span>\n    <span>void</span> <span>say</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>LambdaDemo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>MyMessage</span> msg <span>=</span> <span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Hello AlanLee\"</span><span>)</span><span>;</span>\n        <span>}</span><span>;</span>\n        \n        <span>//一行语句的时候可以不写{}</span>\n        <span>//MyMessage msg = () -> System.out.println(\"Hello AlanLee\");</span>\n        \n        msg<span>.</span><span>say</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code><span>Hello</span> <span>AlanLee</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"其他实例\"> 其他实例</h3>\n<div><pre><code><span>// 1. 不需要参数,返回值为 5  </span>\n<span>(</span><span>)</span> <span>-></span> <span>5</span>  \n  \n<span>// 2. 接收一个参数(数字类型),返回其2倍的值  </span>\nx <span>-></span> <span>2</span> <span>*</span> x  \n  \n<span>// 3. 接受2个参数(数字),并返回他们的差值  </span>\n<span>(</span>x<span>,</span> y<span>)</span> <span>-></span> x – y  \n  \n<span>// 4. 接收2个int型整数,返回他们的和  </span>\n<span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>-></span> x <span>+</span> y  \n  \n<span>// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span>\n<span>(</span><span>String</span> s<span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>s<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"没有参数的方法\"> 没有参数的方法</h3>\n<p><strong>代码</strong></p>\n<div><pre><code><span>MyMessage</span> msg <span>=</span> <span>(</span><span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Hello AlanLee\"</span><span>)</span><span>;</span>\nmsg<span>.</span><span>say</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code><span>Hello</span> <span>AlanLee</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"有参数的方法\"> 有参数的方法</h3>\n<p><strong>代码</strong></p>\n<div><pre><code><span>interface</span> <span>MathUtil</span><span>{</span>\n    <span>int</span> <span>func</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>LambdaDemo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\n        <span>MathUtil</span> add <span>=</span> <span>(</span>x<span>,</span> y<span>)</span> <span>-></span> <span>{</span>\n            <span>return</span> x <span>+</span> y<span>;</span>\n        <span>}</span><span>;</span>\n        <span>//简化版：不要return,不要{}</span>\n        <span>//MathUtil add = (x, y) -> x + y;</span>\n        <span>//也可以加入类型声明</span>\n        <span>//MathUtil add = (int x, int y) -> x + y;</span>\n        \n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>add<span>.</span><span>func</span><span>(</span><span>10</span><span>,</span> <span>20</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code><span>30</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"函数式接口注解及添加多个方法\"> 函数式接口注解及添加多个方法</h3>\n<p>@FunctionalInterface注解声明这是一个函数式接口</p>\n<p>在接口中使用关键字<code>default</code>可以编写一个完整的方法</p>\n<p><strong>代码</strong></p>\n<div><pre><code><span>package</span> <span>study<span>.</span>chapter03<span>.</span>jdk8<span>.</span>lambda</span><span>;</span>\n\n<span>@FunctionalInterface</span>\n<span>interface</span> <span>MyMessage2</span><span>{</span>\n    <span>void</span> <span>say</span><span>(</span><span>String</span> str<span>)</span><span>;</span>\n    <span>//使用关键字default</span>\n    <span>default</span> <span>void</span> <span>print</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"this is a print method\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>LambdaDemo3</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>MyMessage2</span> msg <span>=</span> <span>(</span>str<span>)</span> <span>-></span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>)</span><span>;</span>\n        <span>}</span><span>;</span>\n\n        msg<span>.</span><span>say</span><span>(</span><span>\"hello lambda\"</span><span>)</span><span>;</span>\n        msg<span>.</span><span>print</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code>hello lambda\n<span>this</span> is a print method\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "控制台输入",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/stream/Stream01%20-%20%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/stream/Stream01%20-%20%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5/",
      "content_html": "<h1 id=\"控制台输入\"> 控制台输入</h1>\n<p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。</p>\n<p>Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。</p>\n<p>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</p>\n<p>Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。</p>\n<p>但本节讲述最基本的和流与 I/O 相关的功能。我们将通过一个个例子来学习这些功能。</p>\n<h2 id=\"读取控制台输入\"> 读取控制台输入</h2>\n<p>Java 的控制台输入由 System.in 完成。</p>\n<p>为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。</p>\n<p>下面是创建 BufferedReader 的基本语法：</p>\n<div><pre><code><span>BufferedReader</span> br <span>=</span> <span>new</span> <span>BufferedReader</span><span>(</span><span>new</span> <span>InputStreamReader</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。</p>\n<h2 id=\"bufferedreader-从控制台读取字符输入\"> BufferedReader 从控制台读取字符输入</h2>\n<h3 id=\"知识点\"> 知识点</h3>\n<p>从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下：</p>\n<div><pre><code>int read( ) throws IOException\n</code></pre>\n<div><span>1</span><br></div></div><p>每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。</p>\n<h3 id=\"实例\"> 实例</h3>\n<p>下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 &quot;q&quot;。</p>\n<p>代码：</p>\n<div><pre><code><span>package</span> <span>chapter03<span>.</span>stream</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>BufferedReader</span><span>;</span>\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>IOException</span><span>;</span>\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>InputStreamReader</span><span>;</span>\n\n<span>//使用 BufferedReader 在控制台读取字符</span>\n<span>public</span> <span>class</span> <span>TestBufferedReader</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>//读取字符</span>\n        <span>read</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>public</span> <span>static</span> <span>void</span> <span>read</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span><span>{</span>\n        <span>char</span> c<span>;</span>\n        <span>//在控制台输入字符存入到br</span>\n        <span>BufferedReader</span> br <span>=</span> <span>new</span> <span>BufferedReader</span><span>(</span><span>new</span> <span>InputStreamReader</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"输入字符，按 'q' 键退出\"</span><span>)</span><span>;</span>\n        <span>//读取字符</span>\n        <span>do</span> <span>{</span>\n            <span>//一个字符地一个字符地读取</span>\n            c <span>=</span> <span>(</span><span>char</span><span>)</span>br<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c<span>)</span><span>;</span>\n        <span>}</span><span>while</span> <span>(</span>c <span>!=</span> <span>'q'</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>运行结果：</p>\n<div><pre><code>输入字符，按 <span>'q'</span> 键退出\nalanlee\na\nl\na\nn\nl\ne\ne\n\n\nq\nq\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"bufferedreader-从控制台读取字符串\"> BufferedReader 从控制台读取字符串</h2>\n<h3 id=\"知识点-2\"> 知识点</h3>\n<p>从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法。</p>\n<p>它的一般格式是：</p>\n<div><pre><code>String readLine( ) throws IOException\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"实例-2\"> 实例</h3>\n<p>下面的程序读取和显示字符行直到你输入了单词&quot;end&quot;。</p>\n<p>代码：</p>\n<div><pre><code><span>package</span> <span>chapter03<span>.</span>stream</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>BufferedReader</span><span>;</span>\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>IOException</span><span>;</span>\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>InputStreamReader</span><span>;</span>\n\n<span>//使用 BufferedReader 在控制台读取字符</span>\n<span>public</span> <span>class</span> <span>TestBufferedReader</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>//读取一行</span>\n        <span>readString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>//读取字符串</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>readString</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span><span>{</span>\n        <span>BufferedReader</span> br <span>=</span> <span>new</span> <span>BufferedReader</span><span>(</span><span>new</span> <span>InputStreamReader</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>)</span><span>;</span>\n        <span>String</span> str<span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"请输入一行字符，输入'end'退出\"</span><span>)</span><span>;</span>\n        <span>do</span> <span>{</span>\n            str <span>=</span> br<span>.</span><span>readLine</span><span>(</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>)</span><span>;</span>\n        <span>}</span><span>while</span> <span>(</span><span>!</span><span>\"end\"</span><span>.</span><span>equals</span><span>(</span>str<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>运行结果：</p>\n<div><pre><code>请输入一行字符，输入<span>'end'</span>退出\ni am alanlee\ni am alanlee\nend\nend\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><em>JDK 5 后的版本也可以使用</em> <strong>Java Scanner</strong> <em>类来获取控制台的输入。</em></p>\n",
      "date_published": "2020-01-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "读写文件",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/stream/Stream02%20-%20%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/stream/Stream02%20-%20%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/",
      "content_html": "<h1 id=\"读写文件\"> 读写文件</h1>\n<p>一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。\n<img :src=\"$withBase('note_images/IO流.png')\" /></p>\n<h2 id=\"fileinputstream-读取文件\"> FileInputStream - 读取文件</h2>\n<h3 id=\"知识点\"> 知识点</h3>\n<p>FileInputStream类流用于从文件读取数据，它的对象可以用关键字 new 来创建。类</p>\n<p>有多种构造方法可用来创建对象。</p>\n<p>可以使用字符串类型的文件名来创建一个输入流对象来读取文件</p>\n<div><pre><code><span>//方式1</span>\n<span>InputStream</span> is <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span><span>\"F:/0temp/hello.txt\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：</p>\n<div><pre><code><span>//方式2</span>\n<span>File</span> file <span>=</span> <span>new</span> <span>File</span><span>(</span><span>\"F:/0temp/hello.txt\"</span><span>)</span><span>;</span>\n<span>InputStream</span> is <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span>file<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"实例\"> 实例</h3>\n<p>从磁盘中读取一个文件hello.txt</p>\n<p>代码：</p>\n<div><pre><code><span>package</span> <span>chapter03<span>.</span>stream</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>*</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>TestInputStream</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>input</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>input</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>File</span> file<span>;</span>\n        <span>InputStream</span> is <span>=</span> <span>null</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>//方式1</span>\n            <span>//InputStream is = new FileInputStream(\"F:/0temp/hello.txt\");</span>\n\n            <span>//方式2</span>\n            file <span>=</span> <span>new</span> <span>File</span><span>(</span><span>\"F:/0temp/hello.txt\"</span><span>)</span><span>;</span>\n            is <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span>file<span>)</span><span>;</span>\n\n            <span>int</span> size <span>=</span> is<span>.</span><span>available</span><span>(</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>char</span> read <span>=</span> <span>(</span><span>char</span><span>)</span> is<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>read<span>)</span><span>;</span>\n            <span>}</span>\n            is<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span><span>finally</span> <span>{</span>\n            is<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>序号</strong></th>\n<th style=\"text-align:left\"><strong>方法及描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\"><strong>public void close() throws IOException{}</strong> 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:left\"><strong>protected void finalize()throws IOException {}</strong> 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:left\"><strong>public int read(int r)throws IOException{}</strong> 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:left\"><strong>public int read(byte[] r) throws IOException{}</strong> 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:left\"><strong>public int available() throws IOException{}</strong> 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"fileoutputstream-写入文件\"> FileOutputStream - 写入文件</h2>\n<h3 id=\"知识点-2\"> 知识点</h3>\n<p>FileOutputStream类用来创建一个文件并向文件中写数据。</p>\n<p>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。</p>\n<p>有两个构造方法可以用来创建 FileOutputStream 对象。</p>\n<ul>\n<li>使用字符串类型的文件名来创建一个输出流对象：</li>\n</ul>\n<div><pre><code>OutputStream os = new FileOutputStream(&quot;F:/0temp/hello2.txt&quot;);\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：</li>\n</ul>\n<div><pre><code><span>File</span> file <span>=</span> <span>new</span> <span>File</span><span>(</span><span>\"F:/0temp/hello2.txt\"</span><span>)</span><span>;</span>\n<span>OutputStream</span> os <span>=</span> <span>new</span> <span>FileOutputStream</span><span>(</span>file<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"实例-2\"> 实例</h3>\n<p><strong>向磁盘写入一个文件hello2.txt</strong></p>\n<p>代码：</p>\n<div><pre><code><span>package</span> <span>chapter03<span>.</span>stream</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>*</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>TestOutStream</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>output</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>output</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>OutputStream</span> os <span>=</span> <span>null</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>String</span> str <span>=</span> <span>\"Test OutputStream\"</span><span>;</span>\n            <span>byte</span><span>[</span><span>]</span> content <span>=</span> str<span>.</span><span>getBytes</span><span>(</span><span>)</span><span>;</span>\n            os <span>=</span> <span>new</span> <span>FileOutputStream</span><span>(</span><span>\"F:/0temp/hello2.txt\"</span><span>)</span><span>;</span>\n            os<span>.</span><span>write</span><span>(</span>content<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            os<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>序号</strong></th>\n<th style=\"text-align:left\"><strong>方法及描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\"><strong>public void close() throws IOException{}</strong> 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:left\"><strong>protected void finalize()throws IOException {}</strong> 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:left\"><strong>public void write(int w)throws IOException{}</strong> 这个方法把指定的字节写到输出流中。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:left\"><strong>public void write(byte[] w)</strong> 把指定数组中w.length长度的字节写到OutputStream中。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"解决读写文件中有中文内容时乱码的问题\"> 解决读写文件中有中文内容时乱码的问题</h2>\n<h3 id=\"知识点-3\"> 知识点</h3>\n<p>使用InputStreamReader写入文件时指定编码UTF-8</p>\n<div><pre><code>reader <span>=</span> <span>new</span> <span>InputStreamReader</span><span>(</span>is<span>,</span> <span>\"UTF-8\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>使用OutputStreamWriter写入文件时指定编码UTF-8</p>\n<div><pre><code>writer <span>=</span> <span>new</span> <span>OutputStreamWriter</span><span>(</span>fos<span>,</span> <span>\"UTF-8\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"实例-3\"> 实例</h3>\n<p>向磁盘写入一个文件，并读取文件内容在控制台输出，文件内容为：</p>\n<div><pre><code>我爱java\njava牛逼！\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>代码：</p>\n<div><pre><code><span>package</span> <span>chapter03<span>.</span>stream</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>*</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>TestIOStream</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>String</span> fileName <span>=</span> <span>\"F:/0temp/hello3.txt\"</span><span>;</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>//向磁盘写入文件</span>\n        <span>output</span><span>(</span><span>)</span><span>;</span>\n        <span>//从磁盘读取文件</span>\n        <span>input</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>//向磁盘写入文件</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>output</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>File</span> file <span>=</span> <span>new</span> <span>File</span><span>(</span>fileName<span>)</span><span>;</span>\n        <span>FileOutputStream</span> fos <span>=</span> <span>null</span><span>;</span>\n        <span>OutputStreamWriter</span> writer <span>=</span> <span>null</span><span>;</span>\n        <span>try</span> <span>{</span>\n            fos <span>=</span> <span>new</span> <span>FileOutputStream</span><span>(</span>file<span>)</span><span>;</span>\n            writer <span>=</span> <span>new</span> <span>OutputStreamWriter</span><span>(</span>fos<span>,</span> <span>\"UTF-8\"</span><span>)</span><span>;</span>\n            <span>//写第一句</span>\n            writer<span>.</span><span>append</span><span>(</span><span>\"我爱java\"</span><span>)</span><span>;</span>\n            <span>//换行</span>\n            writer<span>.</span><span>append</span><span>(</span><span>\"\\r\\n\"</span><span>)</span><span>;</span>\n            <span>//写第二句</span>\n            writer<span>.</span><span>append</span><span>(</span><span>\"java牛逼！\"</span><span>)</span><span>;</span>\n            writer<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n            fos<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>FileNotFoundException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            writer<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n            fos<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>//从磁盘读取文件</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>input</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span><span>{</span>\n        <span>InputStream</span> is <span>=</span> <span>null</span><span>;</span>\n        <span>InputStreamReader</span> reader <span>=</span> <span>null</span><span>;</span>\n        <span>try</span> <span>{</span>\n            is <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span>fileName<span>)</span><span>;</span>\n            reader <span>=</span> <span>new</span> <span>InputStreamReader</span><span>(</span>is<span>,</span> <span>\"UTF-8\"</span><span>)</span><span>;</span>\n            <span>StringBuffer</span> buffer <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>\n            <span>while</span> <span>(</span>reader<span>.</span><span>ready</span><span>(</span><span>)</span><span>)</span><span>{</span>\n                buffer<span>.</span><span>append</span><span>(</span><span>(</span><span>char</span><span>)</span>reader<span>.</span><span>read</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>buffer<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>FileNotFoundException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            reader<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n            is<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br></div></div>",
      "date_published": "2020-01-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Java多线程",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B01-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B01-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/",
      "content_html": "<h1 id=\"java多线程\"> Java多线程</h1>\n<h2 id=\"简介\"> 简介</h2>\n<p>Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>\n<p>多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。</p>\n<p>这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。</p>\n<h2 id=\"一个线程的生命周期\"> 一个线程的生命周期</h2>\n<p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。</p>\n<p>下图显示了一个线程完整的生命周期。</p>\n<ul>\n<li>\n<p>新建状态:</p>\n<p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p>\n</li>\n<li>\n<p>就绪状态:</p>\n<p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>\n</li>\n<li>\n<p>运行状态:</p>\n<p>如果就绪状态的线程获取 CPU 资源，就可以执行 <strong>run()</strong>，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>\n</li>\n<li>\n<p>阻塞状态:</p>\n<p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p>\n<ul>\n<li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li>\n<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li>\n<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li>\n</ul>\n</li>\n<li>\n<p>死亡状态:</p>\n<p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>\n</li>\n</ul>\n<h2 id=\"线程的优先级\"> 线程的优先级</h2>\n<p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p>\n<p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p>\n<p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p>\n<p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p>\n<h2 id=\"创建一个线程\"> 创建一个线程</h2>\n<p>Java 提供了三种创建线程的方法：</p>\n<ul>\n<li>通过实现 Runnable 接口；</li>\n<li>通过继承 Thread 类本身；</li>\n<li>通过 Callable 和 Future 创建线程。</li>\n</ul>\n<h2 id=\"问题\"> 问题</h2>\n<p><strong>Runnable与Callable有什么区别？</strong></p>\n<ul>\n<li>Runnable是在JDK1.0的时候提出的多线程实现接口，而Callable是在JDK1.5之后提出的。</li>\n<li>java.lang.Runnable接口之中只提供有一个run()方法，并且没有返回值。</li>\n<li>java.util.concurrent.Callable接口提供有call方法，可以有返回值。</li>\n</ul>\n",
      "date_published": "2020-01-30T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Java 简介",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/1.1%20Java%E7%AE%80%E4%BB%8B/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/1.1%20Java%E7%AE%80%E4%BB%8B/",
      "content_html": "<h1 id=\"java-简介\"> Java 简介</h1>\n<p>Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。</p>\n<p>Java分为三个体系：</p>\n<ul>\n<li>JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）</li>\n<li>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</li>\n<li>JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。</li>\n</ul>\n<p>2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字&quot;2&quot;：J2EE更名为Java EE, J2SE更名为Java SE，J2ME更名为Java ME。</p>\n<h2 id=\"主要特性\"> 主要特性</h2>\n<ul>\n<li>\n<p>Java语言是简单的：</p>\n<p>Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，而是引用。并提供了自动的废料收集，使得程序员不必为内存管理而担忧。</p>\n</li>\n<li>\n<p>Java语言是面向对象的：</p>\n<p>Java语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。</p>\n</li>\n<li>\n<p>Java语言是分布式的：</p>\n<p>Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。</p>\n</li>\n<li>\n<p>Java语言是健壮的：</p>\n<p>Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。Java的安全检查机制使得Java更具健壮性。</p>\n</li>\n<li>\n<p>Java语言是安全的：</p>\n<p>Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。除了Java语言具有的许多安全特性以外，Java对通过网络下载的类具有一个安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类SecurityManager）让Java应用设置安全哨兵。</p>\n</li>\n<li>\n<p>Java语言是体系结构中立的：</p>\n<p>Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。</p>\n</li>\n<li>\n<p>Java语言是可移植的：</p>\n<p>这种可移植性来源于体系结构中立性，另外，Java还严格规定了各个基本数据类型的长度。Java系统本身也具有很强的可移植性，Java编译器是用Java实现的，Java的运行环境是用ANSI C实现的。</p>\n</li>\n<li>\n<p>Java语言是解释型的：</p>\n<p>如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行。在运行时，Java平台中的Java解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。</p>\n</li>\n<li>\n<p>Java是高性能的：</p>\n<p>与那些解释型的高级脚本语言相比，Java的确是高性能的。事实上，Java的运行速度随着JIT(Just-In-Time）编译器技术的发展越来越接近于C++。</p>\n</li>\n<li>\n<p>Java语言是多线程的：</p>\n<p>在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为Thread(Runnable)的构造子类将一个实现了Runnable接口的对象包装成一个线程，其二，从Thread类派生出子类并重写run方法，使用该子类创建的对象即为线程。值得注意的是Thread类已经实现了Runnable接口，因此，任何一个线程均有它的run方法，而run方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为synchronized）。</p>\n</li>\n<li>\n<p>Java语言是动态的：</p>\n<p>Java语言的设计目标之一是适应于动态变化的环境。Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java中的类有一个运行时刻的表示，能进行运行时刻的类型检查。</p>\n</li>\n</ul>\n<h2 id=\"发展历史\"> 发展历史</h2>\n<ul>\n<li>1995年5月23日，Java语言诞生</li>\n<li>1996年1月，第一个JDK-JDK1.0诞生</li>\n<li>1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术</li>\n<li>1996年9月，约8.3万个网页应用了JAVA技术来制作</li>\n<li>1997年2月18日，JDK1.1发布</li>\n<li>1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录</li>\n<li>1997年9月，JavaDeveloperConnection社区成员超过十万</li>\n<li>1998年2月，JDK1.1被下载超过2,000,000次</li>\n<li>1998年12月8日，JAVA2企业平台J2EE发布</li>\n<li>1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME）</li>\n<li>2000年5月8日，JDK1.3发布</li>\n<li>2000年5月29日，JDK1.4发布</li>\n<li>2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机</li>\n<li>2001年9月24日，J2EE1.3发布</li>\n<li>2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升</li>\n<li>2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0</li>\n<li>2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字&quot;2&quot;：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME</li>\n<li>2006年12月，SUN公司发布JRE6.0</li>\n<li>2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。</li>\n<li>2010年11月，由于甲骨文对于Java社区的不友善，因此Apache扬言将退出JCP[4]。</li>\n<li>2011年7月28日，甲骨文发布 Java7.0 的正式版。</li>\n<li>2014年3月18日，Oracle公司发表 Java SE 8。</li>\n<li>2017年9月21日，Oracle公司发表 Java SE 9</li>\n<li>2018年3月21日，Oracle公司发表 Java SE 10</li>\n<li>2018年9月25日，Java SE 11 发布</li>\n<li>2019年3月20日，Java SE 12 发布</li>\n</ul>\n",
      "date_published": "2020-01-22T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Java中的目录操作",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/stream/Stream03%20-%20%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/stream/Stream03%20-%20%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/",
      "content_html": "<h1 id=\"java中的目录操作\"> Java中的目录操作</h1>\n<h2 id=\"创建目录\"> 创建目录</h2>\n<h3 id=\"知识点\"> 知识点</h3>\n<p>File类中有两个方法可以用来创建文件夹：</p>\n<ul>\n<li>**mkdir( )**方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。</li>\n<li>**mkdirs()**方法创建一个文件夹和它的所有父文件夹。</li>\n</ul>\n<h3 id=\"实例\"> 实例</h3>\n<p>在F盘中的0temp文件夹下创建一个叫<code>hello</code>的文件夹</p>\n<div><pre><code><span>public</span> <span>class</span> <span>TestDir</span><span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>File</span> file <span>=</span> <span>new</span> <span>File</span><span>(</span><span>\"F:/0temp/hello\"</span><span>)</span><span>;</span>\n        <span>boolean</span> b <span>=</span> file<span>.</span><span>mkdir</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>b<span>)</span><span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"目录创建成功\"</span><span>)</span><span>;</span>\n        <span>}</span><span>else</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"目录创建失败\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>在F盘中的0temp\\hello文件夹下递归创建<code>hello/hello1/hello2</code>文件夹</p>\n<div><pre><code><span>public</span> <span>class</span> <span>TestDir</span><span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>File</span> file <span>=</span> <span>new</span> <span>File</span><span>(</span><span>\"F:/0temp/hello/hello1/hello2\"</span><span>)</span><span>;</span>\n        <span>boolean</span> b <span>=</span> file<span>.</span><span>mkdirs</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>b<span>)</span><span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"目录创建成功\"</span><span>)</span><span>;</span>\n        <span>}</span><span>else</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"目录创建失败\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"读取目录\"> 读取目录</h2>\n<h3 id=\"知识点-2\"> 知识点</h3>\n<p>一个目录其实就是一个 File 对象，它包含其他文件和文件夹。</p>\n<p>如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。</p>\n<p>可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。</p>\n<h3 id=\"实例-2\"> 实例</h3>\n<p>下面展示的例子说明如何使用 list() 方法来检查一个文件夹中包含的内容：</p>\n<p>读取F盘下0temp文件夹下的内容</p>\n<div><pre><code><span>public</span> <span>class</span> <span>TestDir</span><span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>String</span> dirName <span>=</span> <span>\"F:/0temp\"</span><span>;</span>\n        <span>File</span> file <span>=</span> <span>new</span> <span>File</span><span>(</span>dirName<span>)</span><span>;</span>\n        <span>String</span><span>[</span><span>]</span> list <span>=</span> file<span>.</span><span>list</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>String</span> s <span>:</span> list<span>)</span> <span>{</span>\n            <span>File</span> f <span>=</span> <span>new</span> <span>File</span><span>(</span>dirName <span>+</span> <span>\"/\"</span> <span>+</span> s<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>f<span>.</span><span>isDirectory</span><span>(</span><span>)</span><span>)</span><span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s <span>+</span> <span>\"是一个目录\"</span><span>)</span><span>;</span>\n            <span>}</span><span>else</span> <span>if</span> <span>(</span>f<span>.</span><span>isFile</span><span>(</span><span>)</span><span>)</span><span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s <span>+</span> <span>\"是一个文件\"</span><span>)</span><span>;</span>\n            <span>}</span><span>else</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"未知类型\"</span> <span>+</span> s<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"删除目录或文件\"> 删除目录或文件</h2>\n<h3 id=\"知识点-3\"> 知识点</h3>\n<p>删除文件可以使用 <strong>java.io.File.delete()</strong> 方法。</p>\n<h3 id=\"实例-3\"> 实例</h3>\n<p>以下代码会删除目录<strong>F盘下的0temp/hello文件夹</strong>，需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>TestDir</span><span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>File</span> dirName <span>=</span> <span>new</span> <span>File</span><span>(</span><span>\"F:/0temp/hello\"</span><span>)</span><span>;</span>\n        <span>testDeleteDir</span><span>(</span>dirName<span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>public</span> <span>static</span> <span>void</span> <span>testDeleteDir</span><span>(</span><span>File</span> folder<span>)</span> <span>{</span>\n        <span>File</span><span>[</span><span>]</span> files <span>=</span> folder<span>.</span><span>listFiles</span><span>(</span><span>)</span><span>;</span>\n        <span>Boolean</span> b<span>;</span>\n        <span>if</span> <span>(</span>files <span>!=</span> <span>null</span><span>)</span><span>{</span>\n            <span>for</span> <span>(</span><span>File</span> f <span>:</span> files<span>)</span><span>{</span>\n                <span>if</span> <span>(</span>f<span>.</span><span>isDirectory</span><span>(</span><span>)</span><span>)</span><span>{</span>\n                    <span>testDeleteDir</span><span>(</span>f<span>)</span><span>;</span>\n                <span>}</span><span>else</span> <span>{</span>\n                    b <span>=</span> f<span>.</span><span>delete</span><span>(</span><span>)</span><span>;</span>\n                    <span>if</span> <span>(</span>b<span>)</span><span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>f<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"删除成功\"</span><span>)</span><span>;</span>\n                    <span>}</span><span>else</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>f<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"删除失败\"</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        b <span>=</span> folder<span>.</span><span>delete</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>b<span>)</span><span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>folder<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"删除成功\"</span><span>)</span><span>;</span>\n        <span>}</span><span>else</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>folder<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"删除失败\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div>",
      "date_published": "2020-01-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "线程死锁",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B04-%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B04-%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/",
      "content_html": "<h1 id=\"线程死锁\"> 线程死锁</h1>\n<h2 id=\"知识点\"> 知识点</h2>\n<p>死锁就是若干个线程相互等待，等待对方释放资源。</p>\n<h2 id=\"解决死锁\"> 解决死锁</h2>\n",
      "date_published": "2020-01-30T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "线程的操作",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B02-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%93%8D%E4%BD%9C/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B02-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%93%8D%E4%BD%9C/",
      "content_html": "<h1 id=\"线程的操作\"> 线程的操作</h1>\n<h2 id=\"线程命名\"> 线程命名</h2>\n<h3 id=\"知识点\"> 知识点</h3>\n<p>通过下面代码获取线程名字</p>\n<div><pre><code><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"实例\"> 实例</h3>\n<p><strong>代码</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>TestThread</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前线程：\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>//未自定义名字的线程</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前线程：\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n        <span>//自定义名字的线程</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前线程：\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span><span>,</span> <span>\"线程A\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code>当前线程：main\n当前线程：<span>Thread</span><span>-</span><span>0</span>\n当前线程：线程<span>A</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"线程睡眠\"> 线程睡眠</h2>\n<h3 id=\"知识点-2\"> 知识点</h3>\n<p>通过下面代码使线程睡眠</p>\n<div><pre><code>Thread.sleep(1000);\n</code></pre>\n<div><span>1</span><br></div></div><p>该方法必须处理异常</p>\n<h3 id=\"实例-2\"> 实例</h3>\n<p><strong>代码</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>TestThread2</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>\n                <span>//线程休眠</span>\n                <span>try</span> <span>{</span>\n                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code><span>0</span>\n<span>1</span>\n<span>2</span>\n<span>3</span>\n<span>4</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"线程中断\"> 线程中断</h2>\n<h3 id=\"知识点-3\"> 知识点</h3>\n<p>中断线程</p>\n<div><pre><code>public void interrupt()\n</code></pre>\n<div><span>1</span><br></div></div><p>判断线程是否被中断</p>\n<div><pre><code>public boolean isInterrupted()\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"实例-3\"> 实例</h3>\n<p><strong>代码</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>TestThread3</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>\n                <span>try</span> <span>{</span>\n                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n\n        thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>!</span>thread<span>.</span><span>isInterrupted</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            thread<span>.</span><span>interrupt</span><span>(</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"线程被中断\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code><span>1</span>\n<span><span>java<span>.</span>lang<span>.</span></span>InterruptedException</span><span>:</span> sleep interrupted\n\tat <span><span>java<span>.</span>lang<span>.</span></span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>Native</span> <span>Method</span><span>)</span>\n\tat <span><span>study<span>.</span>chapter03<span>.</span>thread<span>.</span>operation<span>.</span></span>TestThread3</span><span>.</span>lambda$main$<span>0</span><span>(</span><span>TestThread3</span><span>.</span>java<span>:</span><span>9</span><span>)</span>\n\tat <span><span>java<span>.</span>lang<span>.</span></span>Thread</span><span>.</span><span>run</span><span>(</span><span>Thread</span><span>.</span>java<span>:</span><span>748</span><span>)</span>\n<span>2</span>\n<span>3</span>\n<span>4</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"线程强制运行\"> 线程强制运行</h2>\n<h3 id=\"知识点-4\"> 知识点</h3>\n<p>当一个线程满足某些条件之后，这个线程对象将可以一直独占资源，一直到该线程的程序执行结束。</p>\n<p>使用<code>join()</code>方法</p>\n<h3 id=\"实例-4\"> 实例</h3>\n<p><strong>代码</strong></p>\n<div><pre><code><span>//线程强制执行</span>\n<span>public</span> <span>class</span> <span>TestThread4</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Thread</span> mainThread <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>\n\n        <span>//子线程</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>i <span>==</span> <span>5</span><span>)</span><span>{</span>\n                    <span>try</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"主线程加入进来了，让主线程执行完所有代码，再执行子线程的代码！！\"</span><span>)</span><span>;</span>\n                        mainThread<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"主线程执行完了，子线程继续执行子线程里面的代码\"</span><span>)</span><span>;</span>\n                    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"A线程：\"</span> <span>+</span> i<span>)</span><span>;</span>\n                <span>try</span> <span>{</span>\n                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>500</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n\n\n        <span>//主线程</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"主线程：\"</span> <span>+</span> i<span>)</span><span>;</span>\n            <span>try</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>500</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code>主线程：<span>0</span>\n<span>A</span>线程：<span>0</span>\n主线程：<span>1</span>\n<span>A</span>线程：<span>1</span>\n主线程：<span>2</span>\n<span>A</span>线程：<span>2</span>\n主线程：<span>3</span>\n<span>A</span>线程：<span>3</span>\n主线程：<span>4</span>\n<span>A</span>线程：<span>4</span>\n主线程：<span>5</span>\n主线程加入进来了，让主线程执行完所有代码，再执行子线程的代码！！\n主线程：<span>6</span>\n主线程：<span>7</span>\n主线程：<span>8</span>\n主线程：<span>9</span>\n主线程执行完了，子线程继续执行子线程里面的代码\n<span>A</span>线程：<span>5</span>\n<span>A</span>线程：<span>6</span>\n<span>A</span>线程：<span>7</span>\n<span>A</span>线程：<span>8</span>\n<span>A</span>线程：<span>9</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id=\"线程礼让\"> 线程礼让</h2>\n<h3 id=\"知识点-5\"> 知识点</h3>\n<p>线程的礼让指的是先将资源让出去让别的线程先执行。</p>\n<p>使用<code>yield()</code>方法</p>\n<h3 id=\"实例-5\"> 实例</h3>\n<p><strong>代码</strong></p>\n<div><pre><code><span>//线程强制执行</span>\n<span>public</span> <span>class</span> <span>TestThread5</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\n        <span>//A线程</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>i <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span><span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"A线程将资源礼让出去，让其他线程先执行\"</span><span>)</span><span>;</span>\n                    <span>Thread</span><span>.</span><span>yield</span><span>(</span><span>)</span><span>;</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"资源礼让完成，A线程拿回资源继续执行\"</span><span>)</span><span>;</span>\n                <span>}</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"A线程：\"</span> <span>+</span> i<span>)</span><span>;</span>\n                <span>try</span> <span>{</span>\n                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>500</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n\n        <span>//主线程</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"主线程：\"</span> <span>+</span> i<span>)</span><span>;</span>\n            <span>try</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>500</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code>主线程：<span>1</span>\n<span>A</span>线程：<span>1</span>\n<span>A</span>线程将资源礼让出去，让其他线程先执行\n主线程：<span>2</span>\n资源礼让完成，<span>A</span>线程拿回资源继续执行\n<span>A</span>线程：<span>2</span>\n主线程：<span>3</span>\n<span>A</span>线程：<span>3</span>\n主线程：<span>4</span>\n<span>A</span>线程将资源礼让出去，让其他线程先执行\n资源礼让完成，<span>A</span>线程拿回资源继续执行\n<span>A</span>线程：<span>4</span>\n主线程：<span>5</span>\n<span>A</span>线程：<span>5</span>\n主线程：<span>6</span>\n<span>A</span>线程将资源礼让出去，让其他线程先执行\n资源礼让完成，<span>A</span>线程拿回资源继续执行\n<span>A</span>线程：<span>6</span>\n主线程：<span>7</span>\n<span>A</span>线程：<span>7</span>\n主线程：<span>8</span>\n<span>A</span>线程将资源礼让出去，让其他线程先执行\n资源礼让完成，<span>A</span>线程拿回资源继续执行\n<span>A</span>线程：<span>8</span>\n主线程：<span>9</span>\n<span>A</span>线程：<span>9</span>\n主线程：<span>10</span>\n<span>A</span>线程将资源礼让出去，让其他线程先执行\n资源礼让完成，<span>A</span>线程拿回资源继续执行\n<span>A</span>线程：<span>10</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id=\"线程优先级\"> 线程优先级</h2>\n<h3 id=\"知识点-6\"> 知识点</h3>\n<p>从理论上来讲，线程的优先级越高，越有可能先执行（越有可能先抢占到资源）。</p>\n<p>优先级的处理方法：</p>\n<ul>\n<li>设置优先级 public final void setPriority(int newPriority)</li>\n<li>获取优先级 public final int getPriority()</li>\n</ul>\n<p>线程的优先级有3个常量</p>\n<ul>\n<li>最小优先级（默认值为 1）</li>\n</ul>\n<div><pre><code>public final static int MIN_PRIORITY\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>中等优先级（默认值为 5）</li>\n</ul>\n<div><pre><code>public final static int NORM_PRIORITY\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>最大优先级（默认值为 10）</li>\n</ul>\n<div><pre><code>public final static int MAX_PRIORITY\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"实例-6\"> 实例</h3>\n<p><strong>代码</strong></p>\n<div><pre><code><span>//线程的优先级</span>\n<span>public</span> <span>class</span> <span>TestThread6</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\n        <span>//A线程：设置A线程的优先级为最小优先级</span>\n        <span>Thread</span> aThread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"A线程：\"</span> <span>+</span> i<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>,</span> <span>\"A线程\"</span><span>)</span><span>;</span>\n        aThread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        aThread<span>.</span><span>setPriority</span><span>(</span><span>Thread</span><span>.</span>MIN_PRIORITY<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"A线程的优先级：\"</span> <span>+</span> aThread<span>.</span><span>getPriority</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>//B线程：设置B线程的优先级为最大优先级</span>\n        <span>Thread</span> bThread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B线程：\"</span> <span>+</span> i<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>,</span> <span>\"B线程\"</span><span>)</span><span>;</span>\n        bThread<span>.</span><span>setPriority</span><span>(</span><span>Thread</span><span>.</span>MAX_PRIORITY<span>)</span><span>;</span>\n        bThread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B线程的优先级：\"</span> <span>+</span> bThread<span>.</span><span>getPriority</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>//主线程</span>\n        <span>Thread</span> mainThread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"主线程的优先级：\"</span> <span>+</span> mainThread<span>.</span><span>getPriority</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"主线程：\"</span> <span>+</span> i<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code><span>A</span>线程的优先级：<span>1</span>\n<span>A</span>线程：<span>0</span>\n<span>B</span>线程的优先级：<span>10</span>\n主线程的优先级：<span>5</span>\n<span>B</span>线程：<span>0</span>\n<span>B</span>线程：<span>1</span>\n<span>B</span>线程：<span>2</span>\n<span>B</span>线程：<span>3</span>\n主线程：<span>0</span>\n主线程：<span>1</span>\n主线程：<span>2</span>\n主线程：<span>3</span>\n<span>A</span>线程：<span>1</span>\n<span>A</span>线程：<span>2</span>\n<span>A</span>线程：<span>3</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>",
      "date_published": "2020-01-30T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "线程的同步",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B03-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B03-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5/",
      "content_html": "<h1 id=\"线程的同步\"> 线程的同步</h1>\n<h2 id=\"知识点\"> 知识点</h2>\n<p>同步有2中方法</p>\n<ul>\n<li>使用关键字实现声明同步方法</li>\n<li>同步代码块</li>\n</ul>\n<h2 id=\"使用关键字实现声明同步方法\"> 使用关键字实现声明同步方法</h2>\n<h3 id=\"知识点-2\"> 知识点</h3>\n<p>在声明方法时加上<code>synchronized</code></p>\n<h3 id=\"实例\"> 实例</h3>\n<p>3个售票员（线程）卖5张票</p>\n<p><strong>代码</strong></p>\n<div><pre><code><span>package</span> <span>study<span>.</span>chapter03<span>.</span>thread<span>.</span>sync</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>TestThread1</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\n        <span>MyThread</span> myThread <span>=</span> <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>myThread<span>,</span> <span>\"售票员A\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>myThread<span>,</span> <span>\"售票员B\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>myThread<span>,</span> <span>\"售票员C\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>MyThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n    <span>private</span> <span>int</span> ticket <span>=</span> <span>5</span><span>;</span>\n\n    <span>//卖票方法</span>\n    <span>public</span> <span>synchronized</span> <span>boolean</span> <span>sale</span><span>(</span><span>)</span><span>{</span>\n        <span>if</span> <span>(</span>ticket <span>></span> <span>0</span><span>)</span><span>{</span>\n            <span>try</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>500</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"卖票：ticket = \"</span> <span>+</span> <span>this</span><span>.</span>ticket<span>--</span><span>)</span><span>;</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span><span>else</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"========= 票卖光了 ========\"</span><span>)</span><span>;</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>while</span> <span>(</span><span>sale</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code>售票员<span>A</span>卖票：ticket <span>=</span> <span>5</span>\n售票员<span>A</span>卖票：ticket <span>=</span> <span>4</span>\n售票员<span>C</span>卖票：ticket <span>=</span> <span>3</span>\n售票员<span>B</span>卖票：ticket <span>=</span> <span>2</span>\n售票员<span>C</span>卖票：ticket <span>=</span> <span>1</span>\n<span>==</span><span>==</span><span>==</span><span>==</span><span>=</span> 票卖光了 <span>==</span><span>==</span><span>==</span><span>==</span>\n<span>==</span><span>==</span><span>==</span><span>==</span><span>=</span> 票卖光了 <span>==</span><span>==</span><span>==</span><span>==</span>\n<span>==</span><span>==</span><span>==</span><span>==</span><span>=</span> 票卖光了 <span>==</span><span>==</span><span>==</span><span>==</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"使用同步代码块\"> 使用同步代码块</h2>\n<h3 id=\"知识点-3\"> 知识点</h3>\n<p>将要同步的代码放在同步代码块中</p>\n<div><pre><code><span>synchronized</span> <span>(</span><span>this</span><span>)</span><span>{</span>\n\t<span>//写要同步的代码</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"实例-2\"> 实例</h3>\n<p><strong>代码</strong></p>\n<div><pre><code><span>package</span> <span>study<span>.</span>chapter03<span>.</span>thread<span>.</span>sync</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>TestThread1</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\n        <span>MyThread</span> myThread <span>=</span> <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>myThread<span>,</span> <span>\"售票员A\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>myThread<span>,</span> <span>\"售票员B\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>myThread<span>,</span> <span>\"售票员C\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>MyThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n    <span>private</span> <span>int</span> ticket <span>=</span> <span>5</span><span>;</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>while</span> <span>(</span><span>true</span><span>)</span><span>{</span>\n            <span>//每次只允许一个线程访问</span>\n            <span>synchronized</span> <span>(</span><span>this</span><span>)</span><span>{</span>\n                <span>if</span> <span>(</span>ticket <span>></span> <span>0</span><span>)</span><span>{</span>\n                            <span>try</span> <span>{</span>\n            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>500</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"卖票：ticket = \"</span> <span>+</span> <span>this</span><span>.</span>ticket<span>--</span><span>)</span><span>;</span>\n\n                <span>}</span><span>else</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"========= 票卖光了 ========\"</span><span>)</span><span>;</span>\n                    <span>break</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code>售票员<span>A</span>卖票：ticket <span>=</span> <span>5</span>\n售票员<span>A</span>卖票：ticket <span>=</span> <span>4</span>\n售票员<span>C</span>卖票：ticket <span>=</span> <span>3</span>\n售票员<span>B</span>卖票：ticket <span>=</span> <span>2</span>\n售票员<span>C</span>卖票：ticket <span>=</span> <span>1</span>\n<span>==</span><span>==</span><span>==</span><span>==</span><span>=</span> 票卖光了 <span>==</span><span>==</span><span>==</span><span>==</span>\n<span>==</span><span>==</span><span>==</span><span>==</span><span>=</span> 票卖光了 <span>==</span><span>==</span><span>==</span><span>==</span>\n<span>==</span><span>==</span><span>==</span><span>==</span><span>=</span> 票卖光了 <span>==</span><span>==</span><span>==</span><span>==</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>",
      "date_published": "2020-01-30T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "守护线程",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B06-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B06-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/",
      "content_html": "<h1 id=\"守护线程\"> 守护线程</h1>\n<h2 id=\"知识点\"> 知识点</h2>\n<p>线程守护就是主线程或者其他线程还在执行的时候，守护线程将一直存在，并且在后台运行。</p>\n<p>守护线程跟着其他线程存在，其他线程执行完，守护线程也执行完成。</p>\n<p>在Thread类中有两个方法</p>\n<ul>\n<li>设置为守护线程</li>\n</ul>\n<div><pre><code>public final void setDaemon(boolean on)\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>判断是否是守护线程</li>\n</ul>\n<div><pre><code>public final boolean isDaemon()\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"实例\"> 实例</h2>\n<p><strong>代码</strong></p>\n<div><pre><code><span>package</span> <span>study<span>.</span>chapter03<span>.</span>thread<span>.</span>daemon</span><span>;</span>\n\n<span>//守护线程</span>\n<span>public</span> <span>class</span> <span>TestThread</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>//用户线程</span>\n        <span>Thread</span> userThread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"在运行：\"</span> <span>+</span> i<span>)</span><span>;</span>\n                <span>try</span> <span>{</span>\n                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>200</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>,</span> <span>\"用户线程\"</span><span>)</span><span>;</span>\n\n        <span>//守护线程</span>\n        <span>Thread</span> daemonThread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"在运行：\"</span> <span>+</span> i<span>)</span><span>;</span>\n                <span>try</span> <span>{</span>\n                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>200</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>,</span> <span>\"守护线程\"</span><span>)</span><span>;</span>\n        <span>//设为守护线程</span>\n        daemonThread<span>.</span><span>setDaemon</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        userThread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        daemonThread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code>用户线程在运行：<span>0</span>\n守护线程在运行：<span>0</span>\n守护线程在运行：<span>1</span>\n用户线程在运行：<span>1</span>\n用户线程在运行：<span>2</span>\n守护线程在运行：<span>2</span>\n用户线程在运行：<span>3</span>\n守护线程在运行：<span>3</span>\n守护线程在运行：<span>4</span>\n用户线程在运行：<span>4</span>\n守护线程在运行：<span>5</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>",
      "date_published": "2020-01-30T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "ArrayList的扩容机制",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/",
      "content_html": "<h1 id=\"arraylist的扩容机制\"> ArrayList的扩容机制</h1>\n<blockquote>\n<p>本文来源于<strong>JavaGuide</strong></p>\n<p>原文地址：https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md</p>\n</blockquote>\n<h2 id=\"一-先从-arraylist-的构造函数说起\"> 一 先从 ArrayList 的构造函数说起</h2>\n<p><strong>ArrayList有三种方式来初始化，构造方法源码如下：</strong></p>\n<div><pre><code>   <span>/**\n     * 默认初始容量大小\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_CAPACITY <span>=</span> <span>10</span><span>;</span>\n    \n\n    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>\n\n    <span>/**\n     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */</span>\n    <span>public</span> <span>ArrayList</span><span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>elementData <span>=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>;</span>\n    <span>}</span>\n    \n    <span>/**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */</span>\n    <span>public</span> <span>ArrayList</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>initialCapacity <span>></span> <span>0</span><span>)</span> <span>{</span><span>//初始容量大于0</span>\n            <span>//创建initialCapacity大小的数组</span>\n            <span>this</span><span>.</span>elementData <span>=</span> <span>new</span> <span>Object</span><span>[</span>initialCapacity<span>]</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>initialCapacity <span>==</span> <span>0</span><span>)</span> <span>{</span><span>//初始容量等于0</span>\n            <span>//创建空数组</span>\n            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span><span>//初始容量小于0，抛出异常</span>\n            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal Capacity: \"</span><span>+</span>\n                                               initialCapacity<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n   <span>/**\n    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n    *如果指定的集合为null，throws NullPointerException。 \n    */</span>\n     <span>public</span> <span>ArrayList</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>\n        elementData <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>(</span>size <span>=</span> elementData<span>.</span>length<span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n            <span>// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>\n            <span>if</span> <span>(</span>elementData<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>!=</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span>\n                elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>// replace with empty array.</span>\n            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p>\n<h2 id=\"二-一步一步分析-arraylist-扩容机制\"> 二 一步一步分析 ArrayList 扩容机制</h2>\n<p>这里以无参构造函数创建的 ArrayList 为例分析</p>\n<h3 id=\"_1-先来看-add-方法\"> 1. 先来看 <code>add</code> 方法</h3>\n<div><pre><code>    <span>/**\n     * 将指定的元素追加到此列表的末尾。 \n     */</span>\n    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>\n   <span>//添加元素之前，先调用ensureCapacityInternal方法</span>\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>\n        <span>//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>\n        elementData<span>[</span>size<span>++</span><span>]</span> <span>=</span> e<span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_2-再来看看-ensurecapacityinternal-方法\"> 2. 再来看看 <code>ensureCapacityInternal()</code> 方法</h3>\n<p>可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>\n<div><pre><code>   <span>//得到最小扩容量</span>\n    <span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>elementData <span>==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span> <span>{</span>\n              <span>// 获取默认的容量和传入参数的较大值</span>\n            minCapacity <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>DEFAULT_CAPACITY<span>,</span> minCapacity<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。</strong></p>\n<h3 id=\"_3-ensureexplicitcapacity-方法\"> 3. <code>ensureExplicitCapacity()</code> 方法</h3>\n<p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进过（执行）这个方法，下面我们来研究一下这个方法的源码！</p>\n<div><pre><code>  <span>//判断是否需要扩容</span>\n    <span>private</span> <span>void</span> <span>ensureExplicitCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        modCount<span>++</span><span>;</span>\n\n        <span>// overflow-conscious code</span>\n        <span>if</span> <span>(</span>minCapacity <span>-</span> elementData<span>.</span>length <span>></span> <span>0</span><span>)</span>\n            <span>//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>\n            <span>grow</span><span>(</span>minCapacity<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>我们来仔细分析一下：</p>\n<ul>\n<li>当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>\n<li>当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code>不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>\n<li>添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。</li>\n</ul>\n<p>直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。</p>\n<h3 id=\"_4-grow-方法\"> 4. <code>grow()</code> 方法</h3>\n<div><pre><code>    <span>/**\n     * 要分配的最大数组大小\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_ARRAY_SIZE <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>8</span><span>;</span>\n\n    <span>/**\n     * ArrayList扩容的核心方法。\n     */</span>\n    <span>private</span> <span>void</span> <span>grow</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>// oldCapacity为旧容量，newCapacity为新容量</span>\n        <span>int</span> oldCapacity <span>=</span> elementData<span>.</span>length<span>;</span>\n        <span>//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>\n        <span>//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>\n        <span>int</span> newCapacity <span>=</span> oldCapacity <span>+</span> <span>(</span>oldCapacity <span>>></span> <span>1</span><span>)</span><span>;</span>\n        <span>//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>\n        <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span>\n            newCapacity <span>=</span> minCapacity<span>;</span>\n       <span>// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span>\n       <span>//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span>\n        <span>if</span> <span>(</span>newCapacity <span>-</span> MAX_ARRAY_SIZE <span>></span> <span>0</span><span>)</span>\n            newCapacity <span>=</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n        <span>// minCapacity is usually close to size, so this is a win:</span>\n        elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> newCapacity<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity为偶数就是1.5倍，否则是1.5倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p>\n<blockquote>\n<p>&quot;&gt;&gt;&quot;（移位运算符）：&gt;&gt;1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p>\n</blockquote>\n<p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p>\n<ul>\n<li>当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为10，add方法中 return true,size增为1。</li>\n<li>当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。</li>\n<li>以此类推······</li>\n</ul>\n<p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p>\n<ul>\n<li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>\n<li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>\n<li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>\n</ul>\n<h3 id=\"_5-hugecapacity-方法。\"> 5. <code>hugeCapacity()</code> 方法。</h3>\n<p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p>\n<div><pre><code>    <span>private</span> <span>static</span> <span>int</span> <span>hugeCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>\n            <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>\n        <span>//对minCapacity和MAX_ARRAY_SIZE进行比较</span>\n        <span>//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span>\n        <span>//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span>\n        <span>//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>\n        <span>return</span> <span>(</span>minCapacity <span>></span> MAX_ARRAY_SIZE<span>)</span> <span>?</span>\n            <span>Integer</span><span>.</span>MAX_VALUE <span>:</span>\n            MAX_ARRAY_SIZE<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"三-system-arraycopy-和-arrays-copyof-方法\"> 三 <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h2>\n<p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p>\n<h3 id=\"_3-1-system-arraycopy-方法\"> 3.1 <code>System.arraycopy()</code> 方法</h3>\n<div><pre><code>    <span>/**\n     * 在此列表中的指定位置插入指定的元素。 \n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */</span>\n    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>\n        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>\n\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>\n        <span>//arraycopy()方法实现数组自己复制自己</span>\n        <span>//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span>\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> <span>1</span><span>,</span> size <span>-</span> index<span>)</span><span>;</span>\n        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>\n        size<span>++</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>我们写一个简单的方法测试以下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ArraycopyTest</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>// TODO Auto-generated method stub</span>\n\t\t<span>int</span><span>[</span><span>]</span> a <span>=</span> <span>new</span> <span>int</span><span>[</span><span>10</span><span>]</span><span>;</span>\n\t\ta<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>\n\t\ta<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>\n\t\ta<span>[</span><span>2</span><span>]</span> <span>=</span> <span>2</span><span>;</span>\n\t\ta<span>[</span><span>3</span><span>]</span> <span>=</span> <span>3</span><span>;</span>\n\t\t<span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>2</span><span>,</span> a<span>,</span> <span>3</span><span>,</span> <span>3</span><span>)</span><span>;</span>\n\t\ta<span>[</span><span>2</span><span>]</span><span>=</span><span>99</span><span>;</span>\n\t\t<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> a<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n\t\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>[</span>i<span>]</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>结果：</p>\n<div><pre><code>0 1 99 2 3 0 0 0 0 0 \n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_3-2-arrays-copyof-方法\"> 3.2 <code>Arrays.copyOf()</code>方法</h3>\n<div><pre><code>   <span>/**\n     以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 \n     */</span>\n    <span>public</span> <span>Object</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>)</span> <span>{</span>\n    <span>//elementData：要复制的数组；size：要复制的长度</span>\n        <span>return</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ArrayscopyOfTest</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>int</span><span>[</span><span>]</span> a <span>=</span> <span>new</span> <span>int</span><span>[</span><span>3</span><span>]</span><span>;</span>\n\t\ta<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>\n\t\ta<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>\n\t\ta<span>[</span><span>2</span><span>]</span> <span>=</span> <span>2</span><span>;</span>\n\t\t<span>int</span><span>[</span><span>]</span> b <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>a<span>,</span> <span>10</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"b.length\"</span><span>+</span>b<span>.</span>length<span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>结果：</p>\n<div><pre><code>10\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_3-3-两者联系和区别\"> 3.3 两者联系和区别</h3>\n<p><strong>联系：</strong></p>\n<p>看两者源代码可以发现 copyOf() 内部实际调用了 <code>System.arraycopy()</code> 方法</p>\n<p><strong>区别：</strong></p>\n<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>\n<h2 id=\"四-ensurecapacity方法\"> 四 <code>ensureCapacity</code>方法</h2>\n<p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>\n<div><pre><code>    <span>/**\n    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。\n     *\n     * @param   minCapacity   所需的最小容量\n     */</span>\n    <span>public</span> <span>void</span> <span>ensureCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>int</span> minExpand <span>=</span> <span>(</span>elementData <span>!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span>\n            <span>// any size if not default element table</span>\n            <span>?</span> <span>0</span>\n            <span>// larger than default for default empty table. It's already</span>\n            <span>// supposed to be at default size.</span>\n            <span>:</span> DEFAULT_CAPACITY<span>;</span>\n\n        <span>if</span> <span>(</span>minCapacity <span>></span> minExpand<span>)</span> <span>{</span>\n            <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p>\n<p>我们通过下面的代码实际测试以下这个方法的效果：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>EnsureCapacityTest</span> <span>{</span>\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\t\t<span>final</span> <span>int</span> <span>N</span> <span>=</span> <span>10000000</span><span>;</span>\n\t\t<span>long</span> startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n\t\t\tlist<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>long</span> endTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"使用ensureCapacity方法前：\"</span><span>+</span><span>(</span>endTime <span>-</span> startTime<span>)</span><span>)</span><span>;</span>\n\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>运行结果：</p>\n<div><pre><code>使用ensureCapacity方法前：<span>2158</span>\n<span>public</span> <span>class</span> <span>EnsureCapacityTest</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>final</span> <span>int</span> <span>N</span> <span>=</span> <span>10000000</span><span>;</span>\n        list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>long</span> startTime1 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n        list<span>.</span><span>ensureCapacity</span><span>(</span><span>N</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>\n        <span>}</span>\n        <span>long</span> endTime1 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"使用ensureCapacity方法后：\"</span><span>+</span><span>(</span>endTime1 <span>-</span> startTime1<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>运行结果：</p>\n<div><pre><code>使用ensureCapacity方法前：1773\n</code></pre>\n<div><span>1</span><br></div></div><p>通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "生产者与消费者模式",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B05-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B05-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/",
      "content_html": "<h1 id=\"生产者与消费者模式\"> 生产者与消费者模式</h1>\n<h2 id=\"知识点\"> 知识点</h2>\n<p><strong>流程</strong></p>\n<ul>\n<li>生产者负责信息内容的生产</li>\n<li>每当生产者生产完成一项完整的信息之后消费者要从这里面取走信息</li>\n<li>如果生产者没有生产，则消费者要等待它生产完成，如果消费者没有对信息消费，则生产者要等待消费者把信息消费完成后再生产</li>\n</ul>\n<p><strong>模型</strong></p>\n<h2 id=\"实例\"> 实例</h2>\n<p>生产者生产面包，消费者消费面包</p>\n<h3 id=\"数据未同步的问题\"> 数据未同步的问题</h3>\n<p><strong>有问题的代码</strong></p>\n<p><strong>代码</strong></p>\n<div><pre><code><span>package</span> <span>study<span>.</span>chapter03<span>.</span>thread<span>.</span>model</span><span>;</span>\n\n<span>//生产者与消费者模型</span>\n<span>public</span> <span>class</span> <span>TestThread</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Bread</span> bread <span>=</span> <span>new</span> <span>Bread</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Producer</span><span>(</span>bread<span>)</span><span>,</span> <span>\"生产者线程\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Consumer</span><span>(</span>bread<span>)</span><span>,</span> <span>\"消费者线程\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>//面包类</span>\n<span>class</span> <span>Bread</span><span>{</span>\n    <span>private</span> <span>int</span> id<span>;</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n\n    <span>public</span> <span>int</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> id<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setId</span><span>(</span><span>int</span> id<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>id <span>=</span> id<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"Bread{\"</span> <span>+</span>\n                <span>\"id=\"</span> <span>+</span> id <span>+</span>\n                <span>\", name='\"</span> <span>+</span> name <span>+</span> <span>'\\''</span> <span>+</span>\n                <span>'}'</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>//生产者</span>\n<span>class</span> <span>Producer</span> <span>implements</span> <span>Runnable</span><span>{</span>\n    <span>private</span> <span>Bread</span> bread<span>;</span>\n    <span>Producer</span><span>(</span><span>Bread</span> bread<span>)</span><span>{</span>\n        <span>this</span><span>.</span>bread <span>=</span> bread<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"开始生产面包\"</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            bread<span>.</span><span>setId</span><span>(</span>i<span>)</span><span>;</span>\n            bread<span>.</span><span>setName</span><span>(</span><span>\"面包\"</span> <span>+</span> i<span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"生产面包：\"</span> <span>+</span> bread<span>)</span><span>;</span>\n\n            <span>try</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>300</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n<span>//消费者</span>\n<span>class</span> <span>Consumer</span> <span>implements</span> <span>Runnable</span><span>{</span>\n    <span>private</span> <span>Bread</span> bread<span>;</span>\n    <span>Consumer</span><span>(</span><span>Bread</span> bread<span>)</span><span>{</span>\n        <span>this</span><span>.</span>bread <span>=</span> bread<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"开始消费面包\"</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"消费面包：id=\"</span> <span>+</span> bread<span>.</span><span>getId</span><span>(</span><span>)</span> <span>+</span> <span>\"，\"</span> <span>+</span> bread<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>try</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>100</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code>开始生产面包\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>1</span><span>,</span> name<span>=</span><span>'面包1'</span><span>}</span>\n开始消费面包\n消费面包：id<span>=</span><span>1</span>，面包<span>1</span>\n消费面包：id<span>=</span><span>1</span>，面包<span>1</span>\n消费面包：id<span>=</span><span>1</span>，面包<span>1</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>2</span><span>,</span> name<span>=</span><span>'面包2'</span><span>}</span>\n消费面包：id<span>=</span><span>2</span>，面包<span>2</span>\n消费面包：id<span>=</span><span>2</span>，面包<span>2</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>3</span><span>,</span> name<span>=</span><span>'面包3'</span><span>}</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>4</span><span>,</span> name<span>=</span><span>'面包4'</span><span>}</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>5</span><span>,</span> name<span>=</span><span>'面包5'</span><span>}</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>6</span><span>,</span> name<span>=</span><span>'面包6'</span><span>}</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>7</span><span>,</span> name<span>=</span><span>'面包7'</span><span>}</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>8</span><span>,</span> name<span>=</span><span>'面包8'</span><span>}</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>9</span><span>,</span> name<span>=</span><span>'面包9'</span><span>}</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>10</span><span>,</span> name<span>=</span><span>'面包10'</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>这里出现了重复消费的问题，没有考虑同步的问题</strong></p>\n<h3 id=\"解决数据未同步的问题\"> 解决数据未同步的问题</h3>\n<p><strong>加入同步</strong></p>\n<ul>\n<li>\n<p>使用关键字<code>synchronized</code></p>\n</li>\n<li>\n<p>使用Object类的<code>wait()</code>、<code>notify()</code>方法</p>\n</li>\n</ul>\n<p>同步需要同步对象，将面包作为同步对象，所以把同步操作放在了面包类的方法中</p>\n<p><strong>代码</strong></p>\n<div><pre><code><span>package</span> <span>study<span>.</span>chapter03<span>.</span>thread<span>.</span>model</span><span>;</span>\n\n<span>//生产者与消费者模型</span>\n<span>public</span> <span>class</span> <span>TestThread2</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Bread2</span> bread <span>=</span> <span>new</span> <span>Bread2</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Producer2</span><span>(</span>bread<span>)</span><span>,</span> <span>\"生产者线程\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Consumer2</span><span>(</span>bread<span>)</span><span>,</span> <span>\"消费者线程\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>//面包类</span>\n<span>class</span> <span>Bread2</span><span>{</span>\n    <span>private</span> <span>int</span> id<span>;</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n    <span>private</span> <span>Boolean</span> flag <span>=</span> <span>true</span><span>;</span>\n    <span>//flag = true只允许生产</span>\n    <span>//flag = false只允许消费</span>\n\n    <span>//同步需要同步对象，将面包作为同步对象，所以把同步操作放在了面包类的方法中</span>\n    <span>public</span> <span>synchronized</span> <span>void</span> <span>set</span><span>(</span><span>Integer</span> id<span>,</span> <span>String</span> name<span>)</span><span>{</span>\n        <span>if</span> <span>(</span>flag <span>==</span> <span>false</span><span>)</span><span>{</span>     <span>//不能生产，等待被消费</span>\n            <span>try</span> <span>{</span>\n                <span>super</span><span>.</span><span>wait</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>this</span><span>.</span>id <span>=</span> id<span>;</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n        <span>try</span> <span>{</span>\n            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>300</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>this</span><span>.</span>flag <span>=</span> <span>false</span><span>;</span>  <span>//已经生产过了</span>\n        <span>super</span><span>.</span><span>notify</span><span>(</span><span>)</span><span>;</span> <span>//唤起等待的线程</span>\n    <span>}</span>\n\n    <span>public</span> <span>synchronized</span> <span>String</span> <span>get</span><span>(</span><span>)</span><span>{</span>\n        <span>if</span> <span>(</span><span>this</span><span>.</span>flag<span>)</span><span>{</span><span>//还未生产</span>\n            <span>try</span> <span>{</span>\n                <span>super</span><span>.</span><span>wait</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>try</span> <span>{</span>\n            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>100</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>try</span> <span>{</span>\n            <span>return</span> <span>\"消费面包：id=\"</span> <span>+</span> <span>this</span><span>.</span>id <span>+</span> <span>\"，\"</span> <span>+</span> <span>this</span><span>.</span>name<span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            <span>this</span><span>.</span>flag <span>=</span> <span>true</span><span>;</span>\n            <span>super</span><span>.</span><span>notify</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"Bread{\"</span> <span>+</span>\n                <span>\"id=\"</span> <span>+</span> id <span>+</span>\n                <span>\", name='\"</span> <span>+</span> name <span>+</span> <span>'\\''</span> <span>+</span>\n                <span>'}'</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>//生产者</span>\n<span>class</span> <span>Producer2</span> <span>implements</span> <span>Runnable</span><span>{</span>\n    <span>private</span> <span>Bread2</span> bread<span>;</span>\n    <span>Producer2</span><span>(</span><span>Bread2</span> bread<span>)</span><span>{</span>\n        <span>this</span><span>.</span>bread <span>=</span> bread<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"开始生产面包\"</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            bread<span>.</span><span>set</span><span>(</span>i<span>,</span> <span>\"面包\"</span> <span>+</span> i<span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"生产面包：\"</span> <span>+</span> bread<span>)</span><span>;</span>\n\n            <span>try</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>300</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n<span>//消费者</span>\n<span>class</span> <span>Consumer2</span> <span>implements</span> <span>Runnable</span><span>{</span>\n    <span>private</span> <span>Bread2</span> bread<span>;</span>\n    <span>Consumer2</span><span>(</span><span>Bread2</span> bread<span>)</span><span>{</span>\n        <span>this</span><span>.</span>bread <span>=</span> bread<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"开始消费面包\"</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>bread<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code>开始生产面包\n开始消费面包\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>1</span><span>,</span> name<span>=</span><span>'面包1'</span><span>}</span>\n消费面包：id<span>=</span><span>1</span>，面包<span>1</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>2</span><span>,</span> name<span>=</span><span>'面包2'</span><span>}</span>\n消费面包：id<span>=</span><span>2</span>，面包<span>2</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>3</span><span>,</span> name<span>=</span><span>'面包3'</span><span>}</span>\n消费面包：id<span>=</span><span>3</span>，面包<span>3</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>4</span><span>,</span> name<span>=</span><span>'面包4'</span><span>}</span>\n消费面包：id<span>=</span><span>4</span>，面包<span>4</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>5</span><span>,</span> name<span>=</span><span>'面包5'</span><span>}</span>\n消费面包：id<span>=</span><span>5</span>，面包<span>5</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>6</span><span>,</span> name<span>=</span><span>'面包6'</span><span>}</span>\n消费面包：id<span>=</span><span>6</span>，面包<span>6</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>7</span><span>,</span> name<span>=</span><span>'面包7'</span><span>}</span>\n消费面包：id<span>=</span><span>7</span>，面包<span>7</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>8</span><span>,</span> name<span>=</span><span>'面包8'</span><span>}</span>\n消费面包：id<span>=</span><span>8</span>，面包<span>8</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>9</span><span>,</span> name<span>=</span><span>'面包9'</span><span>}</span>\n消费面包：id<span>=</span><span>9</span>，面包<span>9</span>\n生产面包：<span>Bread</span><span>{</span>id<span>=</span><span>10</span><span>,</span> name<span>=</span><span>'面包10'</span><span>}</span>\n消费面包：id<span>=</span><span>10</span>，面包<span>10</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>以上代码实现了数据同步的问题，生产者生产一个、消费者消费一个。</p>\n",
      "date_published": "2020-01-30T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "volatile关键字",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B07-volatile%E5%85%B3%E9%94%AE%E5%AD%97/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/javase/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B07-volatile%E5%85%B3%E9%94%AE%E5%AD%97/",
      "content_html": "<h1 id=\"volatile关键字\"> volatile关键字</h1>\n<h2 id=\"知识点\"> 知识点</h2>\n<p>volatile关键字在属性定义上使用，表示此属性为直接数据操作，而不进行副本的拷贝处理。节约了拷贝副本数据的时间。</p>\n<h2 id=\"实例\"> 实例</h2>\n<p><strong>代码</strong></p>\n<div><pre><code><span>package</span> <span>study<span>.</span>chapter03<span>.</span>thread<span>.</span>keywords</span><span>;</span>\n\n<span>//关键字volatile的使用</span>\n<span>public</span> <span>class</span> <span>TestThread</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>MyThread</span> myThread <span>=</span> <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>myThread<span>,</span> <span>\"售票员A\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>myThread<span>,</span> <span>\"售票员B\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>myThread<span>,</span> <span>\"售票员C\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>MyThread</span> <span>implements</span> <span>Runnable</span><span>{</span>\n    <span>//在属性上使用关键字volatile</span>\n    <span>public</span> <span>volatile</span> <span>int</span> ticket <span>=</span> <span>5</span><span>;</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>synchronized</span> <span>(</span><span>this</span><span>)</span><span>{</span>\n            <span>while</span> <span>(</span>ticket <span>></span> <span>0</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"卖票：ticket=\"</span> <span>+</span> ticket<span>--</span><span>)</span><span>;</span>\n                <span>try</span> <span>{</span>\n                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>100</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code>售票员<span>A</span>卖票：ticket<span>=</span><span>5</span>\n售票员<span>A</span>卖票：ticket<span>=</span><span>4</span>\n售票员<span>A</span>卖票：ticket<span>=</span><span>3</span>\n售票员<span>A</span>卖票：ticket<span>=</span><span>2</span>\n售票员<span>A</span>卖票：ticket<span>=</span><span>1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>",
      "date_published": "2020-01-30T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Java线程的生命周期",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/Java%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/Java%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
      "content_html": "<h1 id=\"java线程的生命周期\"> Java线程的生命周期</h1>\n<h1 id=\"_0-前言\"> 0 前言</h1>\n<p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过 <strong>新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态</strong>。尤其是当线程启动以后，它不可能一直&quot;霸占&quot;着CPU独自运行，所以CPU需要在多条线程之间切换，于是 <strong>线程状态也会多次在运行、阻塞之间切换</strong>。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/6/19/16417a1fd6b14a80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"线程状态转换关系\" /></p>\n<h1 id=\"_1-新建-new-状态\"> 1 新建（New）状态</h1>\n<p>当程序使用new关键字创建了一个线程之后，该线程就处于 <strong>新建状态</strong>，此时的线程情况如下：</p>\n<blockquote>\n<ol>\n<li><strong>此时JVM为其分配内存，并初始化其成员变量的值</strong>；</li>\n<li><strong>此时线程对象没有表现出任何线程的动态特征</strong>，程序也不会执行线程的线程执行体；</li>\n</ol>\n</blockquote>\n<h1 id=\"_2-就绪-runnable-状态\"> 2 就绪（Runnable）状态</h1>\n<p>当线程对象调用了start()方法之后，该线程处于 <strong>就绪状态</strong>。此时的线程情况如下：</p>\n<blockquote>\n<ol>\n<li>此时JVM会为其 <strong>创建方法调用栈和程序计数器</strong>；</li>\n<li>该状态的线程一直处于 <strong>线程就绪队列</strong>（尽管是采用队列形式，事实上，<strong>把它称为可运行池而不是可运行队列</strong>。因为CPU的调度不一定是按照先进先出的顺序来调度的），线程并没有开始运行；</li>\n<li>此时线程 <strong>等待系统为其分配CPU时间片</strong>，并不是说执行了start()方法就立即执行；</li>\n</ol>\n</blockquote>\n<p><strong>调用start()方法与run()方法，对比如下：</strong></p>\n<blockquote>\n<ol>\n<li><strong>调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理</strong>。但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，<strong>系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体</strong>；</li>\n<li>需要指出的是，调用了线程的run()方法之后，<strong>该线程已经不再处于新建状态</strong>，不要再次调用线程对象的start()方法。<strong>只能对处于新建状态的线程调用start()方法，否则将引发IllegaIThreadStateExccption异常</strong>；</li>\n</ol>\n</blockquote>\n<p><strong>如何让子线程调用start()方法之后立即执行而非&quot;等待执行&quot;：</strong></p>\n<blockquote>\n<p>程序可以使用Thread.sleep(1) 来让当前运行的线程（主线程）睡眠1毫秒，1毫秒就够了，<strong>因为在这1毫秒内CPU不会空闲，它会去执行另一个处于就绪状态的线程，这样就可以让子线程立即开始执行</strong>；</p>\n</blockquote>\n<h1 id=\"_3-运行-running-状态\"> 3 运行（Running）状态</h1>\n<p>当CPU开始调度处于 <strong>就绪状态</strong> 的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于 <strong>运行状态</strong>。</p>\n<blockquote>\n<ol>\n<li>如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态；</li>\n<li>如果在一个多处理器的机器上，将会有多个线程并行执行，处于运行状态；</li>\n<li>当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象；</li>\n</ol>\n</blockquote>\n<p>处于运行状态的线程最为复杂，它 <strong>不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了）</strong>，线程在运行过程中需要被中断，<strong>目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略</strong>。线程状态可能会变为 <strong>阻塞状态、就绪状态和死亡状态</strong>。比如：</p>\n<blockquote>\n<ol>\n<li>对于采用 <strong>抢占式策略</strong> 的系统而言，系统会给每个可执行的线程分配一个时间片来处理任务；当该时间片用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。线程就会又 <strong>从运行状态变为就绪状态</strong>，重新等待系统分配资源；</li>\n<li>对于采用 <strong>协作式策略</strong>的系统而言，只有当一个线程调用了它的yield()方法后才会放弃所占用的资源—<strong>也就是必须由该线程主动放弃所占用的资源</strong>，线程就会又 <strong>从运行状态变为就绪状态</strong>。</li>\n</ol>\n</blockquote>\n<h1 id=\"_4-阻塞-blocked-状态\"> 4 阻塞（Blocked）状态</h1>\n<p>处于运行状态的线程在某些情况下，让出CPU并暂时停止自己的运行，进入 <strong>阻塞状态</strong>。</p>\n<p><strong>当发生如下情况时，线程将会进入阻塞状态：</strong></p>\n<blockquote>\n<ol>\n<li><strong>线程调用sleep()方法</strong>，主动放弃所占用的处理器资源，暂时进入中断状态（<strong>不会释放持有的对象锁</strong>），时间到后等待系统分配CPU继续执行；</li>\n<li><strong>线程调用一个阻塞式IO方法</strong>，在该方法返回之前，该线程被阻塞；</li>\n<li><strong>线程试图获得一个同步监视器</strong>，但该同步监视器正被其他线程所持有;</li>\n<li><strong>程序调用了线程的suspend方法将线程挂起</strong>；</li>\n<li><strong>线程调用wait</strong>，等待notify/notifyAll唤醒时(会释放持有的对象锁)；</li>\n</ol>\n</blockquote>\n<p><strong>阻塞状态分类：</strong></p>\n<blockquote>\n<ol>\n<li><strong>等待阻塞</strong>：运行状态中的 <strong>线程执行wait()方法</strong>，使本线程进入到等待阻塞状态；</li>\n<li><strong>同步阻塞</strong>：线程在 <strong>获取synchronized同步锁失败</strong>（因为锁被其它线程占用），它会进入到同步阻塞状态；</li>\n<li><strong>其他阻塞</strong>：通过调用线程的 <strong>sleep()或join()或发出I/O请求</strong> 时，线程会进入到阻塞状态。当 <strong>sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕</strong> 时，线程重新转入就绪状态；</li>\n</ol>\n</blockquote>\n<p><strong>在阻塞状态的线程只能进入就绪状态，无法直接进入运行状态</strong>。而就绪和运行状态之间的转换通常不受程序控制，<strong>而是由系统线程调度所决定</strong>。当处于就绪状态的线程获得处理器资源时，该线程进入运行状态；<strong>当处于运行状态的线程失去处理器资源时，该线程进入就绪状态</strong>。</p>\n<blockquote>\n<p>但有一个方法例外，<strong>调用yield()方法可以让运行状态的线程转入就绪状态</strong>。</p>\n</blockquote>\n<h2 id=\"_4-1-等待-waiting-状态\"> 4.1 等待（WAITING）状态</h2>\n<p>线程处于 <strong>无限制等待状态</strong>，等待一个特殊的事件来重新唤醒，如：</p>\n<blockquote>\n<ol>\n<li>通过wait()方法进行等待的线程等待一个notify()或者notifyAll()方法；</li>\n<li>通过join()方法进行等待的线程等待目标线程运行结束而唤醒；</li>\n</ol>\n</blockquote>\n<p>以上两种一旦通过相关事件唤醒线程，线程就进入了 <strong>就绪（RUNNABLE）状态</strong> 继续运行。</p>\n<h2 id=\"_4-2-时限等待-timed-waiting-状态\"> 4.2 时限等待（TIMED_WAITING）状态</h2>\n<p>线程进入了一个 <strong>时限等待状态</strong>，如：</p>\n<blockquote>\n<p><strong>sleep(3000)</strong>，等待3秒后线程重新进行 <strong>就绪（RUNNABLE）状态</strong> 继续运行。</p>\n</blockquote>\n<h1 id=\"_5-死亡-dead-状态\"> 5 死亡（Dead）状态</h1>\n<p>线程会以如下3种方式结束，结束后就处于 <strong>死亡状态</strong>：</p>\n<blockquote>\n<ol>\n<li><strong>run()或call()方法执行完成</strong>，线程正常结束；</li>\n<li><strong>线程抛出一个未捕获的Exception或Error</strong>；</li>\n<li><strong>直接调用该线程stop()方法来结束该线程</strong>—该方法容易导致死锁，通常不推荐使用；</li>\n</ol>\n</blockquote>\n<p><strong>处于死亡状态的线程对象也许是活的，但是，它已经不是一个单独执行的线程</strong>。线程一旦死亡，就不能复生。 <strong>如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常</strong>。</p>\n<p><strong>所以，需要注意的是：</strong></p>\n<blockquote>\n<p><strong>一旦线程通过start()方法启动后就再也不能回到新建（NEW）状态，线程终止后也不能再回到就绪（RUNNABLE）状态</strong>。</p>\n</blockquote>\n<h2 id=\"_5-1-终止-terminated-状态\"> 5.1 终止（TERMINATED）状态</h2>\n<p>线程执行完毕后，进入终止（TERMINATED）状态。</p>\n<h1 id=\"_6-线程相关方法\"> 6 线程相关方法</h1>\n<div><pre><code><span>public</span> <span>class</span> <span>Thread</span><span>{</span>\n    <span>// 线程的启动</span>\n    <span>public</span> <span>void</span> <span>start</span><span>(</span><span>)</span><span>;</span> \n    <span>// 线程体</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span> \n    <span>// 已废弃</span>\n    <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span><span>;</span> \n    <span>// 已废弃</span>\n    <span>public</span> <span>void</span> <span>resume</span><span>(</span><span>)</span><span>;</span> \n    <span>// 已废弃</span>\n    <span>public</span> <span>void</span> <span>suspend</span><span>(</span><span>)</span><span>;</span> \n    <span>// 在指定的毫秒数内让当前正在执行的线程休眠</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>sleep</span><span>(</span><span>long</span> millis<span>)</span><span>;</span> \n    <span>// 同上，增加了纳秒参数</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>sleep</span><span>(</span><span>long</span> millis<span>,</span> <span>int</span> nanos<span>)</span><span>;</span> \n    <span>// 测试线程是否处于活动状态</span>\n    <span>public</span> <span>boolean</span> <span>isAlive</span><span>(</span><span>)</span><span>;</span> \n    <span>// 中断线程</span>\n    <span>public</span> <span>void</span> <span>interrupt</span><span>(</span><span>)</span><span>;</span> \n    <span>// 测试线程是否已经中断</span>\n    <span>public</span> <span>boolean</span> <span>isInterrupted</span><span>(</span><span>)</span><span>;</span> \n    <span>// 测试当前线程是否已经中断</span>\n    <span>public</span> <span>static</span> <span>boolean</span> <span>interrupted</span><span>(</span><span>)</span><span>;</span> \n    <span>// 等待该线程终止</span>\n    <span>public</span> <span>void</span> <span>join</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span><span>;</span> \n    <span>// 等待该线程终止的时间最长为 millis 毫秒</span>\n    <span>public</span> <span>void</span> <span>join</span><span>(</span><span>long</span> millis<span>)</span> <span>throws</span> <span>InterruptedException</span><span>;</span> \n    <span>// 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒</span>\n    <span>public</span> <span>void</span> <span>join</span><span>(</span><span>long</span> millis<span>,</span> <span>int</span> nanos<span>)</span> <span>throws</span> <span>InterruptedException</span><span>;</span> \n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p><img src=\"https://user-gold-cdn.xitu.io/2018/6/19/16417a1fd6acc8f4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"线程方法状态转换\" /></p>\n<h2 id=\"_6-1-线程就绪、运行和死亡状态转换\"> 6.1 线程就绪、运行和死亡状态转换</h2>\n<ol>\n<li><strong>就绪状态转换为运行状态</strong>：此线程得到CPU资源；</li>\n<li><strong>运行状态转换为就绪状态</strong>：此线程主动调用yield()方法或在运行过程中失去CPU资源。</li>\n<li><strong>运行状态转换为死亡状态</strong>：此线程执行执行完毕或者发生了异常；</li>\n</ol>\n<p><strong>注意：</strong></p>\n<blockquote>\n<p>当调用线程中的yield()方法时，线程从运行状态转换为就绪状态，<strong>但接下来CPU调度就绪状态中的那个线程具有一定的随机性</strong>，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。</p>\n</blockquote>\n<h2 id=\"_6-2-run-start\"> 6.2 run &amp; start</h2>\n<p>通过调用start启动线程，线程执行时会执行run方法中的代码。</p>\n<blockquote>\n<ol>\n<li><strong>start()</strong>：线程的启动；</li>\n<li><strong>run()</strong>：线程的执行体；</li>\n</ol>\n</blockquote>\n<h2 id=\"_6-3-sleep-yield\"> 6.3 sleep &amp; yield</h2>\n<p><strong>sleep()</strong>：通过sleep(millis)使线程进入休眠一段时间，<strong>该方法在指定的时间内无法被唤醒，同时也不会释放对象锁</strong>；</p>\n<p><strong>比如，我们想要使主线程每休眠100毫秒，然后再打印出数字：</strong></p>\n<div><pre><code><span>/**\n * 可以明显看到打印的数字在时间上有些许的间隔\n */</span>\n<span>public</span> <span>class</span> <span>Test1</span> <span>{</span>  \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>  \n        <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span><span>100</span><span>;</span>i<span>++</span><span>)</span><span>{</span>  \n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"main\"</span><span>+</span>i<span>)</span><span>;</span>  \n            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>100</span><span>)</span><span>;</span>  \n        <span>}</span>  \n    <span>}</span>  \n<span>}</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>注意如下几点问题：</strong></p>\n<ol>\n<li>\n<p>sleep是静态方法，最好不要用Thread的实例对象调用它</p>\n<p>，</p>\n<p>因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象</p>\n<p>，</p>\n<p>它只对正在运行状态的线程对象有效</p>\n<p>。看下面的例子：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test1</span> <span>{</span>  \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>  \n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>  \n        <span>MyThread</span> myThread<span>=</span><span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>  \n        myThread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  \n        <span>// 这里sleep的就是main线程，而非myThread线程 </span>\n        myThread<span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span> \n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>10</span><span>)</span><span>;</span>  \n        <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span><span>100</span><span>;</span>i<span>++</span><span>)</span><span>{</span>  \n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"main\"</span><span>+</span>i<span>)</span><span>;</span>  \n        <span>}</span>  \n    <span>}</span>  \n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>\n<li>\n<p>Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。</p>\n<p>因为使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它</p>\n<p>，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test1</span> <span>{</span>  \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>  \n        <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  \n        <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  \n    <span>}</span>  \n<span>}</span>  \n  \n<span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>  \n    <span>@Override</span>  \n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>  \n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>3</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>  \n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>this</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>\"线程\"</span> <span>+</span> i <span>+</span> <span>\"次执行！\"</span><span>)</span><span>;</span>  \n            <span>try</span> <span>{</span>  \n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>50</span><span>)</span><span>;</span>  \n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>  \n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>  \n            <span>}</span>  \n        <span>}</span>  \n    <span>}</span>  \n<span>}</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>看某一次的运行结果</p>\n<p>：可以发现，线程0首先执行，然后线程1执行一次，又了执行一次。发现并不是按照sleep的顺序执行的。</p>\n<div><pre><code>Thread-0线程0次执行！  \nThread-1线程0次执行！  \nThread-1线程1次执行！  \nThread-0线程1次执行！  \nThread-0线程2次执行！  \nThread-1线程2次执行！  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>\n</ol>\n<p><strong>yield()</strong>：与sleep类似，<strong>也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出CPU资源给其他的线程</strong>。但是和sleep()方法不同的是，<strong>它不会进入到阻塞状态，而是进入到就绪状态</strong>。yield()方法只是让当前线程暂停一下，重新进入就绪线程池中，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：<strong>当某个线程调用yield()方法之后，线程调度器又将其调度出来重新进入到运行状态执行</strong>。</p>\n<blockquote>\n<p>实际上，<strong>当某个线程调用了yield()方法暂停之后，优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程更有可能获得执行的机会</strong>，当然，只是有可能，因为我们不可能精确的干涉cpu调度线程。</p>\n</blockquote>\n<div><pre><code><span>public</span> <span>class</span> <span>Test1</span> <span>{</span>  \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>  \n        <span>new</span> <span>MyThread</span><span>(</span><span>\"低级\"</span><span>,</span> <span>1</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  \n        <span>new</span> <span>MyThread</span><span>(</span><span>\"中级\"</span><span>,</span> <span>5</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  \n        <span>new</span> <span>MyThread</span><span>(</span><span>\"高级\"</span><span>,</span> <span>10</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  \n    <span>}</span>  \n<span>}</span>  \n  \n<span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>  \n    <span>public</span> <span>MyThread</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> pro<span>)</span> <span>{</span>  \n        <span>super</span><span>(</span>name<span>)</span><span>;</span><span>// 设置线程的名称  </span>\n        <span>this</span><span>.</span><span>setPriority</span><span>(</span>pro<span>)</span><span>;</span><span>// 设置优先级  </span>\n    <span>}</span>  \n  \n    <span>@Override</span>  \n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>  \n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>30</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>  \n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>this</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"线程第\"</span> <span>+</span> i <span>+</span> <span>\"次执行！\"</span><span>)</span><span>;</span>  \n            <span>if</span> <span>(</span>i <span>%</span> <span>5</span> <span>==</span> <span>0</span><span>)</span>  \n                <span>Thread</span><span>.</span><span>yield</span><span>(</span><span>)</span><span>;</span>  \n        <span>}</span>  \n    <span>}</span>  \n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><strong>关于sleep()方法和yield()方的区别如下</strong>：</p>\n<blockquote>\n<ol>\n<li>sleep方法暂停当前线程后，<strong>会进入阻塞状态</strong>，只有当睡眠时间到了，<strong>才会转入就绪状态</strong>。而yield方法调用后 ，<strong>是直接进入就绪状态</strong>，所以有可能刚进入就绪状态，又被调度到运行状态；</li>\n<li><strong>sleep方法声明抛出了InterruptedException</strong>，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。<strong>而yield方法则没有声明抛出任务异常</strong>；</li>\n<li>sleep方法比yield方法有更好的可移植性，<strong>通常不要依靠yield方法来控制并发线程的执行</strong>；</li>\n</ol>\n</blockquote>\n<h2 id=\"_6-4-join\"> 6.4 join</h2>\n<p>线程的合并的含义就是 <strong>将几个并行线程的线程合并为一个单线程执行</strong>，应用场景是 <strong>当一个线程必须等待另一个线程执行完毕才能执行时</strong>，Thread类提供了join方法来完成这个功能，<strong>注意，它不是静态方法</strong>。</p>\n<p><strong>join有3个重载的方法：</strong></p>\n<div><pre><code>void join()    \n    当前线程等该加入该线程后面，等待该线程终止。    \nvoid join(long millis)    \n    当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度   \nvoid join(long millis,int nanos)    \n    等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>例子代码，如下</strong>：</p>\n<div><pre><code><span>/**\n * 在主线程中调用thread.join(); 就是将主线程加入到thread子线程后面等待执行。不过有时间限制，为1毫秒。\n */</span>\n<span>public</span> <span>class</span> <span>Test1</span> <span>{</span>  \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>  \n        <span>MyThread</span> t<span>=</span><span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>  \n        t<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  \n        t<span>.</span><span>join</span><span>(</span><span>1</span><span>)</span><span>;</span><span>//将主线程加入到子线程后面，不过如果子线程在1毫秒时间内没执行完，则主线程便不再等待它执行完，进入就绪状态，等待cpu调度  </span>\n        <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span><span>30</span><span>;</span>i<span>++</span><span>)</span><span>{</span>  \n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"线程第\"</span> <span>+</span> i <span>+</span> <span>\"次执行！\"</span><span>)</span><span>;</span>  \n        <span>}</span>  \n    <span>}</span>  \n<span>}</span>  \n  \n<span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>  \n    <span>@Override</span>  \n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>  \n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>1000</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>  \n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>this</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"线程第\"</span> <span>+</span> i <span>+</span> <span>\"次执行！\"</span><span>)</span><span>;</span>  \n        <span>}</span>  \n    <span>}</span>  \n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><strong>在JDK中join方法的源码，如下：</strong></p>\n<div><pre><code><span>public</span> <span>final</span> <span>synchronized</span> <span>void</span> <span>join</span><span>(</span><span>long</span> millis<span>)</span>    <span>throws</span> <span>InterruptedException</span> <span>{</span>  \n    <span>long</span> base <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>  \n    <span>long</span> now <span>=</span> <span>0</span><span>;</span>  \n  \n    <span>if</span> <span>(</span>millis <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>  \n        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"timeout value is negative\"</span><span>)</span><span>;</span>  \n    <span>}</span>  \n          \n    <span>if</span> <span>(</span>millis <span>==</span> <span>0</span><span>)</span> <span>{</span>  \n        <span>while</span> <span>(</span><span>isAlive</span><span>(</span><span>)</span><span>)</span> <span>{</span>  \n           <span>wait</span><span>(</span><span>0</span><span>)</span><span>;</span>  \n        <span>}</span>  \n    <span>}</span> <span>else</span> <span>{</span>  \n        <span>while</span> <span>(</span><span>isAlive</span><span>(</span><span>)</span><span>)</span> <span>{</span>  \n            <span>long</span> delay <span>=</span> millis <span>-</span> now<span>;</span>  \n            <span>if</span> <span>(</span>delay <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>  \n                <span>break</span><span>;</span>  \n            <span>}</span>  \n            <span>wait</span><span>(</span>delay<span>)</span><span>;</span>  \n            now <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span> <span>-</span> base<span>;</span>  \n        <span>}</span>  \n    <span>}</span>  \n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><blockquote>\n<p><strong>join方法实现是通过调用wait方法实现</strong>。当main线程调用t.join时候，<strong>main线程会获得线程对象t的锁（wait 意味着拿到该对象的锁)，调用该对象的wait(等待时间)，直到该对象唤醒main线程</strong>，比如退出后。<strong>这就意味着main 线程调用t.join时，必须能够拿到线程t对象的锁</strong>。</p>\n</blockquote>\n<h2 id=\"_6-5-suspend-resume-已过时\"> 6.5 suspend &amp; resume (已过时)</h2>\n<p>suspend-<strong>线程进入阻塞状态，但不会释放锁</strong>。此方法已不推荐使用，<strong>因为同步时不会释放锁，会造成死锁的问题</strong>。</p>\n<p>resume-<strong>使线程重新进入可执行状态</strong>。</p>\n<p>为什么 Thread.suspend 和 Thread.resume 被废弃了？</p>\n<p>Thread.suspend 天生容易引起死锁。<strong>如果目标线程挂起时在保护系统关键资源的监视器上持有锁，那么其他线程在目标线程恢复之前都无法访问这个资源。如果要恢复目标线程的线程在调用 resume 之前试图锁定这个监视器，死锁就发生了</strong>。这种死锁一般自身表现为“冻结（ frozen ）”进程。</p>\n<p><strong>其他相关资料：</strong></p>\n<blockquote>\n<ol>\n<li>https://blog.csdn.net/dlite/article/details/4212915</li>\n</ol>\n</blockquote>\n<h2 id=\"_6-6-stop-已过时\"> 6.6 stop（已过时）</h2>\n<p><strong>不推荐使用，且以后可能去除，因为它不安全</strong>。为什么 Thread.stop 被废弃了？</p>\n<p>因为其天生是不安全的。<strong>停止一个线程会导致其解锁其上被锁定的所有监视器（监视器以在栈顶产生ThreadDeath异常的方式被解锁）</strong>。如果之前被这些监视器保护的任何对象处于不一致状态，其它线程看到的这些对象就会处于不一致状态。<strong>这种对象被称为受损的 （damaged）</strong>。当线程在受损的对象上进行操作时，会导致任意行为。这种行为可能微妙且难以检测，也可能会比较明显。</p>\n<p><strong>不像其他未受检的（unchecked）异常， ThreadDeath 悄无声息的杀死及其他线程</strong>。因此，用户得不到程序可能会崩溃的警告。崩溃会在真正破坏发生后的任意时刻显现，甚至在数小时或数天之后。</p>\n<p><strong>其他相关资料：</strong></p>\n<blockquote>\n<ol>\n<li>https://blog.csdn.net/dlite/article/details/4212915</li>\n</ol>\n</blockquote>\n<h2 id=\"_6-7-wait-notify-notifyall\"> 6.7 wait &amp; notify/notifyAll</h2>\n<p>wait &amp; notify/notifyAll这三个都是Object类的方法。使用 wait ，notify 和 notifyAll <strong>前提是先获得调用对象的锁</strong>。</p>\n<blockquote>\n<ol>\n<li>调用 wait 方法后，释放持有的对象锁，<strong>线程状态有 Running 变为 Waiting</strong>，并将当前线程放置到对象的 <strong>等待队列</strong>；</li>\n<li>调用notify 或者 notifyAll 方法后，<strong>等待线程依旧不会从 wait 返回，需要调用 noitfy 的线程释放锁之后，等待线程才有机会从 wait 返回</strong>；</li>\n<li>notify 方法：<strong>将等待队列的一个等待线程从等待队列种移到同步队列中</strong> ，而 notifyAll 方法：<strong>将等待队列种所有的线程全部移到同步队列，被移动的线程状态由 Waiting 变为 Blocked</strong>。</li>\n</ol>\n</blockquote>\n<p>前面一直提到两个概念，<strong>等待队列（等待池），同步队列（锁池）</strong>，这两者是不一样的。具体如下：</p>\n<blockquote>\n<p><strong>同步队列（锁池）</strong>：假设线程A已经拥有了某个对象（注意:不是类）的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，<strong>所以这些线程就进入了该对象的同步队列（锁池）中，这些线程状态为Blocked</strong>。</p>\n<p><strong>等待队列（等待池）</strong>：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁（因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁），同时 <strong>线程A就进入到了该对象的等待队列（等待池）中，此时线程A状态为Waiting</strong>。如果另外的一个线程调用了相同对象的notifyAll()方法，那么 <strong>处于该对象的等待池中的线程就会全部进入该对象的同步队列（锁池）中，准备争夺锁的拥有权</strong>。如果另外的一个线程调用了相同对象的notify()方法，那么 <strong>仅仅有一个处于该对象的等待池中的线程（随机）会进入该对象的同步队列（锁池）</strong>。</p>\n</blockquote>\n<p><strong>被notify或notifyAll唤起的线程是有规律的，具体如下：</strong></p>\n<blockquote>\n<ol>\n<li>如果是通过notify来唤起的线程，那 <strong>先进入wait的线程会先被唤起来</strong>；</li>\n<li>如果是通过nootifyAll唤起的线程，默认情况是 <strong>最后进入的会先被唤起来</strong>，即LIFO的策略；</li>\n</ol>\n</blockquote>\n<h2 id=\"_6-8-线程优先级\"> 6.8 线程优先级</h2>\n<p>每个线程执行时都有一个优先级的属性，<strong>优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会</strong>。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，<strong>优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行</strong>。</p>\n<blockquote>\n<p><strong>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级</strong>；</p>\n</blockquote>\n<p>Thread类提供了setPriority(int newPriority)和getPriority()方法来设置和返回一个指定线程的优先级，其中setPriority方法的参数是一个整数，范围是1~10之间，也可以使用Thread类提供的三个静态常量：</p>\n<div><pre><code>MAX_PRIORITY   =10\nMIN_PRIORITY   =1\nNORM_PRIORITY   =5\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>例子代码，如下</strong>：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test1</span> <span>{</span>  \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>  \n        <span>new</span> <span>MyThread</span><span>(</span><span>\"高级\"</span><span>,</span> <span>10</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  \n        <span>new</span> <span>MyThread</span><span>(</span><span>\"低级\"</span><span>,</span> <span>1</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  \n    <span>}</span>  \n<span>}</span>  \n  \n<span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>  \n    <span>public</span> <span>MyThread</span><span>(</span><span>String</span> name<span>,</span><span>int</span> pro<span>)</span> <span>{</span>  \n        <span>super</span><span>(</span>name<span>)</span><span>;</span><span>//设置线程的名称  </span>\n        <span>setPriority</span><span>(</span>pro<span>)</span><span>;</span><span>//设置线程的优先级  </span>\n    <span>}</span>  \n    <span>@Override</span>  \n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>  \n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>100</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>  \n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>this</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"线程第\"</span> <span>+</span> i <span>+</span> <span>\"次执行！\"</span><span>)</span><span>;</span>  \n        <span>}</span>  \n    <span>}</span>  \n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>从执行结果可以看到 ，<strong>一般情况下，高级线程更显执行完毕</strong>。</p>\n<p><strong>注意一点</strong>：</p>\n<blockquote>\n<p>虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。<strong>不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应</strong>。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，<strong>这样才能保证程序最好的可移植性</strong>。</p>\n</blockquote>\n<h2 id=\"_6-9-守护线程\"> 6.9 守护线程</h2>\n<p>守护线程与普通线程写法上基本没啥区别，<strong>调用线程对象的方法setDaemon(true)</strong>，则可以将其设置为守护线程。</p>\n<p>守护线程使用的情况较少，但并非无用，举例来说，<strong>JVM的垃圾回收、内存管理等线程都是守护线程</strong>。还有就是在做数据库应用时候，使用的数据库连接池，<strong>连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等</strong>。</p>\n<p><strong>setDaemon方法详细说明</strong>：</p>\n<blockquote>\n<p>public final void setDaemon(boolean on)：将该线程标记为守护线程或用户线程。<strong>当正在运行的线程都是守护线程时，Java 虚拟机退出</strong>。</p>\n<p><strong>该方法必须在启动线程前调用</strong>。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。</p>\n<p><strong>参数：</strong></p>\n<div><pre><code>on - 如果为 true，则将该线程标记为守护线程。\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>抛出：</strong></p>\n<div><pre><code> IllegalThreadStateException - 如果该线程处于活动状态。\n SecurityException - 如果当前线程无法修改该线程。\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div></blockquote>\n<div><pre><code><span>/** \n* Java线程：线程的调度-守护线程 \n*/</span>  \n<span>public</span> <span>class</span> <span>Test</span> <span>{</span>  \n        <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>  \n                <span>Thread</span> t1 <span>=</span> <span>new</span> <span>MyCommon</span><span>(</span><span>)</span><span>;</span>  \n                <span>Thread</span> t2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>MyDaemon</span><span>(</span><span>)</span><span>)</span><span>;</span>  \n                t2<span>.</span><span>setDaemon</span><span>(</span><span>true</span><span>)</span><span>;</span>        <span>//设置为守护线程  </span>\n  \n                t2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  \n                t1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  \n        <span>}</span>  \n<span>}</span>  \n  \n<span>class</span> <span>MyCommon</span> <span>extends</span> <span>Thread</span> <span>{</span>  \n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>  \n                <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>  \n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"线程1第\"</span> <span>+</span> i <span>+</span> <span>\"次执行！\"</span><span>)</span><span>;</span>  \n                        <span>try</span> <span>{</span>  \n                                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>7</span><span>)</span><span>;</span>  \n                        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>  \n                                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>  \n                        <span>}</span>  \n                <span>}</span>  \n        <span>}</span>  \n<span>}</span>  \n  \n<span>class</span> <span>MyDaemon</span> <span>implements</span> <span>Runnable</span> <span>{</span>  \n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>  \n                <span>for</span> <span>(</span><span>long</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>9999999L</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>  \n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"后台线程第\"</span> <span>+</span> i <span>+</span> <span>\"次执行！\"</span><span>)</span><span>;</span>  \n                        <span>try</span> <span>{</span>  \n                                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>7</span><span>)</span><span>;</span>  \n                        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>  \n                                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>  \n                        <span>}</span>  \n                <span>}</span>  \n        <span>}</span>  \n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p>执行结果：</p>\n<div><pre><code>后台线程第0次执行！  \n线程1第0次执行！  \n线程1第1次执行！  \n后台线程第1次执行！  \n后台线程第2次执行！  \n线程1第2次执行！  \n线程1第3次执行！  \n后台线程第3次执行！  \n线程1第4次执行！  \n后台线程第4次执行！  \n后台线程第5次执行！  \n后台线程第6次执行！  \n后台线程第7次执行！ \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>从上面的执行结果可以看出：<strong>前台线程是保证执行完毕的，后台线程还没有执行完毕就退出了</strong>。</p>\n<blockquote>\n<p>实际上：<strong>JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台线程时候一定要注意这个问题</strong>。</p>\n</blockquote>\n<h2 id=\"_6-10-如何结束一个线程\"> 6.10 如何结束一个线程</h2>\n<p><strong>Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit</strong> 这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法。</p>\n<blockquote>\n<ol>\n<li>正常执行完run方法，然后结束掉；</li>\n<li>控制循环条件和判断条件的标识符来结束掉线程；</li>\n</ol>\n</blockquote>\n<p><strong>比如run方法这样写</strong>：只要保证在一定的情况下，run方法能够执行完毕即可。而不是while(true)的无限循环。</p>\n<div><pre><code><span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>  \n    <span>int</span> i<span>=</span><span>0</span><span>;</span>  \n    <span>@Override</span>  \n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>  \n        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>  \n            <span>if</span><span>(</span>i<span>==</span><span>10</span><span>)</span>  \n                <span>break</span><span>;</span>  \n            i<span>++</span><span>;</span>  \n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>  \n              \n        <span>}</span>  \n    <span>}</span>  \n<span>}</span>  \n或者\n<span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>  \n    <span>int</span> i<span>=</span><span>0</span><span>;</span>  \n    <span>boolean</span> next<span>=</span><span>true</span><span>;</span>  \n    <span>@Override</span>  \n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>  \n        <span>while</span> <span>(</span>next<span>)</span> <span>{</span>  \n            <span>if</span><span>(</span>i<span>==</span><span>10</span><span>)</span>  \n                next<span>=</span><span>false</span><span>;</span>  \n            i<span>++</span><span>;</span>  \n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>  \n        <span>}</span>  \n    <span>}</span>  \n<span>}</span>  \n或者\n<span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>  \n    <span>int</span> i<span>=</span><span>0</span><span>;</span>  \n    <span>@Override</span>  \n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>  \n        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>  \n            <span>if</span><span>(</span>i<span>==</span><span>10</span><span>)</span>  \n                <span>return</span><span>;</span>  \n            i<span>++</span><span>;</span>  \n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>  \n        <span>}</span>  \n    <span>}</span>  \n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>诚然，使用上面方法的标识符来结束一个线程，是一个不错的方法，但其也有弊端，如果 <strong>该线程是处于sleep、wait、join的状态时候，while循环就不会执行</strong>，那么我们的标识符就无用武之地了，<strong>当然也不能再通过它来结束处于这3种状态的线程了</strong>。</p>\n<p><strong>所以，此时可以使用interrupt这个巧妙的方式结束掉这个线程</strong>。我们先来看看sleep、wait、join方法的声明：</p>\n<div><pre><code><span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span> \n<span>public</span> <span>static</span> <span>native</span> <span>void</span> <span>sleep</span><span>(</span><span>long</span> millis<span>)</span> <span>throws</span> <span>InterruptedException</span>\n<span>public</span> <span>final</span> <span>void</span> <span>join</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，这三者有一个共同点，都抛出了一个InterruptedException的异常。<strong>在什么时候会产生这样一个异常呢</strong>？</p>\n<blockquote>\n<p><strong>每个Thread都有一个中断状状态，默认为false</strong>。可以通过Thread对象的isInterrupted()方法来判断该线程的中断状态。可以通过Thread对象的interrupt()方法将中断状态设置为true。</p>\n<p>当一个线程处于sleep、wait、join这三种状态之一的时候，<strong>如果此时他的中断状态为true，那么它就会抛出一个InterruptedException的异常</strong>，并将中断状态重新设置为false。</p>\n</blockquote>\n<p>看下面的简单的例子：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test1</span> <span>{</span>  \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>  \n        <span>MyThread</span> thread<span>=</span><span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>  \n        thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  \n    <span>}</span>  \n<span>}</span>  \n  \n<span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>  \n    <span>int</span> i<span>=</span><span>1</span><span>;</span>  \n    <span>@Override</span>  \n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>  \n        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>  \n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>  \n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>this</span><span>.</span><span>isInterrupted</span><span>(</span><span>)</span><span>)</span><span>;</span>  \n            <span>try</span> <span>{</span>  \n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我马上去sleep了\"</span><span>)</span><span>;</span>  \n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>2000</span><span>)</span><span>;</span>  \n                <span>this</span><span>.</span><span>interrupt</span><span>(</span><span>)</span><span>;</span>  \n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>  \n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"异常捕获了\"</span><span>+</span><span>this</span><span>.</span><span>isInterrupted</span><span>(</span><span>)</span><span>)</span><span>;</span>  \n                <span>return</span><span>;</span>  \n            <span>}</span>  \n            i<span>++</span><span>;</span>  \n        <span>}</span>  \n    <span>}</span>  \n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>测试结果：</p>\n<div><pre><code>1  \nfalse  \n我马上去sleep了  \n2  \ntrue  \n我马上去sleep了  \n异常捕获了false \n复制代码\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>可以看到，首先执行第一次while循环，在第一次循环中，睡眠2秒，然后将中断状态设置为true。<strong>当进入到第二次循环的时候，中断状态就是第一次设置的true，当它再次进入sleep的时候，马上就抛出了InterruptedException异常，然后被我们捕获了</strong>。然后中断状态又被重新自动设置为false了（从最后一条输出可以看出来）。</p>\n<p>所以，我们可以使用interrupt方法结束一个线程。具体使用如下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test1</span> <span>{</span>  \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>  \n        <span>MyThread</span> thread<span>=</span><span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>  \n        thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  \n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>3000</span><span>)</span><span>;</span>  \n        thread<span>.</span><span>interrupt</span><span>(</span><span>)</span><span>;</span>  \n    <span>}</span>  \n<span>}</span>  \n  \n<span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>  \n    <span>int</span> i<span>=</span><span>0</span><span>;</span>  \n    <span>@Override</span>  \n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>  \n        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>  \n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>  \n            <span>try</span> <span>{</span>  \n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>  \n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>  \n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"中断异常被捕获了\"</span><span>)</span><span>;</span>  \n                <span>return</span><span>;</span>  \n            <span>}</span>  \n            i<span>++</span><span>;</span>  \n        <span>}</span>  \n    <span>}</span>  \n<span>}</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>多测试几次，会发现一般有两种执行结果：</p>\n<div><pre><code>0  \n1  \n2  \n中断异常被捕获了\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>或者</p>\n<div><pre><code>0  \n1  \n2  \n3  \n中断异常被捕获了 \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这两种结果恰恰说明了，<strong>只要一个线程的中断状态一旦为true，只要它进入sleep等状态，或者处于sleep状态，立马回抛出InterruptedException异常</strong>。</p>\n<blockquote>\n<p><strong>第一种情况</strong>，是当主线程从3秒睡眠状态醒来之后，调用了子线程的interrupt方法，此时子线程正处于sleep状态，立马抛出InterruptedException异常。</p>\n<p><strong>第二种情况</strong>，是当主线程从3秒睡眠状态醒来之后，调用了子线程的interrupt方法，此时子线程还没有处于sleep状态。然后再第3次while循环的时候，在此进入sleep状态，立马抛出InterruptedException异常。</p>\n</blockquote>\n",
      "image": "https://user-gold-cdn.xitu.io/2018/6/19/16417a1fd6b14a80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM内存区域讲解",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E8%A7%A3/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E8%A7%A3/",
      "content_html": "<h1 id=\"jvm内存区域讲解\"> JVM内存区域讲解</h1>\n<blockquote>\n<p>本文来源于 JavaGuide</p>\n<p>原文地址：<a href=\"https://github.com/Snailclimb/JavaGuide/blob/3965c02cc0f294b0bd3580df4868d5e396959e2e/Java%E7%9B%B8%E5%85%B3/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%8A%8AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E7%9A%84%E6%9C%80%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0.md\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Snailclimb/JavaGuide/blob/3965c02cc0f294b0bd3580df4868d5e396959e2e/Java%E7%9B%B8%E5%85%B3/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%8A%8AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E7%9A%84%E6%9C%80%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0.md</a></p>\n</blockquote>\n<h3 id=\"基本问题\"> 基本问题：</h3>\n<ul>\n<li><strong>介绍下 Java 内存区域（运行时数据区）</strong></li>\n<li><strong>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</strong></li>\n<li><strong>对象的访问定位的两种方式（句柄和直接指针两种方式）</strong></li>\n</ul>\n<h3 id=\"拓展问题\"> 拓展问题:</h3>\n<ul>\n<li><strong>String类和常量池</strong></li>\n<li><strong>8种基本类型的包装类和常量池</strong></li>\n</ul>\n<h2 id=\"_1-概述\"> 1 概述</h2>\n<p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像C/C++程序开发程序员这样为内一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>\n<h2 id=\"_2-运行时数据区域\"> 2 运行时数据区域</h2>\n<p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。 <img src=\"https://camo.githubusercontent.com/b997da2ae0e32fac704c8dc813973f3778316676/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564d2545382542462539302545382541312538432545362539372542362545362539352542302545362538442541452545352538432542412545352539462539462e706e67\" alt=\"img\" /></p>\n<p>这些组成部分一些是线程私有的，其他的则是线程共享的。</p>\n<p><strong>线程私有的：</strong></p>\n<ul>\n<li>程序计数器</li>\n<li>虚拟机栈</li>\n<li>本地方法栈</li>\n</ul>\n<p><strong>线程共享的：</strong></p>\n<ul>\n<li>堆</li>\n<li>方法区</li>\n<li>直接内存</li>\n</ul>\n<h3 id=\"_2-1-程序计数器\"> 2.1 程序计数器</h3>\n<p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</strong></p>\n<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>\n<p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p>\n<ol>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>\n<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>\n</ol>\n<p><strong>注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p>\n<h3 id=\"_2-2-java-虚拟机栈\"> 2.2 Java 虚拟机栈</h3>\n<p><strong>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。</strong></p>\n<p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>\n<p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>\n<p><strong>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</strong></p>\n<ul>\n<li><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li>\n<li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li>\n</ul>\n<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>\n<h3 id=\"_2-3-本地方法栈\"> 2.3 本地方法栈</h3>\n<p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>\n<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>\n<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p>\n<h3 id=\"_2-4-堆\"> 2.4 堆</h3>\n<p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>\n<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>\n<p><strong>在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。</strong></p>\n<p>推荐阅读：</p>\n<ul>\n<li>《Java8内存模型—永久代(PermGen)和元空间(Metaspace)》：http://www.cnblogs.com/paddix/p/5309550.html</li>\n</ul>\n<h3 id=\"_2-5-方法区\"> 2.5 方法区</h3>\n<p><strong>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</strong></p>\n<p>HotSpot 虚拟机中方法区也常被称为 <strong>“永久代”</strong>，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p>\n<p><strong>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</strong></p>\n<h3 id=\"_2-6-运行时常量池\"> 2.6 运行时常量池</h3>\n<p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p>\n<p>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p>\n<p><strong>JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p>\n<p>推荐阅读：</p>\n<ul>\n<li>《Java 中几种常量池的区分》： https://blog.csdn.net/qq_26222859/article/details/73135660</li>\n</ul>\n<h3 id=\"_2-7-直接内存\"> 2.7 直接内存</h3>\n<p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。</p>\n<p>JDK1.4中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>\n<p>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>\n<h3 id=\"_2-8-表格总结\"> 2.8 表格总结</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">区域名称</th>\n<th>作用</th>\n<th>线程共享性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">堆</td>\n<td>存放<strong>对象</strong>和<strong>数组</strong>的实例</td>\n<td><strong>共享</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">方法区</td>\n<td>存放<strong>虚拟机加载的类信息</strong>，<strong>常量</strong>，<strong>静态变量</strong>，<strong>即时编译器编译后的代码</strong>等数据。<br><strong>运行时常量池</strong>属于方法区，Class文件中有<strong>类的版本</strong>、<strong>字段</strong>、<strong>方法</strong>、<strong>接口的描述信息</strong>、<strong>常量池</strong>。</td>\n<td><strong>共享</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">程序计数器</td>\n<td>字节码解释器工作时通过改变计数器的值来选取下一条执行指令，如分支、循环、异常处理、线程恢复等。</td>\n<td>私有</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">虚拟机桟</td>\n<td>指的是方法的内存模型，方法创建时会在桟中创建桟帧，用于存储<strong>局部变量表</strong>，<strong>操作数桟</strong>，<strong>动态链接</strong>，<strong>方法出口信息</strong>等。</td>\n<td>私有</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">本地方法桟</td>\n<td>作用与虚拟机桟类似，但本地方法桟让虚拟机使用Native方法服务</td>\n<td>私有</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">直接内存</td>\n<td>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。避免了在 Java 堆和 Native 堆之间来回复制数据。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_3-hotspot-虚拟机对象探秘\"> 3 HotSpot 虚拟机对象探秘</h2>\n<p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>\n<h3 id=\"_3-1-对象的创建\"> 3.1 对象的创建</h3>\n<p>下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。</p>\n<p><strong>①类加载检查：</strong> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>\n<p><strong>②分配内存：</strong> 在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>\n<p><strong>内存分配的两种方式：（补充内容，需要掌握）</strong></p>\n<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是&quot;标记-清除&quot;，还是&quot;标记-整理&quot;（也称作&quot;标记-压缩&quot;），值得注意的是，复制算法内存也是规整的</p>\n<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>\n<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>\n<ul>\n<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>\n<li><strong>TLAB：</strong> 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配</li>\n</ul>\n<p><strong>③初始化零值：</strong> 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>\n<p><strong>④设置对象头：</strong> 初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>\n<p><strong>⑤执行 init 方法：</strong> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>\n<h3 id=\"_3-2-对象的内存布局\"> 3.2 对象的内存布局</h3>\n<p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为3块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>\n<p><strong>Hotspot虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的自身运行时数据</strong>（哈希码、GC分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>\n<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>\n<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>\n<h3 id=\"_3-3-对象的访问定位\"> 3.3 对象的访问定位</h3>\n<p>建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p>\n<ol>\n<li><strong>句柄：</strong> 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li>\n<li><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</li>\n</ol>\n<p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p>\n<h2 id=\"四-重点补充内容\"> 四 重点补充内容</h2>\n<h3 id=\"string-类和常量池\"> String 类和常量池</h3>\n<p><strong>1 String 对象的两种创建方式：</strong></p>\n<div><pre><code>     <span>String</span> str1 <span>=</span> <span>\"abcd\"</span><span>;</span>\n     <span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"abcd\"</span><span>)</span><span>;</span>\n     <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1<span>==</span>str2<span>)</span><span>;</span><span>//false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。\n记住：只要使用new方法，便需要创建新的对象。</p>\n<p><strong>2 String 类型的常量池比较特殊。它的主要使用方法有两种：</strong></p>\n<ul>\n<li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li>\n<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</li>\n</ul>\n<div><pre><code>\t      <span>String</span> s1 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"计算机\"</span><span>)</span><span>;</span>\n\t      <span>String</span> s2 <span>=</span> s1<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>\n\t      <span>String</span> s3 <span>=</span> <span>\"计算机\"</span><span>;</span>\n\t      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s2<span>)</span><span>;</span><span>//计算机</span>\n\t      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1 <span>==</span> s2<span>)</span><span>;</span><span>//false，因为一个是堆内存中的String对象一个是常量池中的String对象，</span>\n\t      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s3 <span>==</span> s2<span>)</span><span>;</span><span>//true，因为两个都是常量池中的String对象</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3 String 字符串拼接</strong></p>\n<div><pre><code>\t\t  <span>String</span> str1 <span>=</span> <span>\"str\"</span><span>;</span>\n\t\t  <span>String</span> str2 <span>=</span> <span>\"ing\"</span><span>;</span>\n\t\t  \n\t\t  <span>String</span> str3 <span>=</span> <span>\"str\"</span> <span>+</span> <span>\"ing\"</span><span>;</span><span>//常量池中的对象</span>\n\t\t  <span>String</span> str4 <span>=</span> str1 <span>+</span> str2<span>;</span> <span>//在堆上创建的新的对象\t  </span>\n\t\t  <span>String</span> str5 <span>=</span> <span>\"string\"</span><span>;</span><span>//常量池中的对象</span>\n\t\t  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str3 <span>==</span> str4<span>)</span><span>;</span><span>//false</span>\n\t\t  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str3 <span>==</span> str5<span>)</span><span>;</span><span>//true</span>\n\t\t  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str4 <span>==</span> str5<span>)</span><span>;</span><span>//false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。</p>\n<h3 id=\"string-s1-new-string-abc-这句话创建了几个对象\"> String s1 = new String(&quot;abc&quot;);这句话创建了几个对象？</h3>\n<p><strong>创建了两个对象。</strong></p>\n<p><strong>验证：</strong></p>\n<div><pre><code>\t\t<span>String</span> s1 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"abc\"</span><span>)</span><span>;</span><span>// 堆内存的地址值</span>\n\t\t<span>String</span> s2 <span>=</span> <span>\"abc\"</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1 <span>==</span> s2<span>)</span><span>;</span><span>// 输出false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>.</span><span>equals</span><span>(</span>s2<span>)</span><span>)</span><span>;</span><span>// 输出true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>结果：</strong></p>\n<div><pre><code><span>false</span>\n<span>true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><strong>解释：</strong></p>\n<p>先有字符串&quot;abc&quot;放入常量池，然后 new 了一份字符串&quot;abc&quot;放入Java堆(字符串常量&quot;abc&quot;在编译期就已经确定放入常量池，而 Java 堆上的&quot;abc&quot;是在运行期初始化阶段才确定)，然后 Java 栈的 str1 指向Java堆上的&quot;abc&quot;。</p>\n<h3 id=\"_8种基本类型的包装类和常量池\"> 8种基本类型的包装类和常量池</h3>\n<ul>\n<li><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。</strong></li>\n<li><strong>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。</strong></li>\n</ul>\n<div><pre><code>\t\t<span>Integer</span> i1 <span>=</span> <span>33</span><span>;</span>\n\t\t<span>Integer</span> i2 <span>=</span> <span>33</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1 <span>==</span> i2<span>)</span><span>;</span><span>// 输出true</span>\n\t\t<span>Integer</span> i11 <span>=</span> <span>333</span><span>;</span>\n\t\t<span>Integer</span> i22 <span>=</span> <span>333</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i11 <span>==</span> i22<span>)</span><span>;</span><span>// 输出false</span>\n\t\t<span>Double</span> i3 <span>=</span> <span>1.2</span><span>;</span>\n\t\t<span>Double</span> i4 <span>=</span> <span>1.2</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i3 <span>==</span> i4<span>)</span><span>;</span><span>// 输出false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>Integer 缓存源代码：</strong></p>\n<div><pre><code><span>/**\n*此方法将始终缓存-128到127（包括端点）范围内的值，并可以缓存此范围之外的其他值。\n*/</span>\n    <span>public</span> <span>static</span> <span>Integer</span> <span>valueOf</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>i <span>>=</span> <span>IntegerCache</span><span>.</span>low <span>&amp;&amp;</span> i <span>&lt;=</span> <span>IntegerCache</span><span>.</span>high<span>)</span>\n            <span>return</span> <span>IntegerCache</span><span>.</span>cache<span>[</span>i <span>+</span> <span>(</span><span>-</span><span>IntegerCache</span><span>.</span>low<span>)</span><span>]</span><span>;</span>\n        <span>return</span> <span>new</span> <span>Integer</span><span>(</span>i<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>应用场景：</strong></p>\n<ol>\n<li>Integer i1=40；Java 在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</li>\n<li>Integer i1 = new Integer(40);这种情况下会创建新的对象。</li>\n</ol>\n<div><pre><code>  <span>Integer</span> i1 <span>=</span> <span>40</span><span>;</span>\n  <span>Integer</span> i2 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>40</span><span>)</span><span>;</span>\n  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1<span>==</span>i2<span>)</span><span>;</span><span>//输出false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>Integer比较更丰富的一个例子:</strong></p>\n<div><pre><code>  <span>Integer</span> i1 <span>=</span> <span>40</span><span>;</span>\n  <span>Integer</span> i2 <span>=</span> <span>40</span><span>;</span>\n  <span>Integer</span> i3 <span>=</span> <span>0</span><span>;</span>\n  <span>Integer</span> i4 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>40</span><span>)</span><span>;</span>\n  <span>Integer</span> i5 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>40</span><span>)</span><span>;</span>\n  <span>Integer</span> i6 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>0</span><span>)</span><span>;</span>\n  \n  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"i1=i2   \"</span> <span>+</span> <span>(</span>i1 <span>==</span> i2<span>)</span><span>)</span><span>;</span>\n  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"i1=i2+i3   \"</span> <span>+</span> <span>(</span>i1 <span>==</span> i2 <span>+</span> i3<span>)</span><span>)</span><span>;</span>\n  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"i1=i4   \"</span> <span>+</span> <span>(</span>i1 <span>==</span> i4<span>)</span><span>)</span><span>;</span>\n  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"i4=i5   \"</span> <span>+</span> <span>(</span>i4 <span>==</span> i5<span>)</span><span>)</span><span>;</span>\n  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"i4=i5+i6   \"</span> <span>+</span> <span>(</span>i4 <span>==</span> i5 <span>+</span> i6<span>)</span><span>)</span><span>;</span>   \n  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"40=i5+i6   \"</span> <span>+</span> <span>(</span><span>40</span> <span>==</span> i5 <span>+</span> i6<span>)</span><span>)</span><span>;</span>     \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>结果：</p>\n<div><pre><code>i1<span>=</span>i2   <span>true</span>\ni1<span>=</span>i2<span>+</span>i3   <span>true</span>\ni1<span>=</span>i4   <span>false</span>\ni4<span>=</span>i5   <span>false</span>\ni4<span>=</span>i5<span>+</span>i6   <span>true</span>\n<span>40</span><span>=</span>i5<span>+</span>i6   <span>true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>解释：</p>\n<p>语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。</p>\n",
      "image": "https://camo.githubusercontent.com/b997da2ae0e32fac704c8dc813973f3778316676/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564d2545382542462539302545382541312538432545362539372542362545362539352542302545362538442541452545352538432542412545352539462539462e706e67",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "ThreadLocal终极篇",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/TheadLocal/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/TheadLocal/",
      "content_html": "<h1 id=\"threadlocal终极篇\"> ThreadLocal终极篇</h1>\n<h3 id=\"前言\"> 前言</h3>\n<p>在面试环节中，考察&quot;ThreadLocal&quot;也是面试官的家常便饭，所以对它理解透彻，是非常有必要的.</p>\n<p>有些面试官会开门见山的提问：</p>\n<ul>\n<li>“知道ThreadLocal吗？”</li>\n<li>“讲讲你对ThreadLocal的理解”</li>\n</ul>\n<p>当然了，也有面试官会慢慢引导到这个话题上，比如提问“在多线程环境下，如何防止自己的变量被其它线程篡改”，将主动权交给你自己，剩下的靠自己发挥。</p>\n<p>那么ThreadLocal可以做什么，在了解它的应用场景之前，我们先看看它的实现原理，只有知道了实现原理，才好判断它是否符合自己的业务场景。</p>\n<h3 id=\"threadlocal是什么\"> ThreadLocal是什么</h3>\n<p>首先，它是一个数据结构，有点像HashMap，可以保存&quot;key : value&quot;键值对，但是一个ThreadLocal只能保存一个，并且各个线程的数据互不干扰。</p>\n<div><pre><code><span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> localName <span>=</span> <span>new</span> <span>ThreadLocal</span><span>(</span><span>)</span><span>;</span>\nlocalName<span>.</span><span>set</span><span>(</span><span>\"占小狼\"</span><span>)</span><span>;</span>\n<span>String</span> name <span>=</span> localName<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在线程1中初始化了一个ThreadLocal对象localName，并通过set方法，保存了一个值<code>占小狼</code>，同时在线程1中通过<code>localName.get()</code>可以拿到之前设置的值，但是如果在线程2中，拿到的将是一个null。</p>\n<p>这是为什么，如何实现？不过之前也说了，ThreadLocal保证了各个线程的数据互不干扰。</p>\n<p>看看<code>set(T value)</code>和<code>get()</code>方法的源码</p>\n<div><pre><code> <span>public</span> <span>void</span> <span>set</span><span>(</span><span>T</span> value<span>)</span> <span>{</span>\n    <span>Thread</span> t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>\n    <span>ThreadLocalMap</span> map <span>=</span> <span>getMap</span><span>(</span>t<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>map <span>!=</span> <span>null</span><span>)</span>\n        map<span>.</span><span>set</span><span>(</span><span>this</span><span>,</span> value<span>)</span><span>;</span>\n    <span>else</span>\n        <span>createMap</span><span>(</span>t<span>,</span> value<span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>T</span> <span>get</span><span>(</span><span>)</span> <span>{</span>\n    <span>Thread</span> t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>\n    <span>ThreadLocalMap</span> map <span>=</span> <span>getMap</span><span>(</span>t<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>map <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>ThreadLocalMap<span>.</span>Entry</span> e <span>=</span> map<span>.</span><span>getEntry</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n            <span>T</span> result <span>=</span> <span>(</span><span>T</span><span>)</span>e<span>.</span>value<span>;</span>\n            <span>return</span> result<span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> <span>setInitialValue</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>ThreadLocalMap</span> <span>getMap</span><span>(</span><span>Thread</span> t<span>)</span> <span>{</span>\n    <span>return</span> t<span>.</span>threadLocals<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>可以发现，每个线程中都有一个<code>ThreadLocalMap</code>数据结构，当执行set方法时，其值是保存在当前线程的<code>threadLocals</code>变量中，当执行set方法中，是从当前线程的<code>threadLocals</code>变量获取。</p>\n<p>所以在线程1中set的值，对线程2来说是摸不到的，而且在线程2中重新set的话，也不会影响到线程1中的值，保证了线程之间不会相互干扰。</p>\n<p>那每个线程中的<code>ThreadLoalMap</code>究竟是什么？</p>\n<h3 id=\"threadloalmap\"> ThreadLoalMap</h3>\n<p>本文分析的是1.7的源码。</p>\n<p>从名字上看，可以猜到它也是一个类似HashMap的数据结构，但是在ThreadLocal中，并没实现Map接口。</p>\n<p>在ThreadLoalMap中，也是初始化一个大小16的Entry数组，Entry对象用来保存每一个key-value键值对，只不过这里的key永远都是ThreadLocal对象，是不是很神奇，通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLoalMap中。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/1/21/16119267b89518d3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<p>这里需要注意的是，ThreadLoalMap的Entry是继承WeakReference，和HashMap很大的区别是，Entry中没有next字段，所以就不存在链表的情况了。</p>\n<h3 id=\"hash冲突\"> hash冲突</h3>\n<p>没有链表结构，那发生hash冲突了怎么办？</p>\n<p>先看看ThreadLoalMap中插入一个key-value的实现</p>\n<div><pre><code><span>private</span> <span>void</span> <span>set</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> key<span>,</span> <span>Object</span> value<span>)</span> <span>{</span>\n    <span>Entry</span><span>[</span><span>]</span> tab <span>=</span> table<span>;</span>\n    <span>int</span> len <span>=</span> tab<span>.</span>length<span>;</span>\n    <span>int</span> i <span>=</span> key<span>.</span>threadLocalHashCode <span>&amp;</span> <span>(</span>len<span>-</span><span>1</span><span>)</span><span>;</span>\n\n    <span>for</span> <span>(</span><span>Entry</span> e <span>=</span> tab<span>[</span>i<span>]</span><span>;</span>\n         e <span>!=</span> <span>null</span><span>;</span>\n         e <span>=</span> tab<span>[</span>i <span>=</span> <span>nextIndex</span><span>(</span>i<span>,</span> len<span>)</span><span>]</span><span>)</span> <span>{</span>\n        <span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> k <span>=</span> e<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n\n        <span>if</span> <span>(</span>k <span>==</span> key<span>)</span> <span>{</span>\n            e<span>.</span>value <span>=</span> value<span>;</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n\n        <span>if</span> <span>(</span>k <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>replaceStaleEntry</span><span>(</span>key<span>,</span> value<span>,</span> i<span>)</span><span>;</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    tab<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Entry</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n    <span>int</span> sz <span>=</span> <span>++</span>size<span>;</span>\n    <span>if</span> <span>(</span><span>!</span><span>cleanSomeSlots</span><span>(</span>i<span>,</span> sz<span>)</span> <span>&amp;&amp;</span> sz <span>>=</span> threshold<span>)</span>\n        <span>rehash</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>每个ThreadLocal对象都有一个hash值<code>threadLocalHashCode</code>，每初始化一个ThreadLocal对象，hash值就增加一个固定的大小<code>0x61c88647</code>。</p>\n<p>在插入过程中，根据ThreadLocal对象的hash值，定位到table中的位置i，过程如下： 1、如果当前位置是空的，那么正好，就初始化一个Entry对象放在位置i上； 2、不巧，位置i已经有Entry对象了，如果这个Entry对象的key正好是即将设置的key，那么重新设置Entry中的value； 3、很不巧，位置i的Entry对象，和即将设置的key没关系，那么只能找下一个空位置；</p>\n<p>这样的话，在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该位置Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置</p>\n<p>可以发现，set和get如果冲突严重的话，效率很低，因为ThreadLoalMap是Thread的一个属性，所以即使在自己的代码中控制了设置的元素个数，但还是不能控制其它代码的行为。</p>\n<h3 id=\"内存泄露\"> 内存泄露</h3>\n<p>ThreadLocal可能导致内存泄漏，为什么？ 先看看Entry的实现：</p>\n<div><pre><code><span>static</span> <span>class</span> <span>Entry</span> <span>extends</span> <span>WeakReference</span><span><span>&lt;</span><span>ThreadLocal</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> <span>{</span>\n    <span>/** The value associated with this ThreadLocal. */</span>\n    <span>Object</span> value<span>;</span>\n\n    <span>Entry</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> k<span>,</span> <span>Object</span> v<span>)</span> <span>{</span>\n        <span>super</span><span>(</span>k<span>)</span><span>;</span>\n        value <span>=</span> v<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>通过之前的分析已经知道，当使用ThreadLocal保存一个value时，会在ThreadLocalMap中的数组插入一个Entry对象，按理说key-value都应该以强引用保存在Entry对象中，但在ThreadLocalMap的实现中，key被保存到了WeakReference对象中。</p>\n<p>这就导致了一个问题，ThreadLocal在没有外部强引用时，发生GC时会被回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p>\n<h4 id=\"如何避免内存泄露\"> 如何避免内存泄露</h4>\n<p>既然已经发现有内存泄露的隐患，自然有应对的策略，在调用ThreadLocal的get()、set()可能会清除ThreadLocalMap中key为null的Entry对象，这样对应的value就没有GC Roots可达了，下次GC的时候就可以被回收，当然如果调用remove方法，肯定会删除对应的Entry对象。</p>\n<p>如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。</p>\n<div><pre><code><span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> localName <span>=</span> <span>new</span> <span>ThreadLocal</span><span>(</span><span>)</span><span>;</span>\n<span>try</span> <span>{</span>\n    localName<span>.</span><span>set</span><span>(</span><span>\"占小狼\"</span><span>)</span><span>;</span>\n    <span>// 其它业务逻辑</span>\n<span>}</span> <span>finally</span> <span>{</span>\n    localName<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>作者：占小狼\n链接：https://juejin.im/post/5a64a581f265da3e3b7aa02d\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n",
      "image": "https://user-gold-cdn.xitu.io/2018/1/21/16119267b89518d3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "SpringBoot自动配置原理",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/Spring%20Boot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/Spring%20Boot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/",
      "content_html": "<h1 id=\"springboot自动配置原理\"> SpringBoot自动配置原理</h1>\n<blockquote>\n<p>备注：该SpringBoot自动配置原理不适合java刚入门学者以及不熟悉Spring4+Springmvc+maven的同学</p>\n</blockquote>\n<p><strong>1、当SpringBoot应用启动的时候，就从主方法里面进行启动的。</strong></p>\n<div><pre><code><span>@SpringBootApplication</span>\n<span>public</span> <span>class</span> <span>SpringBoot02ConfigAutoconfigApplication</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>SpringBoot02ConfigAutoconfigApplication</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。</p>\n<p><strong>2、@EnableAutoConfiguration作用：</strong></p>\n<p>它主要利用了一个</p>\n<p>EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。</p>\n<div><pre><code><span>@Import</span><span>(</span><span>EnableAutoConfigurationImportSelector</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>@interface</span> <span>EnableAutoConfiguration</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><strong>3、那么导入了哪些组件呢？</strong></p>\n<p>我们来看</p>\n<p>EnableAutoConfigurationImportSelector这个类的父类selectImports</p>\n<div><pre><code><span>@Override</span>\n    <span>public</span> <span>String</span><span>[</span><span>]</span> <span>selectImports</span><span>(</span><span>AnnotationMetadata</span> annotationMetadata<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>!</span><span>isEnabled</span><span>(</span>annotationMetadata<span>)</span><span>)</span> <span>{</span>\n            <span>return</span> NO_IMPORTS<span>;</span>\n        <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>父类里面规定了一个方法叫selectImports这个方法，查看了selectImports这个方法里面的代码内容就能知道导入了哪些组件了。</p>\n<p>在selectImports这个方法里面主要有个configurations，并且这个configurations最终会被返回。</p>\n<div><pre><code><span>@Override</span>\n    <span>public</span> <span>String</span><span>[</span><span>]</span> <span>selectImports</span><span>(</span><span>AnnotationMetadata</span> annotationMetadata<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>!</span><span>isEnabled</span><span>(</span>annotationMetadata<span>)</span><span>)</span> <span>{</span>\n            <span>return</span> NO_IMPORTS<span>;</span>\n        <span>}</span>\n        <span>try</span> <span>{</span>\n            <span>AutoConfigurationMetadata</span> autoConfigurationMetadata <span>=</span> <span>AutoConfigurationMetadataLoader</span>\n                    <span>.</span><span>loadMetadata</span><span>(</span><span>this</span><span>.</span>beanClassLoader<span>)</span><span>;</span>\n            <span>AnnotationAttributes</span> attributes <span>=</span> <span>getAttributes</span><span>(</span>annotationMetadata<span>)</span><span>;</span>\n            <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> configurations <span>=</span> <span>getCandidateConfigurations</span><span>(</span>annotationMetadata<span>,</span>\n                    attributes<span>)</span><span>;</span>\n            configurations <span>=</span> <span>removeDuplicates</span><span>(</span>configurations<span>)</span><span>;</span>\n            configurations <span>=</span> <span>sort</span><span>(</span>configurations<span>,</span> autoConfigurationMetadata<span>)</span><span>;</span>\n            <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> exclusions <span>=</span> <span>getExclusions</span><span>(</span>annotationMetadata<span>,</span> attributes<span>)</span><span>;</span>\n            <span>checkExcludedClasses</span><span>(</span>configurations<span>,</span> exclusions<span>)</span><span>;</span>\n            configurations<span>.</span><span>removeAll</span><span>(</span>exclusions<span>)</span><span>;</span>\n            configurations <span>=</span> <span>filter</span><span>(</span>configurations<span>,</span> autoConfigurationMetadata<span>)</span><span>;</span>\n            <span>fireAutoConfigurationImportEvents</span><span>(</span>configurations<span>,</span> exclusions<span>)</span><span>;</span>\n            <span>return</span> configurations<span>.</span><span>toArray</span><span>(</span><span>new</span> <span>String</span><span>[</span>configurations<span>.</span><span>size</span><span>(</span><span>)</span><span>]</span><span>)</span><span>;</span>\n        <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>这个configurations它是获取候选的配置。</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> configurations <span>=</span> \n       <span>getCandidateConfigurations</span><span>(</span>annotationMetadata<span>,</span>attributes<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>这个configurations方法的作用就是利用SpringFactoriesLoader.loadFactoryNames从类路径下得到一个资源</p>\n<div><pre><code><span>public</span> <span>static</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>loadFactoryNames</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> factoryClass<span>,</span> <span>ClassLoader</span> classLoader<span>)</span> <span>{</span>\n        <span>String</span> factoryClassName <span>=</span> factoryClass<span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>Enumeration</span><span><span>&lt;</span>URL<span>></span></span> urls <span>=</span> <span>(</span>classLoader <span>!=</span> <span>null</span> <span>?</span> classLoader<span>.</span><span>getResources</span><span>(</span>FACTORIES_RESOURCE_LOCATION<span>)</span> <span>:</span>\n                    <span>ClassLoader</span><span>.</span><span>getSystemResources</span><span>(</span>FACTORIES_RESOURCE_LOCATION<span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>4、那么得到哪些资源呢？</strong></p>\n<p>它是扫描javajar包类路径下的“META-INF/spring.factories”这个文件</p>\n<div><pre><code><span>/**\n * The location to look for factories.\n * &lt;p>Can be present in multiple JAR files.\n */</span>\n<span>public</span> <span>static</span> <span>final</span> <span>String</span> FACTORIES_RESOURCE_LOCATION <span>=</span> <span>\"META-INF/spring.factories\"</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>**那么扫描到的这些文件作用：**是把这个文件的urls拿到之后并把这些urls每一个遍历，最终把这些文件整成一个properties对象</p>\n<div><pre><code><span>public</span> <span>static</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>loadFactoryNames</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> factoryClass<span>,</span> <span>ClassLoader</span> classLoader<span>)</span> <span>{</span>\n        <span>String</span> factoryClassName <span>=</span> factoryClass<span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>Enumeration</span><span><span>&lt;</span>URL<span>></span></span> urls <span>=</span> <span>(</span>classLoader <span>!=</span> <span>null</span> <span>?</span> classLoader<span>.</span><span>getResources</span><span>(</span>FACTORIES_RESOURCE_LOCATION<span>)</span> <span>:</span>\n                    <span>ClassLoader</span><span>.</span><span>getSystemResources</span><span>(</span>FACTORIES_RESOURCE_LOCATION<span>)</span><span>)</span><span>;</span>\n            <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> result <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n            <span>while</span> <span>(</span>urls<span>.</span><span>hasMoreElements</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>URL</span> url <span>=</span> urls<span>.</span><span>nextElement</span><span>(</span><span>)</span><span>;</span>\n                <span>Properties</span> properties <span>=</span> <span>PropertiesLoaderUtils</span><span>.</span><span>loadProperties</span><span>(</span><span>new</span> <span>UrlResource</span><span>(</span>url<span>)</span><span>)</span><span>;</span>\n                <span>String</span> factoryClassNames <span>=</span> properties<span>.</span><span>getProperty</span><span>(</span>factoryClassName<span>)</span><span>;</span>\n                result<span>.</span><span>addAll</span><span>(</span><span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>StringUtils</span><span>.</span><span>commaDelimitedListToStringArray</span><span>(</span>factoryClassNames<span>)</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> result<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>然后它从properties对象里边获取一些值，把这些获取到的值来加载我们最终要返回的这个结果，这个结果就是我们要交给Spring容器中的所有组件，这相当于这factoryClassName就是我们传过来的Class的这个类名。</p>\n<p>而传过来的Class是调用这个</p>\n<p>getSpringFactoriesLoaderFactoryClass()这个方法得到从properties中获取到EnableAutoConfiguration.class类名对应的值</p>\n<div><pre><code><span>protected</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getSpringFactoriesLoaderFactoryClass</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>EnableAutoConfiguration</span><span>.</span><span>class</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后把它们添加在容器中</p>\n<p><strong>5、按照它的这个意思，来到第二个Springjar包的META-INF下的spring.factories这个文件找到配置所有EnableAutoConfiguration的值加入到Spring容器中</strong></p>\n<p>所以说我们容器中最终会添加很多的类</p>\n<p>比如：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueZOvCI11A1NrtE7PmyyToTe5dpt1QfLAqiciaib6k1x9AqMhhIu89O2S06WaD3mZaemHUdDc5bzjrgA/640?wx_fmt=png\" alt=\"img\" /></p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueZOvCI11A1NrtE7PmyyToT25FEuzoFAfepsE9eIEmDPyHvictrXMkApjFWgqdYb3XXYoDSCYNYn3A/640?wx_fmt=png\" alt=\"img\" /></p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueZOvCI11A1NrtE7PmyyToT67LrQhxCLbw3G5RBAnljrOwk4vlZvxsdCkANfZzrnI5My6oeRc9N3g/640?wx_fmt=png\" alt=\"img\" /></p>\n<p>每一个xxxAutoConfiguration类都是容器中的一个组件，并都加入到容器中。</p>\n<p>加入到容器中之后的作用就是用它们来做自动配置，这就是Springboot自动配置之源，也就是自动配置的开始，只有这些自动配置类进入到容器中以后，接下来这个自动配置类才开始进行启动</p>\n<p><strong>6、每一个自动配置类进行自动配置功能</strong></p>\n<p>以一个自动配置类</p>\n<p>HttpEncodingAutoConfiguration（HTTP的编码自动配置）为例子来解释SpringBoot的自动配置之原理：</p>\n<p>1). 这个HttpEncodingAutoConfiguration类上面标注了一大堆的注解：</p>\n<div><pre><code><span>@Configuration</span>    \n<span>//表示这是一个配置类，类似于以前编写的配置文件一样，也可以给容器中添加组件</span>\n<span>@EnableConfigurationProperties</span><span>(</span><span>HttpEncodingProperties</span><span>.</span><span>class</span><span>)</span> \n<span>//启用ConfigurationProperties功能：</span>\n<span>//这个ConfigurationProperties里面引入了一个类，这个类就是启用指定类的ConfigurationProperties功能</span>\n<span>//有了这个@EnableConfigurationPropertie注解以后相当于把配置文件中对应值就和这个HttpEncodingProperties.class类绑定起来了。</span>\n\n<span>@ConditionalOnWebApplication</span> \n<span>//这个注解的意思就是判断当前是不是web应用，@Conditional是spring底层，意思就是根据不同的条件，来进行自己不同的条件判断，如果满足指定的条件，那么整个配置类里边的配置才会生效。</span>\n\n<span>@ConditionalOnClass</span><span>(</span><span>CharacterEncodingFilter</span><span>.</span><span>class</span><span>)</span>\n<span>//看这个类里边有没有这个过滤器，就是判断当前项目里边有没有CharacterEncodingFilter这个类，这个CharacterEncodingFilter类是Springmvc中乱码解决的过滤器。</span>\n\n<span>@ConditionalOnProperty</span><span>(</span>prefix <span>=</span> <span>\"spring.http.encoding\"</span><span>,</span> value <span>=</span> <span>\"enabled\"</span><span>,</span> matchIfMissing <span>=</span> <span>true</span><span>)</span><span>//@ConditionalOnProperty注解是来判断配置文件中是否存在某个配置，就是是否存在spring.http.encoding.enabled这个配置，matchIfMissing的意思就是如果不存在也认为这个判断是正确的</span>\n<span>//即使配置文件中不配置spring.http.encoding.enabled=true这个属性，也是默认生效的</span>\n<span>public</span> <span>class</span> <span>HttpEncodingAutoConfiguration</span> <span>{</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>点进去HttpEncodingProperties这个类，发现这个HttpEncodingProperties类上面标注了@ConfigurationProperties注解</p>\n<div><pre><code><span>@ConfigurationProperties</span><span>(</span>prefix <span>=</span> <span>\"spring.http.encoding\"</span><span>)</span> \n<span>//从配置文件中获取指定的值和bean的属性进行绑定</span>\n<span>public</span> <span>class</span> <span>HttpEncodingProperties</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>Charset</span> DEFAULT_CHARSET <span>=</span> <span>Charset</span><span>.</span><span>forName</span><span>(</span><span>\"UTF-8\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>所以说配置文件中该配置什么，我们就按照它的这个旨意，它要配spring.http.encoding这个属性，这个属性里边能配置什么值，就对应HttpEncodingProperties这个类来配置，所有的配置文件中能配置的属性都是在xxx.Properties类中封装着</p>\n<div><pre><code><span>@ConfigurationProperties</span><span>(</span>prefix <span>=</span> <span>\"spring.http.encoding\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>HttpEncodingProperties</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>final</span> <span>Charset</span> DEFAULT_CHARSET <span>=</span> <span>Charset</span><span>.</span><span>forName</span><span>(</span><span>\"UTF-8\"</span><span>)</span><span>;</span>\n\n    <span>/**\n     * Charset of HTTP requests and responses. Added to the \"Content-Type\" header if not\n     * set explicitly.\n     */</span>\n    <span>private</span> <span>Charset</span> charset <span>=</span> DEFAULT_CHARSET<span>;</span>\n\n    <span>/**\n     * Force the encoding to the configured charset on HTTP requests and responses.\n     */</span>\n    <span>private</span> <span>Boolean</span> force<span>;</span>\n\n    <span>/**\n     * Force the encoding to the configured charset on HTTP requests. Defaults to true\n     * when \"force\" has not been specified.\n     */</span>\n    <span>private</span> <span>Boolean</span> forceRequest<span>;</span>\n\n    <span>/**\n     * Force the encoding to the configured charset on HTTP responses.\n     */</span>\n    <span>private</span> <span>Boolean</span> forceResponse<span>;</span>\n\n    <span>/**\n     * Locale to Encoding mapping.\n     */</span>\n    <span>private</span> <span>Map</span><span><span>&lt;</span><span>Locale</span><span>,</span> <span>Charset</span><span>></span></span> mapping<span>;</span>\n\n    <span>public</span> <span>Charset</span> <span>getCharset</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span>charset<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setCharset</span><span>(</span><span>Charset</span> charset<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>charset <span>=</span> charset<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>boolean</span> <span>isForce</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>Boolean</span><span>.</span>TRUE<span>.</span><span>equals</span><span>(</span><span>this</span><span>.</span>force<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setForce</span><span>(</span><span>boolean</span> force<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>force <span>=</span> force<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>boolean</span> <span>isForceRequest</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>Boolean</span><span>.</span>TRUE<span>.</span><span>equals</span><span>(</span><span>this</span><span>.</span>forceRequest<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setForceRequest</span><span>(</span><span>boolean</span> forceRequest<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>forceRequest <span>=</span> forceRequest<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>boolean</span> <span>isForceResponse</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>Boolean</span><span>.</span>TRUE<span>.</span><span>equals</span><span>(</span><span>this</span><span>.</span>forceResponse<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setForceResponse</span><span>(</span><span>boolean</span> forceResponse<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>forceResponse <span>=</span> forceResponse<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>Map</span><span><span>&lt;</span><span>Locale</span><span>,</span> <span>Charset</span><span>></span></span> <span>getMapping</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span>mapping<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setMapping</span><span>(</span><span>Map</span><span><span>&lt;</span><span>Locale</span><span>,</span> <span>Charset</span><span>></span></span> mapping<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>mapping <span>=</span> mapping<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div><p><strong>所以说配置文件能配置什么就可以参照某一个功能对应的这个属性类</strong></p>\n<p><strong>7、这个HttpEncodingProperties类就是根据当前不同的条件判断，决定这个配置类是否生效。</strong></p>\n<p>如果一旦生效了，所有的配置类都成功了，就给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，而这properties类里边的每一个属性又是和配置文件绑定的</p>\n<div><pre><code>    <span>@Bean</span>  \n    <span>//给容器中添加一个组件。</span>\n    <span>@ConditionalOnMissingBean</span><span>(</span><span>CharacterEncodingFilter</span><span>.</span><span>class</span><span>)</span> \n    <span>//添加一个我们自己来new这个CharacterEncodingFilter，把这个filter添加过去，但是注意这个filter里边要获取字符集的名字（filter.setEncoding(this.properties.getCharset().name());)，你是UTF8编码还是什么编码，它要从properties中进行获取，意思就是这个组件的某些值需要从properties中获取</span>\n    <span>public</span> <span>CharacterEncodingFilter</span> <span>characterEncodingFilter</span><span>(</span><span>)</span> <span>{</span>\n        <span>CharacterEncodingFilter</span> filter <span>=</span> <span>new</span> <span>OrderedCharacterEncodingFilter</span><span>(</span><span>)</span><span>;</span>\n        filter<span>.</span><span>setEncoding</span><span>(</span><span>this</span><span>.</span>properties<span>.</span><span>getCharset</span><span>(</span><span>)</span><span>.</span><span>name</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        filter<span>.</span><span>setForceRequestEncoding</span><span>(</span><span>this</span><span>.</span>properties<span>.</span><span>shouldForce</span><span>(</span><span>Type</span><span>.</span>REQUEST<span>)</span><span>)</span><span>;</span>\n        filter<span>.</span><span>setForceResponseEncoding</span><span>(</span><span>this</span><span>.</span>properties<span>.</span><span>shouldForce</span><span>(</span><span>Type</span><span>.</span>RESPONSE<span>)</span><span>)</span><span>;</span>\n        <span>return</span> filter<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>我们可以再深入的看一下properties</p>\n<div><pre><code><span>private</span> <span>final</span> <span>HttpEncodingProperties</span> properties<span>;</span> \n<span>//它已经和SpringBoot配置文件进行映射了。</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>我们看到properties是</p>\n<p>HttpEncodingProperties，也就是说HttpEncodingProperties这个对象的值它是获取配置文件的值的，所以我们在配置这个filter到底要用什么编码的时候是从properties获取的。</p>\n<p>而且值得注意的是：</p>\n<div><pre><code><span>@Configuration</span>\n<span>@EnableConfigurationProperties</span><span>(</span><span>HttpEncodingProperties</span><span>.</span><span>class</span><span>)</span>\n<span>@ConditionalOnWebApplication</span>\n<span>@ConditionalOnClass</span><span>(</span><span>CharacterEncodingFilter</span><span>.</span><span>class</span><span>)</span>\n<span>@ConditionalOnProperty</span><span>(</span>prefix <span>=</span> <span>\"spring.http.encoding\"</span><span>,</span> \n          value <span>=</span> <span>\"enabled\"</span><span>,</span> matchIfMissing <span>=</span> <span>true</span><span>)</span>\n<span>public</span> <span>class</span> <span>HttpEncodingAutoConfiguration</span> <span>{</span>\n\n    <span>private</span> <span>final</span> <span>HttpEncodingProperties</span> properties<span>;</span>\n    <span>//只有一个有参构造器</span>\n    <span>public</span> <span>HttpEncodingAutoConfiguration</span><span>(</span><span>HttpEncodingProperties</span> properties<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>properties <span>=</span> properties<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>这个HttpEncodingAutoConfiguration只有一个有参构造器，在只有一个有参构造器的情况下，参数的值就会从容器中拿</p>\n<p><strong>8、而容器中它怎么去拿到呢？</strong></p>\n<p>相当于是前面的这个</p>\n<p>@EnableConfigurationProperties(HttpEncodingProperties.class) 注解，这个@EnableConfigurationProperties注解的作用就是把HttpEncodingProperties.class和配置文件进行绑定起来并把HttpEncodingProperties加入到容器中。</p>\n<p>接下来这个自动配置类，通过一个有参构造器把这个属性拿到，而这个属性已经和SpringBoot映射了，接下来要用什么编码，就是拿到HttpEncodingProperties这个类里边的属性。</p>\n<p>所以SpringBoot能配置什么，它要设置编码，它是获取properties里边getCharset里边的name值。</p>\n<div><pre><code>filter<span>.</span><span>setEncoding</span><span>(</span><span>this</span><span>.</span>properties<span>.</span><span>getCharset</span><span>(</span><span>)</span><span>.</span><span>name</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>所以就以此类推，配置一个Spring配置，就可以照着HttpEncodingProperties这里边的来配置。</p>\n<p>比如在application.properties配置文件下配置一个http.encoding.enabled属性：</p>\n<div><pre><code><span>spring.http.encoding.enabled</span><span>=</span><span>true   //能配置这个就相当于是我们之前的判断属性</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>还能配置其他的一些属性。</p>\n<p>比如：</p>\n<div><pre><code><span>spring.http.encoding.charset</span><span>=</span><span>UTF-8</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>所以我们能够配置哪些属性，都是来源于这个功能的properties类</strong></p>\n<p>有了这个自动配置类，自动配置类就给容器中添加这个filter，然后这个filter就会起作用了。</p>\n<p><strong>用好SpringBoot只要把握这几点：</strong></p>\n<ol>\n<li>SpringBoot启动会加载大量的自动配置类</li>\n<li>所要做的就是我们需要的功能SpringBoot有没有帮我们写好的自动配置类：</li>\n<li>如果有就再来看这个自动配置类中到底配置了哪些组件，Springboot自动配置类里边只要我们要用的组件有，我们就不需要再来配置了，但是如果说没有我们所需要的组件，那么我们就需要自己来写一个配置类来把我们相应的组件配置起来。</li>\n<li>给容器中自动配置类添加组件的时候，会从properties类中获取某些属性，而这些属性我们就可以在配置文件指定这些属性的值</li>\n</ol>\n",
      "image": "https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueZOvCI11A1NrtE7PmyyToTe5dpt1QfLAqiciaib6k1x9AqMhhIu89O2S06WaD3mZaemHUdDc5bzjrgA/640?wx_fmt=png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "1.Object类",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/1.Object%E7%B1%BB/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/1.Object%E7%B1%BB/",
      "content_html": "<h1 id=\"_1-object类\"> 1.Object类</h1>\n<p>我们都知道:在Java中，所有的类都继承了Object这个基类，并且大家都知道，Object有几个比较通用的方法，如equals(),clone(),toString(),我们需要在使用它们的时候进行覆写，今天，我们就具体的探究下这几个方法。</p>\n<h3 id=\"void-registernatives\"> void registerNatives()</h3>\n<p>这是个Native方法，在静态块中调用，其目的是将hashCode,wait,notify,notifyAll和clone方法注册到本地。</p>\n<h3 id=\"class-getclass\"> Class&lt;?&gt; getClass()</h3>\n<p>同样是个Native方法,获取对象的Class。</p>\n<h3 id=\"int-hashcode\"> int hashCode()</h3>\n<p>Native方法，生成哈希码，其中注意三点</p>\n<ul>\n<li>\n<p>一个对象在同一个进程被多次调用，但是它的哈希码仍然应该是相同的。但是，当同一个对象在不同进程中执行，则哈希码有可能不同。JavaDoc原文如下</p>\n<p>Whenever it is invoked on the same object more than once during an execution of a Java application, the {@code hashCode} method must consistently return the same integer, provided no information used in {@code equals} comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</p>\n</li>\n<li>\n<p>如果两个对象通过equals()比较返回true，那么它们的哈希码应该相同。</p>\n</li>\n<li>\n<p>如果两个对象通过equals()比较返回false，那么它们的哈希码应该不同。</p>\n</li>\n</ul>\n<h3 id=\"boolean-equals-object-obj\"> boolean equals(Object obj)</h3>\n<p>这恐怕使我们最常用的方法之一了，我们在实际应用中，也经常遇到什么时候用equals()，什么时候用==的问题。一般来说，基本数据类型用==，因为这样可以直接比较它们的值，但是复合数据类型如果我们用==的话，那么实际上我们比较的就是它们的引用了，除非它们指向的是同一个对象，否则它们不可能相等，因此我们比较符合数据类型一般用equals()，并且我们应该覆写equals(),这是因为Object的equals()方法默认的也是用==进行判定:</p>\n<div><pre><code>public boolean equals(Object obj) {\n        return (this == obj);\n    }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我们再来看看我们经常用的String是如何覆写equals()方法的:</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> anObject<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>this</span> <span>==</span> anObject<span>)</span> <span>{</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span>anObject <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>\n        <span>String</span> anotherString <span>=</span> <span>(</span><span>String</span><span>)</span>anObject<span>;</span>\n        <span>int</span> n <span>=</span> value<span>.</span>length<span>;</span>\n        <span>if</span> <span>(</span>n <span>==</span> anotherString<span>.</span>value<span>.</span>length<span>)</span> <span>{</span>\n            <span>char</span> v1<span>[</span><span>]</span> <span>=</span> value<span>;</span>\n            <span>char</span> v2<span>[</span><span>]</span> <span>=</span> anotherString<span>.</span>value<span>;</span>\n            <span>int</span> i <span>=</span> <span>0</span><span>;</span>\n            <span>while</span> <span>(</span>n<span>--</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>v1<span>[</span>i<span>]</span> <span>!=</span> v2<span>[</span>i<span>]</span><span>)</span>\n                    <span>return</span> <span>false</span><span>;</span>\n                i<span>++</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>在这里还有一个很有趣的问题，请看下面的例子</p>\n<div><pre><code><span>String</span> s1 <span>=</span> <span>\"String\"</span><span>;</span>\n<span>String</span> s2 <span>=</span> <span>\"String\"</span><span>;</span>\n\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"The result is \"</span> <span>+</span> s1<span>.</span><span>equals</span><span>(</span>s2<span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>你会发现返回值为True，这个就和我们上面讲的不一样了，按照我们上面的讲解，这时候应该返回false才对。其实是这样的，因为JVM中会维护一个字符串池，如果池中已经有包含此对象的字符串的时候，那么它就会返回池中的字符串(当然如果你new一个新的String对象的话就另当别论。)所以这个时候返回的是true。</p>\n<h3 id=\"object-clone\"> Object clone()</h3>\n<p>Native方法，我们一般用它来复制一个对象，并且用clone()可以实现深复制(将所有需要复制的对象都复制了一遍，而不单单是用引用指向原来的对象。)示例如下:</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Animal</span> <span>implements</span> <span>Cloneable</span> <span>{</span>\n    <span>private</span> <span>int</span> height<span>;</span>\n    <span>private</span> <span>int</span> age<span>;</span>\n\n    <span>public</span> <span>Animal</span><span>(</span><span>int</span> height<span>,</span> <span>int</span> age<span>)</span><span>{</span>\n        <span>this</span><span>.</span>height <span>=</span> height<span>;</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span> <span>{</span>\n        <span>return</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"Animal{\"</span> <span>+</span>\n                <span>\"height=\"</span> <span>+</span> height <span>+</span>\n                <span>\", age=\"</span> <span>+</span> age <span>+</span>\n                <span>'}'</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getHeight</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> height<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setHeight</span><span>(</span><span>int</span> height<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>height <span>=</span> height<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> age<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n\n<span>public</span> <span>class</span> <span>People</span> <span>implements</span> <span>Cloneable</span> <span>{</span>\n\n    <span>private</span> <span>int</span> height<span>;</span>\n    <span>private</span> <span>int</span> age<span>;</span>\n    <span>private</span> <span>Animal</span> a<span>;</span>\n\n\n    <span>public</span> <span>People</span><span>(</span><span>int</span> height<span>,</span> <span>int</span> age<span>,</span><span>Animal</span> a<span>)</span><span>{</span>\n        <span>this</span><span>.</span>height <span>=</span> height<span>;</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n        <span>this</span><span>.</span>a <span>=</span> a<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span> <span>{</span>\n        <span>People</span> p <span>=</span> <span>(</span><span>People</span><span>)</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>\n        p<span>.</span>a <span>=</span> <span>(</span><span>Animal</span><span>)</span> a<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> p<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"People{\"</span> <span>+</span>\n                <span>\"height=\"</span> <span>+</span> height <span>+</span>\n                <span>\", age=\"</span> <span>+</span> age <span>+</span>\n                <span>\", a=\"</span> <span>+</span> a <span>+</span>\n                <span>'}'</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getHeight</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> height<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setHeight</span><span>(</span><span>int</span> height<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>height <span>=</span> height<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> age<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>void</span> <span>setAnimalAge</span><span>(</span><span>int</span> a<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>a<span>.</span><span>setAge</span><span>(</span><span>5</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br></div></div><p>接下来我们这样调用:</p>\n<div><pre><code><span>Animal</span> a1 <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>100</span><span>,</span><span>3</span><span>)</span><span>;</span>\n<span>People</span> p1 <span>=</span> <span>new</span> <span>People</span><span>(</span><span>173</span><span>,</span><span>24</span><span>,</span>a1<span>)</span><span>;</span>\n\n<span>People</span> p2 <span>=</span> <span>(</span><span>People</span><span>)</span> p1<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>\np2<span>.</span><span>setAge</span><span>(</span><span>26</span><span>)</span><span>;</span>\np2<span>.</span><span>setHeight</span><span>(</span><span>181</span><span>)</span><span>;</span>\np2<span>.</span><span>setAnimalAge</span><span>(</span><span>6</span><span>)</span><span>;</span>\n\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p1<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p2<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这样我们就完成深复制了。</p>\n<h3 id=\"string-tostring\"> String toString()</h3>\n<p>最常用的方法，我们一般用它获取对象成员变量的值。Object的默认实现:</p>\n<div><pre><code><span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>getClass</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"@\"</span> <span>+</span> <span>Integer</span><span>.</span><span>toHexString</span><span>(</span><span>hashCode</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"void-notify-void-notifyall\"> void notify(),void notifyAll()</h3>\n<p>Native方法，多线程时应用，通知其他线程等待结束。</p>\n<h3 id=\"void-wait-long-void-wait-long-int-void-wait\"> void wait(long),void wait(long,int),void wait()</h3>\n<p>Native方法，通知线程等待。</p>\n<h3 id=\"void-finalize\"> void finalize()</h3>\n<p>垃圾回收。当JVM判断一个对象可以被垃圾回收时，那么JVM会调用finalize()方法，但是记住，它只能调用一次(所以如果你想这个对象不被垃圾清除的话，你就要在这里面做点事情了)，但是一般你不能依赖在这里做垃圾回收的工作，在《Java编程思想》中说明了有关finalize()的一个用法，那就是通过finalize()来进行对象终结对象的判断。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "CAS、乐观锁、悲观锁",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/CAS%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/CAS%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81/",
      "content_html": "<h1 id=\"cas、乐观锁、悲观锁\"> CAS、乐观锁、悲观锁</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "图解Java线程安全",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/%E5%9B%BE%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/%E5%9B%BE%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/",
      "content_html": "<h1 id=\"图解java线程安全\"> 图解Java线程安全</h1>\n<h1 id=\"什么是线程\"> 什么是线程</h1>\n<p>按操作系统中的描述，线程是 CPU 调度的最小单元，直观来说线程就是代码按顺序执行下来，执行完毕就结束的一条线。</p>\n<p>举个 🌰，富土康的一个组装车间相当于 CPU ，而线程就是当前车间里的一条条作业流水线。为了提高产能和效率，车间里一般都会有多条流水线同时作业。同样在我们 Android 开发中多线程可以说是随处可见了，如执行耗时操作，网络请求、文件读写、数据库读写等等都会开单独的子线程来执行。</p>\n<p>那么你的线程是安全的吗？线程安全的原理又是什么呢？（本文内容是个人学习总结浅见，如有错误的地方，望大佬们轻拍指正）</p>\n<h1 id=\"线程安全\"> 线程安全</h1>\n<p>了解线程安全的之前先来了解一下 Java 的内存模型，先搞清楚线程是怎么工作的。</p>\n<h2 id=\"java-内存模型-jmm\"> Java 内存模型 - JMM</h2>\n<h3 id=\"什么是-jmm\"> 什么是 JMM</h3>\n<p>JMM(Java Memory Model),是一种基于<code>计算机内存模型（定义了共享内存系统中多线程程序读写操作行为的规范）</code>，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。保证共享内存的<strong>原子性</strong>、<strong>可见性</strong>、<strong>有序性</strong>。</p>\n<p>能用图的地方尽量不废话，先来看一张图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/7/15/16bf62d8c174d776?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\" /></p>\n<p>上图描述了一个多线程执行场景。 线程 A 和线程 B 分别对主内存的<code>变量</code>进行读写操作。其中<strong>主内存</strong>中的<code>变量</code>为<code>共享变量</code>,也就是说此变量只此一份，多个线程间共享。但是线程不能直接读写主内存的<code>共享变量</code>，每个线程都有自己的<strong>工作内存</strong>，线程需要读写主内存的<code>共享变量</code>时需要先将该变量拷贝一份副本到自己的工作内存，然后在自己的工作内存中对该变量进行所有操作，线程工作内存对变量副本完成操作之后需要将结果同步至主内存。</p>\n<blockquote>\n<p>线程的工作内存是线程私有内存，线程间无法互相访问对方的工作内存。</p>\n</blockquote>\n<p>为了便于理解，用图来描述一下线程对变量赋值的流程。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/7/15/16bf62d905a78509?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\" /></p>\n<p>那么问题来了，线程工作内存怎么知道什么时候又是怎样将数据同步到主内存呢？ 这里就轮到 <strong>JMM</strong> 出场了。 <strong>JMM</strong> 规定了何时以及如何做线程工作内存与主内存之间的数据同步。</p>\n<p>对 JMM 有了初步的了解，简单总结一下<strong>原子性</strong>、<strong>可见性</strong>、<strong>有序性</strong></p>\n<p><strong>原子性</strong>：</p>\n<blockquote>\n<p>对共享内存的操作必须是要么全部执行直到执行结束，且中间过程不能被任何外部因素打断，要么就不执行。</p>\n</blockquote>\n<p><strong>可见性</strong>：</p>\n<blockquote>\n<p>多线程操作共享内存时，执行结果能够及时的同步到共享内存，确保其他线程对此结果及时可见。</p>\n</blockquote>\n<p><strong>有序性</strong>：</p>\n<blockquote>\n<p>程序的执行顺序按照代码顺序执行，在单线程环境下，程序的执行都是有序的，但是在多线程环境下，JMM 为了性能优化，编译器和处理器会对指令进行重排，程序的执行会变成无序。</p>\n</blockquote>\n<p>到这里，我们可以引出本文的主题了 --<strong>【线程安全】</strong>。</p>\n<h2 id=\"线程安全的本质\"> 线程安全的本质</h2>\n<p>其实第一张图的例子是有问题的，主内存中的变量是共享的，所有线程都可以访问读写，而线程工作内存又是线程私有的，线程间不可互相访问。那在多线程场景下，图上的线程 A 和线程 B 同时来操做共享内存里的同一个变量，那么主内存内的此变量数据就会被破坏。也就是说主内存内的此变量不是线程安全的。 我们来看个代码小例子帮助理解。</p>\n<div><pre><code>public class ThreadDemo {\n    private int x = 0;\n\n    private void count() {\n        x++;\n    }\n\n    public void runTest() {\n        new Thread() {\n            @Override\n            public void run() {\n                for (int i = 0; i &lt; 1_000_000; i++) {\n                    count();\n                }\n                System.out.println(&quot;final x from 1: &quot; + x);\n            }\n        }.start();\n        new Thread() {\n            @Override\n            public void run() {\n                for (int i = 0; i &lt; 1_000_000; i++) {\n                    count();\n                }\n                System.out.println(&quot;final x from 2: &quot; + x);\n            }\n        }.start();\n    }\n\n    public static void main(String[] args) {\n        new ThreadDemo().runTest();\n    }\n}\n复制代码\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>示例代码中 <code>runTest</code> 方法2个线程分别执行 <code>1_000_000</code> 次 <code>count()</code> 方法, <code>count()</code> 方法中只执行简单的 <code>x++</code> 操作,理论上每次执行 <code>runTest</code> 方法应该有一个线程输出的 <code>x</code> 结果应该是<code>2_000_000</code>。但实际的运行结果并非我们所想：</p>\n<div><pre><code>final x from 1: 989840\nfinal x from 2: 1872479\n复制代码\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我运行了10次，其中一个线程输出 <code>x</code> 的值为 <code>2_000_000</code> 只出现了2次。</p>\n<div><pre><code>final x from 1: 1000000\nfinal x from 2: 2000000\n复制代码\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>出现这样的结果的原因也就是我们上面所说的，在多线程环境下，我们主内存的 <code>x</code> 变量的数据被破坏了。 我们都知道完成一次 <code>i++</code> 相当于执行了：</p>\n<div><pre><code>int tmp = x + 1;\nx = tmp;\n复制代码\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在多线程环境下就会出现在执行完 <code>int tmp = x + 1;</code> 这行代码时就发生了<code>线程切换</code>，当线程再次切回来的时候，<code>x</code> 就会被重复赋值，导致出现上面的运行结果，2个线程都无法输出 <code>2_000_000</code>。</p>\n<p>下图描述了示例代码的执行时序：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/7/15/16bf62d8ff93ec61?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\" /></p>\n<p>那么 Java 是如何来解决上述问题来保证线程安全，保证共享内存的<strong>原子性</strong>、<strong>可见性</strong>、<strong>有序性</strong>的呢？</p>\n<h1 id=\"线程同步\"> 线程同步</h1>\n<p>Java 提供了一系列的关键字和类来保证线程安全</p>\n<h2 id=\"synchronized-关键字\"> Synchronized 关键字</h2>\n<h3 id=\"synchronized-作用\"> Synchronized 作用</h3>\n<h4 id=\"_1-保证方法或代码块操作的原子性\"> 1. 保证方法或代码块操作的原子性</h4>\n<p>Synchronized 保证⽅法内部或代码块内部资源（数据）的互斥访问。即同⼀时间、由同⼀个 <a href=\"https://www.hollischuang.com/archives/2030\" target=\"_blank\" rel=\"noopener noreferrer\">Monitor（监视锁）</a> 监视的代码，最多只能有⼀个线程在访问。</p>\n<blockquote>\n<p>关于 Monitor 和 Synchronized 实现原理了解可以看下这2篇文章：<a href=\"http://www.hollischuang.com/archives/1883\" target=\"_blank\" rel=\"noopener noreferrer\">Synchronized 的实现原理</a>、 <a href=\"https://www.hollischuang.com/archives/2030\" target=\"_blank\" rel=\"noopener noreferrer\">Moniter 的实现原理</a></p>\n</blockquote>\n<p>话不多说来张动图描述一下 Monitor 工作机制：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/7/15/16bf62d8f00da505?imageslim\" alt=\"image\" /></p>\n<p>被 Synchronized 关键字描述的方法或代码块在多线程环境下同一时间只能由一个线程进行访问，在持有当前 Monitor 的线程执行完成之前，其他线程想要调用相关方法就必须进行排队，知道持有持有当前 Monitor 的线程执行结束，释放 Monitor ，下一个线程才可获取 Monitor 执行。</p>\n<p>如果存在多个 Monitor 的情况时，多个 Monitor 之间是不互斥的。</p>\n<blockquote>\n<p>多个 Monitor 的情况出现在自定义多个锁分别来描述不同的方法或代码块，Synchronized 在描述代码块时可以指定自定义 Monitor ，默认为 <code>this</code> 即当前类。</p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/7/15/16bf62d8e8f32fab?imageslim\" alt=\"image\" /></p>\n<h4 id=\"_2-保证监视资源的可见性\"> 2.保证监视资源的可见性</h4>\n<p>保证多线程环境下对监视资源的数据同步。即任何线程在获取到 Monitor 后的第⼀时 间，会先将共享内存中的数据复制到⾃⼰的缓存中；任何线程在释放 Monitor 的第⼀ 时间，会先将缓存中的数据复制到共享内存中。</p>\n<h4 id=\"_3-保证线程间操作的有序性\"> 3.保证线程间操作的有序性</h4>\n<p>Synchronized 的原子性保证了由其描述的方法或代码操作具有有序性，同一时间只能由最多只能有一个线程访问，不会触发 JMM 指令重排机制。</p>\n<h2 id=\"volatile-关键字\"> Volatile 关键字</h2>\n<h3 id=\"volatile-作用\"> Volatile 作用</h3>\n<p>保证被 Volatile 关键字描述变量的操作具有<strong>可见性</strong>和<strong>有序性</strong>（禁止指令重排）</p>\n<blockquote>\n<p>注意：\n1.Volatile 只对基本类型 (byte、char、short、int、long、float、double、boolean) 的赋值 操作和对象的引⽤赋值操作有效。\n2 对于 <code>i++</code> 此类复合操作， Volatile 无法保证其有序性和原子性。\n3.相对 Synchronized 来说 Volatile 更加轻量一些。</p>\n</blockquote>\n<h2 id=\"_3-java-util-concurrent-atomic\"> 3. java.util.concurrent.atomic</h2>\n<p><code>java.util.concurrent.atomic</code> 包提供了一系列的 <code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code> 等类。使用这些类来声明变量可以保证对其操作具有<strong>原子性</strong>来保证线程安全。</p>\n<p>实现原理上与 Synchronized 使用 Monitor（监视锁）保证资源在多线程环境下阻塞互斥访问不同，<code>java.util.concurrent.atomic</code> 包下的各原子类基于 <code>CAS(CompareAndSwap)</code> 操作原理实现。</p>\n<blockquote>\n<p><a href=\"https://www.jianshu.com/p/ae25eb3cfb5d\" target=\"_blank\" rel=\"noopener noreferrer\">CAS</a> 又称无锁操作，一种乐观锁策略，原理就是多线程环境下各线程访问共享变量不会加锁阻塞排队，线程不会被挂起。通俗来讲就是一直循环对比，如果有访问冲突则重试，直到没有冲突为止。</p>\n</blockquote>\n<h2 id=\"_4-lock\"> 4. Lock</h2>\n<p>Lock 也是 <code>java.util.concurrent</code> 包下的一个接口，定义了一系列的锁操作方法。Lock 接口主要有 ReentrantLock，ReentrantReadWriteLock.ReadLock，ReentrantReadWriteLock.WriteLock 实现类。与 Synchronized 不同是 Lock 提供了获取锁和释放锁等相关接口，使得使用上更加灵活，同时也可以做更加复杂的操作，如：</p>\n<div><pre><code>ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\nLock readLock = lock.readLock();\nLock writeLock = lock.writeLock();\nprivate int x = 0;\nprivate void count() {\n    writeLock.lock();\n    try {\n        x++;\n    } finally {\n        writeLock.unlock();\n    }\n}\nprivate void print(int time) {\n    readLock.lock();\n    try {\n        for (int i = 0; i &lt; time; i++) {\n            System.out.print(x + &quot; &quot;);\n        }\n        System.out.println();\n    } finally {\n        readLock.unlock();\n    }\n}\n复制代码\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>关于 Lock 实现原理和更详细的使用推荐以下2篇文章：\n<a href=\"https://juejin.im/post/5ab9a5b46fb9a028ce7b9b7e#heading-2\" target=\"_blank\" rel=\"noopener noreferrer\">Lock锁的使用</a>\n<a href=\"https://juejin.im/entry/5b4ddf6d6fb9a04f97650336\" target=\"_blank\" rel=\"noopener noreferrer\">Lock锁源码分析</a></p>\n<h3 id=\"总结\"> 总结</h3>\n<ol>\n<li>出现线程安全问题的原因：\n在多个线程并发环境下，多个线程共同访问同一共享内存资源时，其中一个线程对资源进行写操作的中途(写⼊入已经开始，但还没 结束)，其他线程对这个写了一半的资源进⾏了读操作，或者对这个写了一半的资源进⾏了写操作，导致此资源出现数据错误。</li>\n<li>如何避免线程安全问题？</li>\n</ol>\n<ul>\n<li>保证共享资源在同一时间只能由一个线程进行操作(原子性，有序性)。</li>\n<li>将线程操作的结果及时刷新，保证其他线程可以立即获取到修改后的最新数据（可见性）。</li>\n</ul>\n",
      "image": "https://user-gold-cdn.xitu.io/2019/7/15/16bf62d8c174d776?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "10.Float类",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/10.Float%E7%B1%BB/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/10.Float%E7%B1%BB/",
      "content_html": "<h1 id=\"_10-float类\"> 10.Float类</h1>\n<p>前面几篇文章我们看了JAVA基本数据类型整型的包装类，接下来我们看下浮点型float的包装类Float类。</p>\n<h4 id=\"基础知识\"> 基础知识：</h4>\n<p>1.IEEE 754：\nIEEE 754是一个标准，该标准定义了浮点数的格式还有一些特殊值，它规定了计算机中二进制与十进制浮点数转换的格式及方法。规定了四种表示浮点数值的方法，单精确度（32位）、双精确度（64位）、延伸单精确度（43位以上）与延伸双精确度（79位以上）。JAVA语言支持这里的单精确度float，与双精确度double。\n2.无穷大：\nJAVA中用Infinity表示正无穷大，任何有限正数除以0为正无穷大，正无穷的值为0x7f800000。用-Infinity表示负无穷大，任何有限负数除以0为负无穷的，负无穷的值为0xff800000。\n3.NAN：\n不是一个数(not a number ),NaN 用来表示处理计算中出现的错误情况，比如0除以0或负数平方根。</p>\n<h4 id=\"主要属性\"> 主要属性:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>float</span> POSITIVE_INFINITY <span>=</span> <span>1.0f</span> <span>/</span> <span>0.0f</span><span>;</span>\n\n<span>public</span> <span>static</span> <span>final</span> <span>float</span> NEGATIVE_INFINITY <span>=</span> <span>-</span><span>1.0f</span> <span>/</span> <span>0.0f</span><span>;</span>\n\n<span>public</span> <span>static</span> <span>final</span> <span>float</span> <span>NaN</span> <span>=</span> <span>0.0f</span> <span>/</span> <span>0.0f</span><span>;</span>\n\n<span>public</span> <span>static</span> <span>final</span> <span>float</span> MAX_VALUE <span>=</span> <span>0x1.fffffeP+127f</span><span>;</span>\n\n<span>public</span> <span>static</span> <span>final</span> <span>float</span> MIN_NORMAL <span>=</span> <span>0x1.0p-126f</span><span>;</span>\n\n<span>public</span> <span>static</span> <span>final</span> <span>float</span> MIN_VALUE <span>=</span> <span>0x0.000002P-126f</span><span>;</span>\n\n<span>public</span> <span>static</span> <span>final</span> <span>int</span> MAX_EXPONENT <span>=</span> <span>127</span><span>;</span>\n\n<span>public</span> <span>static</span> <span>final</span> <span>int</span> MIN_EXPONENT <span>=</span> <span>-</span><span>126</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>POSITIVE_INFINITY 表示正无穷大，其值为0x7f800000。\nNEGATIVE_INFINITY 表示负无穷大，其值为0xff800000。\nNaN 表示计算出错的情况，NaN 实际上是一个数，而是一族数。\nMAX_VALUE最大的浮点数值，其值为3.4028235E38，即2的127次方。\nMIN_NORMAL 用来表示最小标准值，它定义为0x1.0p-126f，这里其实就是2的-126次方的了，值为1.17549435E-38f。\nMIN_VALUE 最小的浮点数值，其值为1.4e-45f。\nMAX_EXPONENT用来表示指数的最大值，这里定为127。\nMIN_EXPONENT 用来表示指数的最小值，这里定为-126。</p>\n<h4 id=\"tostring-float-f\"> toString(float f):</h4>\n<div><pre><code><span>public</span> <span>static</span> String <span>toString</span><span>(</span><span>float</span> f<span>)</span> <span>{</span>\n        <span>return</span> FloatingDecimal<span>.</span><span>toJavaFormatString</span><span>(</span>f<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>通过FloatingDecimal类的toJavaFormatString方法转成字符串。它处理的过程是先将浮点数转成IEEE-754标准的二进制形式，并且还要判断是否是正负无穷大，是否是NaN。然后再按照IEEE-754标准从二进制转换成十进制，最后生成浮点数对应的字符串。</p>\n<h4 id=\"tohexstring-float-f\"> toHexString(float f) :</h4>\n<div><pre><code><span>public</span> <span>static</span> String <span>toHexString</span><span>(</span><span>float</span> f<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>Math<span>.</span><span>abs</span><span>(</span>f<span>)</span> <span>&lt;</span> FloatConsts<span>.</span>MIN_NORMAL\n            <span>&amp;&amp;</span>  f <span>!=</span> <span>0.0f</span> <span>)</span> <span>{</span>\n            String s <span>=</span> Double<span>.</span><span>toHexString</span><span>(</span>Math<span>.</span><span>scalb</span><span>(</span><span>(</span><span>double</span><span>)</span>f<span>,</span>\n                                                     DoubleConsts<span>.</span>MIN_EXPONENT<span>-</span>\n                                                     FloatConsts<span>.</span>MIN_EXPONENT<span>)</span><span>)</span><span>;</span>\n            <span>return</span> s<span>.</span><span>replaceFirst</span><span>(</span><span>\"p-1022$\"</span><span>,</span> <span>\"p-126\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>else</span>\n            <span>return</span> Double<span>.</span><span>toHexString</span><span>(</span>f<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>看方法名就知道是将，float转换成16进制表示的形式，这里先会判断下目标数f，如果是NaN则返回字符串&quot;NaN&quot;,如果是正无穷大，则返回Infinity。如果是负无穷大则返回-Infinity。如果f为0，则用返回&quot;0x0.0p0&quot;，-0则返回&quot;-0x0.0p0&quot;。如果f是具有标准化表示形式的float值，则使用子字符串表示有效位数和指数。有效位数用字符串&quot;0x1.&quot;表示，后跟该有效位数小数部分的小写十六进制表示形式。除非所有位数都为0，否则移除十六进制表示形式中的尾部0，在所有位数为0的情况下，可以用一个0表示，然后用&quot;p&quot;表示指数，后跟无偏指数的十进制字符串，该值与对指数值调用Integer.toString生成的值相同。如果f是具有subnormal表示形式的float值，则用字符&quot;0x0.&quot;表示有效位数，后跟该有效位数小数部分的十六进制表示形式，移除十六进制表示形式中的尾部0，然后用&quot;p-126&quot;表示指数。注意，在subnormal有效位数中，必须至少有一个非0位数。（网上摘的，我也看不大懂）</p>\n<h4 id=\"valueof\"> valueOf</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>Float</span> <span>valueOf</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>Float</span><span>(</span><span>parseFloat</span><span>(</span>s<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>static</span> <span>Float</span> <span>valueOf</span><span>(</span><span>float</span> f<span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>Float</span><span>(</span>f<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>返回对应浮点数的Float对象，可以看到在Float类中没有像Byte或是Integer类那样将常用的数存放到缓存池中。这里是直接创建对象，然后返回。</p>\n<h4 id=\"parsefloat-string-s\"> parseFloat(String s) :</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>float</span> <span>parseFloat</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>FloatingDecimal</span><span>.</span><span>parseFloat</span><span>(</span>s<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>通过调用FloatingDecimal的parseFloat方法来实现对字符串的转换.这里会先判断s是否为NaN,Infinity,-Infinity等数。如果是以0x打头则会按<a href=\"http://aiceflower.farbox.com/post/javaji-zhu-hun-za/javazhong-de-jin-zhi-zhuan-huan\" target=\"_blank\" rel=\"noopener noreferrer\">16进制转换为10进制转换</a>。判断是否包含了E字符，即是否是科学计数法，如果有则需要处理。</p>\n<h4 id=\"isnan\"> isNaN:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>boolean</span> <span>isNaN</span><span>(</span><span>float</span> v<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>v <span>!=</span> v<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>判断一个数是否是NaN，该方法逻辑很简单，直接判断一个数是否与自己相等，因为规定一个NaN与任何值都不相等，包括它自己。这部分逻辑在JVM中会做，这里直接通过比较来判断就可以了。</p>\n<h4 id=\"isinfinite\"> isInfinite</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>boolean</span> <span>isInfinite</span><span>(</span><span>float</span> v<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>v <span>==</span> POSITIVE_INFINITY<span>)</span> <span>||</span> <span>(</span>v <span>==</span> NEGATIVE_INFINITY<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>判断一个数是否为无穷数，无穷大POSITIVE_INFINITY或无穷小NEGATIVE_INFINITY。</p>\n<h4 id=\"isfinite\"> isFinite:</h4>\n<div><pre><code><span>public</span> <span>static</span> boolean <span>isFinite</span><span>(</span><span>float</span> f<span>)</span> <span>{</span>\n        <span>return</span> Math<span>.</span><span>abs</span><span>(</span>f<span>)</span> <span>&lt;=</span> FloatConsts<span>.</span>MAX_VALUE<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>判断一个数是否为有穷数。绝对值（Math.abs(f)是用来获取一个数的绝对值的）小于FloatConsts.MAX_VALUE的数则为有穷数，FloatConsts.MAX_VALUE的值为3.4028235e+38f，它其实与Float类中定义的MAX_VALUE相同。</p>\n<h4 id=\"floattorawintbits\"> floatToRawIntBits:</h4>\n<div><pre><code> <span>public</span> <span>static</span> native <span><span>int</span></span> <span>floatToRawIntBits</span><span>(</span><span><span>float</span></span> <span>value</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>floatToRawIntBits是一个本地方法，该方法主要是将一个浮点数转成IEEE 754标准的二进制形式对应的整型数。用其它语言实现。</p>\n<h4 id=\"floattointbits\"> floatToIntBits:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span><span>int</span></span> <span>floatToIntBits</span><span>(</span><span><span>float</span></span> <span>value</span><span>)</span> <span>{</span>\n    <span><span>int</span></span> result <span>=</span> <span>floatToRawIntBits</span><span>(</span><span>value</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span> <span>(</span><span>(</span>result <span>&amp;</span> FloatConsts<span>.</span>EXP_BIT_MASK<span>)</span> <span>==</span>\n          FloatConsts<span>.</span>EXP_BIT_MASK<span>)</span> <span>&amp;&amp;</span>\n         <span>(</span>result <span>&amp;</span> FloatConsts<span>.</span>SIGNIF_BIT_MASK<span>)</span> <span>!=</span> <span>0</span><span>)</span>\n        result <span>=</span> <span>0x7fc00000</span><span>;</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>该方法主要先通过调用floatToRawIntBits获取到IEEE 754标准对应的整型数，然后再分别用FloatConsts.EXP_BIT_MASK和FloatConsts.SIGNIF_BIT_MASK两个掩码去判断是否为NaN，0x7fc00000对应的即为NaN。</p>\n<h4 id=\"intbitstofloat\"> intBitsToFloat:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>native</span> <span>float</span> <span>intBitsToFloat</span><span>(</span><span>int</span> bits<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>该方法与floatToRawIntBits方法对应，intBitsToFloat同样是一个本地方法，该方法主要是将一个IEEE 754标准的二进制形式对应的整型数转成一个浮点数。用其它语言实现。</p>\n<h4 id=\"sum\"> sum:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>float</span> <span>sum</span><span>(</span><span>float</span> a<span>,</span> <span>float</span> b<span>)</span> <span>{</span>\n        <span>return</span> a <span>+</span> b<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>计算两个浮点数的和。</p>\n<h4 id=\"max\"> max:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>float</span> <span>max</span><span>(</span><span>float</span> a<span>,</span> <span>float</span> b<span>)</span> <span>{</span>\n        <span>return</span> Math<span>.</span><span>max</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>取两个浮点数中较大的一个。</p>\n<h4 id=\"min\"> min:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>float</span> <span>min</span><span>(</span><span>float</span> a<span>,</span> <span>float</span> b<span>)</span> <span>{</span>\n        <span>return</span> Math<span>.</span><span>min</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>取两个浮点数中较小的一个。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "11.Double类",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/11.Double%E7%B1%BB/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/11.Double%E7%B1%BB/",
      "content_html": "<h1 id=\"_11-double类\"> 11.Double类</h1>\n<h4 id=\"基础知识\"> 基础知识：</h4>\n<p>1.浮点数的表示：\n浮点数由三部分组成，符号位s、指数e和尾数f。\n对于float表示如下\n0                       00000000            00000000000000000000000\nsign(1bit)        exponent(8bit)                fraction(23bit)                                   共32bit\n对于求值我们是有一个公式对应的，某个浮点数的值为：\n(−1)^s ∗    (1.f)   ∗   2^(e−127)\n可以看到32位的最高位为符号标识符，1表示负数，0表示正数。指数部分为8位，其实可以是0到255，但是为了可正可负，这里需要减去127后才是真正的指数，而底数固定为2。剩下的23位表示尾数，但默认前面都会加上1.。所以通过上面就可以将一个浮点数表示出来了。\n我们举个例子来看，二进制的“01000001001101100000000000000000”表示的浮点数是啥？\n符号位为0，表示正数。\n指数为“10000010”，减去127后为3。\n尾数对应的值为“1.011011”。\n于是最终得到浮点数为“1011.011”，转成十进制为“11.375”。\n2.精度丢失:\n对float或double 的使用不当，可能会出现精度丢失的问题。浮点运算很少是精确的，只要是超过精度能表示的范围就会产生误差。往往产生误差不是 因为数的大小，而是因为数的精度。因此，产生的结果接近但不等于想要的结果。尤其在使用 float 和 double 作精确运 算的时候要特别小心。如:\nSystem.out.println(0.1d + 0.2d);这个输出的结果不是我们想要的0.3而是0.30000000000000004。这就是java中的精度丢失。可以使用如下方式解决：</p>\n<div><pre><code><span>BigDecimal</span> b1 <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>\"0.1\"</span><span>)</span><span>;</span>\n<span>BigDecimal</span> b2 <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>\"0.2\"</span><span>)</span><span>;</span>\nSystem<span>.</span><span>out</span><span>.</span><span>println</span><span>(</span>b1<span>.</span><span>add</span><span>(</span>b2<span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>所以大家在遇到金钱等对精度要求较高的业务时最好不要使用浮点类型的数。可以考虑使用BigDecimal。或是把单位转换成分，这样处理的数字都是整数，最后再化成小数。这样就不会出现精度丢失的问题了。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "12.Boolean类",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/12.Boolean%E7%B1%BB/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/12.Boolean%E7%B1%BB/",
      "content_html": "<h1 id=\"_12-boolean类\"> 12.Boolean类</h1>\n<p>boolean java基本数据类型之一，只有两个取值：true 和 false 这种类型只作为一种标志来记录 true/false ，其包装类为Boolean类，里面提供了一些处理boolean类型的方法。接下来让我们看一下Boolean类的具体实现。</p>\n<h3 id=\"基础知识\"> 基础知识</h3>\n<p>1.java中判断是否相等：\njava中相等的判断有两中方式，一种是使用操作符==，一种是使用对象的equals方法。\n== ：对于基本数据类型==是数值比较，且基本数据类型只能用==进行比较，对于引用数据类型==比较的是地址值。\nequals：比较两个对象是否相等。如java中有两个Person对象，对于现实中要比较这两个人是否相同，只需要比较其姓名，身份证是否相同就可以了，在java中是两个对象，自然有不同的地址，若是用==进行比较这两个Person显示不是同一个，这时就需要通过重写equals方法实现自己的比较逻辑来判断两个Person是否相等。\n2.对象的排序\njava中对象是通过Collections.sort进行排序的，有两种情况，一种是让对象本身具有比较的特性，对象需要实现Comparable接口实现其compareTo方法；一种是创建一个新的比较器类，该类要实现Comparator接口，实现其compare方法。\n3.设置与获取系统属性\n设置： 通过-Dkey=value的形式设置系统属性\n在eclipse中设置：\nRun--&gt;Run Confgurations--&gt;然后在对话框的右边选择Arguments--&gt;然后在VM arguments中输入-Dkey=value\n在命令行中设置：\njava -Dkey=value -jar Test.jar\n获取：System.getProperty(propertyName)</p>\n<h3 id=\"boolean类\"> Boolean类：</h3>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Boolean</span> <span>implements</span> <span>Serializable</span><span>,</span><span>Comparable</span><span><span>&lt;</span><span>Boolean</span><span>></span></span><span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>可以看到Boolean类是final的不能被继承，同时他实现了Comparable说明对象本身具有比较性。</p>\n<p>主要属性</p>\n<div><pre><code><span>private</span> <span>final</span> <span>boolean</span> value<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>用于保存Boolean对象的值，而且是final的，一但初始化完成，不能被修改。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>final</span> Boolean <span>TRUE</span> <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>true</span><span>)</span><span>;</span>\n<span>public</span> <span>static</span> <span>final</span> Boolean <span>FALSE</span> <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>false</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>全局的不可改变的两个Boolean对象。对于布尔值也就只有两种状态，即我们可以使用以上这两个Boolean对象表示所有的布尔值。提供这两个静态变量相当于对Boolean对象的&quot;缓存&quot;,是为了让开发者直接使用这两个变量而不是每次都创建新的Boolean对象，这样既节省内存又避免了创建一个新实例的时间开销。</p>\n<div><pre><code><span>public</span> <span>Boolean</span><span>(</span><span>boolean</span> <span>value</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span><span>value</span> <span>=</span> <span>value</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>Boolean</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n    <span>this</span><span>(</span><span>toBoolean</span><span>(</span>s<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n<span>private</span> <span>static</span> <span>boolean</span> <span>toBoolean</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>(</span>name <span>!=</span> <span>null</span><span>)</span> <span>&amp;&amp;</span> name<span>.</span><span>equalsIgnoreCase</span><span>(</span><span>\"true\"</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>两种构造方法，一种传入boolean值，一种传入一个字符串，传入字符会进行&quot;to boolean&quot;解析，即当传入的字符串忽略大小写等于&quot;true&quot;时判断为true，否则为false。\n一般我们不推荐直接用构造函数来创建Boolean对象，使用全局变量TRUE 、FALSE 或是使用Boolean.valueOf方法即可，避免生成不必要的对象。</p>\n<h3 id=\"parseboolean\"> parseBoolean:</h3>\n<div><pre><code><span>public</span> <span>static</span> <span>boolean</span> <span>parseBoolean</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n    <span>return</span> <span>toBoolean</span><span>(</span>s<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>将字符串转换为boolean值，调用了toBoolean方法。只有当传入的字符串忽略大小写为&quot;true&quot;时返回true否则返回false。</p>\n<h3 id=\"booleanvalue\"> booleanValue:</h3>\n<div><pre><code><span>public</span> <span>boolean</span> <span>booleanValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>value</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>返回本对象的布尔值。</p>\n<h3 id=\"valueof\"> valueOf:</h3>\n<div><pre><code><span>public</span> <span>static</span> Boolean <span>valueOf</span><span>(</span>boolean b<span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>b <span>?</span> <span>TRUE</span> <span>:</span> <span>FALSE</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>static</span> Boolean <span>valueOf</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n    <span>return</span> <span>toBoolean</span><span>(</span>s<span>)</span> <span>?</span> <span>TRUE</span> <span>:</span> <span>FALSE</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>valueOf方法用于返回对应的Boolean对象，这里可以看成从&quot;缓存&quot;中获取Boolean对象，因为布尔类型只有两种状态。</p>\n<h3 id=\"tostring\"> toString:</h3>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>toString</span><span>(</span><span>boolean</span> b<span>)</span> <span>{</span>\n    <span>return</span> b <span>?</span> <span>\"true\"</span> <span>:</span> <span>\"false\"</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>value</span> <span>?</span> <span>\"true\"</span> <span>:</span> <span>\"false\"</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果为true返回字符串&quot;true&quot;如果为false返回字符串&quot;false&quot;。</p>\n<h3 id=\"hashcode\"> hashCode:</h3>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>value</span> <span>?</span> <span>1231</span> <span>:</span> <span>1237</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>true返回1231，false返回1237。</p>\n<p>equals:</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object obj</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>obj <span>instanceof</span> <span>Boolean</span><span>)</span> <span>{</span>\n        <span>return</span> value <span>==</span> <span>(</span><span>(</span>Boolean<span>)</span>obj<span>)</span><span>.</span><span>booleanValue</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>先判断对象是否是Boolean类型，如果是再比较它们的值是否相等。</p>\n<h3 id=\"getboolean\"> getBoolean:</h3>\n<div><pre><code><span>public</span> <span>static</span> <span>boolean</span> <span>getBoolean</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n    <span>boolean</span> result <span>=</span> <span>false</span><span>;</span>\n    <span>try</span> <span>{</span>\n        result <span>=</span> <span>toBoolean</span><span>(</span><span>System</span><span>.</span><span>getProperty</span><span>(</span>name<span>)</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>IllegalArgumentException</span> e<span>)</span> <span>{</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>NullPointerException</span> e<span>)</span> <span>{</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>根据给定的名称查询系统中是否存在该属性，如果存在且为true则返回true，否则返回false。根据程序需要可以提前设置一些系统属性，使用System.getProperty(name)获取设置的系统属性。</p>\n<h3 id=\"compareto\"> compareTo:</h3>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>compareTo</span><span>(</span><span>Boolean</span> b<span>)</span> <span>{</span>\n    <span>return</span> <span>compare</span><span>(</span><span>this</span><span>.</span><span>value</span><span>,</span> b<span>.</span><span>value</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>static</span> <span><span>int</span></span> <span>compare</span><span>(</span><span>boolean</span> x<span>,</span> <span>boolean</span> y<span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>x <span>==</span> y<span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>x <span>?</span> <span>1</span> <span>:</span> <span>-</span><span>1</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>compareTo用于比较两个布尔值的大小true大于false，compareTo调用了compare方法。(x == y) ? 0 : (x ? 1 : -1)如果相等返回0，如果不等x为true则y为false返回1，否则返回-1。compareTo是实现的Comparable接口中的方法，该方法返回0表示本对象与传入的对象相等，返回正数表示本对象比传入的对象大，返回负数表示本对象比传入的对象小。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "4.AbstractStringBuffer类",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/4.AbstractStringBuffer%E7%B1%BB/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/4.AbstractStringBuffer%E7%B1%BB/",
      "content_html": "<h1 id=\"_4-abstractstringbuffer类\"> 4.AbstractStringBuffer类</h1>\n<p>前一篇查看了String类的源码，发现String类中有不少地方使用了StringBuffer和StringBuilder类，而这两个类都是继承自AbstractStringBuilder类，里面的很多实现都是直接使用父类的，所以就看一下AbstractStringBuilder类的源码。</p>\n<h3 id=\"类的申明\"> 类的申明：</h3>\n<div><pre><code><span>abstract</span> <span>class</span> <span>AbstractStringBuilder</span> <span>implements</span> <span>Appendable</span><span>,</span> <span>CharSequence</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>1.默认访问控制修饰符，说明只能在包内使用，即只能在JDK内部使用，可能有人会问我创建一个java.lang包然后里面的类就可以使用AbstractStringBuilder类了，想法不错，但jkd不允许，会报SecurityException : Prohibited package name: java.lang。故这个类只是给StringBuffer和StringBuilder类使用的。\n2.类名用abstract修饰说明是一个抽象类，只能被继承，不能直接创建对象。查了里面的方法你会发现它就一个抽象方法，toString方法。\n3.实现了Appendable接口，Appendable能够被追加 char 序列和值的对象。如果某个类的实例打算接收来自 Formatter 的格式化输出，那么该类必须实现 Appendable 接口。\n4.实现了Charsequence接口，代表该类，或其子类是一个字符序列。</p>\n<h3 id=\"成员变量\"> 成员变量：</h3>\n<div><pre><code><span><span>char</span><span>[</span><span>]</span></span> <span>value</span><span>;</span>\n<span><span>int</span></span> count<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>value用于承装字符序列，count数组中实际存储字符的数量。这里的value同String类中的value不同，String类中的value是final的不可被修改，这里的value是动态的，并且可提供给外部直接操作。</p>\n<h3 id=\"构造函数\"> 构造函数：</h3>\n<div><pre><code><span>AbstractStringBuilder</span><span>(</span><span>)</span> <span>{</span>\n<span>}</span>\n<span>AbstractStringBuilder</span><span>(</span><span><span>int</span></span> capacity<span>)</span> <span>{</span>\n    <span>value</span> <span>=</span> <span>new</span> <span><span>char</span></span><span>[</span>capacity<span>]</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>AbstractStringBuilder提供两个构造函数，一个是无参构造函数。一个是传一个capacity(代表数组容量)的构造，这个构造函数用于指定类中value数组的初始大小，数组大小后面还可动态改变。</p>\n<h3 id=\"其它方法\"> 其它方法：</h3>\n<h4 id=\"length\"> length:</h4>\n<div><pre><code><span>public</span> <span>int</span> <span>length</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> count<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>返回已经存储字符序列的实际长度，即count的值。</p>\n<h4 id=\"capacity\"> capacity:</h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>capacity</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>value</span><span>.</span>length<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>返回当前value可以存储的字符容量，即在下一次重新申请内存之前能存储字符序列的长度。新添加元素的时候，可能会对数组进行扩容。</p>\n<h4 id=\"ensurecapacity\"> ensureCapacity：</h4>\n<div><pre><code><span>public</span> <span>void</span> <span>ensureCapacity</span><span>(</span><span>int</span> minimumCapacity<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>minimumCapacity <span>></span> <span>0</span><span>)</span>\n        <span>ensureCapacityInternal</span><span>(</span>minimumCapacity<span>)</span><span>;</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>该方法是用来确保容量至少等于指定的最小值,是该类的核心也是其两个实现类StringBuffer和StringBuilder的核心。通过这种方式来实现数组的动态扩容。下面来看下其具体逻辑。\n1.判断入参minimumCapacity是否有效，即是否大于0，大于0执行ensureCapacityInternal方法，小于等于0则忽略。</p>\n<div><pre><code><span>private</span> <span><span>void</span></span> <span>ensureCapacityInternal</span><span>(</span><span><span>int</span></span> minimumCapacity<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>minimumCapacity <span>-</span> <span>value</span><span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>\n        <span>value</span> <span>=</span> Arrays<span>.</span><span>copyOf</span><span>(</span><span>value</span><span>,</span>\n                              <span>newCapacity</span><span>(</span>minimumCapacity<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>2.判断入参容量值是否比原容量大，如果大于原容量，执行扩容操作,实际上就是创建一个新容量的数组，然后再将原数组中的内容拷贝到新数组中，如果小于或等于原容量则忽略。</p>\n<div><pre><code><span>private</span> <span>static</span> final <span><span>int</span></span> MAX_ARRAY_SIZE <span>=</span> Integer<span>.</span>MAX_VALUE <span>-</span> <span>8</span><span>;</span>    \n<span>private</span> <span><span>int</span></span> <span>newCapacity</span><span>(</span><span><span>int</span></span> minCapacity<span>)</span> <span>{</span>\n    <span>// overflow-conscious code</span>\n    <span><span>int</span></span> newCapacity <span>=</span> <span>(</span><span>value</span><span>.</span>length <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>+</span> <span>2</span><span>;</span>\n    <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n        newCapacity <span>=</span> minCapacity<span>;</span>\n    <span>}</span>\n    <span>return</span> <span>(</span>newCapacity <span>&lt;=</span> <span>0</span> <span>||</span> MAX_ARRAY_SIZE <span>-</span> newCapacity <span>&lt;</span> <span>0</span><span>)</span>\n        <span>?</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span>\n        <span>:</span> newCapacity<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>3.计算新数组的容量大小，新容量取原容量的2倍加2和入参minCapacity中较大者。然后再进行一些范围校验。新容量必需在int所支持的范围内，之所以有&lt;=0判断是因为，在执行 (value.length &lt;&lt; 1) + 2操作后，可能会出现int溢出的情况。如果溢出或是大于所支持的最大容量(MAX_ARRAY_SIZE为int所支持的最大值减8)，则进行hugeCapacity计算，否则取newCapacity</p>\n<div><pre><code><span>private</span> <span>int</span> <span>hugeCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>Integer<span>.</span>MAX_VALUE <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>{</span> <span>// overflow</span>\n        <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>(</span>minCapacity <span>></span> MAX_ARRAY_SIZE<span>)</span>\n        <span>?</span> minCapacity <span>:</span> MAX_ARRAY_SIZE<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>4.这一步先进行范围检查，必须在int所支持的最大范围内。然后在minCapacity与MAX_ARRAY_SIZE之间取较大者，此方法取的范围是Integer.MAX_VALUE - 8到Integer.MAX_VALUE之间的范围。\n5.总结：\n1.通过value = Arrays.copyOf(value,newCapacity(minimumCapacity));进行扩容\n2.新容量取 minCapacity，原容量乘以2再加上2中较大的，但不能大于int所支持的最大范围。\n3.在实际环境中在容量远没达到MAX_ARRAY_SIZE的时候就报OutOfMemoryError异常了，其实就是在复制的时候创建了数组char[] copy = new char[newLength];这里支持不了那么大的内存消耗，可以通过 -Xms256M -Xmx768M设置最大内存。</p>\n<h4 id=\"trimtosize\"> trimToSize:</h4>\n<div><pre><code><span>public</span> <span><span>void</span></span> <span>trimToSize</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>count <span>&lt;</span> <span>value</span><span>.</span>length<span>)</span> <span>{</span>\n        <span>value</span> <span>=</span> Arrays<span>.</span><span>copyOf</span><span>(</span><span>value</span><span>,</span> count<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>减少字符序列的使用空间，比如申请了100字符长度的空间，但是现在只用了60个，那剩下的40个无用的空间放在那里占内存，可以调用此方法释放掉未用到的内存。原理很简单，只申请一个count大小的数组把原数组中的内容复制到新数组中，原来的数组由于没有被任何引用所指向，之后会被gc回收。</p>\n<h4 id=\"setlength\"> setLength:</h4>\n<div><pre><code><span>public</span> <span><span>void</span></span> <span>setLength</span><span>(</span><span><span>int</span></span> newLength<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>newLength <span>&lt;</span> <span>0</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>newLength<span>)</span><span>;</span>\n    <span>ensureCapacityInternal</span><span>(</span>newLength<span>)</span><span>;</span>\n\n    <span>if</span> <span>(</span>count <span>&lt;</span> newLength<span>)</span> <span>{</span>\n        Arrays<span>.</span><span>fill</span><span>(</span><span>value</span><span>,</span> count<span>,</span> newLength<span>,</span> <span>'\\0'</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    count <span>=</span> newLength<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>用空字符填充未使用的空间。首先对数组进行扩容，然后将剩余未使用的空间全部填充为'0'字符。</p>\n<h4 id=\"charat\"> charAt:</h4>\n<div><pre><code><span>public</span> <span><span>char</span></span> <span>charAt</span><span>(</span><span><span>int</span></span> index<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>(</span>index <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>index <span>>=</span> count<span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n    <span>return</span> <span>value</span><span>[</span>index<span>]</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>获取字符序列中指定位置的字符，范围为0到count，超出范围抛StringIndexOutOfBoundsException异常。</p>\n<h4 id=\"codepointat\"> codePointAt:</h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>codePointAt</span><span>(</span><span><span>int</span></span> index<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>(</span>index <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>index <span>>=</span> count<span>)</span><span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> Character<span>.</span><span>codePointAtImpl</span><span>(</span><span>value</span><span>,</span> index<span>,</span> count<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>获取字符序列中指定位置的字符，所对应的代码点，即ascii码。</p>\n<h4 id=\"codepointbefore\"> codePointBefore:</h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>codePointBefore</span><span>(</span><span><span>int</span></span> index<span>)</span> <span>{</span>\n    <span><span>int</span></span> i <span>=</span> index <span>-</span> <span>1</span><span>;</span>\n    <span>if</span> <span>(</span><span>(</span>i <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>i <span>>=</span> count<span>)</span><span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> Character<span>.</span><span>codePointBeforeImpl</span><span>(</span><span>value</span><span>,</span> index<span>,</span> <span>0</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>获取字符序列中指定位置的前一个位置的字符，所对应的代码点。</p>\n<h4 id=\"codepointcount\"> codePointCount:</h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>codePointCount</span><span>(</span><span><span>int</span></span> beginIndex<span>,</span> <span><span>int</span></span> endIndex<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>beginIndex <span>&lt;</span> <span>0</span> <span>||</span> endIndex <span>></span> count <span>||</span> beginIndex <span>></span> endIndex<span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> Character<span>.</span><span>codePointCountImpl</span><span>(</span><span>value</span><span>,</span> beginIndex<span>,</span> endIndex<span>-</span>beginIndex<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>获取字符串代码点个数，是实际上的字符个数。不清楚代码点可查看<a href=\"https://www.jianshu.com/p/c3a94294056a\" target=\"_blank\" rel=\"noopener noreferrer\">java中代码点与代码单元的区别</a>。</p>\n<h4 id=\"\"> </h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>offsetByCodePoints</span><span>(</span><span><span>int</span></span> index<span>,</span> <span><span>int</span></span> codePointOffset<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>index <span>&lt;</span> <span>0</span> <span>||</span> index <span>></span> <span>value</span><span>.</span>length<span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> Character<span>.</span><span>offsetByCodePointsImpl</span><span>(</span><span>value</span><span>,</span> <span>0</span><span>,</span> <span>value</span><span>.</span>length<span>,</span>\n                                            index<span>,</span> codePointOffset<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>返回此字符序列中从给定的index处偏移codePointOffset个代码点的索引。不清楚代码点的可以查看<a href=\"https://www.jianshu.com/p/c3a94294056a\" target=\"_blank\" rel=\"noopener noreferrer\">java中代码点与代码单元的区别</a>。</p>\n<h4 id=\"getchars\"> getChars:</h4>\n<div><pre><code><span>public</span> <span><span>void</span></span> <span>getChars</span><span>(</span><span><span>int</span></span> srcBegin<span>,</span> <span><span>int</span></span> srcEnd<span>,</span> <span><span>char</span><span>[</span><span>]</span></span> dst<span>,</span> <span><span>int</span></span> dstBegin<span>)</span>\n<span>{</span>\n    <span>if</span> <span>(</span>srcBegin <span>&lt;</span> <span>0</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>srcBegin<span>)</span><span>;</span>\n    <span>if</span> <span>(</span><span>(</span>srcEnd <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>srcEnd <span>></span> count<span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>srcEnd<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>srcBegin <span>></span> srcEnd<span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span><span>\"srcBegin > srcEnd\"</span><span>)</span><span>;</span>\n    System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> srcBegin<span>,</span> dst<span>,</span> dstBegin<span>,</span> srcEnd <span>-</span> srcBegin<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>将字符序列中指定区间srcBegin到srcEnd内的字符拷贝到dst字符数组中从dstBegin开始往后的位置中。</p>\n<h4 id=\"setcharat\"> setCharAt:</h4>\n<div><pre><code><span>public</span> <span><span>void</span></span> <span>setCharAt</span><span>(</span><span><span>int</span></span> index<span>,</span> <span><span>char</span></span> ch<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>(</span>index <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>index <span>>=</span> count<span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n    <span>value</span><span>[</span>index<span>]</span> <span>=</span> ch<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>设置字符序列中指定索引index位置的字符为ch。</p>\n<h4 id=\"append系列\"> append系列：</h4>\n<div><pre><code><span>public</span> <span>AbstractStringBuilder</span> <span>append</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>str <span>==</span> <span>null</span><span>)</span>\n        <span>return</span> <span>appendNull</span><span>(</span><span>)</span><span>;</span>\n    <span><span>int</span></span> len <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n    <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> len<span>)</span><span>;</span>\n    str<span>.</span><span>getChars</span><span>(</span><span>0</span><span>,</span> len<span>,</span> <span>value</span><span>,</span> count<span>)</span><span>;</span>\n    count <span>+=</span> len<span>;</span>\n    <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>AbstractStringBuilder类中有一系列append方法，作用是在原字符序列后添加给定的对象或元素所对应的字符序列。这里挑一个代表讲解，其它方法原理类似。\n1.首先判断所传参数是否为null，如果为null则调用appendNull方法，实际上就是在原字符序列后加上&quot;null&quot;序列。\n2如果不为null则进行扩容操作，最小值为count+len，这一步可能增加容量也可能不增加，当count+len小于或等于capacity就不用进行扩容。\n3.然后再将参数的字符串序列添加到value中。\n4.最后返回this,注意这里返回的是this，也就意味者，可以在一条语句中多次调用append方法，即大家所知的方法调用链。原理简单，但思想值得借鉴。asb.append(&quot;hello&quot;).append(&quot;world&quot;);</p>\n<h4 id=\"appendcodepoint\"> appendCodePoint:</h4>\n<div><pre><code><span>public</span> <span>AbstractStringBuilder</span> <span>appendCodePoint</span><span>(</span><span><span>int</span></span> codePoint<span>)</span> <span>{</span>\n    final <span><span>int</span></span> count <span>=</span> <span>this</span><span>.</span>count<span>;</span>\n\n    <span>if</span> <span>(</span>Character<span>.</span><span>isBmpCodePoint</span><span>(</span>codePoint<span>)</span><span>)</span> <span>{</span>\n        <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>;</span>\n        <span>value</span><span>[</span>count<span>]</span> <span>=</span> <span>(</span><span>char</span><span>)</span> codePoint<span>;</span>\n        <span>this</span><span>.</span>count <span>=</span> count <span>+</span> <span>1</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>Character<span>.</span><span>isValidCodePoint</span><span>(</span>codePoint<span>)</span><span>)</span> <span>{</span>\n        <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> <span>2</span><span>)</span><span>;</span>\n        Character<span>.</span><span>toSurrogates</span><span>(</span>codePoint<span>,</span> <span>value</span><span>,</span> count<span>)</span><span>;</span>\n        <span>this</span><span>.</span>count <span>=</span> count <span>+</span> <span>2</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>添加代码点，将入参转换为对应的代码点后，添加到原字符序列结尾。不清楚代码点的可以查看<a href=\"https://www.jianshu.com/p/c3a94294056a\" target=\"_blank\" rel=\"noopener noreferrer\">java中代码点与代码单元的区别</a>。</p>\n<h4 id=\"delete\"> delete:</h4>\n<div><pre><code><span>public</span> <span>AbstractStringBuilder</span> <span>delete</span><span>(</span><span><span>int</span></span> start<span>,</span> <span><span>int</span></span> end<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>start <span>&lt;</span> <span>0</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>start<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>end <span>></span> count<span>)</span>\n        end <span>=</span> count<span>;</span>\n    <span>if</span> <span>(</span>start <span>></span> end<span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span><span>)</span><span>;</span>\n    <span><span>int</span></span> len <span>=</span> end <span>-</span> start<span>;</span>\n    <span>if</span> <span>(</span>len <span>></span> <span>0</span><span>)</span> <span>{</span>\n        System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> start<span>+</span>len<span>,</span> <span>value</span><span>,</span> start<span>,</span> count<span>-</span>end<span>)</span><span>;</span>\n        count <span>-=</span> len<span>;</span>\n    <span>}</span>\n    <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>删除字符序列指定区间的内容。这个操作不改变原序列的容量。</p>\n<h4 id=\"deletecharat\"> deleteCharAt:</h4>\n<div><pre><code><span>public</span> <span>AbstractStringBuilder</span> <span>deleteCharAt</span><span>(</span><span><span>int</span></span> index<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>(</span>index <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>index <span>>=</span> count<span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n    System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> index<span>+</span><span>1</span><span>,</span> <span>value</span><span>,</span> index<span>,</span> count<span>-</span>index<span>-</span><span>1</span><span>)</span><span>;</span>\n    count<span>--</span><span>;</span>\n    <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>删除字符序列中指定索引index位置的字符。</p>\n<h4 id=\"replace\"> replace:</h4>\n<div><pre><code><span>public</span> <span>AbstractStringBuilder</span> <span>replace</span><span>(</span><span><span>int</span></span> start<span>,</span> <span><span>int</span></span> end<span>,</span> <span>String</span> str<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>start <span>&lt;</span> <span>0</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>start<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>start <span>></span> count<span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span><span>\"start > length()\"</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>start <span>></span> end<span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span><span>\"start > end\"</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>end <span>></span> count<span>)</span>\n        end <span>=</span> count<span>;</span>\n    <span><span>int</span></span> len <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n    <span><span>int</span></span> newCount <span>=</span> count <span>+</span> len <span>-</span> <span>(</span>end <span>-</span> start<span>)</span><span>;</span>\n    <span>ensureCapacityInternal</span><span>(</span>newCount<span>)</span><span>;</span>\n    System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> end<span>,</span> <span>value</span><span>,</span> start <span>+</span> len<span>,</span> count <span>-</span> end<span>)</span><span>;</span>\n    str<span>.</span><span>getChars</span><span>(</span><span>value</span><span>,</span> start<span>)</span><span>;</span>\n    count <span>=</span> newCount<span>;</span>\n    <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>将原字符序列指定区间start到end区间内的内容替换为str,替换过程中序列长度会改变，所以需要进行扩容和改就count的操作。</p>\n<h4 id=\"substring\"> substring:</h4>\n<div><pre><code><span>public</span> <span>String</span> <span>substring</span><span>(</span><span><span>int</span></span> start<span>)</span> <span>{</span>\n    <span>return</span> <span>substring</span><span>(</span>start<span>,</span> count<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>String</span> <span>substring</span><span>(</span><span><span>int</span></span> start<span>,</span> <span><span>int</span></span> end<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>start <span>&lt;</span> <span>0</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>start<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>end <span>></span> count<span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>end<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>start <span>></span> end<span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>end <span>-</span> start<span>)</span><span>;</span>\n    <span>return</span> <span>new</span> <span>String</span><span>(</span><span>value</span><span>,</span> start<span>,</span> end <span>-</span> start<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>切割原字符序列指定区间start到end内的内容，返回字符串形式。</p>\n<h4 id=\"insert系列\"> insert系列:</h4>\n<div><pre><code><span>public</span> <span>AbstractStringBuilder</span> <span>insert</span><span>(</span><span><span>int</span></span> offset<span>,</span> <span>String</span> str<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>(</span>offset <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>offset <span>></span> <span>length</span><span>(</span><span>)</span><span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>offset<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>str <span>==</span> <span>null</span><span>)</span>\n        str <span>=</span> <span>\"null\"</span><span>;</span>\n    <span><span>int</span></span> len <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n    <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> len<span>)</span><span>;</span>\n    System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> offset<span>,</span> <span>value</span><span>,</span> offset <span>+</span> len<span>,</span> count <span>-</span> offset<span>)</span><span>;</span>\n    str<span>.</span><span>getChars</span><span>(</span><span>value</span><span>,</span> offset<span>)</span><span>;</span>\n    count <span>+=</span> len<span>;</span>\n    <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>insert系列作用是将给定定对象所对应的字符串插入到原序列的指定位置。insert系列同append系列类似，只不过append是在原序列末尾添加元素，insert是在指定位置插入元素。这里也选一个代表进行讲解。\n假设原字符序列为&quot;hello&quot;现调用insert(int 1, “aa&quot;);\n1.对待插入的位置offset进行检查，必须在容量内\n2.如果传入对象为null则插入&quot;null&quot;字符串\n3.对value数组进行扩容\n4.通过System.arraycopy对数组进行复制\narraycopy(Object src,int srcPos,Object dest,int destPos,int length);\nsrc:源数组； ['h','e','l','l','o','o']\nsrcPos:源数组要复制的起始位置；1\ndest:目的数组； ['h','e','l','l','o','w']\ndestPos:目的数组放置的起始位置； 1+2=3\nlength:复制的长度。 6-1=5\n则执行完这句后value中的内容为['h','e','l','e','l','l','o','o']\n可以看到是将位置1到结尾的内容后移了两个长度，因为需要插入的字符串&quot;bb&quot;的长度为2\n5.将str的内容复制到value中\nstr.getChars(value, offset);//将str的内容复制到value中从offset 1位置开始复制\n复制完成后['h','b','b','e','l','l','o','o'],即我们最终想要达到的效果&quot;hbbellow&quot;</p>\n<h4 id=\"indexof\"> indexOf:</h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>indexOf</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>\n    <span>return</span> <span>indexOf</span><span>(</span>str<span>,</span> <span>0</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span><span>int</span></span> <span>indexOf</span><span>(</span><span>String</span> str<span>,</span> <span><span>int</span></span> fromIndex<span>)</span> <span>{</span>\n    <span>return</span> String<span>.</span><span>indexOf</span><span>(</span><span>value</span><span>,</span> <span>0</span><span>,</span> count<span>,</span> str<span>,</span> fromIndex<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>查询给定字符串在原字符序列中第一次出现的位置。调用的其实是String类的indexOf方法，具体可查看<a href=\"https://www.jianshu.com/p/b3e9deacd155\" target=\"_blank\" rel=\"noopener noreferrer\">一起学JDK源码 -- String类</a></p>\n<h4 id=\"reverse\"> reverse:</h4>\n<div><pre><code><span>public</span> <span>AbstractStringBuilder</span> <span>reverse</span><span>(</span><span>)</span> <span>{</span>\n    <span>boolean</span> hasSurrogates <span>=</span> <span>false</span><span>;</span>\n    <span><span>int</span></span> n <span>=</span> count <span>-</span> <span>1</span><span>;</span>\n    <span>for</span> <span>(</span><span><span>int</span></span> j <span>=</span> <span>(</span>n<span>-</span><span>1</span><span>)</span> <span>>></span> <span>1</span><span>;</span> j <span>>=</span> <span>0</span><span>;</span> j<span>--</span><span>)</span> <span>{</span>\n        <span><span>int</span></span> k <span>=</span> n <span>-</span> j<span>;</span>\n        <span><span>char</span></span> cj <span>=</span> <span>value</span><span>[</span>j<span>]</span><span>;</span>\n        <span><span>char</span></span> ck <span>=</span> <span>value</span><span>[</span>k<span>]</span><span>;</span>\n        <span>value</span><span>[</span>j<span>]</span> <span>=</span> ck<span>;</span>\n        <span>value</span><span>[</span>k<span>]</span> <span>=</span> cj<span>;</span>\n        <span>if</span> <span>(</span>Character<span>.</span><span>isSurrogate</span><span>(</span>cj<span>)</span> <span>||</span>\n            Character<span>.</span><span>isSurrogate</span><span>(</span>ck<span>)</span><span>)</span> <span>{</span>\n            hasSurrogates <span>=</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>if</span> <span>(</span>hasSurrogates<span>)</span> <span>{</span>\n        <span>reverseAllValidSurrogatePairs</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>该方法用于将字符序列反转，如&quot;hellow&quot;执行reverse后变成&quot;wolleh&quot;。\n1.hasSurrogates用于判断字符序列中是否包含surrogates pair\n2.将字符反转,count为数组长度，因为是从0开始的所以这里需要减1。具体转换是第一个字符与最后一个字符对调，第二个字符与倒数第二个字符对调，依次类推\n3.实际上上述操作只需要循环(n-1) /2 + 1次[判断条件j&gt;=0所以要+1次,源码中&gt;&gt;1就是除以2]就可以了，如数组长度为9则需要循环 (9-1-1)/2 +1 = 4次,9个字符对调次，第5个位置的字符不用换，如果长度为10需要循环(10-1-1)/2 +1 = 5次\n4.剩下的工作就是两个位置的元素互换。\n5.如果序列中包含surrogates pair 则执行reverseAllValidSurrogatePairs方法</p>\n<h4 id=\"reverseallvalidsurrogatepairs\"> reverseAllValidSurrogatePairs:</h4>\n<div><pre><code><span>private</span> <span><span>void</span></span> <span>reverseAllValidSurrogatePairs</span><span>(</span><span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span><span>int</span></span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> count <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span><span>char</span></span> c2 <span>=</span> <span>value</span><span>[</span>i<span>]</span><span>;</span>\n        <span>if</span> <span>(</span>Character<span>.</span><span>isLowSurrogate</span><span>(</span>c2<span>)</span><span>)</span> <span>{</span>\n            <span><span>char</span></span> c1 <span>=</span> <span>value</span><span>[</span>i <span>+</span> <span>1</span><span>]</span><span>;</span>\n            <span>if</span> <span>(</span>Character<span>.</span><span>isHighSurrogate</span><span>(</span>c1<span>)</span><span>)</span> <span>{</span>\n                <span>value</span><span>[</span>i<span>++</span><span>]</span> <span>=</span> c1<span>;</span>\n                <span>value</span><span>[</span>i<span>]</span> <span>=</span> c2<span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>Surrogate Pair是UTF-16中用于扩展字符而使用的编码方式，是一种采用四个字节(两个UTF-16编码)来表示一个字符。\nchar在java中是16位的，刚好是一个UTF-16编码。而字符串中可能含有Surrogate Pair,但他们是一个单一完整的字符，只不过是用两个char来表示而已，因此在反转字符串的过程中Surrogate Pairs 是不应该被反转的。而reverseAllValidSurrogatePairs方法就是对Surrogate Pair进行处理。</p>\n<h4 id=\"tostring\"> toString:</h4>\n<div><pre><code><span>public</span> <span>abstract</span> <span>String</span> <span>toString</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>这是这个抽象类中唯一的一个抽象方法，需要子类去实现。</p>\n<p>作者：张家界的雪\n链接：https://www.jianshu.com/p/77e82f324144\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "13.System类",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/13.System%E7%B1%BB/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/13.System%E7%B1%BB/",
      "content_html": "<h1 id=\"_13-system类\"> 13.System类</h1>\n<p>说起System类，对我们来说既熟悉又陌生，熟悉的是我们刚接触java时就会用到这个类，甚至每天写代码也会用到这个类(System.out.println())；陌生的是我们对这个类一知半解，它是如何实现的，为什么这样写就能在屏幕上输出东西。今天就让我们通过阅读它的源码揭开它那神秘的面纱。</p>\n<h3 id=\"基础知识\"> 基础知识：</h3>\n<h4 id=\"深拷贝与浅拷贝\"> 深拷贝与浅拷贝:</h4>\n<p>浅拷贝：只是简单的对对象的引用进行复制。\n深拷贝：拷贝对象的值和对象的内容。</p>\n<h3 id=\"类定义\"> 类定义：</h3>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>System</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>System类是被final修饰的，不能被继承。</p>\n<p>成员变量：</p>\n<div><pre><code><span>//标准输入流，一般接收键盘输入</span>\n<span>public</span> <span>final</span> <span>static</span> <span>InputStream</span> in <span>=</span> <span>null</span><span>;</span>\n<span>//标准输出流，向控制台输出正确信息</span>\n<span>public</span> <span>final</span> <span>static</span> <span>PrintStream</span> out <span>=</span> <span>null</span>\n<span>//标准输出流，向控制台输出错误信息</span>\n<span>public</span> <span>final</span> <span>static</span> <span>PrintStream</span> err <span>=</span> <span>null</span><span>;</span>\n<span>//安全管理器，用volatile关键字修饰，表示对象在多个线程间可见</span>\n<span>private</span> <span>static</span> <span>volatile</span> <span>SecurityManager</span> security <span>=</span> <span>null</span><span>;</span>\n<span>//JAVA控制台对象与JAVA虚拟机相联，接收控制台输入，或向控制台输出信息。只能在控制台运行代码，否则获得对象为null。</span>\n<span>private</span> <span>static</span> <span>volatile</span> <span>Console</span> cons <span>=</span> <span>null</span><span>;</span>\n<span>//用于承装系统属性，如os.name os.version等</span>\n<span>private</span> <span>static</span> <span>Properties</span> props<span>;</span>\n<span>//换行符widows返回\"\\r\\n\",UNIX系统返回\"\\n\"</span>\n<span>private</span> <span>static</span> <span>String</span> lineSeparator<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>看到这些成员变量，有些是公有的，有些是私有的。这些对象被赋值为null，而且有的被final修饰不能被重新赋值。找遍整个类也没看到在哪里初始化这些对象。但我们使用System.out.println();的时候并没有报错啊。能够使用，就说明对象在谋个时刻被创建了，那到底这些对象是什么时候被创建的呢。怀着无比好奇的心理，在类中查找，忽然我看到了如下代码。</p>\n<div><pre><code><span>static</span> <span>{</span>\n    <span>registerNatives</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>private</span> <span>static</span> <span>native</span> <span>void</span> <span>registerNatives</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>静态代码块，类被加载的时候执行，会不会这些对象是在registerNatives方法中创建的呢。再一看这个方法是本地方法。看下注释，也看不懂，但隐约能看到VM啊，initializer啊，initializeSystemClass method之类的，找了一下，发现类中有一个initializeSystemClass方法，大概能猜到，是VM会执行这个方法。</p>\n<div><pre><code><span>private</span> <span>static</span> <span><span>void</span></span> <span>initializeSystemClass</span><span>(</span><span>)</span> <span>{</span>\n    props <span>=</span> <span>new</span> <span>Properties</span><span>(</span><span>)</span><span>;</span>\n    <span>initProperties</span><span>(</span>props<span>)</span><span>;</span>  <span>// initialized by the VM</span>\n    sun<span>.</span>misc<span>.</span>VM<span>.</span><span>saveAndRemoveProperties</span><span>(</span>props<span>)</span><span>;</span>\n    lineSeparator <span>=</span> props<span>.</span><span>getProperty</span><span>(</span><span>\"line.separator\"</span><span>)</span><span>;</span>\n    sun<span>.</span>misc<span>.</span>Version<span>.</span><span>init</span><span>(</span><span>)</span><span>;</span>\n    <span>FileInputStream</span> fdIn <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span>FileDescriptor<span>.</span><span>in</span><span>)</span><span>;</span>\n    <span>FileOutputStream</span> fdOut <span>=</span> <span>new</span> <span>FileOutputStream</span><span>(</span>FileDescriptor<span>.</span><span>out</span><span>)</span><span>;</span>\n    <span>FileOutputStream</span> fdErr <span>=</span> <span>new</span> <span>FileOutputStream</span><span>(</span>FileDescriptor<span>.</span>err<span>)</span><span>;</span>\n    <span>setIn0</span><span>(</span><span>new</span> <span>BufferedInputStream</span><span>(</span>fdIn<span>)</span><span>)</span><span>;</span>\n    <span>setOut0</span><span>(</span><span>newPrintStream</span><span>(</span>fdOut<span>,</span> props<span>.</span><span>getProperty</span><span>(</span><span>\"sun.stdout.encoding\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>setErr0</span><span>(</span><span>newPrintStream</span><span>(</span>fdErr<span>,</span> props<span>.</span><span>getProperty</span><span>(</span><span>\"sun.stderr.encoding\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>loadLibrary</span><span>(</span><span>\"zip\"</span><span>)</span><span>;</span>\n    Terminator<span>.</span><span>setup</span><span>(</span><span>)</span><span>;</span>\n    sun<span>.</span>misc<span>.</span>VM<span>.</span><span>initializeOSEnvironment</span><span>(</span><span>)</span><span>;</span>\n    <span>Thread</span> current <span>=</span> Thread<span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>\n    current<span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>.</span><span>add</span><span>(</span>current<span>)</span><span>;</span>\n    <span>setJavaLangAccess</span><span>(</span><span>)</span><span>;</span>\n    sun<span>.</span>misc<span>.</span>VM<span>.</span><span>booted</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>在这个方法中可以看到刚才那些对象都是在这里被创建的。\nlineSeparator = props.getProperty(&quot;line.separator&quot;);从系统中获取换行符。\nsetIn0(new BufferedInputStream(fdIn));设置标准输入流，也就是创建in对象，追溯到源头也就是创建了FileDescriptor.in对象，这个对象用于操作标准输入流，再往深了就到了虚拟机内部实现细节了，这里就有展开了，有兴趣的同学可以自行研究。\n其它的对象像out、err创建过程同in类似。到这里我们终于明白了为什么执行System.out.println()时会向控制台输出东西了。</p>\n<h3 id=\"构造函数\"> 构造函数：</h3>\n<div><pre><code><span>private</span> <span>System</span><span>(</span><span>)</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>可以看到System类就一个构造函数，而且被私有化了，不允许我们创建对象。如果要使用这个类，只能使用类中的一些静态成员。这也是java中单例模式的雏形，把构造私有化，然后对外提供一个内部创建的唯一的对象，就形成单例了。</p>\n<h3 id=\"其它函数\"> 其它函数：</h3>\n<h4 id=\"setin\"> setIn:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>setIn</span><span>(</span><span>InputStream</span> in<span>)</span> <span>{</span>\n    <span>checkIO</span><span>(</span><span>)</span><span>;</span>\n    <span>setIn0</span><span>(</span>in<span>)</span><span>;</span>\n<span>}</span>\n<span>//对setIo进行安全检查</span>\n<span>private</span> <span>static</span> <span>void</span> <span>checkIO</span><span>(</span><span>)</span> <span>{</span>\n    <span>SecurityManager</span> sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        sm<span>.</span><span>checkPermission</span><span>(</span><span>new</span> <span>RuntimePermission</span><span>(</span><span>\"setIO\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>//给System.in重新赋值，内部实现。</span>\n<span>private</span> <span>static</span> <span>native</span> <span>void</span> <span>setIn0</span><span>(</span><span>InputStream</span> in<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>给System.in对象重新赋值。即当调用了些方法后，我们再使用System.in的时候接收的信息不再是从键盘录入了，而是我们指定的文件或设备。点开函数可以看到，第一个函数是进行安全检查的，第二个函数是调用的本地方法。有人疑惑System.in变量不是被final修饰了吗，为什么还可以被修改。额...这个...它调用的是本地方法，由虚拟机内部实现，他是老大能不能改变他说了算。</p>\n<h4 id=\"setout\"> setOut:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span><span>void</span></span> <span>setOut</span><span>(</span>PrintStream <span>out</span><span>)</span> <span>{</span>\n    <span>checkIO</span><span>(</span><span>)</span><span>;</span>\n    <span>setOut0</span><span>(</span><span>out</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>给System.out重新赋值，原理同setIn。比如我们想让System.out.println()把内容输出到文件，就可以调用这个方法，指定输出文件。</p>\n<h4 id=\"seterr\"> setErr:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>setErr</span><span>(</span>PrintStream err<span>)</span> <span>{</span>\n    <span>checkIO</span><span>(</span><span>)</span><span>;</span>\n    <span>setErr0</span><span>(</span>err<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>给System.err重新赋值，原理同setOut。</p>\n<h4 id=\"console\"> console:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>Console</span> <span>console</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>cons <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        <span>synchronized</span> <span>(</span><span>System</span><span>.</span><span>class</span><span>)</span> <span>{</span>\n            cons <span>=</span> <span><span>sun<span>.</span>misc<span>.</span></span>SharedSecrets</span><span>.</span><span>getJavaIOAccess</span><span>(</span><span>)</span><span>.</span><span>console</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> cons<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>返回唯一的Console对象，这个对象是跟Java虚拟机相关联的。可以看到这里使用了synchronized代码块，避免多线程调用的时候返回多个Console对象。</p>\n<h4 id=\"inheritedchannel\"> inheritedChannel:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>Channel</span> <span>inheritedChannel</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n    <span>return</span> <span>SelectorProvider</span><span>.</span><span>provider</span><span>(</span><span>)</span><span>.</span><span>inheritedChannel</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>返回从创建此 java 虚拟机的实体中继承的通道。如果有则返回，没有返回null。</p>\n<h4 id=\"securitymanager设置与获取\"> SecurityManager设置与获取：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>setSecurityManager</span><span>(</span><span>final</span> <span>SecurityManager</span> s<span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n        s<span>.</span><span>checkPackageAccess</span><span>(</span><span>\"java.lang\"</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n        <span>// no-op</span>\n    <span>}</span>\n    <span>setSecurityManager0</span><span>(</span>s<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>static</span> <span>SecurityManager</span> <span>getSecurityManager</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> security<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>设置和获取java的安全管理器，当运行未知的Java程序的时候，该程序可能有操作如删除系统文件、重启系统等，为了防止运行恶意代码对系统产生影响，需要对运行的代码的权限进行控制，这时候就要启用Java安全管理器。</p>\n<p>currentTimeMillis:</p>\n<div><pre><code><span>public</span> <span>static</span> <span>native</span> <span>long</span> <span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>获取当前系统时间的毫秒数。1秒=1000毫秒(ms);</p>\n<h4 id=\"nanotime\"> nanoTime:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>native</span> <span>long</span> <span>nanoTime</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>获取当前系统时间的纳秒数。1秒=1,000,000,000 纳秒(ns);</p>\n<h4 id=\"arraycopy\"> arraycopy:</h4>\n<div><pre><code><span>public</span> <span>static</span> native <span>void</span> <span>arraycopy</span><span>(</span>\n    Object src<span>,</span><span>//源数组</span>\n    <span>int</span>  srcPos<span>,</span> <span>//源数组要复制的起始位置</span>\n    Object dest<span>,</span> <span>//目标数组</span>\n    <span>int</span> destPos<span>,</span> <span>//目标数组的起始位置</span>\n    <span>int</span> length<span>//复制的长度</span>\n<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>复制数组，从一个明确的数组中复制数组元素到另一个数组中。System.arraycopy采用的是浅复制，使用的时候注意一下。</p>\n<h4 id=\"identityhashcode\"> identityHashCode:</h4>\n<div><pre><code>    <span>public</span> <span>static</span> <span>native</span> <span>int</span> <span>identityHashCode</span><span>(</span><span>Object</span> x<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>获取对象的hashCode,一般可通过对象的hashCode()方法获取对象的hashCode,但有些对象重写了hashCode()方法，那么想要获取对象的hashCode时就要使用本方法了。</p>\n<h4 id=\"props\"> props：</h4>\n<div><pre><code>    <span>private</span> <span>static</span> <span>Properties</span> props<span>;</span>\n    <span>private</span> <span>static</span> <span>native</span> <span>Properties</span> <span>initProperties</span><span>(</span><span>Properties</span> props<span>)</span><span>;</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>setProperties</span><span>(</span><span>Properties</span> props<span>)</span> <span>{</span>\n        <span>SecurityManager</span> sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            sm<span>.</span><span>checkPropertiesAccess</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>props <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            props <span>=</span> <span>new</span> <span>Properties</span><span>(</span><span>)</span><span>;</span>\n            <span>initProperties</span><span>(</span>props<span>)</span><span>;</span>\n        <span>}</span>\n        <span>System</span><span>.</span>props <span>=</span> props<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>Properties</span> <span>getProperties</span><span>(</span><span>)</span> <span>{</span>\n        <span>SecurityManager</span> sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            sm<span>.</span><span>checkPropertiesAccess</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>return</span> props<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>props是用于承装java的系统变量的，initProperties是初始化props对象，本地方法实现。setProperties()重新设置系统的Properties对象。getProperties()方法用于获取Properties对象。不论是设置还是获取都先会进行安全检查，看是否对系统属性有安全限制。获取Properties对象后可重新设值取值。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>setProperty</span><span>(</span><span>String</span> key<span>,</span> <span>String</span> value<span>)</span> <span>{</span>\n    <span>checkKey</span><span>(</span>key<span>)</span><span>;</span>\n    <span>SecurityManager</span> sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        sm<span>.</span><span>checkPermission</span><span>(</span><span>new</span> <span>PropertyPermission</span><span>(</span>key<span>,</span>\n                                                  <span>SecurityConstants</span><span>.</span>PROPERTY_WRITE_ACTION<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> <span>(</span><span>String</span><span>)</span> props<span>.</span><span>setProperty</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>设置系统属性到Properties对象中，如果已经存在则覆盖原有属性，并返回原有属性。该对象是全局的，在程序中到处都可以调用。</p>\n<h4 id=\"getproperty\"> getProperty:</h4>\n<div><pre><code><span>public</span> <span>static</span> String <span>getProperty</span><span>(</span><span>String key</span><span>)</span> <span>{</span>\n    <span>checkKey</span><span>(</span>key<span>)</span><span>;</span>\n    SecurityManager sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        sm<span>.</span><span>checkPropertyAccess</span><span>(</span>key<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> props<span>.</span><span>getProperty</span><span>(</span>key<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>从Properties中获取系统属性，如果有则返回，如果没有返回null。</p>\n<h4 id=\"getproperty-string-key-string-def\"> getProperty(String key, String def):</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>getProperty</span><span>(</span><span>String</span> key<span>,</span> <span>String</span> def<span>)</span> <span>{</span>\n    <span>checkKey</span><span>(</span>key<span>)</span><span>;</span>\n    <span>SecurityManager</span> sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        sm<span>.</span><span>checkPropertyAccess</span><span>(</span>key<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> props<span>.</span><span>getProperty</span><span>(</span>key<span>,</span> def<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>从Properties中获取系统属性，如果有则返回，如果没有返回默认值，第二个参数为默认值。</p>\n<h4 id=\"clearproperty\"> clearProperty:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>clearProperty</span><span>(</span><span>String</span> key<span>)</span> <span>{</span>\n    <span>checkKey</span><span>(</span>key<span>)</span><span>;</span>\n    <span>SecurityManager</span> sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        sm<span>.</span><span>checkPermission</span><span>(</span><span>new</span> <span>PropertyPermission</span><span>(</span>key<span>,</span> <span>\"write\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> <span>(</span><span>String</span><span>)</span> props<span>.</span><span>remove</span><span>(</span>key<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>用于清除系统属性，并返回原属性值。</p>\n<h4 id=\"lineseparator\"> lineSeparator:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>lineSeparator</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> lineSeparator<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>获取系统的换行符widows系统返回&quot;\\r\\n&quot;,UNIX系统返回&quot;\\n&quot;。</p>\n<h4 id=\"getenv\"> getenv:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span><span>java<span>.</span>util<span>.</span></span>Map</span><span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>></span></span> <span>getenv</span><span>(</span><span>)</span> <span>{</span>\n    <span>SecurityManager</span> sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        sm<span>.</span><span>checkPermission</span><span>(</span><span>new</span> <span>RuntimePermission</span><span>(</span><span>\"getenv.*\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> <span>ProcessEnvironment</span><span>.</span><span>getenv</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>获取java程序环境信息，如LOCALAPPDATA，JAVA_HOME等。返回的是一个Map对象。</p>\n<h4 id=\"exit\"> exit:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>exit</span><span>(</span><span>int</span> status<span>)</span> <span>{</span>\n    <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>exit</span><span>(</span>status<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>结束当前正在运行中的java虚拟机。参数0代表正常退出，非0代表异常退出。</p>\n<h4 id=\"gc\"> gc：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>gc</span><span>(</span><span>)</span> <span>{</span>\n    <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>gc</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>该方法用于告知虚拟机进行垃圾回收。垃圾收集器将运行以回收未使用的内存空间。注意这一步只是通知虚拟机要进行垃圾回收操作，虚拟机并不一定立即进行回收操作。</p>\n<h4 id=\"runfinalization\"> runFinalization:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>runFinalization</span><span>(</span><span>)</span> <span>{</span>\n    <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>runFinalization</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我们知道Object对象不有一个finalize方法，当进行垃圾回收时，对象被回收前会执行finalize方法。调用runFinalization方法运行处于挂起终止状态的所有对象的终止方法。Java虚拟机已经尽最大努力去完成所有未执行的终止方法。</p>\n<h4 id=\"load\"> load:</h4>\n<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>load</span><span>(</span><span>String</span> filename<span>)</span> <span>{</span>\n        <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>load0</span><span>(</span><span>Reflection</span><span>.</span><span>getCallerClass</span><span>(</span><span>)</span><span>,</span> filename<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>用于装载指定名称filename的系统库文件。filename必需是绝对路径。</p>\n<h4 id=\"loadlibrary\"> loadLibrary：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>loadLibrary</span><span>(</span><span>String</span> libname<span>)</span> <span>{</span>\n    <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>loadLibrary0</span><span>(</span><span>Reflection</span><span>.</span><span>getCallerClass</span><span>(</span><span>)</span><span>,</span> libname<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>加载系统中的本地库，如果是Windows系统加载的是xxx.dll，如果是unix系统加载的是xxx.so，注意该方法不能包含文件的扩展名，但该文件必需在JVM属性java.library.path所指向的路径中。</p>\n<h4 id=\"maplibraryname\"> mapLibraryName：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>native</span> <span>String</span> <span>mapLibraryName</span><span>(</span><span>String</span> libname<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>将一个库名称映射到特定于平台的、表示本机库的字符串中。有点抽象，比如你想映射mapLibraryName这个库名，映射到Windows平台就是mapLibraryName.dll映射到Unix平台就是mapLibraryName.so</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "3.StringBuffer类",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/3.StringBuffer%E7%B1%BB/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/3.StringBuffer%E7%B1%BB/",
      "content_html": "<h1 id=\"_3-stringbuffer类\"> 3.StringBuffer类</h1>\n<p>StringBuffer和String的区别?\n前者长度和内容可变，后者不可变。\n如果使用前者做字符串的拼接，不会浪费太多的资源。</p>\n<p>StringBuffer的构造方法：</p>\n<div><pre><code><span>//无参构造方法</span>\n<span>public</span> <span>StringBuffer</span><span>(</span><span>)</span>\n<span>//指定容量的字符串缓冲区对象</span>\n<span>public</span> <span>StringBuffer</span><span>(</span><span>int</span> capacity<span>)</span>\n<span>//指定字符串内容的字符串缓冲区对象</span>\n<span>public</span> <span>StringBuffer</span><span>(</span><span>String</span> str<span>)</span>\n<span>//默认容量为16</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>添加功能：</p>\n<div><pre><code><span>//追加</span>\n<span>public</span> <span>StringBuffer</span> <span>append</span><span>(</span><span>String</span> str<span>)</span>\n<span>//指定位置插入字符串</span>\n<span>public</span> <span>StringBuffer</span> <span>insert</span><span>(</span><span>int</span> offset<span>,</span><span>String</span> str<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>删除功能：</p>\n<div><pre><code><span>//删除指定位置的字符，并返回本身</span>\n<span>public</span> <span>StringBuffer</span> <span>deleteCharAt</span><span>(</span><span>int</span> index<span>)</span>\n<span>//删除从指定位置开始指定位置结束的内容，并返回本身</span>\n<span>public</span> <span>StringBuffer</span> <span>delete</span><span>(</span><span>int</span> start<span>,</span><span>int</span> end<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>替换功能：</p>\n<div><pre><code><span>//从start开始到end用str替换</span>\n<span>public</span> <span>StringBuffer</span> <span>replace</span><span>(</span><span>int</span> start<span>,</span><span>int</span> end<span>,</span><span>String</span> str<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>反转功能：</p>\n<div><pre><code><span>public</span> <span>StringBuffer</span> <span>reverse</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>截取功能:</p>\n<div><pre><code><span>// 注意返回值类型不再是StringBuffer本身了</span>\n<span>public</span> <span>String</span> <span>substring</span><span>(</span><span>int</span> start<span>)</span>\n<span>public</span> <span>String</span> <span>substring</span><span>(</span><span>int</span> start<span>,</span><span>int</span> end<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>String -转化为-StringBuffer</p>\n<div><pre><code><span>String</span> s <span>=</span> <span>\"hello\"</span><span>;</span>\n<span>// 注意：不能把字符串的值直接赋值给StringBuffer</span>\n<span>// StringBuffer sb = \"hello\";</span>\n<span>// StringBuffer sb = s;</span>\n<span>// 方式1:通过构造方法</span>\n<span>StringBuffer</span> sb <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span>s<span>)</span><span>;</span>\n<span>// 方式2：通过append()方法</span>\n<span>StringBuffer</span> sb2 <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>\nsb2<span>.</span><span>append</span><span>(</span>s<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>StringBuffer -转化为- String</p>\n<div><pre><code><span>StringBuffer</span> buffer <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>\"java\"</span><span>)</span><span>;</span>\n<span>// String(StringBuffer buffer)</span>\n<span>// 方式1:通过构造方法</span>\n<span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span>buffer<span>)</span><span>;</span>\n<span>// 方式2：通过toString()方法</span>\n<span>String</span> str2 <span>=</span> buffer<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>1：String,StringBuffer,StringBuilder的区别?\n　A:String是内容不可变的，而StringBuffer,StringBuilder都是内容可变的。\n　B:StringBuffer是同步的，数据安全,效率低;StringBuilder是不同步的,数据不安全,效率高</p>\n<p>2：StringBuffer和数组的区别?\n　　 二者都可以看出是一个容器，装其他的数据。\n　　 但是呢,StringBuffer的数据最终是一个字符串数据。\n　　 而数组可以放置多种数据，但必须是同一种数据类型的。</p>\n<p>3：形式参数：\n基本类型：形式参数的改变不影响实际参数\n引用类型：形式参数的改变直接影响实际参数\n*注意：\nString作为参数传递，效果和基本类型作为参数传递是一样的。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "2.String类",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/2.String%E7%B1%BB/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/2.String%E7%B1%BB/",
      "content_html": "<h1 id=\"_2-string类\"> 2.String类</h1>\n<p>String类是我们日常开发中使用最频繁的类之一，曾今有人说String类用的好坏能评判你是否是一个合格的java程序员。</p>\n<h4 id=\"基础知识\"> 基础知识：</h4>\n<p>String对象的存放位置：大家都知道java中的对象大都是存放在堆中的，但是String对象是一个特例，它被存放在常量池中。\n当创建一个字面量String对象时，首先会去检查常量池中这个对象的存在与否。\njava本地方法：一个本地方法就是一个java调用非java代码的接口。该方法是非java实现，由C或C++语言实现。形式是：\n修饰符 native 返回值类型 本地方法名(); 如public native String intern();\n在我们看java源码时如果追溯到了本地方法，在java层面上就到头了，如果需要更深层次的了解本地方法的实现，就需要下载openjdk源码然后看它是如何实现的了。有兴趣的同学可以看<a href=\"https://www.jianshu.com/p/4f73957acc5b\" target=\"_blank\" rel=\"noopener noreferrer\">如何查看java本地方法</a>这篇文章。</p>\n<h4 id=\"string类\"> String类:</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>String</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span> <span>Comparable</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span>CharSequence</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>可以看到String类是final修饰的不能被继承，同时它实现了Serializable接口可以序列化和反序列化，实现了Comparable支持字符串的比较，实现了CharSequence接口说明它是一个字符序列。</p>\n<h4 id=\"成员变量\"> 成员变量:</h4>\n<div><pre><code><span>private</span> <span>final</span> <span>char</span> value<span>[</span><span>]</span><span>;</span><span>//存储字符串</span>\n<span>private</span> <span>int</span> hash<span>;</span> <span>//字符串的hash code 默认是0</span>\n<span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>-</span><span>6849794470754667710L</span><span>;</span><span>//序列化id</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>String对象的字符串实际是维护在一个字符数组中的。操作字符串实际上就是操作这个字符数组,而且这个数组也是final修饰的不能够被改变。</p>\n<h3 id=\"构造方法\"> 构造方法:</h3>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> <span>\"\"</span><span>.</span><span>value</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>无参构造方法，值为空串。基本不用。</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>String</span> original<span>)</span> <span>{</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> original<span>.</span><span>value</span><span>;</span>\n        <span>this</span><span>.</span>hash <span>=</span> original<span>.</span>hash<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>参数String对象参数来构造String对象，该构造函数经常被用来做面试题。问new String(&quot;abc&quot;);共创建了几个对象。答案是两个，字面量&quot;abc&quot;创建一个对象放在常量池中，new String()又创建一个对象放在堆中。</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>char</span> <span>value</span><span>[</span><span>]</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> Arrays<span>.</span><span>copyOf</span><span>(</span><span>value</span><span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>通过整个char数组参数来构造String对象，实际将参数char数组值复制给String对象的char数组。</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>char</span> <span>value</span><span>[</span><span>]</span><span>,</span> <span><span>int</span></span> offset<span>,</span> <span><span>int</span></span> count<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>offset <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>offset<span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>count <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>count <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>count<span>)</span><span>;</span>\n            <span>}</span>\n            <span>if</span> <span>(</span>offset <span>&lt;=</span> <span>value</span><span>.</span>length<span>)</span> <span>{</span>\n                <span>this</span><span>.</span><span>value</span> <span>=</span> <span>\"\"</span><span>.</span><span>value</span><span>;</span>\n                <span>return</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>// Note: offset or count might be near -1>>>1.</span>\n        <span>if</span> <span>(</span>offset <span>></span> <span>value</span><span>.</span>length <span>-</span> count<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>offset <span>+</span> count<span>)</span><span>;</span>\n        <span>}</span>\n    <span>this</span><span>.</span><span>value</span> <span>=</span> Arrays<span>.</span><span>copyOfRange</span><span>(</span><span>value</span><span>,</span> offset<span>,</span> offset<span>+</span>count<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>截取入参数组的一部分来构造String对象，具体哪一部分由offset和count决定，其中做了些参数检查，传入非法参数会报数组越界异常StringIndexOutOfBoundsException</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>byte</span> bytes<span>[</span><span>]</span><span>,</span> <span><span>int</span></span> offset<span>,</span> <span><span>int</span></span> length<span>,</span> <span>String</span> charsetName<span>)</span>\n            <span>throws</span> UnsupportedEncodingException <span>{</span>\n        <span>if</span> <span>(</span>charsetName <span>==</span> <span>null</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>\"charsetName\"</span><span>)</span><span>;</span>\n        <span>checkBounds</span><span>(</span>bytes<span>,</span> offset<span>,</span> length<span>)</span><span>;</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> StringCoding<span>.</span><span>decode</span><span>(</span>charsetName<span>,</span> bytes<span>,</span> offset<span>,</span> length<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>通过byte数组构造String对象，将入参byte数组中指定内容，用指定charsetName的字符集转换后构造String对象。\n其中StringCoding.decode(charsetName, bytes, offset, length)是根据指定编码对byte数组进行解码，解码返回char数组。\ncheckBounds(bytes, offset, length)是对参数进行检查(源码如下)，该方法是私有的只能在String类中调用。</p>\n<div><pre><code><span>private</span> <span>static</span> <span><span>void</span></span> <span>checkBounds</span><span>(</span><span><span>byte</span><span>[</span><span>]</span></span> bytes<span>,</span> <span><span>int</span></span> offset<span>,</span> <span><span>int</span></span> length<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>length <span>&lt;</span> <span>0</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>length<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>offset <span>&lt;</span> <span>0</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>offset<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>offset <span>></span> bytes<span>.</span>length <span>-</span> length<span>)</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>offset <span>+</span> length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>public</span> <span>String</span><span>(</span><span>byte</span> bytes<span>[</span><span>]</span><span>,</span> <span><span>int</span></span> offset<span>,</span> <span><span>int</span></span> length<span>,</span> <span>Charset</span> charset<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>charset <span>==</span> <span>null</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>\"charset\"</span><span>)</span><span>;</span>\n        <span>checkBounds</span><span>(</span>bytes<span>,</span> offset<span>,</span> length<span>)</span><span>;</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span>  StringCoding<span>.</span><span>decode</span><span>(</span>charset<span>,</span> bytes<span>,</span> offset<span>,</span> length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>该构造方法与上述构造方法类似，只不过这里的字符集是用Charset指定的，上述是用String指定的。Charset与charsetName是java中表示字符集的两种不同形式。它们之间相互转换如下：\n字符串转Charset对象:Charset charset = Charset.forName(&quot;UTF-8&quot;);\nCharset对象转字符串：String s = charset.displayName();</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>byte</span> bytes<span>[</span><span>]</span><span>,</span> <span>String</span> charsetName<span>)</span>\n            <span>throws</span> <span>UnsupportedEncodingException</span> <span>{</span>\n        <span>this</span><span>(</span>bytes<span>,</span> <span>0</span><span>,</span> bytes<span>.</span>length<span>,</span> charsetName<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>String</span><span>(</span><span>byte</span> bytes<span>[</span><span>]</span><span>,</span> <span>Charset</span> charset<span>)</span> <span>{</span>\n        <span>this</span><span>(</span>bytes<span>,</span> <span>0</span><span>,</span> bytes<span>.</span>length<span>,</span> charset<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这两个方法同上述两个方法类似，上述是转换byte数组中的部分数据构造String对象，这里是转换全部byte数组构造String对象。通过转换byte数组构造String对象在工作中还是挺常用的。</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>byte</span> bytes<span>[</span><span>]</span><span>,</span> <span><span>int</span></span> offset<span>,</span> <span><span>int</span></span> length<span>)</span> <span>{</span>\n        <span>checkBounds</span><span>(</span>bytes<span>,</span> offset<span>,</span> length<span>)</span><span>;</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> StringCoding<span>.</span><span>decode</span><span>(</span>bytes<span>,</span> offset<span>,</span> length<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>String</span><span>(</span><span>byte</span> bytes<span>[</span><span>]</span><span>)</span> <span>{</span>\n        <span>this</span><span>(</span>bytes<span>,</span> <span>0</span><span>,</span> bytes<span>.</span>length<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>通过byte数组，不指定字符集构造String对象。实际要在 StringCoding.decode(bytes, offset, length);解码byte数组的时候会构造默认的字符编码，默认的也就是系统默认的可能过GBK，可能过UTF-8,也可能是其它。可通过-Dfile.encoding=UTF-8进行修改系统默认编码。</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>StringBuffer</span> buffer<span>)</span> <span>{</span>\n        <span>synchronized</span><span>(</span>buffer<span>)</span> <span>{</span>\n            <span>this</span><span>.</span><span>value</span> <span>=</span> Arrays<span>.</span><span>copyOf</span><span>(</span>buffer<span>.</span><span>getValue</span><span>(</span><span>)</span><span>,</span> buffer<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>通过StringBuffer构造String对象，StringBuffer内部也是维护了一个char数组，这里将StringBuffer数组中的内容复制给String对象中的数组。而且StringBuffer是线程安全的，所以这里也加了synchronized块保证线程安全。</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>StringBuilder</span> builder<span>)</span> <span>{</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> Arrays<span>.</span><span>copyOf</span><span>(</span>builder<span>.</span><span>getValue</span><span>(</span><span>)</span><span>,</span> builder<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>通过StringBuilder构造String对象，原理同StringBuffer一样，只不过StringBuilder是线程不安全的，所在这里没有加synchronized块。基础面试中面试官经常询问StringBuffer与StringBuilder的区别，有兴趣的同学可以搜一下。</p>\n<div><pre><code><span>String</span><span>(</span><span><span>char</span><span>[</span><span>]</span></span> <span>value</span><span>,</span> <span>boolean</span> share<span>)</span> <span>{</span>\n        <span>// assert share : \"unshared not supported\";</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> <span>value</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>乍一看不知道这个构造函数是用来干嘛的，仔细分析就知道这个函数大有作用。首先它同String(char[] value)函数相比多了个参数share，虽然在方法本身没有用到share，目前是只支持true，注释也说了不支持false。这个方法定义成这样应该是为了同String(char[] value)进行区分。否则没办法构成方法重载。再来看下这个方法的作用。它是直接将参数的地址传给了String对象，这样要比直接使用String(char[] value)的效率要高，因为String(char[] value)是逐一拷贝。有人会问这样Stirng对象和参数传过来的char[] value共享同一个数组，不就破坏了字符串的不可变性。设计都也考虑到了，所以它设置了保护用protected修饰而没有公开出去。所以从安全性角度考虑，他也是安全的。在java中也有很多地方用到了这种性能好的、节约内存的、安全的构造函数。如replace、concat、valueOf等方法。</p>\n<h3 id=\"其它方法\"> 其它方法</h3>\n<h4 id=\"length\"> length:</h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>length</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>value</span><span>.</span>length<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>获取字符串的长度，实际上就是返回内部数组的长度。因为char数组被final修饰是不可变的，只要构造完成char数组中的内容长度都不会改变，所以这里可以直接返回数组的长度。</p>\n<h4 id=\"isempty\"> isEmpty:</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>value</span><span>.</span>length <span>==</span> <span>0</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>判断字符串是否为空。同理如果char的长度为0则表示字符串空。</p>\n<h4 id=\"charat\"> charAt:</h4>\n<div><pre><code>    <span>public</span> <span><span>char</span></span> <span>charAt</span><span>(</span><span><span>int</span></span> index<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>(</span>index <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>index <span>>=</span> <span>value</span><span>.</span>length<span>)</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>value</span><span>[</span>index<span>]</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>获取字符串中指定索引位置的字符。先判断索引是否合法，不能小于0或是大于字符串长度。然后直接返回数组对应位置的字符。</p>\n<h4 id=\"codepointat\"> codePointAt:</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>codePointAt</span><span>(</span><span><span>int</span></span> index<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>(</span>index <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>index <span>>=</span> <span>value</span><span>.</span>length<span>)</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> Character<span>.</span><span>codePointAtImpl</span><span>(</span><span>value</span><span>,</span> index<span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>同charAt类似，获取字符串指定索引位置的字符的代码点。也就是将对应位置的字符转换成UniCode。</p>\n<h4 id=\"codepointbefore\"> codePointBefore:</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>codePointBefore</span><span>(</span><span><span>int</span></span> index<span>)</span> <span>{</span>\n        <span><span>int</span></span> i <span>=</span> index <span>-</span> <span>1</span><span>;</span>\n        <span>if</span> <span>(</span><span>(</span>i <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>i <span>>=</span> <span>value</span><span>.</span>length<span>)</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> Character<span>.</span><span>codePointBeforeImpl</span><span>(</span><span>value</span><span>,</span> index<span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>获取指定索引位置前一个位置的字符的代码点。</p>\n<h4 id=\"codepointcount\"> codePointCount:</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>codePointCount</span><span>(</span><span><span>int</span></span> beginIndex<span>,</span> <span><span>int</span></span> endIndex<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>beginIndex <span>&lt;</span> <span>0</span> <span>||</span> endIndex <span>></span> <span>value</span><span>.</span>length <span>||</span> beginIndex <span>></span> endIndex<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> Character<span>.</span><span>codePointCountImpl</span><span>(</span><span>value</span><span>,</span> beginIndex<span>,</span> endIndex <span>-</span> beginIndex<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>获取字符串代码点个数，是实际上的字符个数。length()方法返回的是使用的是UTF-16编码的字符代码单元数量，不一定是实际上我们认为的字符个数。如 String str = “/uD835/uDD6B”，那么机器会识别它是2个代码单元代理的1个代码点&quot;Z&quot;，故而，length的结果是代码单元数量2，而codePointCount()的结果是代码点数量1。</p>\n<h4 id=\"getchars-char-dst-int-dstbegin\"> getChars(char dst[], int dstBegin):</h4>\n<div><pre><code>    <span><span>void</span></span> <span>getChars</span><span>(</span><span>char</span> dst<span>[</span><span>]</span><span>,</span> <span><span>int</span></span> dstBegin<span>)</span> <span>{</span>\n        System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> <span>0</span><span>,</span> dst<span>,</span> dstBegin<span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>复制字符串中数组内容到指定字符数组指定位置中。该方法并没有范围检查，方法仅供内部使用不对外公开。</p>\n<h4 id=\"getchars-int-srcbegin-int-srcend-char-dst-int-dstbegin\"> getChars(int srcBegin, int srcEnd, char dst[], int dstBegin):</h4>\n<div><pre><code>    <span>public</span> <span><span>void</span></span> <span>getChars</span><span>(</span><span><span>int</span></span> srcBegin<span>,</span> <span><span>int</span></span> srcEnd<span>,</span> <span>char</span> dst<span>[</span><span>]</span><span>,</span> <span><span>int</span></span> dstBegin<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>srcBegin <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>srcBegin<span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>srcEnd <span>></span> <span>value</span><span>.</span>length<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>srcEnd<span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>srcBegin <span>></span> srcEnd<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>srcEnd <span>-</span> srcBegin<span>)</span><span>;</span>\n        <span>}</span>\n        System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> srcBegin<span>,</span> dst<span>,</span> dstBegin<span>,</span> srcEnd <span>-</span> srcBegin<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>获取字符串中指定位置的字符到目标字符数组中。该方法为公有的，做了范围检查。可以看到对外提供的方法还是要严谨一些。在工作中也是一样，内部使用的可以稍微宽松一些，对外提供的需要做严格的限制。</p>\n<h4 id=\"getbytes\"> getBytes:</h4>\n<div><pre><code>    <span>public</span> <span><span>byte</span><span>[</span><span>]</span></span> <span>getBytes</span><span>(</span><span>String</span> charsetName<span>)</span>\n            <span>throws</span> UnsupportedEncodingException <span>{</span>\n        <span>if</span> <span>(</span>charsetName <span>==</span> <span>null</span><span>)</span> <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> StringCoding<span>.</span><span>encode</span><span>(</span>charsetName<span>,</span> <span>value</span><span>,</span> <span>0</span><span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span><span>byte</span><span>[</span><span>]</span></span> <span>getBytes</span><span>(</span><span>Charset</span> charset<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>charset <span>==</span> <span>null</span><span>)</span> <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> StringCoding<span>.</span><span>encode</span><span>(</span>charset<span>,</span> <span>value</span><span>,</span> <span>0</span><span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span><span>byte</span><span>[</span><span>]</span></span> <span>getBytes</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> StringCoding<span>.</span><span>encode</span><span>(</span><span>value</span><span>,</span> <span>0</span><span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>获取字符串对应的字节数组。将字符串编码成byte数组并返回，其中前两个方法是调用者指定字符集，后一个方法使用系统默认的字符集。</p>\n<h4 id=\"equals\"> equals:</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> anObject<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>this</span> <span>==</span> anObject<span>)</span> <span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>anObject <span>instanceof</span> String<span>)</span> <span>{</span>\n            <span>String</span> anotherString <span>=</span> <span>(</span>String<span>)</span>anObject<span>;</span>\n            <span><span>int</span></span> n <span>=</span> <span>value</span><span>.</span>length<span>;</span>\n            <span>if</span> <span>(</span>n <span>==</span> anotherString<span>.</span><span>value</span><span>.</span>length<span>)</span> <span>{</span>\n                <span>char</span> v1<span>[</span><span>]</span> <span>=</span> <span>value</span><span>;</span>\n                <span>char</span> v2<span>[</span><span>]</span> <span>=</span> anotherString<span>.</span><span>value</span><span>;</span>\n                <span><span>int</span></span> i <span>=</span> <span>0</span><span>;</span>\n                <span>while</span> <span>(</span>n<span>--</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n                    <span>if</span> <span>(</span>v1<span>[</span>i<span>]</span> <span>!=</span> v2<span>[</span>i<span>]</span><span>)</span>\n                        <span>return</span> <span>false</span><span>;</span>\n                    i<span>++</span><span>;</span>\n                <span>}</span>\n                <span>return</span> <span>true</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>重写了Object类的equals方法，这里是比较两个字符器的内容是否完全相等。先判断长度是否相等，长度不相等字符串必然不相等。然后再逐一比较每个对应位置的字符是否相等，如果全部相等则返回true，否则返回false。</p>\n<h4 id=\"contentequals-stringbuffer-sb\"> contentEquals(StringBuffer sb) :</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>contentEquals</span><span>(</span><span>StringBuffer</span> sb<span>)</span> <span>{</span>\n        <span>return</span> <span>SequencontentEquals</span><span>(</span><span>(</span><span>Charce</span><span>)</span>sb<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>比较字符串与StringBuffer对象的内容是否相等，调用了contentEquals(CharSequence cs) 方法，该方法实现如下。</p>\n<h4 id=\"contentequals-charsequence-cs\"> contentEquals(CharSequence cs) :</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>contentEquals</span><span>(</span><span>CharSequence</span> cs<span>)</span> <span>{</span>\n        <span>// Argument is a StringBuffer, StringBuilder</span>\n        <span>if</span> <span>(</span>cs <span>instanceof</span> <span>AbstractStringBuilder</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>cs <span>instanceof</span> <span>StringBuffer</span><span>)</span> <span>{</span>\n                <span>synchronized</span><span>(</span>cs<span>)</span> <span>{</span>\n                   <span>return</span> <span>nonSyncContentEquals</span><span>(</span><span>(</span><span>AbstractStringBuilder</span><span>)</span>cs<span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>return</span> <span>nonSyncContentEquals</span><span>(</span><span>(</span><span>AbstractStringBuilder</span><span>)</span>cs<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>// Argument is a String</span>\n        <span>if</span> <span>(</span>cs <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>\n            <span>return</span> <span>equals</span><span>(</span>cs<span>)</span><span>;</span>\n        <span>}</span>\n        <span>// Argument is a generic CharSequence</span>\n        <span>char</span> v1<span>[</span><span>]</span> <span>=</span> value<span>;</span>\n        <span>int</span> n <span>=</span> v1<span>.</span>length<span>;</span>\n        <span>if</span> <span>(</span>n <span>!=</span> cs<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>v1<span>[</span>i<span>]</span> <span>!=</span> cs<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>)</span> <span>{</span>\n                <span>return</span> <span>false</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>比较字符串内容与字符序列内容是否相等。首先判断是否为AbstractStringBuilder类型，AbstractStringBuilder有两种实现方式，StringBuffer(线程安全的)和StringBuilder(线程不安全的)，如果是则判断是否为StringBuffer类型，此类判断需要加锁以保证线程安全，它们两个都调用了nonSyncContentEquals方法进行判断(见下)。其次判断是否为String类型,因为String类也实现了CharSequence接口，如果是则调用String类的equals方法。最后如果是其它字符序列，则逐一比较字符数组中每个位置的字符是否相等。</p>\n<h4 id=\"nonsynccontentequals\"> nonSyncContentEquals:</h4>\n<div><pre><code>    <span>private</span> <span>boolean</span> <span>nonSyncContentEquals</span><span>(</span><span>AbstractStringBuilder</span> sb<span>)</span> <span>{</span>\n        <span>char</span> v1<span>[</span><span>]</span> <span>=</span> <span>value</span><span>;</span>\n        <span>char</span> v2<span>[</span><span>]</span> <span>=</span> sb<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>\n        <span><span>int</span></span> n <span>=</span> v1<span>.</span>length<span>;</span>\n        <span>if</span> <span>(</span>n <span>!=</span> sb<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>for</span> <span>(</span><span><span>int</span></span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>v1<span>[</span>i<span>]</span> <span>!=</span> v2<span>[</span>i<span>]</span><span>)</span> <span>{</span>\n                <span>return</span> <span>false</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>该方法为私有的供String类内部使用，也使用了相同的逻辑，先判字符数组长度是否相等，再逐一进行比较。其实不论是String的equals方法，contentEquals(CharSequence cs) 方法还是nonSyncContentEquals方法里面的比较逻辑都差不多，是否可以考虑将这类似的逻辑抽取出来单独成立个方法呢。</p>\n<h4 id=\"equalsignorecase\"> equalsIgnoreCase:</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>equalsIgnoreCase</span><span>(</span><span>String</span> anotherString<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>this</span> <span>==</span> anotherString<span>)</span> <span>?</span> <span>true</span>\n                <span>:</span> <span>(</span>anotherString <span>!=</span> <span>null</span><span>)</span>\n                <span>&amp;&amp;</span> <span>(</span>anotherString<span>.</span><span>value</span><span>.</span>length <span>==</span> <span>value</span><span>.</span>length<span>)</span>\n                <span>&amp;&amp;</span> <span>regionMatches</span><span>(</span><span>true</span><span>,</span> <span>0</span><span>,</span> anotherString<span>,</span> <span>0</span><span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>从方法名也可以看出，该方法是忽略大小写比较字符串内容是否相同。先判断两个对象地址是否一样，地址一样内容自然也一样。再判断长度，如果长度一样再调用regionMatches方法进行比较(见后)。这里用了&amp;&amp;逻辑运算符的断路原理，如果前一个判断为假，后面的判断就没意义了。</p>\n<h4 id=\"compareto\"> compareTo:</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>compareTo</span><span>(</span><span>String</span> anotherString<span>)</span> <span>{</span>\n        <span><span>int</span></span> len1 <span>=</span> <span>value</span><span>.</span>length<span>;</span>\n        <span><span>int</span></span> len2 <span>=</span> anotherString<span>.</span><span>value</span><span>.</span>length<span>;</span>\n        <span><span>int</span></span> lim <span>=</span> Math<span>.</span><span>min</span><span>(</span>len1<span>,</span> len2<span>)</span><span>;</span>\n        <span>char</span> v1<span>[</span><span>]</span> <span>=</span> <span>value</span><span>;</span>\n        <span>char</span> v2<span>[</span><span>]</span> <span>=</span> anotherString<span>.</span><span>value</span><span>;</span>\n\n        <span><span>int</span></span> k <span>=</span> <span>0</span><span>;</span>\n        <span>while</span> <span>(</span>k <span>&lt;</span> lim<span>)</span> <span>{</span>\n            <span><span>char</span></span> c1 <span>=</span> v1<span>[</span>k<span>]</span><span>;</span>\n            <span><span>char</span></span> c2 <span>=</span> v2<span>[</span>k<span>]</span><span>;</span>\n            <span>if</span> <span>(</span>c1 <span>!=</span> c2<span>)</span> <span>{</span>\n                <span>return</span> c1 <span>-</span> c2<span>;</span>\n            <span>}</span>\n            k<span>++</span><span>;</span>\n        <span>}</span>\n        <span>return</span> len1 <span>-</span> len2<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>该方法是实现Comparable接口的方法，用于对字符串进行比较大小。逻辑是对两个字符串中的数组进行逐位比较大小，从第一位开始比较，大的字符串就大，如果相同就继续向下比较，直到比较出大小为止。这里取了两个字符串中长度较小的作为循环次数。从源码也可以看出字符串比较并不是我们表面上认为的先进行长度比较，长度不一样再进行每个位置的比较。</p>\n<h4 id=\"内部内\"> 内部内</h4>\n<div><pre><code>    <span>public</span> <span>static</span> <span>final</span> <span>Comparator</span><span><span>&lt;</span><span>String</span><span>></span></span> CASE_INSENSITIVE_ORDER\n                                         <span>=</span> <span>new</span> <span>CaseInsensitiveComparator</span><span>(</span><span>)</span><span>;</span>\n    <span>private</span> <span>static</span> <span>class</span> <span>CaseInsensitiveComparator</span>\n            <span>implements</span> <span>Comparator</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span> <span>{</span>\n        <span>// use serialVersionUID from JDK 1.2.2 for interoperability</span>\n        <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>8575799808933029326L</span><span>;</span>\n\n        <span>public</span> <span>int</span> <span>compare</span><span>(</span><span>String</span> s1<span>,</span> <span>String</span> s2<span>)</span> <span>{</span>\n            <span>int</span> n1 <span>=</span> s1<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n            <span>int</span> n2 <span>=</span> s2<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n            <span>int</span> min <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>n1<span>,</span> n2<span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> min<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>char</span> c1 <span>=</span> s1<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>\n                <span>char</span> c2 <span>=</span> s2<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>\n                <span>if</span> <span>(</span>c1 <span>!=</span> c2<span>)</span> <span>{</span>\n                    c1 <span>=</span> <span>Character</span><span>.</span><span>toUpperCase</span><span>(</span>c1<span>)</span><span>;</span>\n                    c2 <span>=</span> <span>Character</span><span>.</span><span>toUpperCase</span><span>(</span>c2<span>)</span><span>;</span>\n                    <span>if</span> <span>(</span>c1 <span>!=</span> c2<span>)</span> <span>{</span>\n                        c1 <span>=</span> <span>Character</span><span>.</span><span>toLowerCase</span><span>(</span>c1<span>)</span><span>;</span>\n                        c2 <span>=</span> <span>Character</span><span>.</span><span>toLowerCase</span><span>(</span>c2<span>)</span><span>;</span>\n                        <span>if</span> <span>(</span>c1 <span>!=</span> c2<span>)</span> <span>{</span>\n                            <span>// No overflow because of numeric promotion</span>\n                            <span>return</span> c1 <span>-</span> c2<span>;</span>\n                        <span>}</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n            <span>return</span> n1 <span>-</span> n2<span>;</span>\n        <span>}</span>   \n\n        <span>/** Replaces the de-serialized object. */</span>\n        <span>private</span> <span>Object</span> <span>readResolve</span><span>(</span><span>)</span> <span>{</span> <span>return</span> CASE_INSENSITIVE_ORDER<span>;</span> <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>该内部内实际上就是String类定义的一个内部比较器，私有的仅供内部使用，用于进行忽略大小写比较字符串是否相等。CaseInsensitiveComparator(大小写不敏感比较器)，只看名字不看其具体实现也能大致看出来其作用，可见起一个好的名字是多么的重要。比较逻辑是对每位字符逐一进行比较，如果不等则将字符转换为对应的大写字符再进行比较，如果还不等再转换为对应的小写进行比较，最后返回两个字符的大小即为整个字符串的大小。这里先转换为大写，再转换为小写的目的是不是所有的字符都是用英文字母进行表示的，比如汉字等。</p>\n<h4 id=\"comparetoignorecase\"> compareToIgnoreCase:</h4>\n<div><pre><code>    <span>public</span> <span>int</span> <span>compareToIgnoreCase</span><span>(</span>String str<span>)</span> <span>{</span>\n        <span>return</span> CASE_INSENSITIVE_ORDER<span>.</span><span>compare</span><span>(</span><span>this</span><span>,</span> str<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>忽略大小写比较两个字符串的大小，用到了上述内部内的比较逻辑。</p>\n<h4 id=\"regionmatches-int-toffset-string-other-int-ooffset-int-len\"> regionMatches(int toffset, String other, int ooffset,int len):</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>regionMatches</span><span>(</span><span><span>int</span></span> toffset<span>,</span> <span>String</span> other<span>,</span> <span><span>int</span></span> ooffset<span>,</span>\n            <span><span>int</span></span> len<span>)</span> <span>{</span>\n        <span>char</span> ta<span>[</span><span>]</span> <span>=</span> <span>value</span><span>;</span>\n        <span><span>int</span></span> to <span>=</span> toffset<span>;</span>\n        <span>char</span> pa<span>[</span><span>]</span> <span>=</span> other<span>.</span><span>value</span><span>;</span>\n        <span><span>int</span></span> po <span>=</span> ooffset<span>;</span>\n        <span>// Note: toffset, ooffset, or len might be near -1>>>1.</span>\n        <span>if</span> <span>(</span><span>(</span>ooffset <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>toffset <span>&lt;</span> <span>0</span><span>)</span>\n                <span>||</span> <span>(</span>toffset <span>></span> <span>(</span><span>long</span><span>)</span><span>value</span><span>.</span>length <span>-</span> len<span>)</span>\n                <span>||</span> <span>(</span>ooffset <span>></span> <span>(</span><span>long</span><span>)</span>other<span>.</span><span>value</span><span>.</span>length <span>-</span> len<span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>while</span> <span>(</span>len<span>--</span> <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>ta<span>[</span>to<span>++</span><span>]</span> <span>!=</span> pa<span>[</span>po<span>++</span><span>]</span><span>)</span> <span>{</span>\n                <span>return</span> <span>false</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>区域比较，比较两个字符串指定区域指定长度的内容是否相等。从指定区域，开始逐一比较指定长度字符数组内容是否相等。</p>\n<h4 id=\"regionmatches-boolean-ignorecase-int-toffset-string-other-int-ooffset-int-len\"> regionMatches(boolean ignoreCase, int toffset,String other, int ooffset, int len) :</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>regionMatches</span><span>(</span><span>boolean</span> ignoreCase<span>,</span> <span><span>int</span></span> toffset<span>,</span>\n            <span>String</span> other<span>,</span> <span><span>int</span></span> ooffset<span>,</span> <span><span>int</span></span> len<span>)</span> <span>{</span>\n        <span>char</span> ta<span>[</span><span>]</span> <span>=</span> <span>value</span><span>;</span>\n        <span><span>int</span></span> to <span>=</span> toffset<span>;</span>\n        <span>char</span> pa<span>[</span><span>]</span> <span>=</span> other<span>.</span><span>value</span><span>;</span>\n        <span><span>int</span></span> po <span>=</span> ooffset<span>;</span>\n        <span>// Note: toffset, ooffset, or len might be near -1>>>1.</span>\n        <span>if</span> <span>(</span><span>(</span>ooffset <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>toffset <span>&lt;</span> <span>0</span><span>)</span>\n                <span>||</span> <span>(</span>toffset <span>></span> <span>(</span><span>long</span><span>)</span><span>value</span><span>.</span>length <span>-</span> len<span>)</span>\n                <span>||</span> <span>(</span>ooffset <span>></span> <span>(</span><span>long</span><span>)</span>other<span>.</span><span>value</span><span>.</span>length <span>-</span> len<span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>while</span> <span>(</span>len<span>--</span> <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span><span>char</span></span> c1 <span>=</span> ta<span>[</span>to<span>++</span><span>]</span><span>;</span>\n            <span><span>char</span></span> c2 <span>=</span> pa<span>[</span>po<span>++</span><span>]</span><span>;</span>\n            <span>if</span> <span>(</span>c1 <span>==</span> c2<span>)</span> <span>{</span>\n                <span>continue</span><span>;</span>\n            <span>}</span>\n            <span>if</span> <span>(</span>ignoreCase<span>)</span> <span>{</span>\n                <span><span>char</span></span> u1 <span>=</span> Character<span>.</span><span>toUpperCase</span><span>(</span>c1<span>)</span><span>;</span>\n                <span><span>char</span></span> u2 <span>=</span> Character<span>.</span><span>toUpperCase</span><span>(</span>c2<span>)</span><span>;</span>\n                <span>if</span> <span>(</span>u1 <span>==</span> u2<span>)</span> <span>{</span>\n                    <span>continue</span><span>;</span>\n                <span>}</span>\n                <span>if</span> <span>(</span>Character<span>.</span><span>toLowerCase</span><span>(</span>u1<span>)</span> <span>==</span> Character<span>.</span><span>toLowerCase</span><span>(</span>u2<span>)</span><span>)</span> <span>{</span>\n                    <span>continue</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>该方法同上述方法类似，只是加了一个参数ignoreCase，是否忽略大小写，如果忽略大小写则还要将字符转换成对应的大写，小写进行比较。</p>\n<h4 id=\"startswith-string-prefix-int-toffset\"> startsWith(String prefix, int toffset)：</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>startsWith</span><span>(</span><span>String</span> prefix<span>,</span> <span><span>int</span></span> toffset<span>)</span> <span>{</span>\n        <span>char</span> ta<span>[</span><span>]</span> <span>=</span> <span>value</span><span>;</span>\n        <span><span>int</span></span> to <span>=</span> toffset<span>;</span>\n        <span>char</span> pa<span>[</span><span>]</span> <span>=</span> prefix<span>.</span><span>value</span><span>;</span>\n        <span><span>int</span></span> po <span>=</span> <span>0</span><span>;</span>\n        <span><span>int</span></span> pc <span>=</span> prefix<span>.</span><span>value</span><span>.</span>length<span>;</span>\n        <span>// Note: toffset might be near -1>>>1.</span>\n        <span>if</span> <span>(</span><span>(</span>toffset <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>toffset <span>></span> <span>value</span><span>.</span>length <span>-</span> pc<span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>while</span> <span>(</span><span>--</span>pc <span>>=</span> <span>0</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>ta<span>[</span>to<span>++</span><span>]</span> <span>!=</span> pa<span>[</span>po<span>++</span><span>]</span><span>)</span> <span>{</span>\n                <span>return</span> <span>false</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>判断字符串的子串是否以指定字符开始。如&quot;HelloWorld&quot;就是以指定前缀&quot;Hello&quot;开头。逻辑是先创建字符串与指定前缀的副本(目的是为了保护字符串和避免其它线程对字符串进行修改导致比较出错)，再从指定位置判断指定长度，也就是前缀长度字符串内容是否相等。</p>\n<h4 id=\"startswith-string-prefix\"> startsWith(String prefix):</h4>\n<div><pre><code>    <span>public</span> boolean <span>startsWith</span><span>(</span><span>String</span> <span>prefix</span><span>)</span> <span>{</span>\n        <span>return</span> <span>startsWith</span><span>(</span><span>prefix</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>同上述方法，只不过该方法的指定位置是从字符串的第0个位置开始。</p>\n<h4 id=\"endswith\"> endsWith:</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>endsWith</span><span>(</span><span>String</span> suffix<span>)</span> <span>{</span>\n        <span>return</span> <span>startsWith</span><span>(</span>suffix<span>,</span> <span>value</span><span>.</span>length <span>-</span> suffix<span>.</span><span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>判断字符串是否以指定字符结尾。调用了startsWith的判断逻辑。</p>\n<h4 id=\"hashcode\"> hashCode:</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>\n        <span><span>int</span></span> h <span>=</span> hash<span>;</span>\n        <span>if</span> <span>(</span>h <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>value</span><span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>char</span> val<span>[</span><span>]</span> <span>=</span> <span>value</span><span>;</span>\n\n            <span>for</span> <span>(</span><span><span>int</span></span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>value</span><span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                h <span>=</span> <span>31</span> <span>*</span> h <span>+</span> val<span>[</span>i<span>]</span><span>;</span>\n            <span>}</span>\n            hash <span>=</span> h<span>;</span>\n        <span>}</span>\n        <span>return</span> h<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>重写Object的hashCode方法。java中的hashCode有两个作用。一：Object的hashCode返回对象的内存地址。二：对象重写的hashCode配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable等。对于大量的元素比较时直接比较equals效率低下，可先判断hashCode再判断equals，因为不同的对象可能返回相同的hashCode(如&quot;Aa&quot;和&quot;BB&quot;的hashCode就一样),所以比较时有时需要再比较equals。hashCode只是起辅助作用。为了使字符串计算出来的hashCode尽可能的少重复，即降低哈希算法的冲突率，设计者选择了31这个乘数。选31有两个好处。1：31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一，其它的像37、41、43也是不错的乘数选择。2：31可以被 JVM 优化，31 * i = (i &lt;&lt; 5) - i。计算hashCode的原理也很简单，即用原hashCode乘以31再加上char数组的每位值。</p>\n<h4 id=\"indexof-int-ch\"> indexOf(int ch):</h4>\n<div><pre><code>    <span>public</span> <span>int</span> <span>indexOf</span><span>(</span><span>int</span> ch<span>)</span> <span>{</span>\n        <span>return</span> <span>indexOf</span><span>(</span>ch<span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>获取指定字符在字符串中第一次出现的索引位置。具体调用了indexOf(ch, 0) (见后)。</p>\n<h4 id=\"indexof-int-ch-int-fromindex\"> indexOf(int ch, int fromIndex):</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>indexOf</span><span>(</span><span><span>int</span></span> ch<span>,</span> <span><span>int</span></span> fromIndex<span>)</span> <span>{</span>\n        final <span><span>int</span></span> max <span>=</span> <span>value</span><span>.</span>length<span>;</span>\n        <span>if</span> <span>(</span>fromIndex <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            fromIndex <span>=</span> <span>0</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>fromIndex <span>>=</span> max<span>)</span> <span>{</span>\n            <span>// Note: fromIndex might be near -1>>>1.</span>\n            <span>return</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span>\n\n        <span>if</span> <span>(</span>ch <span>&lt;</span> Character<span>.</span>MIN_SUPPLEMENTARY_CODE_POINT<span>)</span> <span>{</span>\n            <span>// handle most cases here (ch is a BMP code point or a</span>\n            <span>// negative value (invalid code point))</span>\n            final <span><span>char</span><span>[</span><span>]</span></span> <span>value</span> <span>=</span> <span>this</span><span>.</span><span>value</span><span>;</span>\n            <span>for</span> <span>(</span><span><span>int</span></span> i <span>=</span> fromIndex<span>;</span> i <span>&lt;</span> max<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span><span>value</span><span>[</span>i<span>]</span> <span>==</span> ch<span>)</span> <span>{</span>\n                    <span>return</span> i<span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>return</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>return</span> <span>indexOfSupplementary</span><span>(</span>ch<span>,</span> fromIndex<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>获取指定字符在字符串中指定位置后第一次出现的索引位置。逻辑是：先对开始索引位置fromIndex进行检查，如果小于0则取0，如果大于数组长度则待查找的结果不存在，返回-1.如果fromIndex合法，再判断待查找的字符是否是在两个字节以内。ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT 这个条件非常重要，是分界BmpCode的界限,Character.MIN_SUPPLEMENTARY_CODE_POINT这个数代表十进制中62355，刚好是2个字节。如果在两个字节内则遍历字符数组找到即返回所引。待查找字符超过两个字节，则使用indexOfSupplementary(int ch, int fromIndex)方法进行查找。该方法是拆分字符的高低位进行比较,int类型在java中占4个字节，如果不是BmpCode代码(2字节以内)点是ValidCodePoint(2字节到四字节)，代码点是有高两位和低两位，这种类型的int转化为字符时分开来处理，作为两个字符。源码如下。</p>\n<div><pre><code>    <span>private</span> <span><span>int</span></span> <span>indexOfSupplementary</span><span>(</span><span><span>int</span></span> ch<span>,</span> <span><span>int</span></span> fromIndex<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>Character<span>.</span><span>isValidCodePoint</span><span>(</span>ch<span>)</span><span>)</span> <span>{</span>\n            final <span><span>char</span><span>[</span><span>]</span></span> <span>value</span> <span>=</span> <span>this</span><span>.</span><span>value</span><span>;</span>\n            final <span><span>char</span></span> hi <span>=</span> Character<span>.</span><span>highSurrogate</span><span>(</span>ch<span>)</span><span>;</span>\n            final <span><span>char</span></span> lo <span>=</span> Character<span>.</span><span>lowSurrogate</span><span>(</span>ch<span>)</span><span>;</span>\n            final <span><span>int</span></span> max <span>=</span> <span>value</span><span>.</span>length <span>-</span> <span>1</span><span>;</span>\n            <span>for</span> <span>(</span><span><span>int</span></span> i <span>=</span> fromIndex<span>;</span> i <span>&lt;</span> max<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span><span>value</span><span>[</span>i<span>]</span> <span>==</span> hi <span>&amp;&amp;</span> <span>value</span><span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>==</span> lo<span>)</span> <span>{</span>\n                    <span>return</span> i<span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>-</span><span>1</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id=\"lastindexof\"> lastIndexOf:</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>lastIndexOf</span><span>(</span><span><span>int</span></span> ch<span>)</span> <span>{</span>\n        <span>return</span> <span>lastIndexOf</span><span>(</span>ch<span>,</span> <span>value</span><span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span><span>int</span></span> <span>lastIndexOf</span><span>(</span><span><span>int</span></span> ch<span>,</span> <span><span>int</span></span> fromIndex<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>ch <span>&lt;</span> Character<span>.</span>MIN_SUPPLEMENTARY_CODE_POINT<span>)</span> <span>{</span>\n            <span>// handle most cases here (ch is a BMP code point or a</span>\n            <span>// negative value (invalid code point))</span>\n            final <span><span>char</span><span>[</span><span>]</span></span> <span>value</span> <span>=</span> <span>this</span><span>.</span><span>value</span><span>;</span>\n            <span><span>int</span></span> i <span>=</span> Math<span>.</span><span>min</span><span>(</span>fromIndex<span>,</span> <span>value</span><span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span><span>value</span><span>[</span>i<span>]</span> <span>==</span> ch<span>)</span> <span>{</span>\n                    <span>return</span> i<span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>return</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>return</span> <span>lastIndexOfSupplementary</span><span>(</span>ch<span>,</span> fromIndex<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>从后住前查找指定字符在字符串中第一次出现的位置。原理同indexOf方法类似，这里就不赘述了。</p>\n<h4 id=\"\"> </h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>indexOf</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>\n        <span>return</span> <span>indexOf</span><span>(</span>str<span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span><span>int</span></span> <span>indexOf</span><span>(</span><span>String</span> str<span>,</span> <span><span>int</span></span> fromIndex<span>)</span> <span>{</span>\n        <span>return</span> <span>indexOf</span><span>(</span><span>value</span><span>,</span> <span>0</span><span>,</span> <span>value</span><span>.</span>length<span>,</span>\n                str<span>.</span><span>value</span><span>,</span> <span>0</span><span>,</span> str<span>.</span><span>value</span><span>.</span>length<span>,</span> fromIndex<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>查找指定字符串在原字符串中第一次出现的索引位置。具体实现是调用了indexOf(char[] source, int sourceOffset, int sourceCount,\nchar[] target, int targetOffset, int targetCount,int fromIndex)方法。实现如下。</p>\n<div><pre><code>    <span>static</span> <span>int</span> <span>indexOf</span><span>(</span><span>char</span><span>[</span><span>]</span> source<span>,</span> <span>int</span> sourceOffset<span>,</span> <span>int</span> sourceCount<span>,</span>\n            <span>char</span><span>[</span><span>]</span> target<span>,</span> <span>int</span> targetOffset<span>,</span> <span>int</span> targetCount<span>,</span>\n            <span>int</span> fromIndex<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>fromIndex <span>>=</span> sourceCount<span>)</span> <span>{</span>\n            <span>return</span> <span>(</span>targetCount <span>==</span> <span>0</span> <span>?</span> sourceCount <span>:</span> <span>-</span><span>1</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>fromIndex <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            fromIndex <span>=</span> <span>0</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>targetCount <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            <span>return</span> fromIndex<span>;</span>\n        <span>}</span>\n        <span>char</span> first <span>=</span> target<span>[</span>targetOffset<span>]</span><span>;</span>\n        <span>int</span> max <span>=</span> sourceOffset <span>+</span> <span>(</span>sourceCount <span>-</span> targetCount<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> sourceOffset <span>+</span> fromIndex<span>;</span> i <span>&lt;=</span> max<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>/* Look for first character. */</span>\n            <span>if</span> <span>(</span>source<span>[</span>i<span>]</span> <span>!=</span> first<span>)</span> <span>{</span>\n                <span>while</span> <span>(</span><span>++</span>i <span>&lt;=</span> max <span>&amp;&amp;</span> source<span>[</span>i<span>]</span> <span>!=</span> first<span>)</span><span>;</span>\n            <span>}</span>\n            <span>/* Found first character, now look at the rest of v2 */</span>\n            <span>if</span> <span>(</span>i <span>&lt;=</span> max<span>)</span> <span>{</span>\n                <span>int</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span>\n                <span>int</span> end <span>=</span> j <span>+</span> targetCount <span>-</span> <span>1</span><span>;</span>\n                <span>for</span> <span>(</span><span>int</span> k <span>=</span> targetOffset <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> end <span>&amp;&amp;</span> source<span>[</span>j<span>]</span>\n                        <span>==</span> target<span>[</span>k<span>]</span><span>;</span> j<span>++</span><span>,</span> k<span>++</span><span>)</span><span>;</span>\n                <span>if</span> <span>(</span>j <span>==</span> end<span>)</span> <span>{</span>\n                    <span>/* Found whole string. */</span>\n                    <span>return</span> i <span>-</span> sourceOffset<span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>-</span><span>1</span><span>;</span>\n    <span>}</span>            \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>该方法是保护的，只能在包内调用。逻辑是(假设是从第0个位置开始找，从其它位置开始逻辑类似)：\n1.遍历当前字符串，找到当前字符串中和参数str字符串第一个字符相同的字符的位置记为i。\n2.然后逐一比较接下来的每个字符是否相等，如果相等则返回，不等进行3\n3.从原字符串第i个位置后找与str第一个字符相等的位置，再比较接下来的每个字符是否相等。\n如此循环直到找到，或原字符串遍历完成结束方法。</p>\n<h4 id=\"lastindexof-string-str\"> lastIndexOf(String str)：</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>lastIndexOf</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>\n        <span>return</span> <span>lastIndexOf</span><span>(</span>str<span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>从后往前查找字符串str在原字符串中第一次出现的索引位置。该系列方法同indexOf(String str)系列方法逻辑类似。只不过查找顺序是从后往前。</p>\n<h4 id=\"substring-int-beginindex\"> substring(int beginIndex)：</h4>\n<div><pre><code>    <span>public</span> <span>String</span> <span>substring</span><span>(</span><span><span>int</span></span> beginIndex<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>beginIndex <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>beginIndex<span>)</span><span>;</span>\n        <span>}</span>\n        <span><span>int</span></span> subLen <span>=</span> <span>value</span><span>.</span>length <span>-</span> beginIndex<span>;</span>\n        <span>if</span> <span>(</span>subLen <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>subLen<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>(</span>beginIndex <span>==</span> <span>0</span><span>)</span> <span>?</span> <span>this</span> <span>:</span> <span>new</span> <span>String</span><span>(</span><span>value</span><span>,</span> beginIndex<span>,</span> subLen<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>截取字符串的子串。截取从指定位置beginIndex开始(包含这个位置)，到字符串结束之间的字符串内容。如果beginIndex=0则返回原串，否则创建一个新的字符串返回。</p>\n<h4 id=\"substring-int-beginindex-int-endindex\"> substring(int beginIndex, int endIndex):</h4>\n<div><pre><code>    <span>public</span> <span>String</span> <span>substring</span><span>(</span><span><span>int</span></span> beginIndex<span>,</span> <span><span>int</span></span> endIndex<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>beginIndex <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>beginIndex<span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>endIndex <span>></span> <span>value</span><span>.</span>length<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>endIndex<span>)</span><span>;</span>\n        <span>}</span>\n        <span><span>int</span></span> subLen <span>=</span> endIndex <span>-</span> beginIndex<span>;</span>\n        <span>if</span> <span>(</span>subLen <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>subLen<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>(</span><span>(</span>beginIndex <span>==</span> <span>0</span><span>)</span> <span>&amp;&amp;</span> <span>(</span>endIndex <span>==</span> <span>value</span><span>.</span>length<span>)</span><span>)</span> <span>?</span> <span>this</span>\n                <span>:</span> <span>new</span> <span>String</span><span>(</span><span>value</span><span>,</span> beginIndex<span>,</span> subLen<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>截取原字符串的子串，同上个方法类似，上一个方法的结束位置是原串的结尾，这个方法是指定结束位置endIndex(不包含这个位置)。需要注意的是这个方法是包含头不包含尾。</p>\n<h4 id=\"subsequence\"> subSequence:</h4>\n<div><pre><code>    <span>public</span> CharSequence <span>subSequence</span><span>(</span><span>int</span> beginIndex<span>,</span> <span>int</span> endIndex<span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span><span>substring</span><span>(</span>beginIndex<span>,</span> endIndex<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>截取指定区间内的字符序列。调用了substring方法，因为String本身就是一个CharSequence，所以这里可以直接返回。</p>\n<h4 id=\"concat\"> concat:</h4>\n<div><pre><code>    <span>public</span> <span>String</span> <span>concat</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>\n        <span><span>int</span></span> otherLen <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>otherLen <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            <span>return</span> <span>this</span><span>;</span>\n        <span>}</span>\n        <span><span>int</span></span> len <span>=</span> <span>value</span><span>.</span>length<span>;</span>\n        <span>char</span> buf<span>[</span><span>]</span> <span>=</span> Arrays<span>.</span><span>copyOf</span><span>(</span><span>value</span><span>,</span> len <span>+</span> otherLen<span>)</span><span>;</span>\n        str<span>.</span><span>getChars</span><span>(</span>buf<span>,</span> len<span>)</span><span>;</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>buf<span>,</span> <span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>连接两个字符串。先创建了一个新的字符数组复制了两个字符串中的内容。然后通过String(char[] value, boolean share)创建结果字符串。注意这里用的是直接复制引用的方式而不是复制数组中字符的内容来创建字符串，这可以提高效率，前面写字符串的构造方法时也提到过。创建的新的字符串，对原来的两个字符串的内容没有影响。</p>\n<h4 id=\"replace-char-oldchar-char-newchar\"> replace(char oldChar, char newChar):</h4>\n<div><pre><code>    <span>public</span> <span>String</span> <span>replace</span><span>(</span><span><span>char</span></span> oldChar<span>,</span> <span><span>char</span></span> newChar<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>oldChar <span>!=</span> newChar<span>)</span> <span>{</span>\n            <span><span>int</span></span> len <span>=</span> <span>value</span><span>.</span>length<span>;</span>\n            <span><span>int</span></span> i <span>=</span> <span>-</span><span>1</span><span>;</span>\n            <span><span>char</span><span>[</span><span>]</span></span> val <span>=</span> <span>value</span><span>;</span> <span>/* avoid getfield opcode */</span>\n\n            <span>while</span> <span>(</span><span>++</span>i <span>&lt;</span> len<span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>val<span>[</span>i<span>]</span> <span>==</span> oldChar<span>)</span> <span>{</span>\n                    <span>break</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>if</span> <span>(</span>i <span>&lt;</span> len<span>)</span> <span>{</span>\n                <span>char</span> buf<span>[</span><span>]</span> <span>=</span> <span>new</span> <span><span>char</span></span><span>[</span>len<span>]</span><span>;</span>\n                <span>for</span> <span>(</span><span><span>int</span></span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                    buf<span>[</span>j<span>]</span> <span>=</span> val<span>[</span>j<span>]</span><span>;</span>\n                <span>}</span>\n                <span>while</span> <span>(</span>i <span>&lt;</span> len<span>)</span> <span>{</span>\n                    <span><span>char</span></span> c <span>=</span> val<span>[</span>i<span>]</span><span>;</span>\n                    buf<span>[</span>i<span>]</span> <span>=</span> <span>(</span>c <span>==</span> oldChar<span>)</span> <span>?</span> newChar <span>:</span> c<span>;</span>\n                    i<span>++</span><span>;</span>\n                <span>}</span>\n                <span>return</span> <span>new</span> <span>String</span><span>(</span>buf<span>,</span> <span>true</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>this</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>将字符串中所有的旧字符oldChar，替换为新的字符newChar。逻辑是：先找到字符串中第一次出现oldChar字符的位置i。将之前的字符数组复制给新数组buf，然后从i后将字符数组中的内容复制给buf，只不过如果字符为oldCha则替换为newChar.然后再通过buf创建新的字符串返回。</p>\n<h4 id=\"matches\"> matches:</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>matches</span><span>(</span><span>String</span> regex<span>)</span> <span>{</span>\n        <span>return</span> <span>Pattern</span><span>.</span><span>matches</span><span>(</span>regex<span>,</span> <span>this</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>查找字符串是否包含指定正则规则的字符串。关于正则在java也是一个很有用知识点，有兴趣的同学可以查一下。</p>\n<h4 id=\"contains\"> contains:</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>CharSequence</span> s<span>)</span> <span>{</span>\n        <span>return</span> <span>indexOf</span><span>(</span>s<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span> <span>></span> <span>-</span><span>1</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>判断字符串中是否包含指定的字符序列。实际是调用indexOf方法，查找序列在字符串中的位置来判断的，如果不包含则查找的索引为-1.</p>\n<h4 id=\"replacefirst\"> replaceFirst：</h4>\n<div><pre><code>    public <span>String</span> <span>replaceFirst</span><span>(</span><span>String</span> regex<span>,</span> <span>String</span> replacement<span>)</span> <span>{</span>\n        <span>return</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span>regex<span>)</span><span>.</span><span>matcher</span><span>(</span><span>this</span><span>)</span><span>.</span><span>replaceFirst</span><span>(</span>replacement<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>替换第一个正则匹配项。需要注意一点，如果需要替换的内容中包含反斜杠\\需要用<img src=\"https://math.jianshu.com/math?formula=代替。这一点从注释中可以看出来。Note that backslashes (\\) and dollar signs ()\" alt=\"代替。这一点从注释中可以看出来。Note that backslashes (\\) and dollar signs (\" /> in the replacement</p>\n<h4 id=\"replaceall\"> replaceAll</h4>\n<div><pre><code>    public <span>String</span> <span>replaceAll</span><span>(</span><span>String</span> regex<span>,</span> <span>String</span> replacement<span>)</span> <span>{</span>\n        <span>return</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span>regex<span>)</span><span>.</span><span>matcher</span><span>(</span><span>this</span><span>)</span><span>.</span><span>replaceAll</span><span>(</span>replacement<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>替换所有的正则匹配项。同理新替换的内容中包含反斜杠\\需要用$代替。</p>\n<h4 id=\"split-string-regex-int-limit\"> split(String regex, int limit) :</h4>\n<div><pre><code>    <span>public</span> String<span>[</span><span>]</span> <span>split</span><span>(</span>String regex<span>,</span> <span>int</span> limit<span>)</span> <span>{</span>\n        <span>char</span> ch <span>=</span> <span>0</span><span>;</span>\n        <span>if</span> <span>(</span><span>(</span><span>(</span>regex<span>.</span>value<span>.</span>length <span>==</span> <span>1</span> <span>&amp;&amp;</span> <span>//判断参数长度是否为1</span>\n             <span>\".$|()[{^?*+\\\\\"</span><span>.</span><span>indexOf</span><span>(</span>ch <span>=</span> regex<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>)</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>||</span> <span>//判断参数不在特殊符号\".$|()[{^?*+\\\\\"中 </span>\n             <span>(</span>regex<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>2</span> <span>&amp;&amp;</span> <span>//判断参数长度是否为2</span>\n              regex<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>==</span> <span>'\\\\'</span> <span>&amp;&amp;</span>  \\\\第一位为转义符<span>\"\\\\\"</span>\n              <span>(</span><span>(</span><span>(</span>ch <span>=</span> regex<span>.</span><span>charAt</span><span>(</span><span>1</span><span>)</span><span>)</span><span>-</span><span>'0'</span><span>)</span><span>|</span><span>(</span><span>'9'</span><span>-</span>ch<span>)</span><span>)</span> <span>&lt;</span> <span>0</span> <span>&amp;&amp;</span> <span>//第二位不是0-9之间 '0'转换为int为48 '9'转换为int为57 </span>\n              <span>(</span><span>(</span>ch<span>-</span><span>'a'</span><span>)</span><span>|</span><span>(</span><span>'z'</span><span>-</span>ch<span>)</span><span>)</span> <span>&lt;</span> <span>0</span> <span>&amp;&amp;</span> <span>//判断不在 a-z之间</span>\n              <span>(</span><span>(</span>ch<span>-</span><span>'A'</span><span>)</span><span>|</span><span>(</span><span>'Z'</span><span>-</span>ch<span>)</span><span>)</span> <span>&lt;</span> <span>0</span><span>)</span><span>)</span> <span>&amp;&amp;</span> <span>//判断不在A-Z之间</span>\n            <span>(</span>ch <span>&lt;</span> Character<span>.</span>MIN_HIGH_SURROGATE <span>||</span> \n             ch <span>></span> Character<span>.</span>MAX_LOW_SURROGATE<span>)</span><span>)</span>  <span>//判断分隔符不在特殊符号中</span>\n        <span>{</span>\n            <span>int</span> off <span>=</span> <span>0</span><span>;</span><span>//当前索引</span>\n            <span>int</span> next <span>=</span> <span>0</span><span>;</span><span>//下一个分割符出现的索引</span>\n            boolean limited <span>=</span> limit <span>></span> <span>0</span><span>;</span><span>//只分割前limit份还是全部分割,limit=0代表全部分割</span>\n            ArrayList<span>&lt;</span>String<span>></span> list <span>=</span> <span>new</span> <span><span>ArrayList</span><span><span>&lt;</span><span>></span></span></span><span>(</span><span>)</span><span>;</span><span>//创建一个集合，用于存放切割好的子串</span>\n            <span>while</span> <span>(</span><span>(</span>next <span>=</span> <span>indexOf</span><span>(</span>ch<span>,</span> off<span>)</span><span>)</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span><span>//判断是否包含下个分隔符，如果有则进入循环</span>\n                <span>if</span> <span>(</span><span>!</span>limited <span>||</span> list<span>.</span><span>size</span><span>(</span><span>)</span> <span>&lt;</span> limit <span>-</span> <span>1</span><span>)</span> <span>{</span><span>//判断是全部分割或当前分割次数小于总分割次数</span>\n                    list<span>.</span><span>add</span><span>(</span><span>substring</span><span>(</span>off<span>,</span> next<span>)</span><span>)</span><span>;</span><span>//切割当前索引到下一个分隔符之间的字符串并添加到list中</span>\n                    off <span>=</span> next <span>+</span> <span>1</span><span>;</span> <span>//继续切割下一下子串</span>\n                <span>}</span> <span>else</span> <span>{</span>    <span>// last one</span>\n                    <span>//assert (list.size() == limit - 1);</span>\n                    list<span>.</span><span>add</span><span>(</span><span>substring</span><span>(</span>off<span>,</span> value<span>.</span>length<span>)</span><span>)</span><span>;</span><span>//切割当前索引到字符串结尾的子字符串并添加到list</span>\n                    off <span>=</span> value<span>.</span>length<span>;</span><span>//将当前索引置为字符串长度</span>\n                    <span>break</span><span>;</span><span>//结束循环</span>\n                <span>}</span>\n            <span>}</span>\n            <span>// If no match was found, return this</span>\n            <span>if</span> <span>(</span>off <span>==</span> <span>0</span><span>)</span> <span>//如果找不到分隔符则返回只有本字符串的数组</span>\n                <span>return</span> <span>new</span> String<span>[</span><span>]</span><span>{</span><span>this</span><span>}</span><span>;</span>\n\n            <span>// Add remaining segment</span>\n            <span>if</span> <span>(</span><span>!</span>limited <span>||</span> list<span>.</span><span>size</span><span>(</span><span>)</span> <span>&lt;</span> limit<span>)</span><span>//如果是全部分割，或者没有达到分割数，则追加最后一项</span>\n                list<span>.</span><span>add</span><span>(</span><span>substring</span><span>(</span>off<span>,</span> value<span>.</span>length<span>)</span><span>)</span><span>;</span>\n\n            <span>// Construct result</span>\n            <span>int</span> resultSize <span>=</span> list<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>limit <span>==</span> <span>0</span><span>)</span> <span>{</span><span>//移除多余集合项</span>\n                <span>while</span> <span>(</span>resultSize <span>></span> <span>0</span> <span>&amp;&amp;</span> list<span>.</span><span>get</span><span>(</span>resultSize <span>-</span> <span>1</span><span>)</span><span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                    resultSize<span>--</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            String<span>[</span><span>]</span> result <span>=</span> <span>new</span> String<span>[</span>resultSize<span>]</span><span>;</span><span>//创建对应长度数组，因为返回结果为字符串数组</span>\n            <span>return</span> list<span>.</span><span>subList</span><span>(</span><span>0</span><span>,</span> resultSize<span>)</span><span>.</span><span>toArray</span><span>(</span>result<span>)</span><span>;</span><span>//集合转数组并返回</span>\n        <span>}</span>\n        <span>return</span> Pattern<span>.</span><span>compile</span><span>(</span>regex<span>)</span><span>.</span><span>split</span><span>(</span><span>this</span><span>,</span> limit<span>)</span><span>;</span><span>//其它情况用正则的切割规则去切割</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p>根据指定规则切割原字符串。如 &quot;abc,def,ghi&quot;.split(&quot;,&quot;)则返回包含&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;三个字符串元素的字符串数组。源码分析直接写在源码中。</p>\n<h4 id=\"split\"> split:</h4>\n<div><pre><code>    <span>public</span> <span>String</span><span>[</span><span>]</span> <span>split</span><span>(</span><span>String</span> regex<span>)</span> <span>{</span> \n        <span>return</span> <span>split</span><span>(</span>regex<span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>根据指定规则切割字符串，切割全部子串。</p>\n<h4 id=\"join\"> join:</h4>\n<div><pre><code>    <span>public</span> <span>static</span> String <span>join</span><span>(</span><span>CharSequence</span> delimiter<span>,</span> CharSequence<span>..</span><span>.</span> elements<span>)</span> <span>{</span>\n        Objects<span>.</span><span>requireNonNull</span><span>(</span>delimiter<span>)</span><span>;</span>\n        Objects<span>.</span><span>requireNonNull</span><span>(</span>elements<span>)</span><span>;</span>\n        <span>// Number of elements not likely worth Arrays.stream overhead.</span>\n        <span>StringJoiner</span> joiner <span>=</span> <span>new</span> <span>StringJoiner</span><span>(</span>delimiter<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>CharSequence</span> cs<span>:</span> elements<span>)</span> <span>{</span>\n            joiner<span>.</span><span>add</span><span>(</span>cs<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> joiner<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> String <span>join</span><span>(</span><span>CharSequence</span> delimiter<span>,</span>\n            <span>Iterable<span>&lt;</span><span>?</span> extends CharSequence<span>></span></span> elements<span>)</span> <span>{</span>\n        Objects<span>.</span><span>requireNonNull</span><span>(</span>delimiter<span>)</span><span>;</span>\n        Objects<span>.</span><span>requireNonNull</span><span>(</span>elements<span>)</span><span>;</span>\n        <span>StringJoiner</span> joiner <span>=</span> <span>new</span> <span>StringJoiner</span><span>(</span>delimiter<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>CharSequence</span> cs<span>:</span> elements<span>)</span> <span>{</span>\n            joiner<span>.</span><span>add</span><span>(</span>cs<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> joiner<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>join方法是jdk1.8之后新加的方法，作用是将字符序列数组，或是字符序列集合通过分割符delimiter连接成一个字符串。提供这两个实现原理差不多，第一个方法使用的可变参数，第二个方法使用的可迭代参数，这样设计主要是为了让方法更好用，参数可以是一个数组也可以是一个集合。再来看下原理。\n通过遍历数组和集合将数组元素或集合元素添加到StringBuilder，添加前会先加入一个分割符delimiter,然后将StringBuilder中的内容返回，具体如下：</p>\n<div><pre><code>    <span>//1.StringJoiner的add方法,使用了方法调用链的方式，返回对象本身，可重复使用add方法。</span>\n    <span>public</span> StringJoiner <span>add</span><span>(</span><span>CharSequence</span> newElement<span>)</span> <span>{</span>\n        <span>prepareBuilder</span><span>(</span><span>)</span><span>.</span><span>append</span><span>(</span>newElement<span>)</span><span>;</span><span>//调用prepareBuilder()包含之前添加的元素和新加入一个分割符，然后再append添加新的元素</span>\n        <span>return</span> <span>this</span><span>;</span>\n    <span>}</span>\n    <span>//2.StringJoiner的prepareBuilder方法,内部维护了一个StringBuilder</span>\n    <span>private</span> <span>StringBuilder</span> <span>prepareBuilder</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>value</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>value</span><span>.</span><span>append</span><span>(</span>delimiter<span>)</span><span>;</span><span>//每次调用这个方法时会,往StringBuilder中添加分割符delimiter</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>value</span> <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>.</span><span>append</span><span>(</span>prefix<span>)</span><span>;</span><span>//第一次调用时创建StringBuilder对象</span>\n        <span>}</span>\n        <span>return</span> <span>value</span><span>;</span><span>//返回StringBuilder对象，以便下次调用的时候操作的是同一个StringBuilder</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id=\"大小写转换函数\"> 大小写转换函数:</h4>\n<div><pre><code>    <span>public</span> String <span>toLowerCase</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>toLowerCase</span><span>(</span>Locale<span>.</span><span>getDefault</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> String <span>toUpperCase</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>toUpperCase</span><span>(</span>Locale<span>.</span><span>getDefault</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>从名字可以看出这两个函数是对字符串进行大小写转换的，需要注意的是只是针对英文字母[a-z][A-Z]转换有效，其它字符转换无效。</p>\n<h4 id=\"trim\"> trim:</h4>\n<div><pre><code>    <span>public</span> <span>String</span> <span>trim</span><span>(</span><span>)</span> <span>{</span>\n        <span><span>int</span></span> len <span>=</span> <span>value</span><span>.</span>length<span>;</span>\n        <span><span>int</span></span> st <span>=</span> <span>0</span><span>;</span>\n        <span><span>char</span><span>[</span><span>]</span></span> val <span>=</span> <span>value</span><span>;</span>    <span>/* avoid getfield opcode */</span>\n\n        <span>while</span> <span>(</span><span>(</span>st <span>&lt;</span> len<span>)</span> <span>&amp;&amp;</span> <span>(</span>val<span>[</span>st<span>]</span> <span>&lt;=</span> <span>' '</span><span>)</span><span>)</span> <span>{</span>\n            st<span>++</span><span>;</span>\n        <span>}</span>\n        <span>while</span> <span>(</span><span>(</span>st <span>&lt;</span> len<span>)</span> <span>&amp;&amp;</span> <span>(</span>val<span>[</span>len <span>-</span> <span>1</span><span>]</span> <span>&lt;=</span> <span>' '</span><span>)</span><span>)</span> <span>{</span>\n            len<span>--</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>(</span><span>(</span>st <span>></span> <span>0</span><span>)</span> <span>||</span> <span>(</span>len <span>&lt;</span> <span>value</span><span>.</span>length<span>)</span><span>)</span> <span>?</span> <span>substring</span><span>(</span>st<span>,</span> len<span>)</span> <span>:</span> <span>this</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>去掉字符串两端的空白字符，空白字符包括，空格、tab、回车符。逻辑：\n1.从左到右循环字符数组，若字符为空字符，则继续循环，直到第一个不为空的字符记录其位置st。\n2.从右到左循环字符数组，若字符为空字符，则继续循环，直到第一个不为空的字符记录其位置len。\n3.截取字符串中从st到len位置的子串。</p>\n<h4 id=\"tostring\"> toString:</h4>\n<div><pre><code>    <span>public</span> String <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>返回字符串对象的字符串形式，实际上就是返回他本身。</p>\n<h4 id=\"tochararray\"> toCharArray:</h4>\n<div><pre><code>    <span>public</span> <span><span>char</span><span>[</span><span>]</span></span> <span>toCharArray</span><span>(</span><span>)</span> <span>{</span>\n        <span>// Cannot use Arrays.copyOf because of class initialization order issues</span>\n        <span>char</span> result<span>[</span><span>]</span> <span>=</span> <span>new</span> <span><span>char</span></span><span>[</span><span>value</span><span>.</span>length<span>]</span><span>;</span>\n        System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> <span>0</span><span>,</span> result<span>,</span> <span>0</span><span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n        <span>return</span> result<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>将字符串转换为字符数组返回。将字符串中维护的字符数组复制一份返回。这里有两点需要注意的地方：\n1.这里不能直接返回内部字符数组value，如果直接返回 value，返回的数组（假设为chArray）与value指向同一个地址，一旦你修改了 chArray数组的内容，value所指向的内容也随之改变，这样破坏了String的不变性。\n2.源码中有一行注释：Cannot use Arrays.copyOf because of class initialization order issues（由于类初始化顺序问题，无法使用ARARY.COSTOFF），这里我猜测是这样的，字符串比Arrays先初始化完成，但是在JDK中存在其它对象使用了toCharArray方法，而这个对象比String对象初始化晚，但比Arrays对象初始化早，导致使用时Arrays未初始化完成从而报错。故这里有了这个注释，而使用 System.arraycopy则不会存在这样的问题，因为这个方法是本地方法。</p>\n<h4 id=\"format\"> format</h4>\n<div><pre><code>    <span>public</span> <span>static</span> String <span>format</span><span>(</span><span>String format<span>,</span> Object<span>...</span> args</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>Formatter</span><span>(</span><span>)</span><span>.</span><span>format</span><span>(</span>format<span>,</span> args<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> String <span>format</span><span>(</span><span>Locale l<span>,</span> String format<span>,</span> Object<span>...</span> args</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>Formatter</span><span>(</span>l<span>)</span><span>.</span><span>format</span><span>(</span>format<span>,</span> args<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>用于创建格式化的字符串以及连接多个字符串对象。熟悉C语言的同学应该记得C语言的sprintf()方法，两者有类似之处。这里给出了两种重载形式，第一种使用本地语言环境，第二种使用指定的语言环境。\n如：String.format(&quot;Hi,%s:%s.%s&quot;, &quot;z3&quot;,&quot;l4&quot;,&quot;w5&quot;);返回Hi:z3,l4,w5</p>\n<h4 id=\"valueof系列\"> valueOf系列：</h4>\n<div><pre><code>    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>Object</span> obj<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>obj <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>\"null\"</span> <span>:</span> obj<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>char</span> data<span>[</span><span>]</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>data<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>char</span> data<span>[</span><span>]</span><span>,</span> <span>int</span> offset<span>,</span> <span>int</span> count<span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>data<span>,</span> offset<span>,</span> count<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>copyValueOf</span><span>(</span><span>char</span> data<span>[</span><span>]</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>data<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>boolean</span> b<span>)</span> <span>{</span>\n        <span>return</span> b <span>?</span> <span>\"true\"</span> <span>:</span> <span>\"false\"</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>char</span> c<span>)</span> <span>{</span>\n        <span>char</span> data<span>[</span><span>]</span> <span>=</span> <span>{</span>c<span>}</span><span>;</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>data<span>,</span> <span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>Integer</span><span>.</span><span>toString</span><span>(</span>i<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>long</span> l<span>)</span> <span>{</span>\n        <span>return</span> <span>Long</span><span>.</span><span>toString</span><span>(</span>l<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>float</span> f<span>)</span> <span>{</span>\n        <span>return</span> <span>Float</span><span>.</span><span>toString</span><span>(</span>f<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>double</span> d<span>)</span> <span>{</span>\n        <span>return</span> <span>Double</span><span>.</span><span>toString</span><span>(</span>d<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>valueOf系列，将传入的参数，转换成各自对应的字符串对象。需要注意两点：\n1.对于对象如果是null则返回字符串&quot;null&quot;.\n2.对于boolean类型真返回&quot;true&quot;,假返回&quot;false&quot;</p>\n<h4 id=\"intern\"> intern：</h4>\n<div><pre><code>    <span>public</span> <span>native</span> <span>String</span> <span>intern</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>最后String还有一个intern方法，这个方法是本地方法，无方法体。\njdk1.7之前intern方法执行后如果在常量池找不到对应的字符串，则会将字符串拷贝到常量池，然后返回常量池中的引用。\njdk1.7之后intern方法执行后如果在常量池找不到对应的字符串，则会在常量池中生成一个对原字符串的引用。\n原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。\n实际上在常量池中有一个对象StringTable，可以看作是一个HashSet。使用StringTable来维护所有存活的字符串的一个对象。\n使用String的intern方法可以节省内存。在某些情况下可以使用 intern() 方法，它能够使内存中的不同字符串都只有一个实例对象。\n看下面的例子：</p>\n<div><pre><code>    <span>public</span> <span>void</span> <span>testIntern</span><span>(</span><span>)</span> <span>{</span>\n        String str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"hello\"</span><span>)</span> <span>+</span> <span>new</span> <span>String</span><span>(</span><span>\"world\"</span><span>)</span><span>;</span>\n        str2<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span><span>// 使用intern方法后str2与str1指向同一个对象，否则它们指向两个不同的对象。这样就能达到节省内存的效果。</span>\n        String str1 <span>=</span> <span>\"helloworld\"</span><span>;</span>\n        System<span>.</span>out<span>.</span><span>println</span><span>(</span>str2 <span>==</span> str1<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>作者：张家界的雪\n链接：https://www.jianshu.com/p/b3e9deacd155\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n",
      "image": "https://math.jianshu.com/math?formula=%E4%BB%A3%E6%9B%BF%E3%80%82%E8%BF%99%E4%B8%80%E7%82%B9%E4%BB%8E%E6%B3%A8%E9%87%8A%E4%B8%AD%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%87%BA%E6%9D%A5%E3%80%82Note%20that%20backslashes%20(%5C",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "5.Number类",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/5.Number%E7%B1%BB/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/5.Number%E7%B1%BB/",
      "content_html": "<h1 id=\"_5-number类\"> 5.Number类</h1>\n<p>java是强类型语言，它提供了八种基本数据类型，  其中有六种数字类型，分别是byte、short、int、long、float、double。看源码我们自然看不到这些类型的源码，我们要看的是这些类型的包装类的源码。今天我们就看看这些类型的包装类的共同的祖先Number类的源码。</p>\n<p>包装类：java是一个面向对象的语言，但java的基本数据类型却不是面向对象的，这在实际的使用中会有诸多不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表。这八个和基本类型对应的类统称为包装类。</p>\n<h4 id=\"number抽象类中的方法\"> Number抽象类中的方法:</h4>\n<div><pre><code><span>public</span> <span>abstract</span> <span><span>int</span></span> <span>intValue</span><span>(</span><span>)</span><span>;</span>\n\n<span>public</span> <span>abstract</span> <span><span>long</span></span> <span>longValue</span><span>(</span><span>)</span><span>;</span>\n\n<span>public</span> <span>abstract</span> <span><span>float</span></span> <span>floatValue</span><span>(</span><span>)</span><span>;</span>\n\n<span>public</span> <span>abstract</span> <span><span>double</span></span> <span>doubleValue</span><span>(</span><span>)</span><span>;</span>\n\n<span>public</span> <span><span>byte</span></span> <span>byteValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>byte</span><span>)</span><span>intValue</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span><span>short</span></span> <span>shortValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>short</span><span>)</span><span>intValue</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>可以看到这些方法都是xxxValue，目的就是将数据转换为相对应的类型，如intValue就是将数据转换为int类型，byteValue就是将数据转换为byte类型，这点从返回值我们也可以看出来</p>\n<h4 id=\"思考\"> 思考：</h4>\n<p>1.byte、short、int、long、float、double都是数字类型，java为什么要搞出这么多的数字类型出来。\n2.Number是这些类型的父类，既然他们的范围不一样，那么转换时会不会出问题\n答1：因为它们的长度各不相同，使用它们是系统开销也不相同。它们有不同的特点，适用于不同的地方。我们可以根据不同的需要，而选择类型。\n答2：转换时当然会出问题，比如int类型的129你将它转换为byte时就会越界，得到的结果是-127。其它的大类型转换为小类型的时候也会有同样的问题，所以使用的时候要格外小心。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "6.Byte类",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/6.Byte%E7%B1%BB/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/6.Byte%E7%B1%BB/",
      "content_html": "<h1 id=\"_6-byte类\"> 6.Byte类</h1>\n<p>byte即字节的意思，java中的基本类型之一、也是java中长度最小的基本数字类型，通常在读取文件时需要用字节数组来保存文件内容。byte数组也常被用作缓冲器，接收文件内容。不管是读还是写文件都会用到。接下来就让我们看看byte类型的包装类Byte类的实现。</p>\n<h4 id=\"基础知识\"> 基础知识：</h4>\n<p>1.java的基本数据类型byte、short、int、long、float、double、char所占的字节长度分别为1、2、4、8、4、8、2。至于boolean所占的长度众说纷纭，有人说boolean只有真和假，只用一位存储就够了。实际上存储空间的基本计量单位是字节，不是位。所以boolean至少占一个字节。JVM规范中，boolean变量作为int处理，也就是4字节；boolean数组当做byte数组处理。\n2.java中字节容量的关系:\n1TB=1024GB      TB是千千兆\n1GB=1024MB      GB是千兆\n1MB=1024KB      MB是兆\n1KB=1024Byte    KB是千字节\n1Byte = 8bit        一个字节是8位\n3.byte与bit的关系:\n我们上面所说的字节也就是byte,是计算机文件大小的基本单位，而bit是Binary digit（二进制数位）的缩写,意为“位”或“比特”，是计算机运算的基础，计算机存储数据都是0和1组成的，每个0或1也就是占这里的1位，即一个bit.\n4.源码、反码、补码:\n在计算机内，定点数有3种表示法：原码、反码和补码\n原码：就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。\n反码：表示法规定：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。\n补码：表示法规定：正数的补码与其原码相同；负数的补码是在其反码的末位加1。\nJAVA中用补码表示二进制数.\n5.位运算\njava中的位运算包括&quot;或&quot;(|)、&quot;与&quot;(&amp;)、&quot;非&quot;(~)、&quot;异或&quot;(^)\n| : 两个操作数的位中，有一个为1，结果才为1，否则结果为0\n&amp; ：两个操作数的位中，全为1，结果才为1，否则结果为0\n~ : 如果位为0，结果是1，如果位为1，结果是0\n^ : 两个操作数的位中，相同则结果为0，不同则结果为1\n上述操作数的位表示的是把目标数据转换为二进制后的每一位，举个栗子：7 &amp; 10\n7转换为二进制后:                        0    1   1   1\n&amp;\n10转换为二进制后：                   1    0   1   0\n上下按&amp;的规则计算结果为          0   0    1   0\n即7&amp;10 = 2 ，其它的位运算操作类似</p>\n<h4 id=\"byte类\"> Byte类:</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Byte</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Byte</span><span>></span></span> <span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到Byte类继承了Number类，而又不是抽象类，自然要重写Number类中的xxxValue方法。另外Byte类实现了Comparable接口，Comparable是一个接口，该接口定义类的自然顺序,实现该接口的类就可以按这种方式排序，一般情况下如果某类对象自身具有比较的特性就可以实现该接口，比如这里的Byte代表的是一种数，而数本身就具有比较的特性，就可以实现该接口。</p>\n<h4 id=\"边界值\"> 边界值:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>byte</span>   MIN_VALUE <span>=</span> <span>-</span><span>128</span><span>;</span>\n<span>public</span> <span>static</span> <span>final</span> <span>byte</span>   MAX_VALUE <span>=</span> <span>127</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>诶，为什么最大值是127，最小值是-128.在基础知识中介绍了，java中用补码表示二进制。byte为1个字节，即8位。最高位是符号位。最大值是01111111，因正数的补码是其本身，即最大值的补码是01111111，最大值的原码也是01111111，所以，此正数为01111111即用十进制表示形式为127。最小值是10000000，由于是补码需要转换成原码，因此先减去1即01111111，然后取反10000000，这就是原码，原码就是10000000，这就是最小值的绝对值，即2^7=128，那么，最小值就是-128</p>\n<p>TYPE:</p>\n<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>Class</span><span><span>&lt;</span><span>Byte</span><span>></span></span>     TYPE <span>=</span> <span>(</span><span>Class</span><span><span>&lt;</span><span>Byte</span><span>></span></span><span>)</span> <span>Class</span><span>.</span><span>getPrimitiveClass</span><span>(</span><span>\"byte\"</span><span>)</span><span>;</span>\n其中<span>Class</span><span>.</span>getPrimitiveClass的源码为<span>:</span>\n<span>static</span> <span>native</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getPrimitiveClass</span><span>(</span><span>String</span> name<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个TYPE表示的是基本类型 byte 的 Class 实例，即byte.class</p>\n<h4 id=\"tostring-byte-b\"> toString(byte b):</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>toString</span><span>(</span><span><span>byte</span></span> b<span>)</span> <span>{</span>\n    <span>return</span> Integer<span>.</span><span>toString</span><span>(</span><span>(</span><span>int</span><span>)</span>b<span>,</span> <span>10</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意这里的toString可不是重写的Object类中的toString方法，Object中的toString方法是没有参数的，方法重写必须和父类中的方法一模一样。这里是将byte数据转换为对应的字符串形式，它调用了Integer.toString(int i, int radix)方法,这个方法等我们看<a href=\"https://www.jianshu.com/p/e07d126ac1d0\" target=\"_blank\" rel=\"noopener noreferrer\">Integer类的源码</a>时再讲解。</p>\n<h4 id=\"bytecache\"> ByteCache：</h4>\n<div><pre><code><span>private</span> <span>static</span> <span>class</span> <span>ByteCache</span> <span>{</span>\n        <span>private</span> <span>ByteCache</span><span>(</span><span>)</span><span>{</span><span>}</span>\n\n        <span>static</span> <span>final</span> <span>Byte</span> cache<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>Byte</span><span>[</span><span>-</span><span>(</span><span>-</span><span>128</span><span>)</span> <span>+</span> <span>127</span> <span>+</span> <span>1</span><span>]</span><span>;</span>\n\n        <span>static</span> <span>{</span>\n            <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cache<span>.</span>length<span>;</span> i<span>++</span><span>)</span>\n                cache<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Byte</span><span>(</span><span>(</span><span>byte</span><span>)</span><span>(</span>i <span>-</span> <span>128</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这是Byte的一个内部类，而且是私有的，只能在本类中调用。可以看到在这个类的内部定义了一个Byte类型的数组，数组的长度刚好是Byte类中最小值到最大值之间的长度(负数128个，正数127个加上0共256个)。在静态代码块中创建了这256个对象放到cache数组中，之前也介绍了静态代码块在类一加载的时候就会执行。这里是将byte类型所有的可能值(对于byte来说其实它的可能值就是从-128到127，一共256个)缓存起来，只能创建256个Byte对象就可以表示所有可能的byte。而且这些都是静态且final的，避免重复的实例化和回收。</p>\n<h4 id=\"valueof-byte-b\"> valueOf(byte b):</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>Byte</span> <span>valueOf</span><span>(</span><span>byte</span> b<span>)</span> <span>{</span>\n        <span>final</span> <span>int</span> offset <span>=</span> <span>128</span><span>;</span>\n        <span>return</span> <span>ByteCache</span><span>.</span>cache<span>[</span><span>(</span><span>int</span><span>)</span>b <span>+</span> offset<span>]</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这里的valueOf其实就是从上述缓存数组中取得对应的byte对象。因为数组下标是从0开始的不包含负数，所以这里会加上一个offset来取得数组对应位置的元素值</p>\n<h4 id=\"parsebyte-string-s-int-radix\"> parseByte(String s, int radix):</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>byte</span> <span>parseByte</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> radix<span>)</span>\n        <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>int</span> i <span>=</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>s<span>,</span> radix<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>&lt;</span> MIN_VALUE <span>||</span> i <span>></span> MAX_VALUE<span>)</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span>\n                <span>\"Value out of range. Value:\\\"\"</span> <span>+</span> s <span>+</span> <span>\"\\\" Radix:\"</span> <span>+</span> radix<span>)</span><span>;</span>\n        <span>return</span> <span>(</span><span>byte</span><span>)</span>i<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这个方法从方法名也可以看出来其作用，就是将一个字符串为byte，首先它调用了 Integer.parseInt(s, radix)将目标字符串转换为int值(对于这个方法我们看<a href=\"https://www.jianshu.com/p/e07d126ac1d0\" target=\"_blank\" rel=\"noopener noreferrer\">Integer类的源码</a>时再讲)，然后判断转换后的值是否在byte类型的数值范围内，如果是就返回，否就抛出一个异常。其中s就是要转换的目标字符串，radix就是目标字符串的进制表示法，常用的有2进制、8进制、10进制和16进制。</p>\n<h4 id=\"parsebyte-string-s\"> parseByte(String s)：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>byte</span> <span>parseByte</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>parseByte</span><span>(</span>s<span>,</span> <span>10</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>将10进制表示的字符串转换为byte数字。这个方法实际上是调用了上面的方法parseByte(String s, int radix)，只不过固定的转换的进制为10进制。</p>\n<p>valueOf(String s, int radix)和 valueOf(String s) ：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>Byte</span> <span>valueOf</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> radix<span>)</span>\n        <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>valueOf</span><span>(</span><span>parseByte</span><span>(</span>s<span>,</span> radix<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>static</span> <span>Byte</span> <span>valueOf</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>valueOf</span><span>(</span>s<span>,</span> <span>10</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>获取指定进制字符串，转换为byte后对应的Byte对象。在上面我们看了valueOf(byte b),获取byte数对应的Byte对应，这里无非是将传入的参数换成了字符串，在内部先将字符串转换为byte数然后再从缓存数组中获取对应的Byte对象。将字符串转换为byte数字和从缓存数组中取Byte对象在上面已经讲过了，这里就不再赘述了。</p>\n<h4 id=\"decode-string-nm\"> decode(String nm):</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>Byte</span> <span>decode</span><span>(</span><span>String</span> nm<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>int</span> i <span>=</span> <span>Integer</span><span>.</span><span>decode</span><span>(</span>nm<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>&lt;</span> MIN_VALUE <span>||</span> i <span>></span> MAX_VALUE<span>)</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span>\n                    <span>\"Value \"</span> <span>+</span> i <span>+</span> <span>\" out of range from input \"</span> <span>+</span> nm<span>)</span><span>;</span>\n        <span>return</span> <span>valueOf</span><span>(</span><span>(</span><span>byte</span><span>)</span>i<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>将其它进制表示法，表示的字符串数据转换为10进制表示的byte数据,然后返回对应的Byte对象。其中常用的&quot;其它&quot;进制表示法有16进制表示法(数字前加0x或#）、8进制表示法(在数字前面加0)、2进制表示法(用0和1表示数字)。具体怎么转换的要看Integer.decode(nm)的源码(对于这个方法我们看<a href=\"https://www.jianshu.com/p/e07d126ac1d0\" target=\"_blank\" rel=\"noopener noreferrer\">Integer类的源码</a>时再讲)。最后判断下转换后的数据是否在byte类型的数值范围内，然后调用valueOf(byte b)方法从缓存中获取Byte对象.</p>\n<h4 id=\"数据存放位置\"> 数据存放位置:</h4>\n<div><pre><code><span>private</span> final <span><span>byte</span></span> <span>value</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>既然Byte为byte类型的包装类，每个byte对应一个Byte对象那byte对应的值存放在什么位置呢，就存在于这里的value属性中。</p>\n<h4 id=\"构造器\"> 构造器:</h4>\n<div><pre><code><span>public</span> <span>Byte</span><span>(</span><span><span>byte</span></span> <span>value</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> <span>value</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>Byte</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> NumberFormatException <span>{</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> <span>parseByte</span><span>(</span>s<span>,</span> <span>10</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>java中的构造器是用于创建对象和初始化对象中的属性用的。Byte类中提供了两个构造器，一个是通过传byte数据来构造对象，一个是通过传字符串数据来创建对象，可以看到最终都是将传入的数据赋值给了value，也就是上面讲的byte数据的存放位置。</p>\n<h4 id=\"取值\"> 取值：</h4>\n<div><pre><code><span>public</span> <span><span>byte</span></span> <span>byteValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>value</span><span>;</span>\n<span>}</span>\n<span>public</span> <span><span>short</span></span> <span>shortValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>short</span><span>)</span><span>value</span><span>;</span>\n<span>}</span>\n<span>public</span> <span><span>int</span></span> <span>intValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>int</span><span>)</span><span>value</span><span>;</span>\n<span>}</span>\n<span>public</span> <span><span>long</span></span> <span>longValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>long</span><span>)</span><span>value</span><span>;</span>\n<span>}</span>\n<span>public</span> <span><span>float</span></span> <span>floatValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>float</span><span>)</span><span>value</span><span>;</span>\n<span>}</span>\n<span>public</span> <span><span>double</span></span> <span>doubleValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>double</span><span>)</span><span>value</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>这里的xxxValue也就是重写了父类Number类中的xxxValue方法，可以看到这些方法用的都是java的强制类型转换机制，由于这些转换中byte的长度最小，所以不用考虑数据溢出的问题。</p>\n<h4 id=\"hashcode\"> hashCode:</h4>\n<div><pre><code>@Override\n<span>public</span> <span><span>int</span></span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> Byte<span>.</span><span>hashCode</span><span>(</span><span>value</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>static</span> <span><span>int</span></span> <span>hashCode</span><span>(</span><span><span>byte</span></span> <span>value</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>int</span><span>)</span><span>value</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这里是重写Object的hashCode方法，可以看到返回的就是Byte对象表示的数值。至于hashCode方法是什么意思在看<a href=\"https://www.jianshu.com/p/08c8890af5a0\" target=\"_blank\" rel=\"noopener noreferrer\">Object类</a>的源码时已经讲到了，如果忘记了可以再回去看一下。</p>\n<p>equals:</p>\n<div><pre><code><span>public</span> boolean <span>equals</span><span>(</span>Object obj<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>obj instanceof Byte<span>)</span> <span>{</span>\n            <span>return</span> value <span>==</span> <span>(</span><span>(</span>Byte<span>)</span>obj<span>)</span><span>.</span><span>byteValue</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>比较两个Byte对象是否是同一个对象，分为两步：第一步判断传入的对象是否是Byte类型，java中用instanceof判断对象是否是某个类型的对象。第二步判断两个对应的value值是否相等。如果这两个条件都满足那么这两个对象就是同一个对象。</p>\n<h4 id=\"compareto\"> compareTo</h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>compareTo</span><span>(</span><span>Byte</span> anotherByte<span>)</span> <span>{</span>\n    <span>return</span> <span>compare</span><span>(</span><span>this</span><span>.</span><span>value</span><span>,</span> anotherByte<span>.</span><span>value</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个方法是实现了Comparable接口中的抽象方法，该方法的作用在文章开始的时候已经讲解了。可以看到在方法内部调用了compare方法,这个方法的源码如下:</p>\n<div><pre><code><span>public</span> <span>static</span> <span><span>int</span></span> <span>compare</span><span>(</span><span><span>byte</span></span> x<span>,</span> <span><span>byte</span></span> y<span>)</span> <span>{</span>\n        <span>return</span> x <span>-</span> y<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到返回的是两个byte数据的差值，需要注意的一点是在compareTo的比较机制中如果返回值大于0表示前一个数据比后一个数据大，返回值等于 0表示两个数据相等，返回值小于0表示第一个数据小于第二个数据</p>\n<h4 id=\"tounsignedint-byte-x\"> toUnsignedInt(byte x)</h4>\n<div><pre><code><span>public</span> <span>static</span> <span><span>int</span></span> <span>toUnsignedInt</span><span>(</span><span><span>byte</span></span> x<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>(</span><span>int</span><span>)</span> x<span>)</span> <span>&amp;</span> <span>0xff</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个方法是jdk1.8之后新加的，作用是将byte数据转换为无符号的int数据。方法的实现很简单就是将目标值和0xff这个数做&amp;的运算。&amp;运算如果有不清楚的可以看下本章的基础知识。</p>\n<h4 id=\"tounsignedlong\"> toUnsignedLong</h4>\n<div><pre><code><span>public</span> <span>static</span> <span><span>long</span></span> <span>toUnsignedLong</span><span>(</span><span><span>byte</span></span> x<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>(</span><span>long</span><span>)</span> x<span>)</span> <span>&amp;</span> <span>0xffL</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个方法同toUnsignedInt类似只不过把数据强转为long类型后进行运算。注意同一个byte类型的数据转换成int和long后所表示的二进制的数据的位数是不相同的int为32位，long是64位。</p>\n<p>SIZE:</p>\n<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>int</span> SIZE <span>=</span> <span>8</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>SIZE用来表示于二进制补码形式的byte值的位数，值为8，静态变量且不可变。</p>\n<h4 id=\"bytes\"> BYTES:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>int</span> BYTES <span>=</span> SIZE <span>/</span> <span>Byte</span><span>.</span>SIZE<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>BYTES用来表示于二进制补码形式的byte值的字节数，值为1，静态变量且不可变。</p>\n<p>注意：\n在本类中有很多使用static和final关键字修饰的属性或方法。用static 和final共同修饰的变量表示这个量为常量，不可改变。用static修饰的方法或属性表示该属性属于类，可以使用  类名.方法名或类名.属性名直接调用。否则这些属性属于对象，需要通过创建对象后，由对象来调用。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Java中的IO模型",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/Java%E4%B8%AD%E7%9A%84IO%E6%A8%A1%E5%9E%8B/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/Java%E4%B8%AD%E7%9A%84IO%E6%A8%A1%E5%9E%8B/",
      "content_html": "<h1 id=\"java中的io模型\"> Java中的IO模型</h1>\n<p>Java的IO模型套用了Linux的IO模型。</p>\n<blockquote>\n<p>因为Linux是操作系统，IO是操作系统完成的。Java属于高级层面，使用了操作系统的IO模型。</p>\n</blockquote>\n<p>这里借用了群里小伙伴的解释，我觉得很有道理，如果小伙伴们有更好的解释的话，欢迎留言。</p>\n<h1 id=\"bio模型\"> BIO模型</h1>\n<p>BIO（Blocking I/O）同步阻塞I/O</p>\n<blockquote>\n<p>在BIO模型下，一个线程在发起IO的请求后会阻塞，直到其他线程把该线程需要的资源准备好(这个过程中，线程一直是阻塞状态)，该线程才会执行剩余的操作。</p>\n</blockquote>\n<h2 id=\"模型\"> 模型</h2>\n<p><strong>BIO的服务端通信模型</strong>：采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行处理。处理完成后，通过输出流返回应答给客户端，处理的线程销毁。即典型的一请求一应答通讯模型。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/20/170f81849e62849c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<h2 id=\"代码\"> 代码</h2>\n<p><strong>BIO客户端代码</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>BIOClient</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>)</span><span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                    <span>Socket</span> socket <span>=</span> <span>new</span> <span>Socket</span><span>(</span><span>\"127.0.0.1\"</span><span>,</span> <span>8090</span><span>)</span><span>;</span>\n                    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n                        <span>try</span> <span>{</span>\n                            socket<span>.</span><span>getOutputStream</span><span>(</span><span>)</span><span>.</span><span>write</span><span>(</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span> <span>+</span> <span>\": hello world\"</span><span>)</span><span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                            socket<span>.</span><span>getOutputStream</span><span>(</span><span>)</span><span>.</span><span>flush</span><span>(</span><span>)</span><span>;</span>\n                            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>2000</span><span>)</span><span>;</span>\n                        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n                        <span>}</span>\n                    <span>}</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n\n            <span>}</span>\n        <span>}</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><strong>BIO服务器端代码</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>BIOServer</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>ServerSocket</span> serverSocket <span>=</span> <span>new</span> <span>ServerSocket</span><span>(</span><span>8090</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                    <span>//accept()阻塞,直到获取到连接</span>\n                    <span>Socket</span> socket <span>=</span> serverSocket<span>.</span><span>accept</span><span>(</span><span>)</span><span>;</span>\n                    <span>//创建新线程，执行相关逻辑</span>\n                    <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n                        <span>byte</span><span>[</span><span>]</span> bytes <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>1024</span><span>]</span><span>;</span>\n                        <span>try</span> <span>{</span>\n                            <span>InputStream</span> inputStream <span>=</span> socket<span>.</span><span>getInputStream</span><span>(</span><span>)</span><span>;</span>\n                            <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n                                <span>int</span> len<span>;</span>\n                                <span>while</span> <span>(</span><span>(</span>len <span>=</span> inputStream<span>.</span><span>read</span><span>(</span>bytes<span>)</span><span>)</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span>\n                                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>new</span> <span>String</span><span>(</span>bytes<span>,</span> <span>0</span><span>,</span> len<span>)</span><span>)</span><span>;</span>\n                                <span>}</span>\n                            <span>}</span>\n                        <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n                            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                        <span>}</span>\n\n                    <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h2 id=\"特点\"> 特点</h2>\n<p>服务器实现模式为<strong>一个连接一个线程</strong>，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p>\n<p><strong>使用场景</strong></p>\n<p>BIO方式适用于<strong>连接数目比较小且固定</strong>的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序<strong>直观简单易理解</strong>。</p>\n<h1 id=\"伪异步io模型\"> 伪异步IO模型</h1>\n<p>伪异步IO模型是对BIO模型的改进，针对客户端的每次连接，服务器端都需要创建一个线程执行相关逻辑，执行完毕后会，创建的线程会被销毁，而线程的创建占用系统资源比较大的问题。使用线程池，解决线程频繁创建的问题。</p>\n<h2 id=\"模型-2\"> 模型</h2>\n<p>伪异步IO模型是对BIO模型的改进，在Acceptor线程负责监听客户端的连接，会将该连接任务，放入<strong>线程池</strong>中执行。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/20/170f8184a0d68e2c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<h2 id=\"代码-2\"> 代码</h2>\n<p><strong>客户端代码和BIO一致</strong></p>\n<p><strong>服务器端代码</strong></p>\n<p>BIOServer2.java</p>\n<div><pre><code><span>public</span> <span>class</span> <span>BIOServer2</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>ServerSocket</span> serverSocket <span>=</span> <span>new</span> <span>ServerSocket</span><span>(</span><span>8090</span><span>)</span><span>;</span>\n        <span>ExecutorService</span> executor <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>10</span><span>)</span><span>;</span>\n        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>//accept()阻塞,直到获取到连接</span>\n                <span>Socket</span> socket <span>=</span> serverSocket<span>.</span><span>accept</span><span>(</span><span>)</span><span>;</span>\n                <span>//将任务交给线程池，执行相关逻辑</span>\n                executor<span>.</span><span>submit</span><span>(</span><span>new</span> <span>ThreadHandler</span><span>(</span>socket<span>)</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>ThreadHandler.java</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadHandler</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n    <span>public</span> <span>Socket</span> socket<span>;</span>\n\n    <span>public</span> <span>ThreadHandler</span><span>(</span><span>Socket</span> socket<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>socket <span>=</span> socket<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>byte</span><span>[</span><span>]</span> bytes <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>1024</span><span>]</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>InputStream</span> inputStream <span>=</span> socket<span>.</span><span>getInputStream</span><span>(</span><span>)</span><span>;</span>\n            <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n                <span>int</span> len<span>;</span>\n                <span>while</span> <span>(</span><span>(</span>len <span>=</span> inputStream<span>.</span><span>read</span><span>(</span>bytes<span>)</span><span>)</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>new</span> <span>String</span><span>(</span>bytes<span>,</span> <span>0</span><span>,</span> len<span>)</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id=\"特点-2\"> 特点</h2>\n<p>伪异步I/O实际上仅仅只是对之前I/O线程模型的一个简单优化，使用线程池解决了频繁创建线程的问题。它无法从根本上解决同步I/O导致的通信线程阻塞问题。</p>\n<h1 id=\"nio模型\"> NIO模型</h1>\n<p>NIO是一种多路复用的I/O模型，提供了 <strong>Channel</strong> ,  <strong>Selector</strong>，<strong>Buffer</strong>等抽象。</p>\n<h3 id=\"channel\"> <strong>Channel</strong></h3>\n<p>Java NIO Channel类似于Stream，但有一些区别：</p>\n<ul>\n<li>Channel可以读取和写入。Stream通常是单向的（读或写）。</li>\n<li>Channel可以异步读写。</li>\n<li>Channel始终读取或写入缓冲区。</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/20/170f8184a0f56e19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<h3 id=\"buffer\"> <strong>Buffer</strong></h3>\n<p>在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p>\n<p>在面向流的I/O中。可以将数据直接写入或者将数据直接读到 Stream 对象中。</p>\n<p>缓冲区本质上是一个内存块。</p>\n<ul>\n<li>capacity</li>\n<li>position</li>\n<li>limit</li>\n</ul>\n<p><code>position</code>和<code>limit</code>取决于是否<code>Buffer</code> 在读或写模式。不管缓冲模式如何，<code>capacity</code>始终不变。</p>\n<p><strong>capacity</strong></p>\n<p>作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”。你只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p>\n<p><strong>position</strong></p>\n<p>当你写数据到Buffer中时，position表示当前的位置。初始的position值为0。当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.</p>\n<p>当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0。当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</p>\n<p><strong>limit</strong></p>\n<p>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。</p>\n<p>当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</p>\n<h3 id=\"selector\"> <strong>Selector</strong></h3>\n<p>使用单个线程来处理多个Channel的好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/20/170f8184a0e79349?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<h2 id=\"模型-3\"> 模型</h2>\n<p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。</p>\n<blockquote>\n<p>BIO的每个客户端的连接都需要使用一个单独的线程执行逻辑；</p>\n<p>NIO对于客户端的连接中有<code>可以进行读写的网络连接符</code>的连接，即监听需要读、写、连接的事件，之后才会使用单独的线程执行逻辑。</p>\n<p>举个例子，大家都有去餐馆吃饭的经历。</p>\n<p>每进去一个人(客户端连接)，餐馆都会给进来的客人配备一个服务员(处理线程)等待客人点菜。其实客人进来不一定会马上点菜，有可能等朋友来之后才点菜，但是服务员在这期间都会一直在那里等待。这样会大大浪费餐厅的服务员资源。这可以认为是BIO模型。</p>\n<p>每进去一个人(客户端连接)，餐厅专门配备一个员工(Selector)，询问客人现在点不点菜。有的客人进来不一定会马上点菜，有可能等朋友来之后才点菜。有的的客人会告诉员工，自己需要点菜。这时候才会有服务员到需要点菜的员工那里，等待客人点菜。这样服务员资源得到充分的使用。这可以认为是NIO模型。</p>\n</blockquote>\n<p>单线程处理I/O的效率确实非常高，没有线程切换，只是拼命的读、写、选择事件。但现在的服务器，一般都是多核处理器，如果能够利用多核心进行I/O，无疑对效率会有更大的提高。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/3/20/170f8184a15a6832?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" /></p>\n<h2 id=\"代码-3\"> 代码</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>NIOServer</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>Selector</span> serverSelector <span>=</span> <span>Selector</span><span>.</span><span>open</span><span>(</span><span>)</span><span>;</span>\n        <span>Selector</span> clientSelector <span>=</span> <span>Selector</span><span>.</span><span>open</span><span>(</span><span>)</span><span>;</span>\n\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>// 对应IO编程中服务端启动</span>\n                <span>ServerSocketChannel</span> listenerChannel <span>=</span> <span>ServerSocketChannel</span><span>.</span><span>open</span><span>(</span><span>)</span><span>;</span>\n                listenerChannel<span>.</span><span>socket</span><span>(</span><span>)</span><span>.</span><span>bind</span><span>(</span><span>new</span> <span>InetSocketAddress</span><span>(</span><span>8000</span><span>)</span><span>)</span><span>;</span>\n                listenerChannel<span>.</span><span>configureBlocking</span><span>(</span><span>false</span><span>)</span><span>;</span>\n                listenerChannel<span>.</span><span>register</span><span>(</span>serverSelector<span>,</span> <span>SelectionKey</span><span>.</span>OP_ACCEPT<span>)</span><span>;</span>\n\n                <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n                    <span>// 监测是否有新的连接，这里的1指的是阻塞的时间为1ms</span>\n                    <span>if</span> <span>(</span>serverSelector<span>.</span><span>select</span><span>(</span><span>1</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>\n                        <span>Set</span><span><span>&lt;</span><span>SelectionKey</span><span>></span></span> set <span>=</span> serverSelector<span>.</span><span>selectedKeys</span><span>(</span><span>)</span><span>;</span>\n                        <span>Iterator</span><span><span>&lt;</span><span>SelectionKey</span><span>></span></span> keyIterator <span>=</span> set<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>\n\n                        <span>while</span> <span>(</span>keyIterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                            <span>SelectionKey</span> key <span>=</span> keyIterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>\n\n                            <span>if</span> <span>(</span>key<span>.</span><span>isAcceptable</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                                <span>try</span> <span>{</span>\n                                    <span>// (1) 每来一个新连接，不需要创建一个线程，而是直接注册到clientSelector</span>\n                                    <span>SocketChannel</span> clientChannel <span>=</span> <span>(</span><span>(</span><span>ServerSocketChannel</span><span>)</span> key<span>.</span><span>channel</span><span>(</span><span>)</span><span>)</span><span>.</span><span>accept</span><span>(</span><span>)</span><span>;</span>\n                                    clientChannel<span>.</span><span>configureBlocking</span><span>(</span><span>false</span><span>)</span><span>;</span>\n                                    clientChannel<span>.</span><span>register</span><span>(</span>clientSelector<span>,</span> <span>SelectionKey</span><span>.</span>OP_READ<span>)</span><span>;</span>\n                                <span>}</span> <span>finally</span> <span>{</span>\n                                    keyIterator<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>\n                                <span>}</span>\n                            <span>}</span>\n\n                        <span>}</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> ignored<span>)</span> <span>{</span>\n            <span>}</span>\n\n        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n                    <span>// (2) 批量轮询是否有哪些连接有数据可读，这里的1指的是阻塞的时间为1ms</span>\n                    <span>if</span> <span>(</span>clientSelector<span>.</span><span>select</span><span>(</span><span>1</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>\n                        <span>Set</span><span><span>&lt;</span><span>SelectionKey</span><span>></span></span> set <span>=</span> clientSelector<span>.</span><span>selectedKeys</span><span>(</span><span>)</span><span>;</span>\n                        <span>Iterator</span><span><span>&lt;</span><span>SelectionKey</span><span>></span></span> keyIterator <span>=</span> set<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>\n\n                        <span>while</span> <span>(</span>keyIterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                            <span>SelectionKey</span> key <span>=</span> keyIterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>\n\n                            <span>if</span> <span>(</span>key<span>.</span><span>isReadable</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                                <span>try</span> <span>{</span>\n                                    <span>SocketChannel</span> clientChannel <span>=</span> <span>(</span><span>SocketChannel</span><span>)</span> key<span>.</span><span>channel</span><span>(</span><span>)</span><span>;</span>\n                                    <span>ByteBuffer</span> byteBuffer <span>=</span> <span>ByteBuffer</span><span>.</span><span>allocate</span><span>(</span><span>1024</span><span>)</span><span>;</span>\n                                    <span>// (3) 读取数据以块为单位批量读取</span>\n                                    clientChannel<span>.</span><span>read</span><span>(</span>byteBuffer<span>)</span><span>;</span>\n                                    byteBuffer<span>.</span><span>flip</span><span>(</span><span>)</span><span>;</span>\n                                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Charset</span><span>.</span><span>defaultCharset</span><span>(</span><span>)</span><span>.</span><span>newDecoder</span><span>(</span><span>)</span><span>.</span><span>decode</span><span>(</span>byteBuffer<span>)</span>\n                                            <span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                                <span>}</span> <span>finally</span> <span>{</span>\n                                    keyIterator<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>\n                                    key<span>.</span><span>interestOps</span><span>(</span><span>SelectionKey</span><span>.</span>OP_READ<span>)</span><span>;</span>\n                                <span>}</span>\n                            <span>}</span>\n\n                        <span>}</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> ignored<span>)</span> <span>{</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br></div></div><h2 id=\"特点-3\"> 特点</h2>\n<p>服务器实现模式为<strong>一个请求一个线程</strong>，即客户端发送的连接请求都会注册到<strong>多路复用器</strong>上，<strong>多路复用器轮询</strong>到连接有I/O请求时才启动一个线程进行处理。</p>\n<p><strong>使用场景</strong></p>\n<p>NIO方式适用于<strong>连接数目多且连接比较短</strong>（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。</p>\n<h1 id=\"aio模型\"> AIO模型</h1>\n<p>关于AIO的模型、代码就不在这里表述了，因为我对于这一块也不太了解，基本上也没用过。有需要的同学可以自己去查找资料。代码可以参考<a href=\"https://colobu.com/2014/11/13/java-aio-introduction/\" target=\"_blank\" rel=\"noopener noreferrer\">java aio 编程</a>的内容。</p>\n<p>据我了解Netty开发的新一代版本支持AIO模型，但是感觉效果不好，就又放弃了。</p>\n<h2 id=\"特点-4\"> 特点</h2>\n<p><strong>AIO</strong>：异步非阻塞，服务器实现模式为<strong>一个有效请求一个线程</strong>，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p>\n<p><strong>使用场景</strong></p>\n<p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p>\n<p>作者：图解Java\n链接：https://juejin.im/post/5e74c2a8f265da571043a7b1\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n",
      "image": "https://user-gold-cdn.xitu.io/2020/3/20/170f81849e62849c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "7.Short类",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/7.Short%E7%B1%BB/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/7.Short%E7%B1%BB/",
      "content_html": "<h1 id=\"_7-short类\"> 7.Short类</h1>\n<p>short是java基本数据类型中的一种，为短整型，占2个字节，16位。Short为short类型的包装类。</p>\n<h4 id=\"基础知识\"> 基础知识：</h4>\n<p>1.整型变量的分类，java中整型变量分为以下四类：\n短整型，类型关键字为short[int]占2个字节。　　\n整型，类型关键字为int占4个字节。\n长整型，类型关键字为long[int]占8个字节。　　\n无符号整型，类型关键字为unsigned[int]或unsignedshort或unsignedlong</p>\n<h4 id=\"short类源码\"> Short类源码：</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Short</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Short</span><span>></span></span> <span>{</span>\n    <span>//short类型最小值</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>short</span>   MIN_VALUE <span>=</span> <span>-</span><span>32768</span><span>;</span>\n    <span>//short类型最大值</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>short</span>   MAX_VALUE <span>=</span> <span>32767</span><span>;</span>\n    <span>//基本类型 short 的 Class 实例，即short.class</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>Class</span><span><span>&lt;</span><span>Short</span><span>></span></span>    TYPE <span>=</span> <span>(</span><span>Class</span><span><span>&lt;</span><span>Short</span><span>></span></span><span>)</span> <span>Class</span><span>.</span><span>getPrimitiveClass</span><span>(</span><span>\"short\"</span><span>)</span><span>;</span>\n    <span>//将short类型的数转换为其10进制对应的数的字符串形式</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>toString</span><span>(</span><span>short</span> s<span>)</span> <span>{</span>\n        <span>return</span> <span>Integer</span><span>.</span><span>toString</span><span>(</span><span>(</span><span>int</span><span>)</span>s<span>,</span> <span>10</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>//将short类型的数转换为其指定进制对应的数的字符串形式</span>\n    <span>public</span> <span>static</span> <span>short</span> <span>parseShort</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> radix<span>)</span>\n        <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>int</span> i <span>=</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>s<span>,</span> radix<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>&lt;</span> MIN_VALUE <span>||</span> i <span>></span> MAX_VALUE<span>)</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span>\n                <span>\"Value out of range. Value:\\\"\"</span> <span>+</span> s <span>+</span> <span>\"\\\" Radix:\"</span> <span>+</span> radix<span>)</span><span>;</span>\n        <span>return</span> <span>(</span><span>short</span><span>)</span>i<span>;</span>\n    <span>}</span>\n    <span>//将10进制的字符串数转换为对应的short类型的数字</span>\n    <span>public</span> <span>static</span> <span>short</span> <span>parseShort</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>parseShort</span><span>(</span>s<span>,</span> <span>10</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>//将指定进制的字符串数转换为对应的short类型的数字</span>\n    <span>public</span> <span>static</span> <span>Short</span> <span>valueOf</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> radix<span>)</span>\n        <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>valueOf</span><span>(</span><span>parseShort</span><span>(</span>s<span>,</span> radix<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>//获取字符串形式的数字，所对应的Short对象</span>\n    <span>public</span> <span>static</span> <span>Short</span> <span>valueOf</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>valueOf</span><span>(</span>s<span>,</span> <span>10</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>//Short对象的缓冲类</span>\n    <span>private</span> <span>static</span> <span>class</span> <span>ShortCache</span> <span>{</span>\n        <span>private</span> <span>ShortCache</span><span>(</span><span>)</span><span>{</span><span>}</span>\n        <span>//缓冲数组</span>\n        <span>static</span> <span>final</span> <span>Short</span> cache<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>Short</span><span>[</span><span>-</span><span>(</span><span>-</span><span>128</span><span>)</span> <span>+</span> <span>127</span> <span>+</span> <span>1</span><span>]</span><span>;</span>\n        <span>//创建缓冲对象，共256个</span>\n        <span>static</span> <span>{</span>\n            <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cache<span>.</span>length<span>;</span> i<span>++</span><span>)</span>\n                cache<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Short</span><span>(</span><span>(</span><span>short</span><span>)</span><span>(</span>i <span>-</span> <span>128</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>//从缓冲对象中获取对应的Short对象</span>\n    <span>//可以看到在-127到128之间是从缓存数组中取的，其它范围的是创建的新的对象</span>\n    <span>public</span> <span>static</span> <span>Short</span> <span>valueOf</span><span>(</span><span>short</span> s<span>)</span> <span>{</span>\n        <span>final</span> <span>int</span> offset <span>=</span> <span>128</span><span>;</span>\n        <span>int</span> sAsInt <span>=</span> s<span>;</span>\n        <span>if</span> <span>(</span>sAsInt <span>>=</span> <span>-</span><span>128</span> <span>&amp;&amp;</span> sAsInt <span>&lt;=</span> <span>127</span><span>)</span> <span>{</span> <span>// must cache</span>\n            <span>return</span> <span>ShortCache</span><span>.</span>cache<span>[</span>sAsInt <span>+</span> offset<span>]</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>new</span> <span>Short</span><span>(</span>s<span>)</span><span>;</span>\n    <span>}</span>\n    <span>//将其它进制表示法，表示的字符串数据转换为10进制表示的short数据,然后返回对应的Short对象</span>\n    <span>public</span> <span>static</span> <span>Short</span> <span>decode</span><span>(</span><span>String</span> nm<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>int</span> i <span>=</span> <span>Integer</span><span>.</span><span>decode</span><span>(</span>nm<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>&lt;</span> MIN_VALUE <span>||</span> i <span>></span> MAX_VALUE<span>)</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span>\n                    <span>\"Value \"</span> <span>+</span> i <span>+</span> <span>\" out of range from input \"</span> <span>+</span> nm<span>)</span><span>;</span>\n        <span>return</span> <span>valueOf</span><span>(</span><span>(</span><span>short</span><span>)</span>i<span>)</span><span>;</span>\n    <span>}</span>\n    <span>//用于存储short数值</span>\n    <span>private</span> <span>final</span> <span>short</span> value<span>;</span>\n    <span>//Short类的构造器,参数为short值</span>\n    <span>public</span> <span>Short</span><span>(</span><span>short</span> value<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>value <span>=</span> value<span>;</span>\n    <span>}</span>\n    <span>//Short类的构造器,参数为字符串</span>\n    <span>public</span> <span>Short</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>this</span><span>.</span>value <span>=</span> <span>parseShort</span><span>(</span>s<span>,</span> <span>10</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>//将short数转换为byte，由于short长度大于byte所以这里可以会出现溢出的情况</span>\n    <span>public</span> <span>byte</span> <span>byteValue</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>byte</span><span>)</span>value<span>;</span>\n    <span>}</span>\n    <span>//返回short数据</span>\n    <span>public</span> <span>short</span> <span>shortValue</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> value<span>;</span>\n    <span>}</span>\n    <span>//将short数转换为int类型</span>\n    <span>public</span> <span>int</span> <span>intValue</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>int</span><span>)</span>value<span>;</span>\n    <span>}</span>\n    <span>//将short数转换为long类型</span>\n    <span>public</span> <span>long</span> <span>longValue</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>long</span><span>)</span>value<span>;</span>\n    <span>}</span>\n    <span>//将short数转换为float类型</span>\n    <span>public</span> <span>float</span> <span>floatValue</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>float</span><span>)</span>value<span>;</span>\n    <span>}</span>\n    <span>//将short数转换为double类型</span>\n    <span>public</span> <span>double</span> <span>doubleValue</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>double</span><span>)</span>value<span>;</span>\n    <span>}</span>\n    <span>//toString方法</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>Integer</span><span>.</span><span>toString</span><span>(</span><span>(</span><span>int</span><span>)</span>value<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>Short</span><span>.</span><span>hashCode</span><span>(</span>value<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>hashCode</span><span>(</span><span>short</span> value<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>int</span><span>)</span>value<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>obj <span>instanceof</span> <span>Short</span><span>)</span> <span>{</span>\n            <span>return</span> value <span>==</span> <span>(</span><span>(</span><span>Short</span><span>)</span>obj<span>)</span><span>.</span><span>shortValue</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n    <span>//比较两个short对象的大小</span>\n    <span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>Short</span> anotherShort<span>)</span> <span>{</span>\n        <span>return</span> <span>compare</span><span>(</span><span>this</span><span>.</span>value<span>,</span> anotherShort<span>.</span>value<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>compare</span><span>(</span><span>short</span> x<span>,</span> <span>short</span> y<span>)</span> <span>{</span>\n        <span>return</span> x <span>-</span> y<span>;</span>\n    <span>}</span>\n    <span>//short类型所占的位数</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>int</span> SIZE <span>=</span> <span>16</span><span>;</span>\n    <span>//short类型所占的字节数</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>int</span> BYTES <span>=</span> SIZE <span>/</span> <span>Byte</span><span>.</span>SIZE<span>;</span>\n    <span>//short的高8位与低8位互换</span>\n    <span>public</span> <span>static</span> <span>short</span> <span>reverseBytes</span><span>(</span><span>short</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>short</span><span>)</span> <span>(</span><span>(</span><span>(</span>i <span>&amp;</span> <span>0xFF00</span><span>)</span> <span>>></span> <span>8</span><span>)</span> <span>|</span> <span>(</span>i <span>&lt;&lt;</span> <span>8</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>//将short类型的数转换为无符号的int类型</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>toUnsignedInt</span><span>(</span><span>short</span> x<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>(</span><span>int</span><span>)</span> x<span>)</span> <span>&amp;</span> <span>0xffff</span><span>;</span>\n    <span>}</span>\n    <span>//将short类型的数转换为无符号的long类型</span>\n    <span>public</span> <span>static</span> <span>long</span> <span>toUnsignedLong</span><span>(</span><span>short</span> x<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>(</span><span>long</span><span>)</span> x<span>)</span> <span>&amp;</span> <span>0</span>xffffL<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br></div></div><p>可以看到在Short类的源码中绝大部分属性或方法都跟Byte类类似，这里我就不再重复讲解了，不明白的同学可以看下<a href=\"https://www.jianshu.com/p/26bedb3ae3c4\" target=\"_blank\" rel=\"noopener noreferrer\">Byte类</a>的源码学习。</p>\n<h4 id=\"与byte类的不同\"> 与Byte类的不同:</h4>\n<p>1.缓存池：</p>\n<div><pre><code><span>private</span> <span>static</span> <span>class</span> <span>ShortCache</span> <span>{</span>\n        <span>private</span> <span>ShortCache</span><span>(</span><span>)</span><span>{</span><span>}</span>\n        <span>//缓冲数组</span>\n        <span>static</span> <span>final</span> <span>Short</span> cache<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>Short</span><span>[</span><span>-</span><span>(</span><span>-</span><span>128</span><span>)</span> <span>+</span> <span>127</span> <span>+</span> <span>1</span><span>]</span><span>;</span>\n        <span>//创建缓冲对象，共256个</span>\n        <span>static</span> <span>{</span>\n            <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cache<span>.</span>length<span>;</span> i<span>++</span><span>)</span>\n                cache<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Short</span><span>(</span><span>(</span><span>short</span><span>)</span><span>(</span>i <span>-</span> <span>128</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>可以看到Short类的缓存池中也是存放了256个对象，那为什么说这里与Byte类不同呢，原因很简单，因为short类型的范围是-32768到32767，这里只缓存了256个对象，那为什么不全部缓存下来呢，因为太多了，占用的内在空间较大，所以在使用Short类的时候，对于-128到127内的Short对象是从缓存池中取的，其它的是创建的新对象。\n2.reverseBytes方法</p>\n<div><pre><code><span>public</span> <span>static</span> <span>short</span> <span>reverseBytes</span><span>(</span><span>short</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>short</span><span>)</span> <span>(</span><span>(</span><span>(</span>i <span>&amp;</span> <span>0xFF00</span><span>)</span> <span>>></span> <span>8</span><span>)</span> <span>|</span> <span>(</span>i <span>&lt;&lt;</span> <span>8</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到在Byte类中没有这个方法，这个方法是用来将short类型的低8位与高8位互换的。解释如下:\n1.将目标数i与0xFF00(转换为2进制是 1111 1111 0000 0000)做&amp;的运算,得到的结果为i的高8位不变，低8位全变为0，然后右移8位，就得到了目标数i的高8位\n2.将i左移8位，得到的数为一个新数,这个新数的高8位为原目标数i的低8位，这个数的低8位为0，然后将i的高8位与这个新数做|运算，得到的结果就是将目标数i的高8位，与低8位互换的数。\n有兴趣的同学可以亲自先一个数运算一下，如果不清楚位运算&amp;和|可以看下<a href=\"https://www.jianshu.com/p/26bedb3ae3c4\" target=\"_blank\" rel=\"noopener noreferrer\">一起学JDK源码 -- Byte类</a>的基础知识。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "9.Long类",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/9.Long%E7%B1%BB/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/9.Long%E7%B1%BB/",
      "content_html": "<h1 id=\"_9-long类\"> 9.Long类</h1>\n<p>Long类为java基本类型long的包装类，其中提供了一些处理long类型的方法。但是大部分方法名称和实现都同Integer类类似，本章中不与列出，可查看<a href=\"https://www.jianshu.com/p/e07d126ac1d0\" target=\"_blank\" rel=\"noopener noreferrer\">一起学JDK源码 -- Integer</a>查看相应的解释，本章只列出Integer类中没有实现的方法。</p>\n<h4 id=\"基础知识\"> 基础知识</h4>\n<p>1.java默认数值类型:</p>\n<ul>\n<li>java中数值类型分为整形(short、int、long)和浮点形(单精度浮点float，双精度浮点double)</li>\n<li>对于整数来说，缺省后缀的都视为int，long类型在数字末尾加l或L，推荐使用大写L,因为小写l看起来像数字1</li>\n<li>对于浮点数来说，缺省后缀的都视为double，double类型后缀为d，float类型后缀为f。注意 double d = 3f 可以，但 float f = 3d不可以</li>\n</ul>\n<p>2.访问修饰符：\njava中的访问修饰符是用来控制类及类中的方法和属性的访问权限的。共有以下四种:</p>\n<ul>\n<li>public： 用public修饰的类、类属变量及方法，包内及包外的任何类（包括子类和普通类）均可以访问；</li>\n<li>protected： 用protected修饰的类、类属变量及方法，包内的任何类及包外那些继承了该类的子类才能访问（此处稍后解释），protected重点突出继承；</li>\n<li>default： 如果一个类、类属变量及方法没有用任何修饰符（即没有用public、protected及private中任何一种修饰），则其访问权限为default（默认访问权限）。默认访问权限的类、类属变量及方法，包内的任何类（包括继承了此类的子类）都可以访问它，而对于包外的任何类都不能访问它（包括包外继承了此类的子类）。default重点突出包；</li>\n<li>用private修饰的类、类属变量及方法，只有本类可以访问，而包内包外的任何类均不能访问它。</li>\n</ul>\n<p>3数值溢出: java中的数值溢出是指当某一类型的数据无法承装一个数时出现结果错误显示的情况。啥，这是啥，我也不明白。举个例子： byte a = (byte)127; byte b = (byte)127; byte c = (byte)a + b; 结果是254? no，byte的范围是-128到127怎么可能出现254呢。这就出现了数值溢出的情况了。254转换为二进制就是0000000011111110，而byte只有8位，取8位也就是11111110这个数转换为10进制就是-2 ，所以上述结果为-2，超出byte范围的二进制被舍去，也就是我们常说的溢出了，其它类型数值运算结果超出某一类型所表示的范围，或大类型的数据转换为小类型的数据都有可能出现数值溢出的情况。原理跟这个类似。</p>\n<h4 id=\"tounsignedbiginteger\"> toUnsignedBigInteger:</h4>\n<div><pre><code><span>private</span> <span>static</span> <span>BigInteger</span> <span>toUnsignedBigInteger</span><span>(</span><span><span>long</span></span> i<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>i <span>>=</span> <span>0L</span><span>)</span>\n            <span>return</span> BigInteger<span>.</span><span>valueOf</span><span>(</span>i<span>)</span><span>;</span>\n        <span>else</span> <span>{</span>\n            <span><span>int</span></span> upper <span>=</span> <span>(</span><span>int</span><span>)</span> <span>(</span>i <span>>></span><span>></span> <span>32</span><span>)</span><span>;</span>\n            <span><span>int</span></span> lower <span>=</span> <span>(</span><span>int</span><span>)</span> i<span>;</span>\n\n            <span>// return (upper &lt;&lt; 32) + lower</span>\n            <span>return</span> <span>(</span>BigInteger<span>.</span><span>valueOf</span><span>(</span>Integer<span>.</span><span>toUnsignedLong</span><span>(</span>upper<span>)</span><span>)</span><span>)</span><span>.</span><span>shiftLeft</span><span>(</span><span>32</span><span>)</span><span>.</span>\n                <span>add</span><span>(</span>BigInteger<span>.</span><span>valueOf</span><span>(</span>Integer<span>.</span><span>toUnsignedLong</span><span>(</span>lower<span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>这个方法的作用是将long类型的数字转换为无符号的BigInteger类型(这是一个可以承装很大类型数据的类，如一个数据超出了int的范围，甚至超出了long的范围，那么我们就可以使用BigInteger类来承装这个数据。BigInteger内部维护了int类型的数组，想象一下，一个数组最大长度为 Integer.MAX_VALUE 大约20 多亿，int最大20 多亿，20亿 * 20亿 多大的数大概都能装下吧，这里只是简单说了下BigInteger，更多关于BigInteger类，等我们看到[BigInteger类源码]的时候再讲解)。\n第一步：判断目标数i是否为0，如果为0直接调用BigInteger.valueOf(i)返回BigInteger对象\n第二步：如果不为0，将long类型的数字拆分为高32位upper和低32位lower。\n第三步：将高32位和低32位的数字使用Integer的方法转换为无符号Long类型，然后调用BigInteger的add方法(就是两个数相加，只不过这里可以相加两个超大的数而不出现溢出)把两个数加起来。</p>\n<h4 id=\"remainderunsigned-long-dividend-long-divisor\"> remainderUnsigned(long dividend, long divisor):</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>long</span> <span>remainderUnsigned</span><span>(</span><span>long</span> dividend<span>,</span> <span>long</span> divisor<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>dividend <span>></span> <span>0</span> <span>&amp;&amp;</span> divisor <span>></span> <span>0</span><span>)</span> <span>{</span> <span>// signed comparisons</span>\n            <span>return</span> dividend <span>%</span> divisor<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>if</span> <span>(</span><span>compareUnsigned</span><span>(</span>dividend<span>,</span> divisor<span>)</span> <span>&lt;</span> <span>0</span><span>)</span> <span>// Avoid explicit check for 0 divisor</span>\n                <span>return</span> dividend<span>;</span>\n            <span>else</span>\n                <span>return</span> <span>toUnsignedBigInteger</span><span>(</span>dividend<span>)</span><span>.</span>\n                    <span>remainder</span><span>(</span><span>toUnsignedBigInteger</span><span>(</span>divisor<span>)</span><span>)</span><span>.</span><span>longValue</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这个方法的作用就是将两个数转换为无符号的数然后求余数。首先对于两个正数，无有无符号之分直接求余数就可以了。然后比较两个数的大小，如果前一个数比后一个数小，余数为前一个数，道理也很简单一个小的数除以一个大的数商为0余数为这个小的数。接着如果前一个数比后一个数大。那么先将这两个数转换为无符号的BigInteger类型。然后再对这两个数进行求余数的操作。最后将结果转换为long类型返回。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "ConcurrentHashMap线程安全的具体实现方式/底层具体实现",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/ConcurrentHashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/ConcurrentHashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/",
      "content_html": "<h2 id=\"concurrenthashmap线程安全的具体实现方式-底层具体实现\"> ConcurrentHashMap线程安全的具体实现方式/底层具体实现</h2>\n<h3 id=\"jdk1-7-上面有示意图\"> JDK1.7（上面有示意图）</h3>\n<p><img src=\"https://camo.githubusercontent.com/092aae16c3a38854b4cea8b7e42dc6720df4441f/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f436f6e63757272656e74486173684d61702545352538382538362545362541452542352545392539342538312e6a7067\" alt=\"JDK1.7的ConcurrentHashMap\" /></p>\n<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>\n<p><strong>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</strong>。</p>\n<p>Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p>\n<div><pre><code><span>static</span> <span>class</span> <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>ReentrantLock</span> <span>implements</span> <span>Serializable</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>\n<h3 id=\"jdk1-8-上面有示意图\"> JDK1.8 （上面有示意图）</h3>\n<p><img src=\"https://camo.githubusercontent.com/b823c5f2cf18e7e27da70409d2b5e18fed820364/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4a444b312e382d436f6e63757272656e74486173684d61702d5374727563747572652e6a7067\" alt=\"JDK1.8的ConcurrentHashMap\" /></p>\n<p>ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）</p>\n<p>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>\n<h2 id=\"comparable-和-comparator的区别\"> comparable 和 Comparator的区别</h2>\n<ul>\n<li>comparable接口实际上是出自java.lang包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>\n<li>comparator接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>\n</ul>\n<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p>\n<h3 id=\"comparator定制排序\"> Comparator定制排序</h3>\n<div><pre><code>        <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> arrayList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>5</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>7</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>4</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>9</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>7</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"原始数组:\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n        <span>// void reverse(List list)：反转</span>\n        <span>Collections</span><span>.</span><span>reverse</span><span>(</span>arrayList<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Collections.reverse(arrayList):\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n\n        <span>// void sort(List list),按自然排序的升序排序</span>\n        <span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Collections.sort(arrayList):\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n        <span>// 定制排序的用法</span>\n        <span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>,</span> <span>new</span> <span>Comparator</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n\n            <span>@Override</span>\n            <span>public</span> <span>int</span> <span>compare</span><span>(</span><span>Integer</span> o1<span>,</span> <span>Integer</span> o2<span>)</span> <span>{</span>\n                <span>return</span> o2<span>.</span><span>compareTo</span><span>(</span>o1<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"定制排序后：\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>Output:</p>\n<div><pre><code>原始数组:\n[-1, 3, 3, -5, 7, 4, -9, -7]\nCollections.reverse(arrayList):\n[-7, -9, 4, 7, -5, 3, 3, -1]\nCollections.sort(arrayList):\n[-9, -7, -5, -1, 3, 3, 4, 7]\n定制排序后：\n[7, 4, 3, 3, -1, -5, -7, -9]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"重写compareto方法实现按年龄来排序\"> 重写compareTo方法实现按年龄来排序</h3>\n<div><pre><code><span>// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span>\n<span>// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span>\n<span>// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span>\n\n<span>public</span>  <span>class</span> <span>Person</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Person</span><span>></span></span> <span>{</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n    <span>private</span> <span>int</span> age<span>;</span>\n\n    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>\n        <span>super</span><span>(</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> age<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * TODO重写compareTo方法实现按年龄来排序\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>Person</span> o<span>)</span> <span>{</span>\n        <span>// TODO Auto-generated method stub</span>\n        <span>if</span> <span>(</span><span>this</span><span>.</span>age <span>></span> o<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>1</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>this</span><span>.</span>age <span>&lt;</span> o<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span>\n        <span>return</span> age<span>;</span>\n    <span>}</span>\n<span>}</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span> pdata <span>=</span> <span>new</span> <span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>\"张三\"</span><span>,</span> <span>30</span><span>)</span><span>,</span> <span>\"zhangsan\"</span><span>)</span><span>;</span>\n        pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>\"李四\"</span><span>,</span> <span>20</span><span>)</span><span>,</span> <span>\"lisi\"</span><span>)</span><span>;</span>\n        pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>\"王五\"</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>\"wangwu\"</span><span>)</span><span>;</span>\n        pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>\"小红\"</span><span>,</span> <span>5</span><span>)</span><span>,</span> <span>\"xiaohong\"</span><span>)</span><span>;</span>\n        <span>// 得到key的值的同时得到key所对应的值</span>\n        <span>Set</span><span><span>&lt;</span><span>Person</span><span>></span></span> keys <span>=</span> pdata<span>.</span><span>keySet</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>Person</span> key <span>:</span> keys<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>key<span>.</span><span>getAge</span><span>(</span><span>)</span> <span>+</span> <span>\"-\"</span> <span>+</span> key<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><p>Output：</p>\n<div><pre><code>5-小红\n10-王五\n20-李四\n30-张三\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>",
      "image": "https://camo.githubusercontent.com/092aae16c3a38854b4cea8b7e42dc6720df4441f/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f436f6e63757272656e74486173684d61702545352538382538362545362541452542352545392539342538312e6a7067",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "我自己对HashMap的理解",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/%E8%87%AA%E5%B7%B1%E5%AF%B9HashMap%E7%9A%84%E7%90%86%E8%A7%A3/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/%E8%87%AA%E5%B7%B1%E5%AF%B9HashMap%E7%9A%84%E7%90%86%E8%A7%A3/",
      "content_html": "<h1 id=\"我自己对hashmap的理解\"> 我自己对HashMap的理解</h1>\n<h2 id=\"一些问题\"> 一些问题</h2>\n<ul>\n<li>容量为什么一定是2的次方数？</li>\n<li>如何扩容？</li>\n<li>计算hash值时为什么要无符号右移16位？</li>\n<li>为什么使用求数组下标时使用 <code>(n - 1) &amp; hash</code> 而不用 <code>hash % n</code> 的方式？</li>\n<li>为什么负载因子默认值是0.75？</li>\n<li>为什么默认初始值是16？</li>\n<li>HashMap中是如何解决hash冲突的？</li>\n<li>阈值如何计算？</li>\n<li>什么时候将链表转化为红黑树？</li>\n<li>为什么线程不安全？</li>\n</ul>\n<p>答案在文章底部写出</p>\n<hr>\n<h2 id=\"一些重要属性\"> 一些重要属性</h2>\n<div><pre><code><span>//默认初始容量-必须为2的幂。</span>\n<span>static</span> <span>final</span> <span>int</span> DEFAULT_INITIAL_CAPACITY <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>4</span><span>;</span> <span>// aka 16</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>//在构造函数中未指定时使用的负载系数。</span>\n<span>static</span> <span>final</span> <span>float</span> DEFAULT_LOAD_FACTOR <span>=</span> <span>0.75f</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>//对该HashMap进行结构修改的次数结构修改是指更改HashMap中的映射数或以其他方式修改其内部结构（例如重新哈希）的修改。</span>\n<span>//此字段用于使HashMap的Collection-view上的迭代器快速失败。 </span>\n<span>//（请参阅ConcurrentModificationException）。</span>\n<span>transient</span> <span>int</span> modCount<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>//下一个要调整大小的大小值（容量*负载系数）</span>\n<span>//（javadoc描述在序列化时为true。</span>\n<span>//此外，如果尚未分配表数组，则此字段</span>\n<span>//保留初始数组容量，或零表示</span>\n<span>// DEFAULT_INITIAL_CAPACITY。）</span>\n<span>int</span> threshold<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>//哈希表的负载因子</span>\n<span>final</span> <span>float</span> loadFactor<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>//map的大小</span>\n<span>transient</span> <span>int</span> size<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"构造方法\"> 构造方法</h2>\n<div><pre><code><span>//用指定的初始容量和负载因子的空HashMap中 </span>\n<span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>,</span> <span>float</span> loadFactor<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>initialCapacity <span>&lt;</span> <span>0</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal initial capacity: \"</span> <span>+</span>\n                                           initialCapacity<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>initialCapacity <span>></span> MAXIMUM_CAPACITY<span>)</span>\n        initialCapacity <span>=</span> MAXIMUM_CAPACITY<span>;</span>\n    <span>if</span> <span>(</span>loadFactor <span>&lt;=</span> <span>0</span> <span>||</span> <span>Float</span><span>.</span><span>isNaN</span><span>(</span>loadFactor<span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal load factor: \"</span> <span>+</span>\n                                           loadFactor<span>)</span><span>;</span>\n    <span>this</span><span>.</span>loadFactor <span>=</span> loadFactor<span>;</span>\n    <span>this</span><span>.</span>threshold <span>=</span> <span>tableSizeFor</span><span>(</span>initialCapacity<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>//用指定的初始容量和默认加载因子（0.75）的空HashMap中</span>\n<span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>\n    <span>this</span><span>(</span>initialCapacity<span>,</span> DEFAULT_LOAD_FACTOR<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>//构造具有默认初始容量（16）和默认负载因数（0.75）的空HashMap中 </span>\n<span>public</span> <span>HashMap</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>loadFactor <span>=</span> DEFAULT_LOAD_FACTOR<span>;</span> <span>// all other fields defaulted</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>//构造一个具有相同的映射关系与指定Map一个新的HashMap。 </span>\n<span>//HashMap中与默认负载因数（0.75）和初始容量足以容纳在指定的map的映射创建。</span>\n<span>public</span> <span>HashMap</span><span>(</span><span>Map</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> m<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>loadFactor <span>=</span> DEFAULT_LOAD_FACTOR<span>;</span>\n    <span>putMapEntries</span><span>(</span>m<span>,</span> <span>false</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"put方法\"> put方法</h2>\n<div><pre><code>put(K key, V value) -&gt; putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>putVal()</strong></p>\n<div><pre><code><span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>,</span>\n                   <span>boolean</span> evict<span>)</span> <span>{</span>\n    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>;</span> <span>int</span> n<span>,</span> i<span>;</span>\n    <span>//如果tab为null或tab的长度为0，则进入判断（第一次put），利用resize()方法计算了tab的长度，并赋值给n</span>\n    <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>==</span> <span>null</span> <span>||</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>==</span> <span>0</span><span>)</span>\n        n <span>=</span> <span>(</span>tab <span>=</span> <span>resize</span><span>(</span><span>)</span><span>)</span><span>.</span>length<span>;</span>\n    <span>//判断Node对象是否null，为null就要调用构造方法初始化一下</span>\n    <span>//(n - 1) &amp; hash是为了计算tab的下标</span>\n    <span>if</span> <span>(</span><span>(</span>p <span>=</span> tab<span>[</span>i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>]</span><span>)</span> <span>==</span> <span>null</span><span>)</span>\n        tab<span>[</span>i<span>]</span> <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>\n    <span>else</span> <span>{</span><span>//Node对象p不为null</span>\n        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span> <span>K</span> k<span>;</span>\n        <span>//判断是否有相同的key，</span>\n        <span>//如果 hash值相同，key相同，</span>\n        <span>//则进入这里面的代码，作用是替换新值</span>\n        <span>if</span> <span>(</span>p<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>\n            <span>(</span><span>(</span>k <span>=</span> p<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>\n            <span>//将p的值赋给新的Node节点e</span>\n            e <span>=</span> p<span>;</span>\n        <span>else</span> <span>if</span> <span>(</span>p <span>instanceof</span> <span>TreeNode</span><span>)</span>\n            e <span>=</span> <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>p<span>)</span><span>.</span><span>putTreeVal</span><span>(</span><span>this</span><span>,</span> tab<span>,</span> hash<span>,</span> key<span>,</span> value<span>)</span><span>;</span>\n        <span>else</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> binCount <span>=</span> <span>0</span><span>;</span> <span>;</span> <span>++</span>binCount<span>)</span> <span>{</span>\n                <span>if</span> <span>(</span><span>(</span>e <span>=</span> p<span>.</span>next<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                    p<span>.</span>next <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>\n                    <span>if</span> <span>(</span>binCount <span>>=</span> TREEIFY_THRESHOLD <span>-</span> <span>1</span><span>)</span> <span>// -1 for 1st</span>\n                        <span>treeifyBin</span><span>(</span>tab<span>,</span> hash<span>)</span><span>;</span>\n                    <span>break</span><span>;</span>\n                <span>}</span>\n                <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>\n                    <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>\n                    <span>break</span><span>;</span>\n                p <span>=</span> e<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>//如果e不为null，</span>\n        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span> <span>// existing mapping for key</span>\n            <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>\n            <span>if</span> <span>(</span><span>!</span>onlyIfAbsent <span>||</span> oldValue <span>==</span> <span>null</span><span>)</span>\n                e<span>.</span>value <span>=</span> value<span>;</span>\n            <span>afterNodeAccess</span><span>(</span>e<span>)</span><span>;</span>\n            <span>return</span> oldValue<span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>//记录修改数据结构的次数</span>\n    <span>++</span>modCount<span>;</span>\n    \n    <span>//如果map的size大于阈值，要进行resize</span>\n    <span>if</span> <span>(</span><span>++</span>size <span>></span> threshold<span>)</span>\n        <span>resize</span><span>(</span><span>)</span><span>;</span>\n    <span>afterNodeInsertion</span><span>(</span>evict<span>)</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><blockquote>\n<div><pre><code><span>if</span> <span>(</span><span>(</span>p <span>=</span> tab<span>[</span>i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>]</span><span>)</span> <span>==</span> <span>null</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>(n - 1) &amp; hash</strong>：求tab数组的下标index</p>\n<div><pre><code>假设\nn = 16\nhash = 97\n(n - 1) &amp; 97 即 15 &amp; 97\n15 = 0000 0000 0000 0000 0000 0000 0000 1111\n&amp;\n97 = 0000 0000 0000 0000 0000 0000 0110 0001\n结果  0000 0000 0000 0000 0000 0000 0000 0001\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>为什么不用%取余呢</p>\n<p>因为位运算速度更快</p>\n</blockquote>\n<p><strong>hash(Object key)</strong></p>\n<div><pre><code><span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>int</span> h<span>;</span>\n    <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<p>计算key.hashCode（），并将（XOR）散列的较高位扩展到较低位。</p>\n<p>由于该表使用2的幂次掩码，因此仅在当前掩码上方的位中发生变化的散列集总是会发生冲突。</p>\n<p>（众所周知的例子是Float键集在小表中保存连续的整数。）</p>\n<p>因此，我们应用了一种变换，向下扩展了较高位的影响。在速度，效用和比特扩展质量之间需要权衡。因为许多常见的哈希集已经合理地分布了（所以不能从扩展中受益），并且由于我们使用树来处理大量的hash冲突(碰撞)，所以我们仅以最简单的方式对一些移位后的位进行XOR运算，减少系统损失，以及合并最高位的影响，否则由于表的限制，这些位将永远不会用于索引计算。</p>\n</blockquote>\n<p>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</p>\n<blockquote>\n<p>假设h = 97</p>\n<p>97 ^ (97 &gt;&gt;&gt; 16)</p>\n<p>97 &gt;&gt;&gt; 16</p>\n<div><pre><code>97二进制 0000 0000 0000 0000 0000 0000 0110 0001\n右移     &gt;&gt;&gt; 16\n结果     0000 0000 0000 0000 0000 0000 0000 0000\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>97 ^ 0</p>\n<div><pre><code>（97）    0000 0000 0000 0000 0000 0000 0110 0001\n异或 ^    0000 0000 0000 0000 0000 0000 0000 0000\n结果      0000 0000 0000 0000 0000 0000 0110 0001 = 97\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>h &gt;&gt;&gt; 16 是为了计算得到的数组下标更散列一些</strong></p>\n</blockquote>\n<p><strong>resize()</strong></p>\n<div><pre><code><span>final</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> <span>resize</span><span>(</span><span>)</span> <span>{</span>\n    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> oldTab <span>=</span> table<span>;</span>\n    <span>int</span> oldCap <span>=</span> <span>(</span>oldTab <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> oldTab<span>.</span>length<span>;</span>\n    <span>int</span> oldThr <span>=</span> threshold<span>;</span>\n    <span>int</span> newCap<span>,</span> newThr <span>=</span> <span>0</span><span>;</span>\n    <span>//第1次put时，不会进入该判断，</span>\n    <span>//扩容时会进入该判断</span>\n    <span>if</span> <span>(</span>oldCap <span>></span> <span>0</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>oldCap <span>>=</span> MAXIMUM_CAPACITY<span>)</span> <span>{</span>\n            threshold <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>\n            <span>return</span> oldTab<span>;</span>\n        <span>}</span>\n        <span>//将新容量newCap和新阈值newThr翻倍</span>\n        <span>else</span> <span>if</span> <span>(</span><span>(</span>newCap <span>=</span> oldCap <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;&amp;</span>\n                 oldCap <span>>=</span> DEFAULT_INITIAL_CAPACITY<span>)</span>\n            newThr <span>=</span> oldThr <span>&lt;&lt;</span> <span>1</span><span>;</span> <span>// double threshold</span>\n    <span>}</span>\n    <span>else</span> <span>if</span> <span>(</span>oldThr <span>></span> <span>0</span><span>)</span> <span>// initial capacity was placed in threshold</span>\n        newCap <span>=</span> oldThr<span>;</span>\n    <span>else</span> <span>{</span>               <span>// zero initial threshold signifies using defaults</span>\n        newCap <span>=</span> DEFAULT_INITIAL_CAPACITY<span>;</span>\n        newThr <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span>DEFAULT_LOAD_FACTOR <span>*</span> DEFAULT_INITIAL_CAPACITY<span>)</span><span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span>newThr <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        <span>float</span> ft <span>=</span> <span>(</span><span>float</span><span>)</span>newCap <span>*</span> loadFactor<span>;</span>\n        newThr <span>=</span> <span>(</span>newCap <span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;&amp;</span> ft <span>&lt;</span> <span>(</span><span>float</span><span>)</span>MAXIMUM_CAPACITY <span>?</span>\n                  <span>(</span><span>int</span><span>)</span>ft <span>:</span> <span>Integer</span><span>.</span>MAX_VALUE<span>)</span><span>;</span>\n    <span>}</span>\n    threshold <span>=</span> newThr<span>;</span>\n    <span>@SuppressWarnings</span><span>(</span><span>{</span><span>\"rawtypes\"</span><span>,</span><span>\"unchecked\"</span><span>}</span><span>)</span>\n    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> newTab <span>=</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>Node</span><span>[</span>newCap<span>]</span><span>;</span>\n    table <span>=</span> newTab<span>;</span>\n    <span>if</span> <span>(</span>oldTab <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>//将旧的table中的数据转移到新的table中</span>\n        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> oldCap<span>;</span> <span>++</span>j<span>)</span> <span>{</span>\n            <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span>\n            <span>if</span> <span>(</span><span>(</span>e <span>=</span> oldTab<span>[</span>j<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                oldTab<span>[</span>j<span>]</span> <span>=</span> <span>null</span><span>;</span>\n                <span>if</span> <span>(</span>e<span>.</span>next <span>==</span> <span>null</span><span>)</span>\n                    newTab<span>[</span>e<span>.</span>hash <span>&amp;</span> <span>(</span>newCap <span>-</span> <span>1</span><span>)</span><span>]</span> <span>=</span> e<span>;</span>\n                <span>else</span> <span>if</span> <span>(</span>e <span>instanceof</span> <span>TreeNode</span><span>)</span>\n                    <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>e<span>)</span><span>.</span><span>split</span><span>(</span><span>this</span><span>,</span> newTab<span>,</span> j<span>,</span> oldCap<span>)</span><span>;</span>\n                <span>else</span> <span>{</span> <span>// preserve order</span>\n                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> loHead <span>=</span> <span>null</span><span>,</span> loTail <span>=</span> <span>null</span><span>;</span>\n                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> hiHead <span>=</span> <span>null</span><span>,</span> hiTail <span>=</span> <span>null</span><span>;</span>\n                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>;</span>\n                    <span>do</span> <span>{</span>\n                        next <span>=</span> e<span>.</span>next<span>;</span>\n                        <span>if</span> <span>(</span><span>(</span>e<span>.</span>hash <span>&amp;</span> oldCap<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                            <span>if</span> <span>(</span>loTail <span>==</span> <span>null</span><span>)</span>\n                                loHead <span>=</span> e<span>;</span>\n                            <span>else</span>\n                                loTail<span>.</span>next <span>=</span> e<span>;</span>\n                            loTail <span>=</span> e<span>;</span>\n                        <span>}</span>\n                        <span>else</span> <span>{</span>\n                            <span>if</span> <span>(</span>hiTail <span>==</span> <span>null</span><span>)</span>\n                                hiHead <span>=</span> e<span>;</span>\n                            <span>else</span>\n                                hiTail<span>.</span>next <span>=</span> e<span>;</span>\n                            hiTail <span>=</span> e<span>;</span>\n                        <span>}</span>\n                    <span>}</span> <span>while</span> <span>(</span><span>(</span>e <span>=</span> next<span>)</span> <span>!=</span> <span>null</span><span>)</span><span>;</span>\n                    <span>if</span> <span>(</span>loTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                        loTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>\n                        newTab<span>[</span>j<span>]</span> <span>=</span> loHead<span>;</span>\n                    <span>}</span>\n                    <span>if</span> <span>(</span>hiTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                        hiTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>\n                        newTab<span>[</span>j <span>+</span> oldCap<span>]</span> <span>=</span> hiHead<span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> newTab<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br></div></div><blockquote>\n<div><pre><code>newCap <span>=</span> DEFAULT_INITIAL_CAPACITY<span>;</span>\nnewThr <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span>DEFAULT_LOAD_FACTOR <span>*</span> DEFAULT_INITIAL_CAPACITY<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>resize方法主要计算了</p>\n<ul>\n<li>新容量newCap（默认的初始容量）</li>\n<li>新阈值newThr（默认的负载因子 * 默认的初始容量）</li>\n</ul>\n<p>并返回一个新table</p>\n</blockquote>\n<h2 id=\"一些问题-2\"> 一些问题</h2>\n<ul>\n<li>\n<p>容量为什么一定是2的次方数？</p>\n<blockquote>\n<p>因为只有长度是2的N次方，进行减一操作得到的数的二进制结果的低位进行按位与运算才能拿到全部是1的值，在进行按位与运算才能快速的拿到数组的下标，并且分布是均匀的。</p>\n<p>当计算<code>(n - 1) &amp; hash</code>时，可以提高计算效率也可以快速定位</p>\n<p>如果不是2的次方数，扩容时会变成比该容量的最小2的次方数，比如3会变成4, 11会变成16</p>\n</blockquote>\n</li>\n<li>\n<p>如何扩容？</p>\n<blockquote>\n<p>将新容量newCap和新阈值newThr翻倍</p>\n</blockquote>\n</li>\n<li>\n<p>为什么使用求数组下标时使用 <code>(n - 1) &amp; hash</code> 而不用 <code>hash % n</code> 的方式？</p>\n<blockquote>\n<p>位运算速度快</p>\n</blockquote>\n</li>\n<li>\n<p>为什么负载因子默认值是0.75？</p>\n<blockquote>\n<p>负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。</p>\n</blockquote>\n</li>\n<li>\n<p>为什么默认初始值是16？</p>\n</li>\n<li>\n<p>HashMap中是如何解决hash冲突的？</p>\n<blockquote>\n<p>使用链表</p>\n</blockquote>\n</li>\n<li>\n<p>阈值如何计算？</p>\n</li>\n</ul>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "8.Integer类",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/8.Integer%E7%B1%BB/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/8.Integer%E7%B1%BB/",
      "content_html": "<h1 id=\"_8-integer类\"> 8.Integer类</h1>\n<p>Integer类为java基本类型int的包装类，除了前面提到的Byte类，Short类中的大部分方法，Integer类中还提供了很多处理int类型的方法，接下来就让我们一起看看吧。</p>\n<h4 id=\"基础知识\"> 基础知识：</h4>\n<p>1.Java移位运算，移位运算也是java中位运算的一部分主要有以下三种：\n前提：\n1).移位是在将对应的数字转换为2进制后进行的，JAVA中用补码表示二进制数.\n2).移位后总长度不变，比如int类型为32位，移动后还需补齐为32位，其它也类似\n3).左边为低位，右边为高位\n左移( &lt;&lt; )：将运算符左边的对象，向左移动运算符右边指定的位数，并且在低位补零。向左移n 位，就相当于乘上2 的n 次方\n右移( &gt;&gt; )：将运算符左边的运算对象，向右移动运算符右边指定的位数。如果是正数，在高位补零，如果是负数，则在高位补1\n无符号右移( &gt;&gt;&gt; )：将运算符左边的对象向右移动运算符右边指定的位数，并且在高位补0\n注：\n1).对于正数来说，右移或无称号右移n 位，就相当于除上2 的n 次方。\n2).对于int类型(长度为32位)移位，左移(&lt;&lt;)n位，相当于移动 n % 32 位，如:  1 &lt;&lt; 33 实际上是 1 &lt;&lt; 1 也就是2，其它类型移动超过自身类型长度的也应该是类似，有兴趣的可以自行研究下。\n3).java中没有无符号左移，原因很简单，左移补的是低位，java中高位的第一位表示符号位。</p>\n<h4 id=\"前言\"> 前言：</h4>\n<p>从本文开始，对于比较简单的属性和方法，或是在之前文章中讲过的文章中将不再列出，有兴趣的同学可以看下之前的文章，或是留言笔者将根据大家的需求考虑是否后续在文章中添加。</p>\n<h4 id=\"几个数组属性\"> 几个数组属性:</h4>\n<div><pre><code><span>final</span> <span>static</span> <span>char</span><span>[</span><span>]</span> digits <span>=</span> <span>{</span>\n        <span>'0'</span> <span>,</span> <span>'1'</span> <span>,</span> <span>'2'</span> <span>,</span> <span>'3'</span> <span>,</span> <span>'4'</span> <span>,</span> <span>'5'</span> <span>,</span>\n        <span>'6'</span> <span>,</span> <span>'7'</span> <span>,</span> <span>'8'</span> <span>,</span> <span>'9'</span> <span>,</span> <span>'a'</span> <span>,</span> <span>'b'</span> <span>,</span>\n        <span>'c'</span> <span>,</span> <span>'d'</span> <span>,</span> <span>'e'</span> <span>,</span> <span>'f'</span> <span>,</span> <span>'g'</span> <span>,</span> <span>'h'</span> <span>,</span>\n        <span>'i'</span> <span>,</span> <span>'j'</span> <span>,</span> <span>'k'</span> <span>,</span> <span>'l'</span> <span>,</span> <span>'m'</span> <span>,</span> <span>'n'</span> <span>,</span>\n        <span>'o'</span> <span>,</span> <span>'p'</span> <span>,</span> <span>'q'</span> <span>,</span> <span>'r'</span> <span>,</span> <span>'s'</span> <span>,</span> <span>'t'</span> <span>,</span>\n        <span>'u'</span> <span>,</span> <span>'v'</span> <span>,</span> <span>'w'</span> <span>,</span> <span>'x'</span> <span>,</span> <span>'y'</span> <span>,</span> <span>'z'</span>\n<span>}</span><span>;</span>\n<span>final</span> <span>static</span> <span>char</span> <span>[</span><span>]</span> <span>DigitTens</span> <span>=</span> <span>{</span>\n        <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span>\n        <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span>\n        <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span>\n        <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span>\n        <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span>\n        <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span>\n        <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span>\n        <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span>\n        <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span>\n        <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span>\n    <span>}</span> <span>;</span>\n\n<span>final</span> <span>static</span> <span>char</span> <span>[</span><span>]</span> <span>DigitOnes</span> <span>=</span> <span>{</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n    <span>}</span> <span>;</span>\n<span>final</span> <span>static</span> <span>int</span> <span>[</span><span>]</span> sizeTable <span>=</span> <span>{</span> <span>9</span><span>,</span> <span>99</span><span>,</span> <span>999</span><span>,</span> <span>9999</span><span>,</span> <span>99999</span><span>,</span> <span>999999</span><span>,</span> <span>9999999</span><span>,</span>\n                                      <span>99999999</span><span>,</span> <span>999999999</span><span>,</span> <span>Integer</span><span>.</span>MAX_VALUE <span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>digits数组用于表示所有可能出现的字符，因为int支持从2进制到36进制，所以这里需要有36个字符才能表示所有不同进制的数字\nDigitTens和DigitOnes两个数组也很好理解，它们主要用于获取0到99之间某个数的十位和个位，比如36，通过DigitTens数组直接取出来十位为3，而通过DigitOnes数组取出来个位为6。\nsizeTable数组主要用在判断一个int型数字对应字符串的长度。避免了使用除法或求余等操作，以提高效率。</p>\n<p>toString(int i, int radix)：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>toString</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> radix<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>radix <span>&lt;</span> <span>Character</span><span>.</span>MIN_RADIX <span>||</span> radix <span>></span> <span>Character</span><span>.</span>MAX_RADIX<span>)</span>\n            radix <span>=</span> <span>10</span><span>;</span>\n        <span>if</span> <span>(</span>radix <span>==</span> <span>10</span><span>)</span> <span>{</span>\n            <span>return</span> <span>toString</span><span>(</span>i<span>)</span><span>;</span>\n        <span>}</span>\n        <span>char</span> buf<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>char</span><span>[</span><span>33</span><span>]</span><span>;</span>\n        <span>boolean</span> negative <span>=</span> <span>(</span>i <span>&lt;</span> <span>0</span><span>)</span><span>;</span>\n        <span>int</span> charPos <span>=</span> <span>32</span><span>;</span>\n\n        <span>if</span> <span>(</span><span>!</span>negative<span>)</span> <span>{</span>\n            i <span>=</span> <span>-</span>i<span>;</span>\n        <span>}</span>\n        <span>while</span> <span>(</span>i <span>&lt;=</span> <span>-</span>radix<span>)</span> <span>{</span>\n            buf<span>[</span>charPos<span>--</span><span>]</span> <span>=</span> digits<span>[</span><span>-</span><span>(</span>i <span>%</span> radix<span>)</span><span>]</span><span>;</span>\n            i <span>=</span> i <span>/</span> radix<span>;</span>\n        <span>}</span>\n        buf<span>[</span>charPos<span>]</span> <span>=</span> digits<span>[</span><span>-</span>i<span>]</span><span>;</span>\n        <span>if</span> <span>(</span>negative<span>)</span> <span>{</span>\n            buf<span>[</span><span>--</span>charPos<span>]</span> <span>=</span> <span>'-'</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>buf<span>,</span> charPos<span>,</span> <span>(</span><span>33</span> <span>-</span> charPos<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>该方法的作用就是将int类型的数字，转换为指定进制的数的字符串形式。\n第一步判断:int类型支持的进制数为2(Character.MIN_RADIX)到36(Character.MAX_RADIX),如果不是这个范围就按10进制来处理。\n第二步：如果是10进制，调用toString(i)(这个方法我们后面再讲)，如果不是10进制，继续往下走。\n第三步：接着它创建了一个长度为33的char类型的数组，诶，为什么这里长度为33，int类型的最大长度为32啊，看到后面你就知道了，还要给 '-'留一个位置，原来这个方法的转换并不是真正意义上的转换，都是按照正数来转换，如果是负数就在正数转换的结果上加'-'。\n第四步：创建了两个局部变量negative和charPos其中negative是个标识，用来标识目标数是正数还是负数。charPos是用来指定转换后的数存储在缓冲数组中的位置。\n第五步：转换，这里就是按照10进制的数转换为其它进制数的转换方法进行的。如果不清楚的同学可以看下另一篇文章<a href=\"http://aiceflower.farbox.com/post/javaji-zhu-hun-za/javazhong-de-jin-zhi-zhuan-huan\" target=\"_blank\" rel=\"noopener noreferrer\">Java中的进制转换</a>\n第六步：创建一个字符串对象返回。</p>\n<h4 id=\"tostring-int-i\"> toString(int i):</h4>\n<div><pre><code><span>public</span> <span>static</span> String <span>toString</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>i <span>==</span> Integer<span>.</span>MIN_VALUE<span>)</span>\n            <span>return</span> <span>\"-2147483648\"</span><span>;</span>\n        <span>int</span> size <span>=</span> <span>(</span>i <span>&lt;</span> <span>0</span><span>)</span> <span>?</span> <span>stringSize</span><span>(</span><span>-</span>i<span>)</span> <span>+</span> <span>1</span> <span>:</span> <span>stringSize</span><span>(</span>i<span>)</span><span>;</span>\n        <span>char</span><span>[</span><span>]</span> buf <span>=</span> <span>new</span> <span>char</span><span>[</span>size<span>]</span><span>;</span>\n        <span>getChars</span><span>(</span>i<span>,</span> size<span>,</span> buf<span>)</span><span>;</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>buf<span>,</span> <span>true</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这个方法用来将10进制的数转换为10进制的字符串形式。\n第一步：判断如果是int类型的最小值，就直接返回一个固定的值，无需计算。\n第二步：计算数字的长度，用到的stringSize方法,如下:</p>\n<div><pre><code><span>static</span> <span>int</span> <span>stringSize</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> <span>;</span> i<span>++</span><span>)</span>\n            <span>if</span> <span>(</span>x <span>&lt;=</span> sizeTable<span>[</span>i<span>]</span><span>)</span>\n                <span>return</span> i<span>+</span><span>1</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>可以看到它使用了sizeTable这个数组，巧妙的避免了除法和求余，以高效的求得对应字符串长度。方法实现很简单，但是思想我们可以借鉴。\n第三步：创建了一个数组，然后调用getChars方法填充数组中的内容。getChars方法实现如下:</p>\n<div><pre><code><span>static</span> <span>void</span> <span>getChars</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> index<span>,</span> <span>char</span><span>[</span><span>]</span> buf<span>)</span> <span>{</span>\n        <span>int</span> q<span>,</span> r<span>;</span>\n        <span>int</span> charPos <span>=</span> index<span>;</span>\n        <span>char</span> sign <span>=</span> <span>0</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            sign <span>=</span> <span>'-'</span><span>;</span>\n            i <span>=</span> <span>-</span>i<span>;</span>\n        <span>}</span>\n        <span>// Generate two digits per iteration</span>\n        <span>while</span> <span>(</span>i <span>>=</span> <span>65536</span><span>)</span> <span>{</span>\n            q <span>=</span> i <span>/</span> <span>100</span><span>;</span>\n        <span>// really: r = i - (q * 100);</span>\n            r <span>=</span> i <span>-</span> <span>(</span><span>(</span>q <span>&lt;&lt;</span> <span>6</span><span>)</span> <span>+</span> <span>(</span>q <span>&lt;&lt;</span> <span>5</span><span>)</span> <span>+</span> <span>(</span>q <span>&lt;&lt;</span> <span>2</span><span>)</span><span>)</span><span>;</span>\n            i <span>=</span> q<span>;</span>\n            buf <span>[</span><span>--</span>charPos<span>]</span> <span>=</span> DigitOnes<span>[</span>r<span>]</span><span>;</span>\n            buf <span>[</span><span>--</span>charPos<span>]</span> <span>=</span> DigitTens<span>[</span>r<span>]</span><span>;</span>\n        <span>}</span>\n        <span>// Fall thru to fast mode for smaller numbers</span>\n        <span>// assert(i &lt;= 65536, i);</span>\n        <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n            q <span>=</span> <span>(</span>i <span>*</span> <span>52429</span><span>)</span> <span>>></span><span>></span> <span>(</span><span>16</span><span>+</span><span>3</span><span>)</span><span>;</span>\n            r <span>=</span> i <span>-</span> <span>(</span><span>(</span>q <span>&lt;&lt;</span> <span>3</span><span>)</span> <span>+</span> <span>(</span>q <span>&lt;&lt;</span> <span>1</span><span>)</span><span>)</span><span>;</span>  <span>// r = i-(q*10) ...</span>\n            buf <span>[</span><span>--</span>charPos<span>]</span> <span>=</span> digits <span>[</span>r<span>]</span><span>;</span>\n            i <span>=</span> q<span>;</span>\n            <span>if</span> <span>(</span>i <span>==</span> <span>0</span><span>)</span> <span>break</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>sign <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n            buf <span>[</span><span>--</span>charPos<span>]</span> <span>=</span> sign<span>;</span>\n        <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>这个方法的作用就是将一个int类型的数按顺序放到char数组中。不过这里使用了很多的技巧。它把int的高位的两个字节和低位的两个字节分开处理，while (i &gt;= 65536)就是处理高位的两个字节`。每次处理两位数，使用了一个技巧((q &lt;&lt; 6) + (q &lt;&lt; 5) + (q &lt;&lt; 2)),就是 q * (2^6 +2^5 + 2^2) = q * 100。DigitTens和DigitOnes用来取十位和个位。后面就是对低位的两个数进行处理了，其本质就是求余，也用了一些技巧，(i * 52429) &gt;&gt;&gt; (16+3)其实约等于i/10，((q &lt;&lt; 3) + (q &lt;&lt; 1))其实等于q*10，最后通过digits数组获取到对应的字符。这里面使用乘法和移位运算代替除法和取余，用移位运算和加法代替乘法，可见在运算效率上加法和移位高于乘法，乘法高于除法。\n第四步：根据填充好的char数组创建字符串对象返回\n注：\n1.这个方法也就是toString(int i, int radix)方法中对于10进制的处理。可以看到对于10进制的转化，可是花了大功夫在优化上，为了避免使用除法，应用各种移位操作来进行，即使在不得不使用除法的地方也尽可能用除以100而不是除以10来减少除法次数。\n2.这里使用getChars去填充char数组，显然写这段代码的之前是一个写C语言这种面向过程的人。对于java这种面向对象的语言来说，这里我们应该用  char[] buf = getChars(i, size);这种方式，以后大家写java代码我也推荐大家使用这种方式。什么没看明白，自己去百度下面向过程和面向对象方面的知识吧。</p>\n<h4 id=\"int类型转换为其它进制的字符串形式\"> int类型转换为其它进制的字符串形式:</h4>\n<div><pre><code><span>//转换为16进制</span>\n<span>public</span> <span>static</span> String <span>toHexString</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>toUnsignedString0</span><span>(</span>i<span>,</span> <span>4</span><span>)</span><span>;</span>\n<span>}</span>\n<span>//转换为8进制</span>\n<span>public</span> <span>static</span> String <span>toOctalString</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>toUnsignedString0</span><span>(</span>i<span>,</span> <span>3</span><span>)</span><span>;</span>\n<span>}</span>\n<span>//转换为2进制</span>\n<span>public</span> <span>static</span> String <span>toBinaryString</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>toUnsignedString0</span><span>(</span>i<span>,</span> <span>1</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>可以看到这几个转换的方法都调用了同一个方法toUnsignedString0只是传的参数不同，toUnsignedString0方法如下：</p>\n<div><pre><code><span>private</span> <span>static</span> String <span>toUnsignedString0</span><span>(</span><span>int</span> val<span>,</span> <span>int</span> shift<span>)</span> <span>{</span>\n        <span>// assert shift > 0 &amp;&amp; shift &lt;=5 : \"Illegal shift value\";</span>\n        <span>int</span> mag <span>=</span> Integer<span>.</span>SIZE <span>-</span> Integer<span>.</span><span>numberOfLeadingZeros</span><span>(</span>val<span>)</span><span>;</span>\n        <span>int</span> chars <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>(</span><span>(</span>mag <span>+</span> <span>(</span>shift <span>-</span> <span>1</span><span>)</span><span>)</span> <span>/</span> shift<span>)</span><span>,</span> <span>1</span><span>)</span><span>;</span>\n        <span>char</span><span>[</span><span>]</span> buf <span>=</span> <span>new</span> <span>char</span><span>[</span>chars<span>]</span><span>;</span>\n        <span>formatUnsignedInt</span><span>(</span>val<span>,</span> shift<span>,</span> buf<span>,</span> <span>0</span><span>,</span> chars<span>)</span><span>;</span>\n        <span>// Use special constructor which takes over \"buf\".</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>buf<span>,</span> <span>true</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>第一步：获取目标值value的二进制形式有效位长度，Integer.numberOfLeadingZeros(val)这个方法是计算value的二进制高位共有多少位0，后面我们再讲这个方法。\n第二步:获取缓冲数组的大小\n第三步:调用formatUnsignedInt方法，这个方法才是核心，原因如下：</p>\n<div><pre><code><span>static</span> <span>int</span> <span>formatUnsignedInt</span><span>(</span><span>int</span> val<span>,</span> <span>int</span> shift<span>,</span> <span>char</span><span>[</span><span>]</span> buf<span>,</span> <span>int</span> offset<span>,</span> <span>int</span> len<span>)</span> <span>{</span>\n        <span>int</span> charPos <span>=</span> len<span>;</span>\n        <span>int</span> radix <span>=</span> <span>1</span> <span>&lt;&lt;</span> shift<span>;</span>\n        <span>int</span> mask <span>=</span> radix <span>-</span> <span>1</span><span>;</span>\n        <span>do</span> <span>{</span>\n            buf<span>[</span>offset <span>+</span> <span>--</span>charPos<span>]</span> <span>=</span> Integer<span>.</span>digits<span>[</span>val <span>&amp;</span> mask<span>]</span><span>;</span>\n            val <span>>></span><span>>=</span> shift<span>;</span>\n        <span>}</span> <span>while</span> <span>(</span>val <span>!=</span> <span>0</span> <span>&amp;&amp;</span> charPos <span>></span> <span>0</span><span>)</span><span>;</span>\n        <span>return</span> charPos<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这里就是<a href=\"http://aiceflower.farbox.com/post/javaji-zhu-hun-za/javazhong-de-jin-zhi-zhuan-huan\" target=\"_blank\" rel=\"noopener noreferrer\">将10进制数转换为其它进制数</a>的代码体现了,其中 1 &lt;&lt; shift相当于2^shift，radix - 1如果转换为16进制就是15如果是8进制就是7，这里是为了后面做&amp;的计算，你想一下如果转换为16进制，一个数&amp;上15(1111)，就是取得这个数字的低4位，这样4位4位的计算不就转换为这个数的16进制了吗，转换为8进制同理。后面的val&amp;mask  就相当于  val%(mask+1)也就是进制转换的过程了。\n第四步：根据buf数组，创建String对象后返回。</p>\n<h4 id=\"parseint\"> parseInt:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>parseInt</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> radix<span>)</span>\n                <span>throws</span> <span>NumberFormatException</span>\n    <span>{</span>\n        <span>if</span> <span>(</span>s <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span><span>\"null\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>radix <span>&lt;</span> <span>Character</span><span>.</span>MIN_RADIX<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span><span>\"radix \"</span> <span>+</span> radix <span>+</span>\n                                            <span>\" less than Character.MIN_RADIX\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>radix <span>></span> <span>Character</span><span>.</span>MAX_RADIX<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span><span>\"radix \"</span> <span>+</span> radix <span>+</span>\n                                            <span>\" greater than Character.MAX_RADIX\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>int</span> result <span>=</span> <span>0</span><span>;</span>\n        <span>boolean</span> negative <span>=</span> <span>false</span><span>;</span>\n        <span>int</span> i <span>=</span> <span>0</span><span>,</span> len <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> limit <span>=</span> <span>-</span><span>Integer</span><span>.</span>MAX_VALUE<span>;</span>\n        <span>int</span> multmin<span>;</span>\n        <span>int</span> digit<span>;</span>\n        <span>if</span> <span>(</span>len <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>char</span> firstChar <span>=</span> s<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>firstChar <span>&lt;</span> <span>'0'</span><span>)</span> <span>{</span> <span>// Possible leading \"+\" or \"-\"</span>\n                <span>if</span> <span>(</span>firstChar <span>==</span> <span>'-'</span><span>)</span> <span>{</span>\n                    negative <span>=</span> <span>true</span><span>;</span>\n                    limit <span>=</span> <span>Integer</span><span>.</span>MIN_VALUE<span>;</span>\n                <span>}</span> <span>else</span> <span>if</span> <span>(</span>firstChar <span>!=</span> <span>'+'</span><span>)</span>\n                    <span>throw</span> <span>NumberFormatException</span><span>.</span><span>forInputString</span><span>(</span>s<span>)</span><span>;</span>\n                <span>if</span> <span>(</span>len <span>==</span> <span>1</span><span>)</span> <span>// Cannot have lone \"+\" or \"-\"</span>\n                    <span>throw</span> <span>NumberFormatException</span><span>.</span><span>forInputString</span><span>(</span>s<span>)</span><span>;</span>\n                i<span>++</span><span>;</span>\n            <span>}</span>\n            multmin <span>=</span> limit <span>/</span> radix<span>;</span>\n            <span>while</span> <span>(</span>i <span>&lt;</span> len<span>)</span> <span>{</span>\n                digit <span>=</span> <span>Character</span><span>.</span><span>digit</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span>i<span>++</span><span>)</span><span>,</span>radix<span>)</span><span>;</span>\n                <span>if</span> <span>(</span>digit <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n                    <span>throw</span> <span>NumberFormatException</span><span>.</span><span>forInputString</span><span>(</span>s<span>)</span><span>;</span>\n                <span>}</span>\n                <span>if</span> <span>(</span>result <span>&lt;</span> multmin<span>)</span> <span>{</span>\n                    <span>throw</span> <span>NumberFormatException</span><span>.</span><span>forInputString</span><span>(</span>s<span>)</span><span>;</span>\n                <span>}</span>\n                result <span>*=</span> radix<span>;</span>\n                <span>if</span> <span>(</span>result <span>&lt;</span> limit <span>+</span> digit<span>)</span> <span>{</span>\n                    <span>throw</span> <span>NumberFormatException</span><span>.</span><span>forInputString</span><span>(</span>s<span>)</span><span>;</span>\n                <span>}</span>\n                result <span>-=</span> digit<span>;</span>\n            <span>}</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>throw</span> <span>NumberFormatException</span><span>.</span><span>forInputString</span><span>(</span>s<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> negative <span>?</span> result <span>:</span> <span>-</span>result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><p>parseInt有两个方法，作用是将指定进制的数的字符串形式转换为int类型。看上面这个就行。\n第一步：参数校验。字符串为null或是radix不在可转换的进制范围内就抛出异常。\n第二步：核心处理逻辑是字符串转换数字，<a href=\"http://aiceflower.farbox.com/post/javaji-zhu-hun-za/javazhong-de-jin-zhi-zhuan-huan\" target=\"_blank\" rel=\"noopener noreferrer\">其它进制转成十进制</a>，如521为8进制，则结果为5* 8^2 + 2<em>8^1 + 1</em>8^0.上面的转换方法也差不多是根据此方法，只是稍微转变了思路( (5 * 8+2)*8)+1结果都是一样的。规律就是从左到右遍历字符串的每个字符，然后乘以进制数，再加上下一个字符，接着再乘以进制数，再加上下个字符，不断重复，直到最后一个字符。除此之外另外一个不同就是上面的转换不使用加法来做，全都转成负数来运算，其实可以看成是等价了。因为负数Integer.MIN_VALUE变化为正数时会导致数值溢出，所以全部都用负数来运算。\n第三步：返回正确的结果如果是负数就添加负号。</p>\n<p>无符号转换:</p>\n<div><pre><code><span>public</span> <span>static</span> String <span>toUnsignedString</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> radix<span>)</span> <span>{</span>\n        <span>return</span> Long<span>.</span><span>toUnsignedString</span><span>(</span><span>toUnsignedLong</span><span>(</span>i<span>)</span><span>,</span> radix<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>static</span> <span>long</span> <span>toUnsignedLong</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>(</span><span>long</span><span>)</span> x<span>)</span> <span>&amp;</span> <span>0xffffffffL</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这两个方法就是将目标数转换为无符号表示的long或是字符串，无符号意思就是将二进制中的高位的第一位不当作符号位来看待。其中toUnsignedString使用了Long.toUnsignedString方法，一直跟踪源码可以发现实现方式与Integer中的实现方式相同，这里就不再重复了，不明白的同学可以看下Integer中的toString方法和toUnsignedString0方法。</p>\n<h4 id=\"parseunsignedint\"> parseUnsignedInt：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>parseUnsignedInt</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> radix<span>)</span>\n                <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>if</span> <span>(</span>s <span>==</span> <span>null</span><span>)</span>  <span>{</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span><span>\"null\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>int</span> len <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>len <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>char</span> firstChar <span>=</span> s<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>firstChar <span>==</span> <span>'-'</span><span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span>\n                    <span>NumberFormatException</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"Illegal leading minus sign \"</span> <span>+</span>\n                                                       <span>\"on unsigned string %s.\"</span><span>,</span> s<span>)</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>if</span> <span>(</span>len <span>&lt;=</span> <span>5</span> <span>||</span> <span>// Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits</span>\n                    <span>(</span>radix <span>==</span> <span>10</span> <span>&amp;&amp;</span> len <span>&lt;=</span> <span>9</span><span>)</span> <span>)</span> <span>{</span> <span>// Integer.MAX_VALUE in base 10 is 10 digits</span>\n                    <span>return</span> <span>parseInt</span><span>(</span>s<span>,</span> radix<span>)</span><span>;</span>\n                <span>}</span> <span>else</span> <span>{</span>\n                    <span>long</span> ell <span>=</span> <span>Long</span><span>.</span><span>parseLong</span><span>(</span>s<span>,</span> radix<span>)</span><span>;</span>\n                    <span>if</span> <span>(</span><span>(</span>ell <span>&amp;</span> <span>0</span>xffff_ffff_0000_0000L<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                        <span>return</span> <span>(</span><span>int</span><span>)</span> ell<span>;</span>\n                    <span>}</span> <span>else</span> <span>{</span>\n                        <span>throw</span> <span>new</span>\n                            <span>NumberFormatException</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"String value %s exceeds \"</span> <span>+</span>\n                                                                <span>\"range of unsigned int.\"</span><span>,</span> s<span>)</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>throw</span> <span>NumberFormatException</span><span>.</span><span>forInputString</span><span>(</span>s<span>)</span><span>;</span>\n        <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>将目标字符串数字转换为指定进制的无符号整型。\n第一步：获取第一个字符，判断是否为'-',如果是'-'就抛出异常。\n第二步：判断长度小于5或是小于9的10进制，使用parseInt方法长度小于5是因为int类型的最大数转换为最大进制36进制是6位。parseInt方法在上面已经讲过了。\n第三步：如果超出第二步判断的范围，就要使用long来转换了，否则可能溢出。 if ((ell &amp; 0xffff_ffff_0000_0000L) == 0) 若未超过int无符号数支持的范围，即数字高八位为0，则返回int值，否则抛出异常，数字超过int可表示的范围。</p>\n<p>IntegerCache：</p>\n<div><pre><code><span>private</span> <span>static</span> <span>class</span> <span>IntegerCache</span> <span>{</span>\n        <span>static</span> <span>final</span> <span>int</span> low <span>=</span> <span>-</span><span>128</span><span>;</span>\n        <span>static</span> <span>final</span> <span>int</span> high<span>;</span>\n        <span>static</span> <span>final</span> <span>Integer</span> cache<span>[</span><span>]</span><span>;</span>\n\n        <span>static</span> <span>{</span>\n            <span>int</span> h <span>=</span> <span>127</span><span>;</span>\n            <span>String</span> integerCacheHighPropValue <span>=</span>\n                sun<span>.</span>misc<span>.</span>VM<span>.</span><span>getSavedProperty</span><span>(</span><span>\"java.lang.Integer.IntegerCache.high\"</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>integerCacheHighPropValue <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                    <span>int</span> i <span>=</span> <span>parseInt</span><span>(</span>integerCacheHighPropValue<span>)</span><span>;</span>\n                    i <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>i<span>,</span> <span>127</span><span>)</span><span>;</span>\n                    h <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>i<span>,</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>(</span><span>-</span>low<span>)</span> <span>-</span><span>1</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span><span>(</span> <span>NumberFormatException</span> nfe<span>)</span> <span>{</span>\n                <span>}</span>\n            <span>}</span>\n            high <span>=</span> h<span>;</span>\n            cache <span>=</span> <span>new</span> <span>Integer</span><span>[</span><span>(</span>high <span>-</span> low<span>)</span> <span>+</span> <span>1</span><span>]</span><span>;</span>\n            <span>int</span> j <span>=</span> low<span>;</span>\n            <span>for</span><span>(</span><span>int</span> k <span>=</span> <span>0</span><span>;</span> k <span>&lt;</span> cache<span>.</span>length<span>;</span> k<span>++</span><span>)</span>\n                cache<span>[</span>k<span>]</span> <span>=</span> <span>new</span> <span>Integer</span><span>(</span>j<span>++</span><span>)</span><span>;</span>\n            <span>assert</span> <span>IntegerCache</span><span>.</span>high <span>>=</span> <span>127</span><span>;</span>\n        <span>}</span>\n        <span>private</span> <span>IntegerCache</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>可以看出Integer类也有如同Byte和Short类类似的缓存池机制，而不同点在于Integer的缓存池可以改变上限的大小，通过 sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);来获取上限，这个参数可以在JVM中配置。但是在设置的时候这个值是要大于或等于127小于Integer.MAX_VALUE。如果小于127以127为上限。注意。下限是-128这个是不可以改变的。</p>\n<h4 id=\"getinteger\"> getInteger:</h4>\n<div><pre><code><span>public</span> static Integer <span>getInteger</span><span>(</span>String nm<span>,</span> Integer <span>val</span><span>)</span> <span>{</span>\n        String v <span>=</span> <span>null</span><span>;</span>\n        <span>try</span> <span>{</span>\n            v <span>=</span> System<span>.</span><span>getProperty</span><span>(</span>nm<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span>IllegalArgumentException | NullPointerException e<span>)</span> <span>{</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>v <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>return</span> Integer<span>.</span><span>decode</span><span>(</span>v<span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span>NumberFormatException e<span>)</span> <span>{</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>val</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这个方法是从系统属性中查找数据然后转换为对应的Integer对象，如果系统中不存在待查找的属性，则返回null。单从方法名上看Integer.getInteger与Integer.valueOf(由于valueOf方法在之前的<a href=\"https://www.jianshu.com/p/26bedb3ae3c4\" target=\"_blank\" rel=\"noopener noreferrer\">Byte类</a>或<a href=\"https://www.jianshu.com/p/3826ccd9e867\" target=\"_blank\" rel=\"noopener noreferrer\">Short类</a>中已经讲过了，都是相似的，这里不赘述)方法功能是一样的，但实际则不然，我们在使用的时候也要小心一点。</p>\n<h4 id=\"decode\"> decode：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>Integer</span> <span>decode</span><span>(</span><span>String</span> nm<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>int</span> radix <span>=</span> <span>10</span><span>;</span>\n        <span>int</span> index <span>=</span> <span>0</span><span>;</span>\n        <span>boolean</span> negative <span>=</span> <span>false</span><span>;</span>\n        <span>Integer</span> result<span>;</span>\n        <span>if</span> <span>(</span>nm<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span><span>\"Zero length string\"</span><span>)</span><span>;</span>\n        <span>char</span> firstChar <span>=</span> nm<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>// Handle sign, if present</span>\n        <span>if</span> <span>(</span>firstChar <span>==</span> <span>'-'</span><span>)</span> <span>{</span>\n            negative <span>=</span> <span>true</span><span>;</span>\n            index<span>++</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>firstChar <span>==</span> <span>'+'</span><span>)</span>\n            index<span>++</span><span>;</span>\n        <span>// Handle radix specifier, if present</span>\n        <span>if</span> <span>(</span>nm<span>.</span><span>startsWith</span><span>(</span><span>\"0x\"</span><span>,</span> index<span>)</span> <span>||</span> nm<span>.</span><span>startsWith</span><span>(</span><span>\"0X\"</span><span>,</span> index<span>)</span><span>)</span> <span>{</span>\n            index <span>+=</span> <span>2</span><span>;</span>\n            radix <span>=</span> <span>16</span><span>;</span>\n        <span>}</span>\n        <span>else</span> <span>if</span> <span>(</span>nm<span>.</span><span>startsWith</span><span>(</span><span>\"#\"</span><span>,</span> index<span>)</span><span>)</span> <span>{</span>\n            index <span>++</span><span>;</span>\n            radix <span>=</span> <span>16</span><span>;</span>\n        <span>}</span>\n        <span>else</span> <span>if</span> <span>(</span>nm<span>.</span><span>startsWith</span><span>(</span><span>\"0\"</span><span>,</span> index<span>)</span> <span>&amp;&amp;</span> nm<span>.</span><span>length</span><span>(</span><span>)</span> <span>></span> <span>1</span> <span>+</span> index<span>)</span> <span>{</span>\n            index <span>++</span><span>;</span>\n            radix <span>=</span> <span>8</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>nm<span>.</span><span>startsWith</span><span>(</span><span>\"-\"</span><span>,</span> index<span>)</span> <span>||</span> nm<span>.</span><span>startsWith</span><span>(</span><span>\"+\"</span><span>,</span> index<span>)</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span><span>\"Sign character in wrong position\"</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            result <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span>nm<span>.</span><span>substring</span><span>(</span>index<span>)</span><span>,</span> radix<span>)</span><span>;</span>\n            result <span>=</span> negative <span>?</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>-</span>result<span>.</span><span>intValue</span><span>(</span><span>)</span><span>)</span> <span>:</span> result<span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>NumberFormatException</span> e<span>)</span> <span>{</span>\n            <span>// If number is Integer.MIN_VALUE, we'll end up here. The next line</span>\n            <span>// handles this case, and causes any genuine format error to be</span>\n            <span>// rethrown.</span>\n            <span>String</span> constant <span>=</span> negative <span>?</span> <span>(</span><span>\"-\"</span> <span>+</span> nm<span>.</span><span>substring</span><span>(</span>index<span>)</span><span>)</span>\n                                       <span>:</span> nm<span>.</span><span>substring</span><span>(</span>index<span>)</span><span>;</span>\n            result <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span>constant<span>,</span> radix<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>这个方法是用来解析2进制，8进制，10进制16进制表示的字符串的。我们用数字前面加0表示8进制如056，数字前面加0x或是#，如0x1234或是#1234，表示16进制，默认数字为10进制。注意这个方法也不是太智能，如你传100这个字符串，他就不知道是10进制还是2进制，默认当10进制来转换了。又如你给定字符串 0000 0000 0000 0100 ，你想让他按2进制来解析，但实际上他按8进制来解析。所以使用的时候如果有这种有歧义的字符串，要小心一些。</p>\n<p>无符号比较：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>compareUnsigned</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span>\n        <span>return</span> <span>compare</span><span>(</span>x <span>+</span> MIN_VALUE<span>,</span> y <span>+</span> MIN_VALUE<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>static</span> <span>int</span> <span>compare</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>x <span>&lt;</span> y<span>)</span> <span>?</span> <span>-</span><span>1</span> <span>:</span> <span>(</span><span>(</span>x <span>==</span> y<span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>1</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>无符号就是二进制的最高位符号位不当作符号位来，比较，实现过程也很简单。那么这个函数用来比较两个数-1是最大的，因为-1的所有位都是1，当然最大。</p>\n<h4 id=\"divideunsigned\"> divideUnsigned:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>divideUnsigned</span><span>(</span><span>int</span> dividend<span>,</span> <span>int</span> divisor<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>int</span><span>)</span><span>(</span><span>toUnsignedLong</span><span>(</span>dividend<span>)</span> <span>/</span> <span>toUnsignedLong</span><span>(</span>divisor<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>divide意为除的意思，这个方法就是将两个数转换为无符号的数，然后再相除。</p>\n<h4 id=\"remainderunsigned\"> remainderUnsigned:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>remainderUnsigned</span><span>(</span><span>int</span> dividend<span>,</span> <span>int</span> divisor<span>)</span> <span>{</span>\n        <span>// In lieu of tricky code, for now just use long arithmetic.</span>\n        <span>return</span> <span>(</span><span>int</span><span>)</span><span>(</span><span>toUnsignedLong</span><span>(</span>dividend<span>)</span> <span>%</span> <span>toUnsignedLong</span><span>(</span>divisor<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>将两个数转换为无符号的数，然后再计算余数,可以看到源码的注释 // In lieu of tricky code, for now just use long arithmetic.意思就是因为这个情况很棘手，所以现在暂时用long型数据，具体待我们看到<a href=\"https://www.jianshu.com/p/160c2bf8f781\" target=\"_blank\" rel=\"noopener noreferrer\">Long类的源码</a>时再研究</p>\n<h4 id=\"highestonebit\"> highestOneBit:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>highestOneBit</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        i <span>|=</span> <span>(</span>i <span>>></span>  <span>1</span><span>)</span><span>;</span>\n        i <span>|=</span> <span>(</span>i <span>>></span>  <span>2</span><span>)</span><span>;</span>\n        i <span>|=</span> <span>(</span>i <span>>></span>  <span>4</span><span>)</span><span>;</span>\n        i <span>|=</span> <span>(</span>i <span>>></span>  <span>8</span><span>)</span><span>;</span>\n        i <span>|=</span> <span>(</span>i <span>>></span> <span>16</span><span>)</span><span>;</span>\n        <span>return</span> i <span>-</span> <span>(</span>i <span>>></span><span>></span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>乍一看这个方法是干什么的，不明白。按照位运算|和移位运算一步一步的跟下来，你就会发现，将目标数转换为二进制后。保留这个数的最高位1，即从右边开始数第一个1保留。然后其它位全变为0后的结果。如10 ，二进制为1010，保留最高位1，其它位全变0就是1000，结果就为8.</p>\n<p>lowestOneBit：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>lowestOneBit</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>return</span> i <span>&amp;</span> <span>-</span>i<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>同highestOneBit类似，从左边开始数第1位1保留，其它全变0后的结果。</p>\n<h4 id=\"numberofleadingzeros\"> numberOfLeadingZeros：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>numberOfLeadingZeros</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>i <span>==</span> <span>0</span><span>)</span>\n            <span>return</span> <span>32</span><span>;</span>\n        <span>int</span> n <span>=</span> <span>1</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>>></span><span>></span> <span>16</span> <span>==</span> <span>0</span><span>)</span> <span>{</span> n <span>+=</span> <span>16</span><span>;</span> i <span>&lt;&lt;=</span> <span>16</span><span>;</span> <span>}</span>\n        <span>if</span> <span>(</span>i <span>>></span><span>></span> <span>24</span> <span>==</span> <span>0</span><span>)</span> <span>{</span> n <span>+=</span>  <span>8</span><span>;</span> i <span>&lt;&lt;=</span>  <span>8</span><span>;</span> <span>}</span>\n        <span>if</span> <span>(</span>i <span>>></span><span>></span> <span>28</span> <span>==</span> <span>0</span><span>)</span> <span>{</span> n <span>+=</span>  <span>4</span><span>;</span> i <span>&lt;&lt;=</span>  <span>4</span><span>;</span> <span>}</span>\n        <span>if</span> <span>(</span>i <span>>></span><span>></span> <span>30</span> <span>==</span> <span>0</span><span>)</span> <span>{</span> n <span>+=</span>  <span>2</span><span>;</span> i <span>&lt;&lt;=</span>  <span>2</span><span>;</span> <span>}</span>\n        n <span>-=</span> i <span>>></span><span>></span> <span>31</span><span>;</span>\n        <span>return</span> n<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这个函数的作用就是，取一个int类型数的二进制左边共有多少位0.如10的二进制为1010，int共有32位，那么左边就有28个0，即numberOfLeadingZeros(10)结果为28。这个方法作用很简单，但实现这个方法用的一个思想却是很重要，值得我们一学。有兴趣的同学可以看下我的别一篇文章<a href=\"http://aiceflower.farbox.com/post/ji-zhu-si-xiang/cong-jdkyuan-ma-kan-er-fen-si-xiang\" target=\"_blank\" rel=\"noopener noreferrer\">从JDK源码看二分思想</a>。</p>\n<h4 id=\"numberoftrailingzeros\"> numberOfTrailingZeros：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>numberOfTrailingZeros</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>int</span> y<span>;</span>\n        <span>if</span> <span>(</span>i <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>32</span><span>;</span>\n        <span>int</span> n <span>=</span> <span>31</span><span>;</span>\n        y <span>=</span> i <span>&lt;&lt;</span><span>16</span><span>;</span> <span>if</span> <span>(</span>y <span>!=</span> <span>0</span><span>)</span> <span>{</span> n <span>=</span> n <span>-</span><span>16</span><span>;</span> i <span>=</span> y<span>;</span> <span>}</span>\n        y <span>=</span> i <span>&lt;&lt;</span> <span>8</span><span>;</span> <span>if</span> <span>(</span>y <span>!=</span> <span>0</span><span>)</span> <span>{</span> n <span>=</span> n <span>-</span> <span>8</span><span>;</span> i <span>=</span> y<span>;</span> <span>}</span>\n        y <span>=</span> i <span>&lt;&lt;</span> <span>4</span><span>;</span> <span>if</span> <span>(</span>y <span>!=</span> <span>0</span><span>)</span> <span>{</span> n <span>=</span> n <span>-</span> <span>4</span><span>;</span> i <span>=</span> y<span>;</span> <span>}</span>\n        y <span>=</span> i <span>&lt;&lt;</span> <span>2</span><span>;</span> <span>if</span> <span>(</span>y <span>!=</span> <span>0</span><span>)</span> <span>{</span> n <span>=</span> n <span>-</span> <span>2</span><span>;</span> i <span>=</span> y<span>;</span> <span>}</span>\n        <span>return</span> n <span>-</span> <span>(</span><span>(</span>i <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>>></span><span>></span> <span>31</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>同numberOfLeadingZeros类似，这个方法的作用就是取一个int类型的二进制右边共有多少位0。如10的二进制为1010.右边共有1个0.numberOfTrailingZeros(10)结果就为1。</p>\n<h4 id=\"bitcount\"> bitCount：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>bitCount</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        i <span>=</span> i <span>-</span> <span>(</span><span>(</span>i <span>>></span><span>></span> <span>1</span><span>)</span> <span>&amp;</span> <span>0x55555555</span><span>)</span><span>;</span>\n        i <span>=</span> <span>(</span>i <span>&amp;</span> <span>0x33333333</span><span>)</span> <span>+</span> <span>(</span><span>(</span>i <span>>></span><span>></span> <span>2</span><span>)</span> <span>&amp;</span> <span>0x33333333</span><span>)</span><span>;</span>\n        i <span>=</span> <span>(</span>i <span>+</span> <span>(</span>i <span>>></span><span>></span> <span>4</span><span>)</span><span>)</span> <span>&amp;</span> <span>0x0f0f0f0f</span><span>;</span>\n        i <span>=</span> i <span>+</span> <span>(</span>i <span>>></span><span>></span> <span>8</span><span>)</span><span>;</span>\n        i <span>=</span> i <span>+</span> <span>(</span>i <span>>></span><span>></span> <span>16</span><span>)</span><span>;</span>\n        <span>return</span> i <span>&amp;</span> <span>0x3f</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这个方法的作用是，将一个int类型的数转换为二进制后，数里面有多少个1。如10，二进制为1010，有两个1，那么bitCount(10)结果就为2。其核心思想是使用二分法，两两一组相加，之后四个四个一组相加，接着八个八个，最后就得到各位之和了。 第一行是计算每两位中的 1 的个数 , 并且用该对应的两位来存储这个个数 , 如 : 01101100  转换后为 01011000 , 即先把前者每两位分段 01 10 11 00 , 分别有 1 1 2 0 个 1, 用两位二进制数表示为 01 01 10 00, 合起来为 01011000。 第二行是计算每四位中的 1 的个数 , 并且用该对应的四位来存储这个个数 。如 : 01101100 经过第一行计算后得 01011000 , 然后把 01011000 每四位分段成 0101 1000 , 段内移位相加 : 前段 01+01 =10 , 后段 10+00=10, 分别用四位二进制数表示为 0010 0010, 合起来为 00100010 . 下面的各行以此类推 , 分别计算每 8 位 ,16 位 ,32 位中的 1 的个数 。</p>\n<p>rotateLeft:</p>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>rotateLeft</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> distance<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>i <span>&lt;&lt;</span> distance<span>)</span> <span>|</span> <span>(</span>i <span>>></span><span>></span> <span>-</span>distance<span>)</span><span>;</span>\n       \n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>(i &lt;&lt; distance) 先把尾巴那几位空出来成0，然后(i &gt;&gt;&gt; -distance)获得前面的那几位，然后按位或运算，就旋转了，即循环左移。</p>\n<h4 id=\"rotateright\"> rotateRight:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>rotateRight</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> distance<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>i <span>>></span><span>></span> distance<span>)</span> <span>|</span> <span>(</span>i <span>&lt;&lt;</span> <span>-</span>distance<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>跟前面的rotateLeft一样，先把位置空出来，然后取得对应的二进制位，按位或运算，就成了。</p>\n<h4 id=\"reverse\"> reverse：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>reverse</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        i <span>=</span> <span>(</span>i <span>&amp;</span> <span>0x55555555</span><span>)</span> <span>&lt;&lt;</span> <span>1</span> <span>|</span> <span>(</span>i <span>>></span><span>></span> <span>1</span><span>)</span> <span>&amp;</span> <span>0x55555555</span><span>;</span>\n        i <span>=</span> <span>(</span>i <span>&amp;</span> <span>0x33333333</span><span>)</span> <span>&lt;&lt;</span> <span>2</span> <span>|</span> <span>(</span>i <span>>></span><span>></span> <span>2</span><span>)</span> <span>&amp;</span> <span>0x33333333</span><span>;</span>\n        i <span>=</span> <span>(</span>i <span>&amp;</span> <span>0x0f0f0f0f</span><span>)</span> <span>&lt;&lt;</span> <span>4</span> <span>|</span> <span>(</span>i <span>>></span><span>></span> <span>4</span><span>)</span> <span>&amp;</span> <span>0x0f0f0f0f</span><span>;</span>\n        i <span>=</span> <span>(</span>i <span>&lt;&lt;</span> <span>24</span><span>)</span> <span>|</span> <span>(</span><span>(</span>i <span>&amp;</span> <span>0xff00</span><span>)</span> <span>&lt;&lt;</span> <span>8</span><span>)</span> <span>|</span>\n            <span>(</span><span>(</span>i <span>>></span><span>></span> <span>8</span><span>)</span> <span>&amp;</span> <span>0xff00</span><span>)</span> <span>|</span> <span>(</span>i <span>>></span><span>></span> <span>24</span><span>)</span><span>;</span>\n        <span>return</span> i<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>将目标数转换为32位二进制数据后，高位和低位对应位置数据互换。如10转换为2进制后为00000000 000000000 00000000 0001010则转换后数据为01010000 00000000 00000000 00000000怎么样很好理解吧。其实Integer中的很多操作都是转换为二进制后，再处理的，光看代码很复杂。把数据转换成二进制，然后再对照代码看就很简单了。</p>\n<h4 id=\"signum\"> signum：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>signum</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>i <span>>></span> <span>31</span><span>)</span> <span>|</span> <span>(</span><span>-</span>i <span>>></span><span>></span> <span>31</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个方法我还没研究明白是干什么用的，i &gt;&gt; 31这个如果i为正数运算后全变为0，如果是负数运算后全变为1(指的是二进制位)，(-i &gt;&gt;&gt;31) 如果i为正数，运算后为1，如果i为负数运算后为0。两个数做|运算后，如果i为正则结果为1，如果为负数结果为-1，如果是0则结果为0，估计是运来判断一个数是正数负数还是0吧。如果是这样的话直接跟0做比较不就好了，写这段代码干什么呢，搞不明白。</p>\n<p>reverseBytes:</p>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>reverseBytes</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>(</span>i <span>>></span><span>></span> <span>24</span><span>)</span>           <span>)</span> <span>|</span>\n               <span>(</span><span>(</span>i <span>>></span>   <span>8</span><span>)</span> <span>&amp;</span>   <span>0xFF00</span><span>)</span> <span>|</span>\n               <span>(</span><span>(</span>i <span>&lt;&lt;</span>   <span>8</span><span>)</span> <span>&amp;</span> <span>0xFF0000</span><span>)</span> <span>|</span>\n               <span>(</span><span>(</span>i <span>&lt;&lt;</span> <span>24</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这个方法同Byte类的reverseBytes方法有点类似。但这里是高8位与低8位互换，中间的两个8位互换之后的结果。转换成二进制后就一目了然了，我就不举例了。</p>\n<h4 id=\"其它方法\"> 其它方法：</h4>\n<div><pre><code><span>//求两个数之和</span>\n<span>public</span> <span>static</span> <span>int</span> <span>sum</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n   <span>return</span> a <span>+</span> b<span>;</span>\n<span>}</span>\n<span>//取两个数中较大的数</span>\n<span>public</span> <span>static</span> <span>int</span> <span>max</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n    <span>return</span> Math<span>.</span><span>max</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>\n<span>}</span>\n<span>//取两个数中较小的数</span>\n<span>public</span> <span>static</span> <span>int</span> <span>min</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n    <span>return</span> Math<span>.</span><span>min</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>这几个方法挺简单的，大家一看就明白了。</p>\n<p>注：</p>\n<ul>\n<li>Integer类中的很多方法都是操作二进制数的。光看代码可能一头雾水，转换为二进制后，再辅助代码就直观多了。</li>\n<li>这个类中涉及了很多的位运算，如果对位运算不清楚的可以看下<a href=\"https://www.jianshu.com/p/26bedb3ae3c4\" target=\"_blank\" rel=\"noopener noreferrer\">一起学JDK源码 -- Byte类</a>和本章的基础知识部分。</li>\n<li>这个类中有一些方法如signum、reverseBytes等操作二进制数的思想到是很精彩。但实际不知道有什么用。不知道是作者炫耀它的思想，还是我太菜没看出来他的意图。</li>\n</ul>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "深入浅出多线程教程",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%99%E7%A8%8B/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/note/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%99%E7%A8%8B/",
      "content_html": "<h1 id=\"深入浅出多线程教程\"> 深入浅出多线程教程</h1>\n<h2 id=\"第一篇-基础篇\"> 第一篇 基础篇</h2>\n<h3 id=\"_1-进程与线程基本概念\"> 1 进程与线程基本概念</h3>\n<h4 id=\"_1-1-进程产生的背景\"> <strong>1.1 进程产生的背景</strong></h4>\n<p>最初的计算机只能接受一些特定的指令，用户每输入一个指令，计算机就做出一个操作。当用户在思考或者输入时，计算机就在等待。这样效率非常低下，在很多时候，计算机都处在等待状态。</p>\n<p><strong>批处理操作系统</strong></p>\n<p>后来有了<strong>批处理操作体统</strong>,把一系列需要操作的指令写下来，形成一个清单，一次性交给计算机。用户将多个需要执行的程序写在磁带上，然后交由计算机去读取并逐个执行这些程序，并将输出结果写在另一个磁带上。</p>\n<p>批处理操作系统在一定程度上提高了计算机的效率，但是由于<strong>批处理操作系统的指令运行方式仍然是串行的，内存中始终只有一个程序在运行</strong>，后面的程序需要等待前面的程序执行完成后才能开始执行，而前面的程序有时会由于I/O操作、网络等原因阻塞，所以<strong>批处理操作效率也不高</strong>。</p>\n<p><strong>进程的提出</strong></p>\n<p>人们对于计算机的性能要求越来越高，现有的批处理操作系统并不能满足人们的需求，而批处理操作系统的瓶颈在于内存中只存在一个程序，那么内存中能不能存在多个程序呢？这是人们亟待解决的问题。</p>\n<p>于是，科学家们提出了进程的概念。</p>\n<p>进程就是<strong>应用程序在内存中分配的空间，也就是正在运行的程序</strong>，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。</p>\n<blockquote>\n<p>程序：用某种编程语言(java、python等)编写，能够完成一定任务或者功能的代码集合,是指令和数据的有序集合，是<strong>一段静态代码</strong>。</p>\n</blockquote>\n<p>此时，CPU采用时间片轮转的方式运行进程：CPU为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且CPU分配给另一个进程（这个过程叫做上下文切换）。如果进程在时间片结束前阻塞或结束，则CPU立即进行切换，不用等待时间片用完。</p>\n<blockquote>\n<p>当进程暂停时，它会保存当前进程的状态（进程标识，进程使用的资源等），在下一次切换回来时根据之前保存的状态进行恢复，接着继续执行。</p>\n</blockquote>\n<p>使用进程+CPU时间片轮转方式的操作系统，在宏观上看起来同一时间段执行多个任务，换句话说，<strong>进程让操作体统的并发成为了可能</strong>。虽然并发从宏观上看有多个任务在执行，但在事实上，对于<strong>单核CPU</strong>来说，任意具体时刻都只有一个任务在占用CPU资源。</p>\n<p><strong>对操作系统的要求进一步提高</strong></p>\n<p>虽然进程的出现，使得操作系统的性能大大提升，但是随着时间的推移，人们并不满足一个进程在一段时间只能做一件事情，如果一个进程有多个子任务时，只能逐个得执行这些子任务，很影响效率。</p>\n<blockquote>\n<p>比如杀毒软件在检测用户电脑时，如果在某一项检测中卡住了，那么后面的检测项也会受到影响。或者说当你使用杀毒软件中的扫描病毒功能时，在扫描病毒结束之前，无法使用杀毒软件中清理垃圾的功能，这显然无法满足人们的要求。</p>\n</blockquote>\n<p><strong>线程的提出</strong></p>\n<p>那么能不能让这些子任务同时执行呢？于是人们又提出了线程的概念，<strong>让一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。</strong></p>\n<blockquote>\n<p>使用线程之后，事情就变得简单多了。当用户使用扫描病毒功能时，就让扫描病毒这个线程去执行。同时，如果用户又使用清理垃圾功能，那么可以先暂停扫描病毒线程，先响应用户的清理垃圾的操作，让清理垃圾这个线程去执行。响应完后再切换回来，接着执行扫描病毒线程。</p>\n<p>注意：操作系统是如何分配时间片给每一个线程的，涉及到线程的调度策略，有兴趣的同学可以看一下《操作系统》，本文不做深入详解。</p>\n</blockquote>\n<p>总之，进程和线程的提出极大的提高了操作提供的性能。<strong>进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能。</strong></p>\n<p><strong>多进程的方式也可以实现并发，为什么我们要使用多线程？</strong></p>\n<p>多进程方式确实可以实现并发，但使用多线程，有以下几个好处：</p>\n<ul>\n<li>进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。</li>\n<li>进程是重量级的，而线程是轻量级的，故多线程方式的系统开销更小。</li>\n</ul>\n<p><strong>进程和线程的区别</strong></p>\n<p>进程是一个独立的运行环境，而线程是在进程中执行的一个任务。他们两个本质的区别是<strong>是否单独占有内存地址空间及其它系统资源（比如I/O）</strong>：</p>\n<ul>\n<li>进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。</li>\n<li>进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。</li>\n<li>进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</li>\n</ul>\n<p>另外一个重要区别是，<strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位</strong>，即CPU分配时间的单位 。</p>\n<h4 id=\"_1-2-上下文切换\"> <strong>1.2 上下文切换</strong></h4>\n<p>上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。上下文是指<strong>某一时间点 CPU 寄存器和程序计数器的内容。</strong></p>\n<blockquote>\n<p>寄存器是cpu内部的少量的速度很快的闪存，通常存储和访问计算过程的中间值提高计算机程序的运行速度。</p>\n<p>程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体实现依赖于特定的系统。</p>\n<p>举例说明 线程A - B</p>\n<p>1.先挂起线程A，将其在cpu中的状态保存在内存中。</p>\n<p>2.在内存中检索下一个线程B的上下文并将其在 CPU 的寄存器中恢复,执行B线程。</p>\n<p>3.当B执行完，根据程序计数器中指向的位置恢复线程A。</p>\n</blockquote>\n<p>CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。</p>\n<p>但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p>\n<p>上下文切换通常是计算密集型的，意味着此操作会<strong>消耗大量的 CPU 时间，故线程也不是越多越好</strong>。如何减少系统中上下文切换次数，是提升多线程性能的一个重点课题。</p>\n<h3 id=\"_2-java多线程入门类和接口\"> 2 Java多线程入门类和接口</h3>\n<h4 id=\"_2-1-thread类和runnable接口\"> <strong>2.1 Thread类和Runnable接口</strong></h4>\n<p>上一章我们了解了操作系统中多线程的基本概念。那么在Java中，我们是如何使用多线程的呢？</p>\n<p>首先，我们需要有一个“线程”类。JDK提供了<code>Thread</code>类和<code>Runnalble</code>接口来让我们实现自己的“线程”类。</p>\n<ul>\n<li>继承<code>Thread</code>类，并重写<code>run</code>方法；</li>\n<li>实现<code>Runnable</code>接口的<code>run</code>方法；</li>\n</ul>\n<h4 id=\"_2-1-1-继承thread类\"> <strong>2.1.1 继承Thread类</strong></h4>\n<p>先学会怎么用，再学原理。首先我们来看看怎么用<code>Thread</code>和<code>Runnable</code>来写一个Java多线程程序。</p>\n<p>首先是继承<code>Thread</code>类：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Demo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"MyThread\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Thread</span> myThread <span>=</span> <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>\n        myThread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>注意要调用<code>start()</code>方法后，该线程才算启动！</p>\n<blockquote>\n<p>我们在程序里面调用了start()方法后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时再调用run()方法。</p>\n<p>注意不可多次调用start()方法。在第一次调用start()方法后，再次调用start()方法会抛出异常。</p>\n</blockquote>\n<h4 id=\"_2-1-2-实现runnable接口\"> <strong>2.1.2 实现Runnable接口</strong></h4>\n<p>接着我们来看一下<code>Runnable</code>接口(JDK 1.8 +)：</p>\n<div><pre><code><span>@FunctionalInterface</span>\n<span>public</span> <span>interface</span> <span>Runnable</span> <span>{</span>\n    <span>public</span> <span>abstract</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>可以看到<code>Runnable</code>是一个函数式接口，这意味着我们可以使用<strong>Java 8的函数式编程</strong>来简化代码。</p>\n<p>示例代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Demo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>MyThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"MyThread\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// Java 8 函数式编程，可以省略MyThread类</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Java 8 匿名内部类\"</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id=\"_2-1-3-thread类构造方法\"> <strong>2.1.3 Thread类构造方法</strong></h4>\n<p><code>Thread</code>类是一个<code>Runnable</code>接口的实现类，我们来看看<code>Thread</code>类的源码。</p>\n<p>查看<code>Thread</code>类的构造方法，发现其实是简单调用一个私有的<code>init</code>方法来实现初始化。<code>init</code>的方法签名：</p>\n<div><pre><code><span>// Thread类源码 </span>\n\n<span>// 片段1 - init方法</span>\n<span>private</span> <span>void</span> <span>init</span><span>(</span><span>ThreadGroup</span> g<span>,</span> <span>Runnable</span> target<span>,</span> <span>String</span> name<span>,</span>\n                      <span>long</span> stackSize<span>,</span> <span>AccessControlContext</span> acc<span>,</span>\n                      <span>boolean</span> inheritThreadLocals<span>)</span>\n\n<span>// 片段2 - 构造函数调用init方法</span>\n<span>public</span> <span>Thread</span><span>(</span><span>Runnable</span> target<span>)</span> <span>{</span>\n    <span>init</span><span>(</span><span>null</span><span>,</span> target<span>,</span> <span>\"Thread-\"</span> <span>+</span> <span>nextThreadNum</span><span>(</span><span>)</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 片段3 - 使用在init方法里初始化AccessControlContext类型的私有属性</span>\n<span>this</span><span>.</span>inheritedAccessControlContext <span>=</span> \n    acc <span>!=</span> <span>null</span> <span>?</span> acc <span>:</span> <span>AccessController</span><span>.</span><span>getContext</span><span>(</span><span>)</span><span>;</span>\n\n<span>// 片段4 - 两个对用于支持ThreadLocal的私有属性</span>\n<span>ThreadLocal<span>.</span>ThreadLocalMap</span> threadLocals <span>=</span> <span>null</span><span>;</span>\n<span>ThreadLocal<span>.</span>ThreadLocalMap</span> inheritableThreadLocals <span>=</span> <span>null</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>我们挨个来解释一下<code>init</code>方法的这些参数：</p>\n<ul>\n<li>\n<p>g：线程组，指定这个线程是在哪个线程组下；</p>\n</li>\n<li>\n<p>target：指定要执行的任务；</p>\n</li>\n<li>\n<p>name：线程的名字，多个线程的名字是可以重复的。如果不指定名字，见片段2；</p>\n</li>\n<li>\n<p>acc：见片段3，用于初始化私有变量<code>inheritedAccessControlContext</code>。</p>\n<blockquote>\n<p>这个变量有点神奇。它是一个私有变量，但是在<code>Thread</code>类里只有<code>init</code>方法对它进行初始化，在<code>exit</code>方法把它设为<code>null</code>。其它没有任何地方使用它。一般我们是不会使用它的，那什么时候会使用到这个变量呢？可以参考这个stackoverflow的问题：<a href=\"https://stackoverflow.com/questions/13516766/restrict-permissions-to-threads-which-execute-third-party-software\" target=\"_blank\" rel=\"noopener noreferrer\">Restrict permissions to threads which execute third party software</a>；</p>\n</blockquote>\n</li>\n<li>\n<p>inheritThreadLocals：可继承的<code>ThreadLocal</code>，见片段4，<code>Thread</code>类里面有两个私有属性来支持<code>ThreadLocal</code>，我们会在后面的章节介绍<code>ThreadLocal</code>的概念。</p>\n</li>\n</ul>\n<p>实际情况下，我们大多是直接调用下面两个构造方法：</p>\n<div><pre><code><span>Thread</span><span>(</span><span>Runnable</span> target<span>)</span>\n<span>Thread</span><span>(</span><span>Runnable</span> target<span>,</span> <span>String</span> name<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_2-1-4-thread类的几个常用方法\"> <strong>2.1.4 Thread类的几个常用方法</strong></h4>\n<p>这里介绍一下Thread类的几个常用的方法：</p>\n<ul>\n<li>currentThread()：静态方法，返回对当前正在执行的线程对象的引用；</li>\n<li>start()：开始执行线程的方法，java虚拟机会调用线程内的run()方法；</li>\n<li>yield()：yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调用了yield()方法，程序在调度的时候，也还有可能继续运行这个线程的；</li>\n<li>sleep()：静态方法，使当前线程睡眠一段时间；</li>\n<li>join()：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的；</li>\n</ul>\n<h4 id=\"_2-1-5-thread类与runnable接口的比较\"> <strong>2.1.5 Thread类与Runnable接口的比较：</strong></h4>\n<p>实现一个自定义的线程类，可以有继承<code>Thread</code>类或者实现<code>Runnable</code>接口这两种方式，它们之间有什么优劣呢？</p>\n<ul>\n<li>由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活。</li>\n<li>Runnable接口出现更符合面向对象，将线程单独进行对象的封装。</li>\n<li>Runnable接口出现，降低了线程对象和线程任务的耦合性。</li>\n<li>如果使用线程时不需要使用Thread类的诸多方法，显然使用Runnable接口更为轻量。</li>\n</ul>\n<p>所以，我们通常优先使用“实现<code>Runnable</code>接口”这种方式来自定义线程类。</p>\n<h4 id=\"_2-2-callable、future与futuretask\"> <strong>2.2 Callable、Future与FutureTask</strong></h4>\n<p>通常来说，我们使用<code>Runnable</code>和<code>Thread</code>来创建一个新的线程。但是它们有一个弊端，就是<code>run</code>方法是没有返回值的。而有时候我们希望开启一个线程去执行一个任务，并且这个任务执行完成后有一个返回值。</p>\n<p>JDK提供了<code>Callable</code>接口与<code>Future</code>类为我们解决这个问题，这也是所谓的“异步”模型。</p>\n<h4 id=\"_2-2-1-callable接口\"> <strong>2.2.1 Callable接口</strong></h4>\n<p><code>Callable</code>与<code>Runnable</code>类似，同样是只有一个抽象方法的函数式接口。不同的是，<code>Callable</code>提供的方法是<strong>有返回值</strong>的，而且支持<strong>泛型</strong>。</p>\n<div><pre><code><span>@FunctionalInterface</span>\n<span>public</span> <span>interface</span> <span>Callable</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>\n    <span>V</span> <span>call</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>那一般是怎么使用<code>Callable</code>的呢？<code>Callable</code>一般是配合线程池工具<code>ExecutorService</code>来使用的。我们会在后续章节解释线程池的使用。这里只介绍<code>ExecutorService</code>可以使用<code>submit</code>方法来让一个<code>Callable</code>接口执行。它会返回一个<code>Future</code>，我们后续的程序可以通过这个<code>Future</code>的<code>get</code>方法得到结果。</p>\n<p>这里可以看一个简单的使用demo：</p>\n<div><pre><code><span>// 自定义Callable</span>\n<span>class</span> <span>Task</span> <span>implements</span> <span>Callable</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>Integer</span> <span>call</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>// 模拟计算需要一秒</span>\n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n        <span>return</span> <span>2</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span> args<span>[</span><span>]</span><span>)</span><span>{</span>\n        <span>// 使用</span>\n        <span>ExecutorService</span> executor <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>)</span><span>;</span>\n        <span>Task</span> task <span>=</span> <span>new</span> <span>Task</span><span>(</span><span>)</span><span>;</span>\n        <span>Future</span><span><span>&lt;</span><span>Integer</span><span>></span></span> result <span>=</span> executor<span>.</span><span>submit</span><span>(</span>task<span>)</span><span>;</span>\n        <span>// 注意调用get方法会阻塞当前线程，直到得到结果。</span>\n        <span>// 所以实际编码中建议使用可以设置超时时间的重载get方法。</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span> \n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>输出结果：</p>\n<div><pre><code>2\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_2-2-2-future接口\"> <strong>2.2.2 Future接口</strong></h4>\n<p><code>Future</code>接口只有几个比较简单的方法：</p>\n<div><pre><code><span>public</span> <span>abstract</span> <span>interface</span> <span>Future</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>abstract</span> <span>boolean</span> <span>cancel</span><span>(</span><span>boolean</span> paramBoolean<span>)</span><span>;</span>\n    <span>public</span> <span>abstract</span> <span>boolean</span> <span>isCancelled</span><span>(</span><span>)</span><span>;</span>\n    <span>public</span> <span>abstract</span> <span>boolean</span> <span>isDone</span><span>(</span><span>)</span><span>;</span>\n    <span>public</span> <span>abstract</span> <span>V</span> <span>get</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span><span>,</span> <span>ExecutionException</span><span>;</span>\n    <span>public</span> <span>abstract</span> <span>V</span> <span>get</span><span>(</span><span>long</span> paramLong<span>,</span> <span>TimeUnit</span> paramTimeUnit<span>)</span>\n            <span>throws</span> <span>InterruptedException</span><span>,</span> <span>ExecutionException</span><span>,</span> <span>TimeoutException</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>cancel</code>方法是试图取消一个线程的执行。</p>\n<p>注意是<strong>试图</strong>取消，<strong>并不一定能取消成功</strong>。因为任务可能已完成、已取消、或者一些其它因素不能取消，存在取消失败的可能。<code>boolean</code>类型的返回值是“是否取消成功”的意思。参数<code>paramBoolean</code>表示是否采用中断的方式取消线程执行。</p>\n<p>所以有时候，为了让任务有能够取消的功能，就使用<code>Callable</code>来代替<code>Runnable</code>。如果为了可取消性而使用 <code>Future</code>但又不提供可用的结果，则可以声明 <code>Future</code>形式类型、并返回 <code>null</code>作为底层任务的结果。</p>\n<h4 id=\"_2-2-3-futuretask类\"> <strong>2.2.3 FutureTask类</strong></h4>\n<p>上面介绍了<code>Future</code>接口。这个接口有一个实现类叫<code>FutureTask</code>。<code>FutureTask</code>是实现的<code>RunnableFuture</code>接口的，而<code>RunnableFuture</code>接口同时继承了<code>Runnable</code>接口和<code>Future</code>接口：</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>RunnableFuture</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>extends</span> <span>Runnable</span><span>,</span> <span>Future</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>\n    <span>/**\n     * Sets this Future to the result of its computation\n     * unless it has been cancelled.\n     */</span>\n    <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>那<code>FutureTask</code>类有什么用？为什么要有一个<code>FutureTask</code>类？前面说到了<code>Future</code>只是一个接口，而它里面的<code>cancel</code>，<code>get</code>，<code>isDone</code>等方法要自己实现起来都是<strong>非常复杂</strong>的。所以JDK提供了一个<code>FutureTask</code>类来供我们使用。</p>\n<p>示例代码：</p>\n<div><pre><code><span>// 自定义Callable，与上面一样</span>\n<span>class</span> <span>Task</span> <span>implements</span> <span>Callable</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>Integer</span> <span>call</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>// 模拟计算需要一秒</span>\n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n        <span>return</span> <span>2</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span> args<span>[</span><span>]</span><span>)</span><span>{</span>\n        <span>// 使用</span>\n        <span>ExecutorService</span> executor <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>)</span><span>;</span>\n        <span>FutureTask</span><span><span>&lt;</span><span>Integer</span><span>></span></span> futureTask <span>=</span> <span>new</span> <span>FutureTask</span><span><span>&lt;</span><span>></span></span><span>(</span><span>new</span> <span>Task</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        executor<span>.</span><span>submit</span><span>(</span>futureTask<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>futureTask<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>使用上与第一个Demo有一点小的区别。首先，调用<code>submit</code>方法是没有返回值的。这里实际上是调用的<code>submit(Runnable task)</code>方法，而上面的Demo，调用的是<code>submit(Callable task)</code>方法。</p>\n<p>然后，这里是使用<code>FutureTask</code>直接取<code>get</code>取值，而上面的Demo是通过<code>submit</code>方法返回的<code>Future</code>去取值。</p>\n<p>在很多高并发的环境下，有可能Callable和FutureTask会创建多次。FutureTask能够在高并发环境下<strong>确保任务只执行一次</strong>。这块有兴趣的同学可以参看FutureTask源码。</p>\n<h4 id=\"_2-2-4-futuretask的几个状态\"> <strong>2.2.4 FutureTask的几个状态</strong></h4>\n<div><pre><code><span>/**\n  *\n  * state可能的状态转变路径如下：\n  * NEW -> COMPLETING -> NORMAL\n  * NEW -> COMPLETING -> EXCEPTIONAL\n  * NEW -> CANCELLED\n  * NEW -> INTERRUPTING -> INTERRUPTED\n  */</span>\n<span>private</span> <span>volatile</span> <span>int</span> state<span>;</span>\n<span>private</span> <span>static</span> <span>final</span> <span>int</span> NEW          <span>=</span> <span>0</span><span>;</span>\n<span>private</span> <span>static</span> <span>final</span> <span>int</span> COMPLETING   <span>=</span> <span>1</span><span>;</span>\n<span>private</span> <span>static</span> <span>final</span> <span>int</span> NORMAL       <span>=</span> <span>2</span><span>;</span>\n<span>private</span> <span>static</span> <span>final</span> <span>int</span> EXCEPTIONAL  <span>=</span> <span>3</span><span>;</span>\n<span>private</span> <span>static</span> <span>final</span> <span>int</span> CANCELLED    <span>=</span> <span>4</span><span>;</span>\n<span>private</span> <span>static</span> <span>final</span> <span>int</span> INTERRUPTING <span>=</span> <span>5</span><span>;</span>\n<span>private</span> <span>static</span> <span>final</span> <span>int</span> INTERRUPTED  <span>=</span> <span>6</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><blockquote>\n<p>state表示任务的运行状态，初始状态为NEW。运行状态只会在set、setException、cancel方法中终止。COMPLETING、INTERRUPTING是任务完成后的瞬时状态。</p>\n</blockquote>\n<p>以上就是Java多线程几个基本的类和接口的介绍。可以打开JDK看看源码，体会这几个类的设计思路和用途吧！</p>\n<h3 id=\"_3-线程组和线程优先级\"> 3 线程组和线程优先级</h3>\n<h4 id=\"_3-1-线程组-threadgroup\"> <strong>3.1 线程组(ThreadGroup)</strong></h4>\n<p>Java中用ThreadGroup来表示线程组，我们可以使用线程组对线程进行批量控制。</p>\n<p>ThreadGroup和Thread的关系就如同他们的字面意思一样简单粗暴，每个Thread必然存在于一个ThreadGroup中，Thread不能独立于ThreadGroup存在。执行main()方法线程的名字是main，如果在new Thread时没有显式指定，那么默认将父线程（当前执行new Thread的线程）线程组设置为自己的线程组。</p>\n<p>示例代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Demo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Thread</span> testThread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"testThread当前线程组名字：\"</span> <span>+</span>\n                    <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"testThread线程名字：\"</span> <span>+</span>\n                    <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n\n        testThread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"执行main方法线程名字：\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>输出结果：</p>\n<div><pre><code>执行main方法线程名字：main\ntestThread当前线程组名字：main\ntestThread线程名字：<span>Thread</span><span>-</span><span>0</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>ThreadGroup管理着它下面的Thread，ThreadGroup是一个标准的<strong>向下引用</strong>的树状结构，这样设计的原因是<strong>防止&quot;上级&quot;线程被&quot;下级&quot;线程引用而无法有效地被GC回收</strong>。</p>\n<h4 id=\"_3-2-线程的优先级\"> <strong>3.2 线程的优先级</strong></h4>\n<p>Java中线程优先级可以指定，范围是1~10。但是并不是所有的操作系统都支持10级优先级的划分（比如有些操作系统只支持3级划分：低，中，高），Java只是给操作系统一个优先级的<strong>参考值</strong>，线程最终<strong>在操作系统的优先级</strong>是多少还是由操作系统决定。</p>\n<p>Java默认的线程优先级为5，线程的执行顺序由调度程序来决定，线程的优先级会在线程被调用之前设定。</p>\n<p>通常情况下，高优先级的线程将会比低优先级的线程有<strong>更高的几率</strong>得到执行。我们使用方法<code>Thread</code>类的<code>setPriority()</code>实例方法来设定线程的优先级。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Demo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Thread</span> a <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我是默认线程优先级：\"</span><span>+</span>a<span>.</span><span>getPriority</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Thread</span> b <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>)</span><span>;</span>\n        b<span>.</span><span>setPriority</span><span>(</span><span>10</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我是设置过的线程优先级：\"</span><span>+</span>b<span>.</span><span>getPriority</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>输出结果：</p>\n<div><pre><code>我是默认线程优先级：<span>5</span>\n我是设置过的线程优先级：<span>10</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>既然有1-10的级别来设定了线程的优先级，这时候可能有些读者会问，那么我是不是可以在业务实现的时候，采用这种方法来指定一些线程执行的先后顺序？</p>\n<p>对于这个问题，我们的答案是:No!</p>\n<p>Java中的优先级来说不是特别的可靠，<strong>Java程序中对线程所设置的优先级只是给操作系统一个建议，操作系统不一定会采纳。而真正的调用顺序，是由操作系统的线程调度算法决定的</strong>。</p>\n<p>我们通过代码来验证一下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Demo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>class</span> T1 <span>extends</span> <span>Thread</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>super</span><span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"当前执行的线程是：%s，优先级：%d\"</span><span>,</span>\n                    <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span>\n                    <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getPriority</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>IntStream</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span> <span>10</span><span>)</span><span>.</span><span>forEach</span><span>(</span>i <span>-></span> <span>{</span>\n            <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>T1</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            thread<span>.</span><span>setPriority</span><span>(</span>i<span>)</span><span>;</span>\n            thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>某次输出：</p>\n<div><pre><code>当前执行的线程是：<span>Thread</span><span>-</span><span>17</span>，优先级：<span>9</span>\n当前执行的线程是：<span>Thread</span><span>-</span><span>1</span>，优先级：<span>1</span>\n当前执行的线程是：<span>Thread</span><span>-</span><span>13</span>，优先级：<span>7</span>\n当前执行的线程是：<span>Thread</span><span>-</span><span>11</span>，优先级：<span>6</span>\n当前执行的线程是：<span>Thread</span><span>-</span><span>15</span>，优先级：<span>8</span>\n当前执行的线程是：<span>Thread</span><span>-</span><span>7</span>，优先级：<span>4</span>\n当前执行的线程是：<span>Thread</span><span>-</span><span>9</span>，优先级：<span>5</span>\n当前执行的线程是：<span>Thread</span><span>-</span><span>3</span>，优先级：<span>2</span>\n当前执行的线程是：<span>Thread</span><span>-</span><span>5</span>，优先级：<span>3</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Java提供一个<strong>线程调度器</strong>来监视和控制处于<strong>RUNNABLE状态</strong>的线程。线程的调度策略采用<strong>抢占式</strong>，优先级高的线程比优先级低的线程会有更大的几率优先执行。在优先级相同的情况下，按照“先到先得”的原则。每个Java程序都有一个默认的主线程，就是通过JVM启动的第一个线程main线程。</p>\n<p>还有一种线程称为<strong>守护线程（Daemon）</strong>，守护线程默认的优先级比较低。</p>\n<blockquote>\n<p>如果某线程是守护线程，那如果所以的非守护线程结束，这个守护线程也会自动结束。</p>\n<p>应用场景是：当所有非守护线程结束时，结束其余的子线程（守护线程）自动关闭，就免去了还要继续关闭子线程的麻烦。</p>\n<p>一个线程默认是非守护线程，可以通过Thread类的setDaemon(boolean on)来设置。</p>\n</blockquote>\n<p>在之前，我们有谈到一个线程必然存在于一个线程组中，那么当线程和线程组的优先级不一致的时候将会怎样呢？我们用下面的案例来验证一下：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>ThreadGroup</span> threadGroup <span>=</span> <span>new</span> <span>ThreadGroup</span><span>(</span><span>\"t1\"</span><span>)</span><span>;</span>\n    threadGroup<span>.</span><span>setMaxPriority</span><span>(</span><span>6</span><span>)</span><span>;</span>\n    <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span>threadGroup<span>,</span><span>\"thread\"</span><span>)</span><span>;</span>\n    thread<span>.</span><span>setPriority</span><span>(</span><span>9</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我是线程组的优先级\"</span><span>+</span>threadGroup<span>.</span><span>getMaxPriority</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我是线程的优先级\"</span><span>+</span>thread<span>.</span><span>getPriority</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>输出：</p>\n<blockquote>\n<p>我是线程组的优先级6 我是线程的优先级6</p>\n</blockquote>\n<p>所以，如果某个线程优先级大于线程所在<strong>线程组的最大优先级</strong>，那么该线程的优先级将会失效，取而代之的是线程组的最大优先级。</p>\n<h4 id=\"_3-3-线程组的常用方法及数据结构\"> <strong>3.3 线程组的常用方法及数据结构</strong></h4>\n<h5 id=\"_3-3-1-线程组的常用方法\"> <strong>3.3.1 线程组的常用方法</strong></h5>\n<p><strong>获取当前的线程组名字</strong></p>\n<div><pre><code><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>复制线程组</strong></p>\n<div><pre><code><span>// 复制一个线程数组到一个线程组</span>\n<span>Thread</span><span>[</span><span>]</span> threads <span>=</span> <span>new</span> <span>Thread</span><span>[</span>threadGroup<span>.</span><span>activeCount</span><span>(</span><span>)</span><span>]</span><span>;</span>\n<span>TheadGroup</span> threadGroup <span>=</span> <span>new</span> <span>ThreadGroup</span><span>(</span><span>)</span><span>;</span>\nthreadGroup<span>.</span><span>enumerate</span><span>(</span>threads<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>线程组统一异常处理</strong></p>\n<div><pre><code><span>package</span> <span>com<span>.</span>func<span>.</span>axc<span>.</span>threadgroup</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>ThreadGroupDemo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>ThreadGroup</span> threadGroup1 <span>=</span> <span>new</span> <span>ThreadGroup</span><span>(</span><span>\"group1\"</span><span>)</span> <span>{</span>\n            <span>// 继承ThreadGroup并重新定义以下方法</span>\n            <span>// 在线程成员抛出unchecked exception</span>\n            <span>// 会执行此方法</span>\n            <span>public</span> <span>void</span> <span>uncaughtException</span><span>(</span><span>Thread</span> t<span>,</span> <span>Throwable</span> e<span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>t<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\": \"</span> <span>+</span> e<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>;</span>\n\n        <span>// 这个线程是threadGroup1的一员</span>\n        <span>Thread</span> thread1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span>threadGroup1<span>,</span> <span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>// 抛出unchecked异常</span>\n                <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"测试异常\"</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n\n        thread1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h5 id=\"_3-3-2-线程组的数据结构\"> <strong>3.3.2 线程组的数据结构</strong></h5>\n<p>线程组还可以包含其他的线程组，不仅仅是线程。</p>\n<p>首先看看 <code>ThreadGroup</code>源码中的成员变量</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadGroup</span> <span>implements</span> <span>Thread<span>.</span>UncaughtExceptionHandler</span> <span>{</span>\n    <span>private</span> <span>final</span> <span>ThreadGroup</span> parent<span>;</span> <span>// 父亲ThreadGroup</span>\n    <span>String</span> name<span>;</span> <span>// ThreadGroupr 的名称</span>\n    <span>int</span> maxPriority<span>;</span> <span>// 线程最大优先级</span>\n    <span>boolean</span> destroyed<span>;</span> <span>// 是否被销毁</span>\n    <span>boolean</span> daemon<span>;</span> <span>// 是否守护线程</span>\n    <span>boolean</span> vmAllowSuspension<span>;</span> <span>// 是否可以中断</span>\n\n    <span>int</span> nUnstartedThreads <span>=</span> <span>0</span><span>;</span> <span>// 还未启动的线程</span>\n    <span>int</span> nthreads<span>;</span> <span>// ThreadGroup中线程数目</span>\n    <span>Thread</span> threads<span>[</span><span>]</span><span>;</span> <span>// ThreadGroup中的线程</span>\n\n    <span>int</span> ngroups<span>;</span> <span>// 线程组数目</span>\n    <span>ThreadGroup</span> groups<span>[</span><span>]</span><span>;</span> <span>// 线程组数组</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>然后看看构造函数：</p>\n<div><pre><code><span>// 私有构造函数</span>\n<span>private</span> <span>ThreadGroup</span><span>(</span><span>)</span> <span>{</span> \n    <span>this</span><span>.</span>name <span>=</span> <span>\"system\"</span><span>;</span>\n    <span>this</span><span>.</span>maxPriority <span>=</span> <span>Thread</span><span>.</span>MAX_PRIORITY<span>;</span>\n    <span>this</span><span>.</span>parent <span>=</span> <span>null</span><span>;</span>\n<span>}</span>\n\n<span>// 默认是以当前ThreadGroup传入作为parent  ThreadGroup，新线程组的父线程组是目前正在运行线程的线程组。</span>\n<span>public</span> <span>ThreadGroup</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n    <span>this</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>,</span> name<span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 构造函数</span>\n<span>public</span> <span>ThreadGroup</span><span>(</span><span>ThreadGroup</span> parent<span>,</span> <span>String</span> name<span>)</span> <span>{</span>\n    <span>this</span><span>(</span><span>checkParentAccess</span><span>(</span>parent<span>)</span><span>,</span> parent<span>,</span> name<span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 私有构造函数，主要的构造函数</span>\n<span>private</span> <span>ThreadGroup</span><span>(</span><span>Void</span> unused<span>,</span> <span>ThreadGroup</span> parent<span>,</span> <span>String</span> name<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>this</span><span>.</span>maxPriority <span>=</span> parent<span>.</span>maxPriority<span>;</span>\n    <span>this</span><span>.</span>daemon <span>=</span> parent<span>.</span>daemon<span>;</span>\n    <span>this</span><span>.</span>vmAllowSuspension <span>=</span> parent<span>.</span>vmAllowSuspension<span>;</span>\n    <span>this</span><span>.</span>parent <span>=</span> parent<span>;</span>\n    parent<span>.</span><span>add</span><span>(</span><span>this</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>第三个构造函数里调用了<code>checkParentAccess</code>方法，这里看看这个方法的源码：</p>\n<div><pre><code><span>// 检查parent ThreadGroup</span>\n<span>private</span> <span>static</span> <span>Void</span> <span>checkParentAccess</span><span>(</span><span>ThreadGroup</span> parent<span>)</span> <span>{</span>\n    parent<span>.</span><span>checkAccess</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span>\n\n<span>// 判断当前运行的线程是否具有修改线程组的权限</span>\n<span>public</span> <span>final</span> <span>void</span> <span>checkAccess</span><span>(</span><span>)</span> <span>{</span>\n    <span>SecurityManager</span> security <span>=</span> <span>System</span><span>.</span><span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>security <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        security<span>.</span><span>checkAccess</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><blockquote>\n<p>这里涉及到<code>SecurityManager</code>这个类，它是Java的安全管理器，它允许应用程序在执行一个可能不安全或敏感的操作前确定该操作是什么，以及是否是在允许执行该操作的安全上下文中执行它。应用程序可以允许或不允许该操作。</p>\n<p>比如引入了第三方类库，但是并不能保证它的安全性。</p>\n<p>其实Thread类也有一个checkAccess()方法，不过是用来当前运行的线程是否有权限修改被调用的这个线程实例。（Determines if the currently running thread has permission to modify this thread.）</p>\n</blockquote>\n<p>总结来说，线程组是一个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统一控制线程的优先级和检查线程的权限的作用。</p>\n<h3 id=\"_4-java线程的状态及主要转化方法\"> 4 Java线程的状态及主要转化方法</h3>\n<h4 id=\"_4-1-操作系统中的线程状态转换\"> <strong>4.1 操作系统中的线程状态转换</strong></h4>\n<p>首先我们来看看操作系统中的线程状态转换。</p>\n<blockquote>\n<p>在现在的操作系统中，线程是被视为轻量级进程的，所以<strong>操作系统线程的状态其实和操作系统进程的状态是一致的</strong>。</p>\n</blockquote>\n<p><img src=\"https://gblobscdn.gitbook.com/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJM1VhwmwbNGzqwJ%2F系统进程状态转换图.png?alt=media\" alt=\"img\" /></p>\n<p>系统进程/线程转换图</p>\n<p>操作系统线程主要有以下三个状态：</p>\n<ul>\n<li>就绪状态(ready)：线程正在等待使用CPU，经调度程序调用之后可进入running状态。</li>\n<li>执行状态(running)：线程正在使用CPU。</li>\n<li>等待状态(waiting): 线程经过等待事件的调用或者正在等待其他资源（如I/O）。</li>\n</ul>\n<h4 id=\"_4-2-java线程的6个状态\"> <strong>4.2 Java线程的6个状态</strong></h4>\n<div><pre><code><span>// Thread.State 源码</span>\n<span>public</span> <span>enum</span> <span>State</span> <span>{</span>\n    NEW<span>,</span>\n    RUNNABLE<span>,</span>\n    BLOCKED<span>,</span>\n    WAITING<span>,</span>\n    TIMED_WAITING<span>,</span>\n    TERMINATED<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h5 id=\"_4-2-1-new\"> <strong>4.2.1 NEW</strong></h5>\n<p>处于NEW状态的线程此时尚未启动。这里的尚未启动指的是还没调用Thread实例的start()方法。</p>\n<div><pre><code><span>private</span> <span>void</span> <span>testStateNew</span><span>(</span><span>)</span> <span>{</span>\n    <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span><span>}</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>thread<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 输出 NEW </span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>从上面可以看出，只是创建了线程而并没有调用start()方法，此时线程处于NEW状态。</p>\n<p><strong>关于start()的两个引申问题</strong></p>\n<ol>\n<li>反复调用同一个线程的start()方法是否可行？</li>\n<li>假如一个线程执行完毕（此时处于TERMINATED状态），再次调用这个线程的start()方法是否可行？</li>\n</ol>\n<p>要分析这两个问题，我们先来看看start()的源码：</p>\n<div><pre><code><span>public</span> <span>synchronized</span> <span>void</span> <span>start</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>threadStatus <span>!=</span> <span>0</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>IllegalThreadStateException</span><span>(</span><span>)</span><span>;</span>\n\n    group<span>.</span><span>add</span><span>(</span><span>this</span><span>)</span><span>;</span>\n\n    <span>boolean</span> started <span>=</span> <span>false</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>start0</span><span>(</span><span>)</span><span>;</span>\n        started <span>=</span> <span>true</span><span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>if</span> <span>(</span><span>!</span>started<span>)</span> <span>{</span>\n                group<span>.</span><span>threadStartFailed</span><span>(</span><span>this</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> ignore<span>)</span> <span>{</span>\n\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>我们可以看到，在start()内部，这里有一个threadStatus的变量。如果它不等于0，调用start()是会直接抛出异常的。</p>\n<p>我们接着往下看，有一个native的<code>start0()</code>方法。这个方法里并没有对<strong>threadStatus</strong>的处理。到了这里我们仿佛就拿这个threadStatus没辙了，我们通过debug的方式再看一下:</p>\n<div><pre><code><span>@Test</span>\n<span>public</span> <span>void</span> <span>testStartMethod</span><span>(</span><span>)</span> <span>{</span>\n    <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span><span>}</span><span>)</span><span>;</span>\n    thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span> <span>// 第一次调用</span>\n    thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span> <span>// 第二次调用</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我是在start()方法内部的最开始打的断点，叙述下在我这里打断点看到的结果：</p>\n<ul>\n<li>第一次调用时threadStatus的值是0。</li>\n<li>第二次调用时threadStatus的值不为0。</li>\n</ul>\n<p>查看当前线程状态的源码：</p>\n<div><pre><code><span>// Thread.getState方法源码：</span>\n<span>public</span> <span>State</span> <span>getState</span><span>(</span><span>)</span> <span>{</span>\n    <span>// get current thread state</span>\n    <span>return</span> sun<span>.</span>misc<span>.</span>VM<span>.</span><span>toThreadState</span><span>(</span>threadStatus<span>)</span><span>;</span>\n<span>}</span>\n\n<span>// sun.misc.VM 源码：</span>\n<span>public</span> <span>static</span> <span>State</span> <span>toThreadState</span><span>(</span><span>int</span> var0<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>(</span>var0 <span>&amp;</span> <span>4</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n        <span>return</span> <span>State</span><span>.</span>RUNNABLE<span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>(</span>var0 <span>&amp;</span> <span>1024</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n        <span>return</span> <span>State</span><span>.</span>BLOCKED<span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>(</span>var0 <span>&amp;</span> <span>16</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n        <span>return</span> <span>State</span><span>.</span>WAITING<span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>(</span>var0 <span>&amp;</span> <span>32</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n        <span>return</span> <span>State</span><span>.</span>TIMED_WAITING<span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>(</span>var0 <span>&amp;</span> <span>2</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n        <span>return</span> <span>State</span><span>.</span>TERMINATED<span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>return</span> <span>(</span>var0 <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span> <span>?</span> <span>State</span><span>.</span>NEW <span>:</span> <span>State</span><span>.</span>RUNNABLE<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>所以，我们结合上面的源码可以得到引申的两个问题的结果：</p>\n<blockquote>\n<p>两个问题的答案都是不可行，在调用一次start()之后，threadStatus的值会改变（threadStatus !=0），此时再次调用start()方法会抛出IllegalThreadStateException异常。</p>\n<p>比如，threadStatus为2代表当前线程状态为TERMINATED。</p>\n</blockquote>\n<h5 id=\"_4-2-2-runnable\"> <strong>4.2.2 RUNNABLE</strong></h5>\n<p>表示当前线程正在运行中。处于RUNNABLE状态的线程在Java虚拟机中运行，也有可能在等待其他系统资源（比如I/O）。</p>\n<p><strong>Java中线程的RUNNABLE状态</strong></p>\n<p>看了操作系统线程的几个状态之后我们来看看Thread源码里对RUNNABLE状态的定义：</p>\n<div><pre><code><span>/**\n * Thread state for a runnable thread.  A thread in the runnable\n * state is executing in the Java virtual machine but it may\n * be waiting for other resources from the operating system\n * such as processor.\n */</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>\n<p>Java线程的<strong>RUNNABLE</strong>状态其实是包括了传统操作系统线程的<strong>ready</strong>和<strong>running</strong>两个状态的。</p>\n</blockquote>\n<h5 id=\"_4-2-3-blocked\"> <strong>4.2.3 BLOCKED</strong></h5>\n<p>阻塞状态。处于BLOCKED状态的线程正等待锁的释放以进入同步区。</p>\n<p>我们用BLOCKED状态举个生活中的例子：</p>\n<blockquote>\n<p>假如今天你下班后准备去食堂吃饭。你来到食堂仅有的一个窗口，发现前面已经有个人在窗口前了，此时你必须得等前面的人从窗口离开才行。 假设你是线程t2，你前面的那个人是线程t1。此时t1占有了锁（食堂唯一的窗口），t2正在等待锁的释放，所以此时t2就处于BLOCKED状态。</p>\n</blockquote>\n<h5 id=\"_4-2-4-waiting\"> <strong>4.2.4 WAITING</strong></h5>\n<p>等待状态。处于等待状态的线程变成RUNNABLE状态需要其他线程唤醒。</p>\n<p>调用如下3个方法会使线程进入等待状态：</p>\n<ul>\n<li>Object.wait()：使当前线程处于等待状态直到另一个线程唤醒它；</li>\n<li>Thread.join()：等待线程执行完毕，底层调用的是Object实例的wait方法；</li>\n<li>LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度。</li>\n</ul>\n<p>我们延续上面的例子继续解释一下WAITING状态：</p>\n<blockquote>\n<p>你等了好几分钟现在终于轮到你了，突然你们有一个“不懂事”的经理突然来了。你看到他你就有一种不祥的预感，果然，他是来找你的。</p>\n<p>他把你拉到一旁叫你待会儿再吃饭，说他下午要去作报告，赶紧来找你了解一下项目的情况。你心里虽然有一万个不愿意但是你还是从食堂窗口走开了。</p>\n<p>此时，假设你还是线程t2，你的经理是线程t1。虽然你此时都占有锁（窗口）了，“不速之客”来了你还是得释放掉锁。此时你t2的状态就是WAITING。然后经理t1获得锁，进入RUNNABLE状态。</p>\n<p>要是经理t1不主动唤醒你t2（notify、notifyAll..），可以说你t2只能一直等待了。</p>\n</blockquote>\n<h5 id=\"_4-2-5-timed-waiting\"> <strong>4.2.5 TIMED_WAITING</strong></h5>\n<p>超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。</p>\n<p>调用如下方法会使线程进入超时等待状态：</p>\n<ul>\n<li>Thread.sleep(long millis)：使当前线程睡眠指定时间；</li>\n<li>Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒；</li>\n<li>Thread.join(long millis)：等待当前线程最多执行millis毫秒，如果millis为0，则会一直执行；</li>\n<li>LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；</li>\n<li>LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；</li>\n</ul>\n<p>我们继续延续上面的例子来解释一下TIMED_WAITING状态：</p>\n<blockquote>\n<p>到了第二天中午，又到了饭点，你还是到了窗口前。</p>\n<p>突然间想起你的同事叫你等他一起，他说让你等他十分钟他改个bug。</p>\n<p>好吧，你说那你就等等吧，你就离开了窗口。很快十分钟过去了，你见他还没来，你想都等了这么久了还不来，那你还是先去吃饭好了。</p>\n<p>这时你还是线程t1，你改bug的同事是线程t2。t2让t1等待了指定时间，t1先主动释放了锁。此时t1等待期间就属于TIMED_WATING状态。</p>\n<p>t1等待10分钟后，就自动唤醒，拥有了去争夺锁的资格。</p>\n</blockquote>\n<h5 id=\"_4-2-6-terminated\"> <strong>4.2.6 TERMINATED</strong></h5>\n<p>终止状态。此时线程已执行完毕。</p>\n<h4 id=\"_4-3-线程状态的转换\"> <strong>4.3 线程状态的转换</strong></h4>\n<p>根据上面关于线程状态的介绍我们可以得到下面的<strong>线程状态转换图</strong>： <img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1594777561839&di=50f4e9de6ceeaec5fa7c004bb3d90daa&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fq_70%2Cc_zoom%2Cw_640%2Fimages%2F20171024%2Fa450fdec915d43bca2ad74b63bcaad8e.jpeg\" alt=\"线程状态转换图\" /></p>\n<h5 id=\"_4-3-1-blocked与runnable状态的转换\"> <strong>4.3.1 BLOCKED与RUNNABLE状态的转换</strong></h5>\n<p>我们在上面说到：处于BLOCKED状态的线程是因为在等待锁的释放。假如这里有两个线程a和b，a线程提前获得了锁并且暂未释放锁，此时b就处于BLOCKED状态。我们先来看一个例子：</p>\n<div><pre><code><span>@Test</span>\n<span>public</span> <span>void</span> <span>blockedTest</span><span>(</span><span>)</span> <span>{</span>\n\n    <span>Thread</span> a <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>testMethod</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>,</span> <span>\"a\"</span><span>)</span><span>;</span>\n    <span>Thread</span> b <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>testMethod</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>,</span> <span>\"b\"</span><span>)</span><span>;</span>\n\n    a<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    b<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\":\"</span> <span>+</span> a<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 输出？</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\":\"</span> <span>+</span> b<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 输出？</span>\n<span>}</span>\n\n<span>// 同步方法争夺锁</span>\n<span>private</span> <span>synchronized</span> <span>void</span> <span>testMethod</span><span>(</span><span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>2000L</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>初看之下，大家可能会觉得线程a会先调用同步方法，同步方法内又调用了Thread.sleep()方法，必然会输出TIMED_WAITING，而线程b因为等待线程a释放锁所以必然会输出BLOCKED。</p>\n<p>其实不然，有两点需要值得大家注意，一是<strong>在测试方法blockedTest()内还有一个main线程</strong>，二是<strong>启动线程后执行run方法还是需要消耗一定时间的</strong>。不打断点的情况下，上面代码中都应该输出<strong>RUNNABLE</strong>。</p>\n<blockquote>\n<p>测试方法的main线程只保证了a，b两个线程调用start()方法（转化为RUNNABLE状态），还没等两个线程真正开始争夺锁，就已经打印此时两个线程的状态（RUNNABLE）了。</p>\n</blockquote>\n<p>这时你可能又会问了，要是我想要打印出BLOCKED状态我该怎么处理呢？其实就处理下测试方法里的main线程就可以了，你让它“休息一会儿”，打断点或者调用Thread.sleep方法就行。</p>\n<p>这里需要注意的是main线程休息的时间，要保证在线程争夺锁的时间内，不要等到前一个线程锁都释放了你再去争夺锁，此时还是得不到BLOCKED状态的。</p>\n<p>我们把上面的测试方法blockedTest()改动一下：</p>\n<div><pre><code><span>public</span> <span>void</span> <span>blockedTest</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n    ······\n    a<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000L</span><span>)</span><span>;</span> <span>// 需要注意这里main线程休眠了1000毫秒，而testMethod()里休眠了2000毫秒</span>\n    b<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\":\"</span> <span>+</span> a<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 输出？</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\":\"</span> <span>+</span> b<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 输出？</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在这个例子中，由于main线程休眠，所以线程a的run()方法跟着执行，线程b再接着执行。</p>\n<p>在线程a执行run()调用testMethod()之后，线程a休眠了2000ms（注意这里是没有释放锁的），main线程休眠完毕，接着b线程执行的时候是争夺不到锁的，所以这里输出：</p>\n<div><pre><code>a<span>:</span>TIMED_WAITING\nb<span>:</span>BLOCKED\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h5 id=\"_4-3-2-waiting状态与runnable状态的转换\"> <strong>4.3.2 WAITING状态与RUNNABLE状态的转换</strong></h5>\n<p>根据转换图我们知道有3个方法可以使线程从RUNNABLE状态转为WAITING状态。我们主要介绍下<strong>Object.wait()<strong>和</strong>Thread.join()</strong>。 <strong>Object.wait()</strong></p>\n<blockquote>\n<p>调用wait()方法前线程必须持有对象的锁。</p>\n<p>线程调用wait()方法时，会释放当前的锁，直到有其他线程调用notify()/notifyAll()方法唤醒等待锁的线程。</p>\n<p>需要注意的是，其他线程调用notify()方法只会唤醒单个等待锁的线程，如有有多个线程都在等待这个锁的话不一定会唤醒到之前调用wait()方法的线程。</p>\n<p>同样，调用notifyAll()方法唤醒所有等待锁的线程之后，也不一定会马上把时间片分给刚才放弃锁的那个线程，具体要看系统的调度。</p>\n</blockquote>\n<p><strong>Thread.join()</strong></p>\n<blockquote>\n<p>调用join()方法不会释放锁，会一直等待当前线程执行完毕（转换为TERMINATED状态）。</p>\n</blockquote>\n<p>我们再把上面的例子线程启动那里改变一下：</p>\n<div><pre><code><span>public</span> <span>void</span> <span>blockedTest</span><span>(</span><span>)</span> <span>{</span>\n    ······\n    a<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    a<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>\n    b<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\":\"</span> <span>+</span> a<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 输出 TERMINATED</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\":\"</span> <span>+</span> b<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>要是没有调用join方法，main线程不管a线程是否执行完毕都会继续往下走。</p>\n<p>a线程启动之后马上调用了join方法，这里main线程就会等到a线程执行完毕，所以这里a线程打印的状态固定是<strong>TERMIATED</strong>。</p>\n<p>至于b线程的状态，有可能打印RUNNABLE（尚未进入同步方法），也有可能打印TIMED_WAITING（进入了同步方法）。</p>\n<h5 id=\"_4-3-3-timed-waiting与runnable状态转换\"> <strong>4.3.3 TIMED_WAITING与RUNNABLE状态转换</strong></h5>\n<p>TIMED_WAITING与WAITING状态类似，只是TIMED_WAITING状态等待的时间是指定的。</p>\n<p><strong>Thread.sleep(long)</strong></p>\n<blockquote>\n<p>使当前线程睡眠指定时间。需要注意这里的“睡眠”只是暂时使线程停止执行，并不会释放锁。时间到后，线程会重新进入RUNNABLE状态。</p>\n</blockquote>\n<p><strong>Object.wait(long)</strong></p>\n<blockquote>\n<p>wait(long)方法使线程进入TIMED_WAITING状态。这里的wait(long)方法与无参方法wait()相同的地方是，都可以通过其他线程调用notify()或notifyAll()方法来唤醒。</p>\n<p>不同的地方是，有参方法wait(long)就算其他线程不来唤醒它，经过指定时间long之后它会自动唤醒，拥有去争夺锁的资格。</p>\n</blockquote>\n<p><strong>Thread.join(long)</strong></p>\n<blockquote>\n<p>join(long)使当前线程执行指定时间，并且使线程进入TIMED_WAITING状态。</p>\n<p>我们再来改一改刚才的示例:</p>\n<div><pre><code><span>public</span> <span>void</span> <span>blockedTest</span><span>(</span><span>)</span> <span>{</span>\n    ······\n    a<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    a<span>.</span><span>join</span><span>(</span><span>1000L</span><span>)</span><span>;</span>\n    b<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\":\"</span> <span>+</span> a<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 输出 TIEMD_WAITING</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\":\"</span> <span>+</span> b<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这里调用a.join(1000L)，因为是指定了具体a线程执行的时间的，并且执行时间是小于a线程sleep的时间，所以a线程状态输出TIMED_WAITING。</p>\n</blockquote>\n<p>b线程状态仍然不固定（RUNNABLE或BLOCKED）。</p>\n<h5 id=\"_4-3-4-线程中断\"> <strong>4.3.4 线程中断</strong></h5>\n<blockquote>\n<p>在某些情况下，我们在线程启动后发现并不需要它继续执行下去时，需要中断线程。目前在Java里还没有安全直接的方法来停止线程，但是Java提供了线程中断机制来处理需要中断线程的情况。</p>\n<p>线程中断机制是一种协作机制。需要注意，通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理。</p>\n</blockquote>\n<p>简单介绍下Thread类里提供的关于线程中断的几个方法：</p>\n<ul>\n<li>Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为true（默认是flase）；</li>\n<li>Thread.interrupted()：测试当前线程是否被中断。线程的中断状态受这个方法的影响，意思是调用一次使线程中断状态设置为true，连续调用两次会使得这个线程的中断状态重新转为false；</li>\n<li>Thread.isInterrupted()：测试当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态。</li>\n</ul>\n<blockquote>\n<p>在线程中断机制里，当其他线程通知需要被中断的线程后，线程中断的状态被设置为true，但是具体被要求中断的线程要怎么处理，完全由被中断线程自己而定，可以在合适的实际处理中断请求，也可以完全不处理继续执行下去。</p>\n</blockquote>\n<h3 id=\"_5-java线程间的通信\"> 5 Java线程间的通信</h3>\n<p>合理的使用Java多线程可以更好地利用服务器资源。一般来讲，线程内部有自己私有的线程上下文，互不干扰。但是当我们需要多个线程之间相互协作的时候，就需要我们掌握Java线程的通信方式。本文将介绍Java线程之间的几种通信原理。</p>\n<h4 id=\"_5-1-锁与同步\"> <strong>5.1 锁与同步</strong></h4>\n<p>在Java中，锁的概念都是基于对象的，所以我们又经常称它为对象锁。线程和锁的关系，我们可以用婚姻关系来理解。一个锁同一时间只能被一个线程持有。也就是说，一个锁如果和一个线程“结婚”（持有），那其他线程如果需要得到这个锁，就得等这个线程和这个锁“离婚”（释放）。</p>\n<p>在我们的线程之间，有一个同步的概念。什么是同步呢，假如我们现在有2位正在抄暑假作业答案的同学：线程A和线程B。当他们正在抄的时候，老师突然来修改了一些答案，可能A和B最后写出的暑假作业就不一样。我们为了A,B能写出2本相同的暑假作业，我们就需要让老师先修改答案，然后A，B同学再抄。或者A，B同学先抄完，老师再修改答案。这就是线程A，线程B的线程同步。</p>\n<p>可以以解释为：线程同步是线程之间按照<strong>一定的顺序</strong>执行。</p>\n<p>为了达到线程同步，我们可以使用锁来实现它。</p>\n<p>我们先来看看一个无锁的程序：</p>\n<div><pre><code>public class NoneLock {\n\n    static class ThreadA implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i &lt; 100; i++) {\n                System.out.println(&quot;Thread A &quot; + i);\n            }\n        }\n    }\n\n    static class ThreadB implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i &lt; 100; i++) {\n                System.out.println(&quot;Thread B &quot; + i);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new Thread(new ThreadA()).start();\n        new Thread(new ThreadB()).start();\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>执行这个程序，你会在控制台看到，线程A和线程B各自独立工作，输出自己的打印值。如下是我的电脑上某一次运行的结果。每一次运行结果都会不一样。</p>\n<div><pre><code>....\nThread A 48\nThread A 49\nThread B 0\nThread A 50\nThread B 1\nThread A 51\nThread A 52\n....\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>那我现在有一个需求，我想等A先执行完之后，再由B去执行，怎么办呢？最简单的方式就是使用一个“对象锁”：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ObjectLock</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>Object</span> lock <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>\n\n    <span>static</span> <span>class</span> <span>ThreadA</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>synchronized</span> <span>(</span>lock<span>)</span> <span>{</span>\n                <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>100</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Thread A \"</span> <span>+</span> i<span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>static</span> <span>class</span> <span>ThreadB</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>synchronized</span> <span>(</span>lock<span>)</span> <span>{</span>\n                <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>100</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Thread B \"</span> <span>+</span> i<span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadA</span><span>(</span><span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>10</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadB</span><span>(</span><span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>这里声明了一个名字为<code>lock</code>的对象锁。我们在<code>ThreadA</code>和<code>ThreadB</code>内需要同步的代码块里，都是用<code>synchronized</code>关键字加上了同一个对象锁<code>lock</code>。</p>\n<p>上文我们说到了，根据线程和锁的关系，同一时间只有一个线程持有一个锁，那么线程B就会等线程A执行完成后释放<code>lock</code>，线程B才能获得锁<code>lock</code>。</p>\n<blockquote>\n<p>这里在主线程里使用sleep方法睡眠了10毫秒，是为了防止线程B先得到锁。因为如果同时start，线程A和线程B都是出于就绪状态，操作系统可能会先让B运行。这样就会先输出B的内容，然后B执行完成之后自动释放锁，线程A再执行。</p>\n</blockquote>\n<h4 id=\"_5-2-等待-通知机制\"> <strong>5.2 等待/通知机制</strong></h4>\n<p>上面一种基于“锁”的方式，线程需要不断地去尝试获得锁，如果失败了，再继续尝试。这可能会耗费服务器资源。</p>\n<p>而等待/通知机制是另一种方式。</p>\n<p>Java多线程的等待/通知机制是基于<code>Object</code>类的<code>wait()</code>方法和<code>notify()</code>, <code>notifyAll()</code>方法来实现的。</p>\n<blockquote>\n<p>notify()方法会随机叫醒一个正在等待的线程，而notifyAll()会叫醒所有正在等待的线程。</p>\n</blockquote>\n<p>前面我们讲到，一个锁同一时刻只能被一个线程持有。而假如线程A现在持有了一个锁<code>lock</code>并开始执行，它可以使用<code>lock.wait()</code>让自己进入等待状态。这个时候，<code>lock</code>这个锁是被释放了的。</p>\n<p>这时，线程B获得了<code>lock</code>这个锁并开始执行，它可以在某一时刻，使用<code>lock.notify()</code>，通知之前持有<code>lock</code>锁并进入等待状态的线程A，说“线程A你不用等了，可以往下执行了”。</p>\n<blockquote>\n<p>需要注意的是，这个时候线程B并没有释放锁<code>lock</code>，除非线程B这个时候使用<code>lock.wait()</code>释放锁，或者线程B执行结束自行释放锁，线程A才能得到<code>lock</code>锁。</p>\n</blockquote>\n<p>我们用代码来实现一下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>WaitAndNotify</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>Object</span> lock <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>\n\n    <span>static</span> <span>class</span> <span>ThreadA</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>synchronized</span> <span>(</span>lock<span>)</span> <span>{</span>\n                <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                    <span>try</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"ThreadA: \"</span> <span>+</span> i<span>)</span><span>;</span>\n                        lock<span>.</span><span>notify</span><span>(</span><span>)</span><span>;</span>\n                        lock<span>.</span><span>wait</span><span>(</span><span>)</span><span>;</span>\n                    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n                lock<span>.</span><span>notify</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>static</span> <span>class</span> <span>ThreadB</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>synchronized</span> <span>(</span>lock<span>)</span> <span>{</span>\n                <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                    <span>try</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"ThreadB: \"</span> <span>+</span> i<span>)</span><span>;</span>\n                        lock<span>.</span><span>notify</span><span>(</span><span>)</span><span>;</span>\n                        lock<span>.</span><span>wait</span><span>(</span><span>)</span><span>;</span>\n                    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n                lock<span>.</span><span>notify</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadA</span><span>(</span><span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadB</span><span>(</span><span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>// 输出：</span>\n<span>ThreadA</span><span>:</span> <span>0</span>\n<span>ThreadB</span><span>:</span> <span>0</span>\n<span>ThreadA</span><span>:</span> <span>1</span>\n<span>ThreadB</span><span>:</span> <span>1</span>\n<span>ThreadA</span><span>:</span> <span>2</span>\n<span>ThreadB</span><span>:</span> <span>2</span>\n<span>ThreadA</span><span>:</span> <span>3</span>\n<span>ThreadB</span><span>:</span> <span>3</span>\n<span>ThreadA</span><span>:</span> <span>4</span>\n<span>ThreadB</span><span>:</span> <span>4</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><p>在这个Demo里，线程A和线程B首先打印出自己需要的东西，然后使用<code>notify()</code>方法叫醒另一个正在等待的线程，然后自己使用<code>wait()</code>方法陷入等待并释放<code>lock</code>锁。</p>\n<blockquote>\n<p>需要注意的是等待/通知机制使用的是使用同一个对象锁，如果你两个线程使用的是不同的对象锁，那它们之间是不能用等待/通知机制通信的。</p>\n</blockquote>\n<h4 id=\"_5-3-信号量\"> <strong>5.3 信号量</strong></h4>\n<p>JDK提供了一个类似于“信号量”功能的类<code>Semaphore</code>。但本文不是要介绍这个类，而是介绍一种基于<code>volatile</code>关键字的自己实现的信号量通信。</p>\n<p>后面会有专门的章节介绍<code>volatile</code>关键字，这里只是做一个简单的介绍。</p>\n<blockquote>\n<p>volitile关键字能够保证内存的可见性，如果用volitile关键字声明了一个变量，在一个线程里面改变了这个变量的值，那其它线程是立马可见更改后的值的。</p>\n</blockquote>\n<p>比如我现在有一个需求，我想让线程A输出0，然后线程B输出1，再然后线程A输出2…以此类推。我应该怎样实现呢？</p>\n<p>代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Signal</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>volatile</span> <span>int</span> signal <span>=</span> <span>0</span><span>;</span>\n\n    <span>static</span> <span>class</span> <span>ThreadA</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>while</span> <span>(</span>signal <span>&lt;</span> <span>5</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>signal <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"threadA: \"</span> <span>+</span> signal<span>)</span><span>;</span>\n                    <span>synchronized</span> <span>(</span><span>this</span><span>)</span> <span>{</span>\n                        signal<span>++</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>static</span> <span>class</span> <span>ThreadB</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>while</span> <span>(</span>signal <span>&lt;</span> <span>5</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>signal <span>%</span> <span>2</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"threadB: \"</span> <span>+</span> signal<span>)</span><span>;</span>\n                    <span>synchronized</span> <span>(</span><span>this</span><span>)</span> <span>{</span>\n                        signal <span>=</span> signal <span>+</span> <span>1</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadA</span><span>(</span><span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadB</span><span>(</span><span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>// 输出：</span>\nthreadA<span>:</span> <span>0</span>\nthreadB<span>:</span> <span>1</span>\nthreadA<span>:</span> <span>2</span>\nthreadB<span>:</span> <span>3</span>\nthreadA<span>:</span> <span>4</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p>我们可以看到，使用了一个<code>volatile</code>变量<code>signal</code>来实现了“信号量”的模型。这里需要注意的是，<code>volatile</code>变量需要进行原子操作。<code>signal++</code>并不是一个原子操作，所以我们需要使用<code>synchronized</code>给它“上锁”。</p>\n<blockquote>\n<p>这种实现方式并不一定高效，本例只是演示信号量</p>\n</blockquote>\n<h5 id=\"信号量的应用场景\"> <strong>信号量的应用场景：</strong></h5>\n<p>假如在一个停车场中，车位是我们的公共资源，线程就如同车辆，而看门的管理员就是起的“信号量”的作用。</p>\n<p>因为在这种场景下，多个线程（超过2个）需要相互合作，我们用简单的“锁”和“等待通知机制”就不那么方便了。这个时候就可以用到信号量。</p>\n<p>其实JDK中提供的很多多线程通信工具类都是基于信号量模型的。我们会在后面第三篇的文章中介绍一些常用的通信工具类。</p>\n<h4 id=\"_5-4-管道\"> <strong>5.4 管道</strong></h4>\n<p>管道是基于“管道流”的通信方式。JDK提供了<code>PipedWriter</code>、 <code>PipedReader</code>、 <code>PipedOutputStream</code>、 <code>PipedInputStream</code>。其中，前面两个是基于字符的，后面两个是基于字节流的。</p>\n<p>这里的示例代码使用的是基于字符的：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Pipe</span> <span>{</span>\n    <span>static</span> <span>class</span> <span>ReaderThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n        <span>private</span> <span>PipedReader</span> reader<span>;</span>\n\n        <span>public</span> <span>ReaderThread</span><span>(</span><span>PipedReader</span> reader<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>reader <span>=</span> reader<span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"this is reader\"</span><span>)</span><span>;</span>\n            <span>int</span> receive <span>=</span> <span>0</span><span>;</span>\n            <span>try</span> <span>{</span>\n                <span>while</span> <span>(</span><span>(</span>receive <span>=</span> reader<span>.</span><span>read</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>(</span><span>char</span><span>)</span>receive<span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>static</span> <span>class</span> <span>WriterThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n\n        <span>private</span> <span>PipedWriter</span> writer<span>;</span>\n\n        <span>public</span> <span>WriterThread</span><span>(</span><span>PipedWriter</span> writer<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>writer <span>=</span> writer<span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"this is writer\"</span><span>)</span><span>;</span>\n            <span>int</span> receive <span>=</span> <span>0</span><span>;</span>\n            <span>try</span> <span>{</span>\n                writer<span>.</span><span>write</span><span>(</span><span>\"test\"</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>finally</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                    writer<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span><span>,</span> <span>InterruptedException</span> <span>{</span>\n        <span>PipedWriter</span> writer <span>=</span> <span>new</span> <span>PipedWriter</span><span>(</span><span>)</span><span>;</span>\n        <span>PipedReader</span> reader <span>=</span> <span>new</span> <span>PipedReader</span><span>(</span><span>)</span><span>;</span>\n        writer<span>.</span><span>connect</span><span>(</span>reader<span>)</span><span>;</span> <span>// 这里注意一定要连接，才能通信</span>\n\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ReaderThread</span><span>(</span>reader<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>WriterThread</span><span>(</span>writer<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>// 输出：</span>\n<span>this</span> is reader\n<span>this</span> is writer\ntest\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><p>我们通过线程的构造函数，传入了<code>PipedWrite</code>和<code>PipedReader</code>对象。可以简单分析一下这个示例代码的执行流程：</p>\n<ol>\n<li>线程ReaderThread开始执行，</li>\n<li>线程ReaderThread使用管道reader.read()进入”阻塞“，</li>\n<li>线程WriterThread开始执行，</li>\n<li>线程WriterThread用writer.write(&quot;test&quot;)往管道写入字符串，</li>\n<li>线程WriterThread使用writer.close()结束管道写入，并执行完毕，</li>\n<li>线程ReaderThread接受到管道输出的字符串并打印，</li>\n<li>线程ReaderThread执行完毕。</li>\n</ol>\n<h5 id=\"管道通信的应用场景\"> <strong>管道通信的应用场景：</strong></h5>\n<p>这个很好理解。使用管道多半与I/O流相关。当我们一个线程需要先另一个线程发送一个信息（比如字符串）或者文件等等时，就需要使用管道通信了。</p>\n<h4 id=\"_5-5-其它通信相关\"> <strong>5.5 其它通信相关</strong></h4>\n<p>以上介绍了一些线程间通信的基本原理和方法。除此以外，还有一些与线程通信相关的知识点，这里一并介绍。</p>\n<h5 id=\"_5-5-1-join方法\"> <strong>5.5.1 join方法</strong></h5>\n<p>join()方法是Thread类的一个实例方法。它的作用是让当前线程陷入“等待”状态，等join的这个线程执行完成后，再继续执行当前线程。</p>\n<p>有时候，主线程创建并启动了子线程，如果子线程中需要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。</p>\n<p>如果主线程想等待子线程执行完毕后，获得子线程中的处理完的某个数据，就要用到join方法了。</p>\n<p>示例代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Join</span> <span>{</span>\n    <span>static</span> <span>class</span> <span>ThreadA</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我是子线程，我先睡一秒\"</span><span>)</span><span>;</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我是子线程，我睡完了一秒\"</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadA</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        thread<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"如果不加join方法，我会先被打出来，加了就不一样了\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><blockquote>\n<p>注意join()方法有两个重载方法，一个是join(long)， 一个是join(long, int)。</p>\n<p>实际上，通过源码你会发现，join()方法及其重载方法底层都是利用了wait(long)这个方法。</p>\n<p>对于join(long, int)，通过查看源码(JDK 1.8)发现，底层并没有精确到纳秒，而是对第二个参数做了简单的判断和处理。</p>\n</blockquote>\n<h5 id=\"_5-5-2-sleep方法\"> <strong>5.5.2 sleep方法</strong></h5>\n<p>sleep方法是Thread类的一个静态方法。它的作用是让当前线程睡眠一段时间。它有这样两个方法：</p>\n<ul>\n<li>Thread.sleep(long)</li>\n<li>Thread.sleep(long, int)</li>\n</ul>\n<blockquote>\n<p>同样，查看源码(JDK 1.8)发现，第二个方法貌似只对第二个参数做了简单的处理，没有精确到纳秒。实际上还是调用的第一个方法。</p>\n</blockquote>\n<p>这里需要强调一下：**sleep方法是不会释放当前的锁的，而wait方法会。**这也是最常见的一个多线程面试题。</p>\n<p>它们还有这些区别：</p>\n<ul>\n<li>wait可以指定时间，也可以不指定；而sleep必须指定时间。</li>\n<li>wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁。</li>\n<li>wait必须放在同步块或同步方法中，而sleep可以再任意位置</li>\n</ul>\n<h5 id=\"_5-5-3-threadlocal类\"> <strong>5.5.3 ThreadLocal类</strong></h5>\n<p>ThreadLocal是一个本地线程副本变量工具类。内部是一个<strong>弱引用</strong>的Map来维护。这里不详细介绍它的原理，而是只是介绍它的使用，以后有独立章节来介绍ThreadLocal类的原理。</p>\n<p>有些朋友称ThreadLocal为<strong>线程本地变量</strong>或<strong>线程本地存储</strong>。严格来说，ThreadLocal类并不属于多线程间的通信，而是让每个线程有自己”独立“的变量，线程之间互不影响。它为每个线程都创建一个<strong>副本</strong>，每个线程可以访问自己内部的副本变量。</p>\n<p>ThreadLocal类最常用的就是set方法和get方法。示例代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadLocalDemo</span> <span>{</span>\n    <span>static</span> <span>class</span> <span>ThreadA</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n        <span>private</span> <span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> threadLocal<span>;</span>\n\n        <span>public</span> <span>ThreadA</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> threadLocal<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>threadLocal <span>=</span> threadLocal<span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            threadLocal<span>.</span><span>set</span><span>(</span><span>\"A\"</span><span>)</span><span>;</span>\n            <span>try</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"ThreadA输出：\"</span> <span>+</span> threadLocal<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>static</span> <span>class</span> <span>ThreadB</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n            <span>private</span> <span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> threadLocal<span>;</span>\n\n            <span>public</span> <span>ThreadB</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> threadLocal<span>)</span> <span>{</span>\n                <span>this</span><span>.</span>threadLocal <span>=</span> threadLocal<span>;</span>\n            <span>}</span>\n\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                threadLocal<span>.</span><span>set</span><span>(</span><span>\"B\"</span><span>)</span><span>;</span>\n                <span>try</span> <span>{</span>\n                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"ThreadB输出：\"</span> <span>+</span> threadLocal<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n            <span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> threadLocal <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n            <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadA</span><span>(</span>threadLocal<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n            <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadB</span><span>(</span>threadLocal<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n<span>// 输出：</span>\n<span>ThreadA</span>输出：<span>A</span>\n<span>ThreadB</span>输出：<span>B</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><p>可以看到，虽然两个线程使用的同一个ThreadLocal实例（通过构造方法传入），但是它们各自可以存取自己当前线程的一个值。</p>\n<p>那ThreadLocal有什么作用呢？如果只是单纯的想要线程隔离，在每个线程中声明一个私有变量就好了呀，为什么要使用ThreadLocal？</p>\n<p>如果开发者希望将类的某个静态变量（user ID或者transaction ID）与线程状态关联，则可以考虑使用ThreadLocal。</p>\n<p>最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。数据库连接和Session管理涉及多个复杂对象的初始化和关闭。如果在每个线程中声明一些私有变量来进行操作，那这个线程就变得不那么“轻量”了，需要频繁的创建和关闭连接。</p>\n<h5 id=\"_5-5-4-inheritablethreadlocal\"> <strong>5.5.4 InheritableThreadLocal</strong></h5>\n<p>InheritableThreadLocal类与ThreadLocal类稍有不同，Inheritable是继承的意思。它不仅仅是当前线程可以存取副本值，而且它的子线程也可以存取这个副本值。</p>\n<h2 id=\"第二篇-原理篇\"> 第二篇 原理篇</h2>\n<h3 id=\"_6-java内存模型基础知识\"> 6 Java内存模型基础知识</h3>\n<h4 id=\"_6-1-并发编程模型的两个关键问题\"> <strong>6.1 并发编程模型的两个关键问题</strong></h4>\n<ul>\n<li>线程间如何通信？即：线程之间以何种机制来交换信息</li>\n<li>线程间如何同步？即：线程以何种机制来控制不同线程间操作发生的相对顺序</li>\n</ul>\n<p>有两种并发模型可以解决这两个问题：</p>\n<ul>\n<li>消息传递并发模型</li>\n<li>共享内存并发模型</li>\n</ul>\n<p>这两种模型之间的区别如下表所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/chenxiao19920206/RedSpiderArticlePhotos/master/java-base/multi-thread/两种并发模型的比较.png\" alt=\"img\" /></p>\n<p>image</p>\n<p><strong>在Java中，使用的是共享内存并发模型</strong>。</p>\n<h4 id=\"_6-2-java内存模型的抽象结构\"> <strong>6.2 Java内存模型的抽象结构</strong></h4>\n<h5 id=\"_6-2-1-运行时内存的划分\"> <strong>6.2.1  运行时内存的划分</strong></h5>\n<p>先谈一下运行时数据区，下面这张图相信大家一点都不陌生： <img src=\"https://raw.githubusercontent.com/chenxiao19920206/RedSpiderArticlePhotos/master/java-base/multi-thread/Java运行时数据区.png\" alt=\"image\" /></p>\n<p>对于每一个线程来说，栈都是私有的，而堆是共有的。</p>\n<p>也就是说在栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程之间共享，也就不会有内存可见性（下文会说到）的问题，也不受内存模型的影响。而在堆中的变量是共享的，本文称为共享变量。</p>\n<p>所以，内存可见性是针对的<strong>共享变量</strong>。</p>\n<h5 id=\"_6-2-2-既然堆是共享的-为什么在堆中会有内存不可见问题\"> <strong>6.2.2 既然堆是共享的，为什么在堆中会有内存不可见问题？</strong></h5>\n<p>这是因为现代计算机为了高效，往往会在高速缓存区中缓存共享变量，因为cpu访问缓存区比访问内存要快得多。</p>\n<blockquote>\n<p>线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本。本地内存是Java内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。</p>\n</blockquote>\n<p>Java线程之间的通信由Java内存模型（简称JMM）控制，从抽象的角度来说，JMM定义了线程和主内存之间的抽象关系。JMM的抽象示意图如图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/chenxiao19920206/RedSpiderArticlePhotos/master/java-base/multi-thread/JMM抽象示意图.jpg\" alt=\"img\" /></p>\n<p>从图中可以看出： 1. 所有的共享变量都存在主内存中。 2. 每个线程都保存了一份该线程使用到的共享变量的副本。 3. 如果线程A与线程B之间要通信的话，必须经历下面2个步骤： 1. 线程A将本地内存A中更新过的共享变量刷新到主内存中去。 2. 线程B到主内存中去读取线程A之前已经更新过的共享变量。</p>\n<p><strong>所以，线程A无法直接访问线程B的工作内存，线程间通信必须经过主内存。</strong></p>\n<p>注意，根据JMM的规定，<strong>线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取</strong>。</p>\n<p>所以线程B并不是直接去主内存中读取共享变量的值，而是先在本地内存B中找到这个共享变量，发现这个共享变量已经被更新了，然后本地内存B去主内存中读取这个共享变量的新值，并拷贝到本地内存B中，最后线程B再读取本地内存B中的新值。</p>\n<p>那么怎么知道这个共享变量的被其他线程更新了呢？这就是JMM的功劳了，也是JMM存在的必要性之一。<strong>JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证</strong>。</p>\n<blockquote>\n<p>Java中的volatile关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，synchronized关键字不仅保证可见性，同时也保证了原子性（互斥性）。在更底层，JMM通过内存屏障来实现内存的可见性以及禁止重排序。为了程序员的方便理解，提出了happens-before，它更加的简单易懂，从而避免了程序员为了理解内存可见性而去学习复杂的重排序规则以及这些规则的具体实现方法。这里涉及到的所有内容后面都会有专门的章节介绍。</p>\n</blockquote>\n<h5 id=\"_6-2-3-jmm与java内存区域划分的区别与联系\"> <strong>6.2.3 JMM与Java内存区域划分的区别与联系</strong></h5>\n<p>上面两小节分别提到了JMM和Java运行时内存区域的划分，这两者既有差别又有联系：</p>\n<ul>\n<li>\n<p>区别</p>\n<p>两者是不同的概念层次。JMM是抽象的，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。而Java运行时内存的划分是具体的，是JVM运行Java程序时，必要的内存划分。</p>\n</li>\n<li>\n<p>联系</p>\n<p>都存在私有数据区域和共享数据区域。一般来说，JMM中的主内存属于共享数据区域，他是包含了堆和方法区；同样，JMM中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。</p>\n</li>\n</ul>\n<p><strong>实际上，他们表达的是同一种含义，这里不做区分。</strong></p>\n<h3 id=\"_7-重排序与happens-before\"> 7 重排序与happens-before</h3>\n<h4 id=\"_7-1-什么是重排序\"> <strong>7.1 什么是重排序？</strong></h4>\n<p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。</p>\n<p><strong>为什么指令重排序可以提高性能？</strong></p>\n<p>简单地说，每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此，<strong>流水线技术</strong>产生了，它的原理是指令1还没有执行完，就可以开始执行指令2，而不用等到指令1执行结束之后再执行指令2，这样就大大提高了效率。</p>\n<p>但是，流水线技术最害怕<strong>中断</strong>，恢复中断的代价是比较大的，所以我们要想尽办法不让流水线中断。指令重排就是减少中断的一种技术。</p>\n<p>我们分析一下下面这个代码的执行情况：</p>\n<div><pre><code>a <span>=</span> b <span>+</span> c<span>;</span>\nd <span>=</span> e <span>-</span> f <span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>先加载b、c（<strong>注意，即有可能先加载b，也有可能先加载c</strong>），但是在执行add(b,c)的时候，需要等待b、c装载结束才能继续执行，也就是增加了停顿，那么后面的指令也会依次有停顿,这降低了计算机的执行效率。</p>\n<p>为了减少这个停顿，我们可以先加载e和f,然后再去加载add(b,c),这样做对程序（串行）是没有影响的,但却减少了停顿。既然add(b,c)需要停顿，那还不如去做一些有意义的事情。</p>\n<p>综上所述，<strong>指令重排对于提高CPU处理性能十分必要。虽然由此带来了乱序的问题，但是这点牺牲是值得的。</strong></p>\n<p>指令重排一般分为以下三种：</p>\n<ul>\n<li>\n<p><strong>编译器优化重排</strong></p>\n<p>编译器在<strong>不改变单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序。</p>\n</li>\n<li>\n<p><strong>指令并行重排</strong></p>\n<p>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果<strong>不存在数据依赖性</strong>(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</p>\n</li>\n<li>\n<p><strong>内存系统重排</strong></p>\n<p>由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</p>\n</li>\n</ul>\n<p><strong>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>。所以在多线程下，指令重排序可能会导致一些问题。</p>\n<h4 id=\"_7-2-顺序一致性模型与jmm的保证\"> <strong>7.2 顺序一致性模型与JMM的保证</strong></h4>\n<p>顺序一致性模型是一个<strong>理论参考模型</strong>，内存模型在设计的时候都会以顺序一致性内存模型作为参考。</p>\n<h5 id=\"_7-2-1-数据竞争与顺序一致性\"> <strong>7.2.1 数据竞争与顺序一致性</strong></h5>\n<p>当程序未正确同步的时候，就可能存在数据竞争。</p>\n<blockquote>\n<p>数据竞争：在一个线程中写一个变量，在另一个线程读同一个变量，并且写和读没有通过同步来排序。</p>\n</blockquote>\n<p>如果程序中包含了数据竞争，那么运行的结果往往充满了<strong>不确定性</strong>，比如读发生在了写之前，可能就会读到错误的值；如果一个线程程序能够正确同步，那么就不存在数据竞争。</p>\n<p>Java内存模型（JMM）对于正确同步多线程程序的内存一致性做了以下保证：</p>\n<blockquote>\n<p><strong>如果程序是正确同步的，程序的执行将具有顺序一致性</strong>。 即程序的执行结果和该程序在顺序一致性模型中执行的结果相同。</p>\n</blockquote>\n<p>这里的同步包括了使用<code>volatile</code>、<code>final</code>、<code>synchronized</code>等关键字来实现<strong>多线程下的同步</strong>。</p>\n<p>如果程序员没有正确使用<code>volatile</code>、<code>final</code>、<code>synchronized</code>，那么即便是使用了同步（单线程下的同步），JMM也不会有内存可见性的保证，可能会导致你的程序出错，并且具有不可重现性，很难排查。</p>\n<p>所以如何正确使用<code>volatile</code>、<code>final</code>、<code>synchronized</code>，是程序员应该去了解的。后面会有专门的章节介绍这几个关键字的内存语义及使用。</p>\n<h5 id=\"_7-2-2-顺序一致性模型\"> <strong>7.2.2 顺序一致性模型</strong></h5>\n<p>顺序一致性内存模型是一个<strong>理想化的理论参考模型</strong>，它为程序员提供了极强的内存可见性保证。</p>\n<p>顺序一致性模型有两大特性：</p>\n<ul>\n<li>一个线程中的所有操作必须按照程序的顺序（即Java代码的顺序）来执行。</li>\n<li>不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。即在顺序一致性模型中，每个操作必须是<strong>原子性的，且立刻对所有线程可见</strong>。</li>\n</ul>\n<p>为了理解这两个特性，我们举个例子，假设有两个线程A和B并发执行，线程A有3个操作，他们在程序中的顺序是A1-&gt;A2-&gt;A3，线程B也有3个操作，B1-&gt;B2-&gt;B3。</p>\n<p>假设<strong>正确使用了同步</strong>，A线程的3个操作执行后释放锁，B线程获取同一个锁。那么在<strong>顺序一致性模型</strong>中的执行效果如下所示：</p>\n<p><img src=\"https://gblobscdn.gitbook.com/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TIqcRdKDsOukyesb%2F正确同步.png?alt=media\" alt=\"img\" /></p>\n<p>正确同步图</p>\n<p>操作的执行整体上有序，并且两个线程都只能看到这个执行顺序。</p>\n<p>假设<strong>没有使用同步</strong>，那么在<strong>顺序一致性模型</strong>中的执行效果如下所示：</p>\n<p><img src=\"https://gblobscdn.gitbook.com/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TIqeL6b2dOSGAIEt%2F没有正确同步.png?alt=media\" alt=\"img\" /></p>\n<p>没有正确同步图</p>\n<p>操作的执行整体上无序，但是两个线程都只能看到这个执行顺序。之所以可以得到这个保证，是因为顺序一致性模型中的<strong>每个操作必须立即对任意线程可见</strong>。</p>\n<p><strong>但是JMM没有这样的保证。</strong></p>\n<p>比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，这个写操作根本没有被当前线程所执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才对其他线程可见。在这种情况下，当前线程和其他线程看到的执行顺序是不一样的。</p>\n<h5 id=\"_7-2-3-jmm中同步程序的顺序一致性效果\"> <strong>7.2.3 JMM中同步程序的顺序一致性效果</strong></h5>\n<p>在顺序一致性模型中，所有操作完全按照程序的顺序串行执行。但是JMM中，临界区内（同步块或同步方法中）的代码可以发生重排序（但不允许临界区内的代码“逃逸”到临界区之外，因为会破坏锁的内存语义）。</p>\n<p>虽然线程A在临界区做了重排序，但是因为锁的特性，线程B无法观察到线程A在临界区的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p>\n<p>同时，JMM会在退出临界区和进入临界区做特殊的处理，使得在临界区内程序获得与顺序一致性模型相同的内存视图。</p>\n<p><strong>由此可见，JMM的具体实现方针是：在不改变（正确同步的）程序执行结果的前提下，尽量为编译期和处理器的优化打开方便之门</strong>。</p>\n<h5 id=\"_7-2-4-jmm中未同步程序的顺序一致性效果\"> <strong>7.2.4 JMM中未同步程序的顺序一致性效果</strong></h5>\n<p>对于未同步的多线程程序，JMM只提供<strong>最小安全性</strong>：线程读取到的值，要么是之前某个线程写入的值，要么是默认值，不会无中生有。</p>\n<p>为了实现这个安全性，JVM在堆上分配对象时，首先会对内存空间清零，然后才会在上面分配对象（这两个操作是同步的）。</p>\n<p><strong>JMM没有保证未同步程序的执行结果与该程序在顺序一致性中执行结果一致。因为如果要保证执行结果一致，那么JMM需要禁止大量的优化，对程序的执行性能会产生很大的影响。</strong></p>\n<p>未同步程序在JMM和顺序一致性内存模型中的执行特性有如下差异： 1. 顺序一致性保证单线程内的操作会按程序的顺序执行；JMM不保证单线程内的操作会按程序的顺序执行。（因为重排序，但是JMM保证单线程下的重排序不影响执行结果） 2. 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。（因为JMM不保证所有操作立即可见） 3. JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读写操作都具有原子性。</p>\n<h4 id=\"_7-3-happens-before\"> <strong>7.3 happens-before</strong></h4>\n<h5 id=\"_7-3-1-什么是happens-before\"> <strong>7.3.1 什么是happens-before?</strong></h5>\n<p>一方面，程序员需要JMM提供一个强的内存模型来编写代码；另一方面，编译器和处理器希望JMM对它们的束缚越少越好，这样它们就可以最可能多的做优化来提高性能，希望的是一个弱的内存模型。</p>\n<p>JMM考虑了这两种需求，并且找到了平衡点，对编译器和处理器来说，<strong>只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。</strong></p>\n<p>而对于程序员，JMM提供了<strong>happens-before规则</strong>（JSR-133规范），满足了程序员的需求——**简单易懂，并且提供了足够强的内存可见性保证。**换言之，程序员只要遵循happens-before规则，那他写的程序就能保证在JMM中具有强的内存可见性。</p>\n<p>JMM使用happens-before的概念来定制两个操作之间的执行顺序。这两个操作可以在一个线程以内，也可以是不同的线程之间。因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证。</p>\n<p>happens-before关系的定义如下： 1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 2. <strong>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。</strong></p>\n<p>happens-before关系本质上和as-if-serial语义是一回事。</p>\n<p>as-if-serial语义保证单线程内重排序后的执行结果和程序代码本身应有的结果是一致的，happens-before关系保证正确同步的多线程程序的执行结果不被重排序改变。</p>\n<p>总之，<strong>如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在一个线程。</strong></p>\n<h5 id=\"_7-3-2-天然的happens-before关系\"> <strong>7.3.2 天然的happens-before关系</strong></h5>\n<p>在Java中，有以下天然的happens-before关系：</p>\n<ul>\n<li>程序顺序规则：一个线程中的每一个操作，happens-before于该线程中的任意后续操作。</li>\n<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>\n<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>\n<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>\n<li>start规则：如果线程A执行操作ThreadB.start()启动线程B，那么A线程的ThreadB.start（）操作happens-before于线程B中的任意操作、</li>\n<li>join规则：如果线程A执行操作ThreadB.join（）并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>\n</ul>\n<p>举例：</p>\n<div><pre><code><span>int</span> a <span>=</span> <span>1</span><span>;</span> <span>// A操作</span>\n<span>int</span> b <span>=</span> <span>2</span><span>;</span> <span>// B操作</span>\n<span>int</span> sum <span>=</span> a <span>+</span> b<span>;</span><span>// C 操作</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sum<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>根据以上介绍的happens-before规则，假如只有一个线程，那么不难得出：</p>\n<div><pre><code><span>1</span><span>></span> <span>A</span> happens<span>-</span>before <span>B</span> \n<span>2</span><span>></span> <span>B</span> happens<span>-</span>before <span>C</span> \n<span>3</span><span>></span> <span>A</span> happens<span>-</span>before <span>C</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意，真正在执行指令的时候，其实JVM有可能对操作A &amp; B进行重排序，因为无论先执行A还是B，他们都对对方是可见的，并且不影响执行结果。</p>\n<p>如果这里发生了重排序，这在视觉上违背了happens-before原则，但是JMM是允许这样的重排序的。</p>\n<p>所以，我们只关心happens-before规则，不用关心JVM到底是怎样执行的。只要确定操作A happens-before操作B就行了。</p>\n<p>重排序有两类，JMM对这两类重排序有不同的策略：</p>\n<ul>\n<li>会改变程序执行结果的重排序，比如 A -&gt; C，JMM要求编译器和处理器都不许禁止这种重排序。</li>\n<li>不会改变程序执行结果的重排序，比如 A -&gt; B，JMM对编译器和处理器不做要求，允许这种重排序。</li>\n</ul>\n<h3 id=\"_8-volatitle\"> 8 volatitle</h3>\n<h4 id=\"_8-1-几个基本概念\"> <strong>8.1 几个基本概念</strong></h4>\n<p>在介绍volatile之前，我们先回顾及介绍几个基本的概念。</p>\n<h5 id=\"_8-1-1-内存可见性\"> <strong>8.1.1 内存可见性</strong></h5>\n<p>在Java内存模型那一章我们介绍了JMM有一个主内存，每个线程有自己私有的工作内存，工作内存中保存了一些变量在主内存的拷贝。</p>\n<p><strong>内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值</strong>。</p>\n<h5 id=\"_8-1-2-重排序\"> <strong>8.1.2 重排序</strong></h5>\n<p>为优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU重排序等。</p>\n<h5 id=\"_8-1-3-happens-before规则\"> <strong>8.1.3 happens-before规则</strong></h5>\n<p>是一个给程序员使用的规则，只要程序员在写代码的时候遵循happens-before规则，JVM就能保证指令在多线程之间的顺序性符合程序员的预期。</p>\n<h4 id=\"_8-2-volatile的内存语义\"> <strong>8.2 volatile的内存语义</strong></h4>\n<p>在Java中，volatile关键字有特殊的内存语义。volatile主要有以下两个功能：</p>\n<ul>\n<li>保证变量的<strong>内存可见性</strong></li>\n<li>禁止volatile变量与普通变量<strong>重排序</strong>（JSR133提出，Java 5 开始才有这个“增强的volatile内存语义”）</li>\n</ul>\n<h5 id=\"_8-2-1-内存可见性\"> <strong>8.2.1 内存可见性</strong></h5>\n<p>以一段示例代码开始：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>VolatileExample</span> <span>{</span>\n    <span>int</span> a <span>=</span> <span>0</span><span>;</span>\n    <span>volatile</span> <span>boolean</span> flag <span>=</span> <span>false</span><span>;</span>\n\n    <span>public</span> <span>void</span> <span>writer</span><span>(</span><span>)</span> <span>{</span>\n        a <span>=</span> <span>1</span><span>;</span> <span>// step 1</span>\n        flag <span>=</span> <span>true</span><span>;</span> <span>// step 2</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>reader</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>flag<span>)</span> <span>{</span> <span>// step 3</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>)</span><span>;</span> <span>// step 4</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>在这段代码里，我们使用<code>volatile</code>关键字修饰了一个<code>boolean</code>类型的变量<code>flag</code>。</p>\n<p>所谓内存可见性，指的是当一个线程对<code>volatile</code>修饰的变量进行<strong>写操作</strong>（比如step 2）时，JMM会立即把该线程对应的本地内存中的共享变量的值刷新到主内存；当一个线程对<code>volatile</code>修饰的变量进行<strong>读操作</strong>（比如step 3）时，JMM会把立即该线程对应的本地内存置为无效，从主内存中读取共享变量的值。</p>\n<blockquote>\n<p>在这一点上，volatile与锁具有相同的内存效果，volatile变量的写和锁的释放具有相同的内存语义，volatile变量的读和锁的获取具有相同的内存语义。</p>\n</blockquote>\n<p>假设在时间线上，线程A先自行方法<code>writer</code>方法，线程B后执行<code>reader</code>方法。那必然会有下图：</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/volatile内存示意图.jpg\" alt=\"volatile内存示意图\" /></p>\n<p>而如果<code>flag</code>变量<strong>没有</strong>用<code>volatile</code>修饰，在step 2，线程A的本地内存里面的变量就不会立即更新到主内存，那随后线程B也同样不会去主内存拿最新的值，仍然使用线程B本地内存缓存的变量的值<code>a = 0，flag = false</code>。</p>\n<h5 id=\"_8-2-1-禁止重排序\"> <strong>8.2.1 禁止重排序</strong></h5>\n<p>在JSR-133之前的旧的Java内存模型中，是允许volatile变量与普通变量重排序的。那上面的案例中，可能就会被重排序成下列时序来执行：</p>\n<ol>\n<li>线程A写volatile变量，step 2，设置flag为true；</li>\n<li>线程B读同一个volatile，step 3，读取到flag为true；</li>\n<li>线程B读普通变量，step 4，读取到 a = 0；</li>\n<li>线程A修改普通变量，step 1，设置 a = 1；</li>\n</ol>\n<p>可见，如果volatile变量与普通变量发生了重排序，虽然volatile变量能保证内存可见性，也可能导致普通变量读取错误。</p>\n<p>所以在旧的内存模型中，volatile的写-读就不能与锁的释放-获取具有相同的内存语义了。为了提供一种比锁更轻量级的<strong>线程间的通信机制</strong>，<strong>JSR-133</strong>专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序。</p>\n<p>编译器还好说，JVM是怎么还能限制处理器的重排序的呢？它是通过<strong>内存屏障</strong>来实现的。</p>\n<p>什么是内存屏障？硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用：</p>\n<ol>\n<li>阻止屏障两侧的指令重排序；</li>\n<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。</li>\n</ol>\n<blockquote>\n<p>注意这里的缓存主要指的是CPU缓存，如L1，L2等</p>\n</blockquote>\n<p>编译器在<strong>生成字节码时</strong>，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个<strong>比较保守的JMM内存屏障插入策略</strong>，这样可以保证在任何处理器平台，任何程序中都能得到正确的volatile内存语义。这个策略是：</p>\n<ul>\n<li>在每个volatile写操作前插入一个StoreStore屏障；</li>\n<li>在每个volatile写操作后插入一个StoreLoad屏障；</li>\n<li>在每个volatile读操作后插入一个LoadLoad屏障；</li>\n<li>在每个volatile读操作后再插入一个LoadStore屏障。</li>\n</ul>\n<p>大概示意图是这个样子：</p>\n<p><img src=\"https://segmentfault.com/img/bV7Pbg?w=500&h=306\" alt=\"clipboard.png\" /></p>\n<p>内存屏障</p>\n<blockquote>\n<p>再逐个解释一下这几个屏障。注：下述Load代表读操作，Store代表写操作</p>\n<p><strong>LoadLoad屏障</strong>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>\n<p><strong>StoreStore屏障</strong>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p>\n<p><strong>LoadStore屏障</strong>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p>\n<p><strong>StoreLoad屏障</strong>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</p>\n</blockquote>\n<p>对于连续多个volatile变量读或者连续多个volatile变量写，编译器做了一定的优化来提高性能，比如：</p>\n<blockquote>\n<p>第一个volatile读;</p>\n<p>LoadLoad屏障；</p>\n<p>第二个volatile读；</p>\n<p>LoadStore屏障</p>\n</blockquote>\n<p>再介绍一下volatile与普通变量的重排序规则:</p>\n<ol>\n<li>如果第一个操作是volatile读，那无论第二个操作是什么，都不能重排序；</li>\n<li>如果第二个操作是volatile写，那无论第一个操作是什么，都不能重排序；</li>\n<li>如果第一个操作是volatile写，第二个操作是volatile读，那不能重排序。</li>\n</ol>\n<p>举个例子，我们在案例中step 1，是普通变量的写，step 2是volatile变量的写，那符合第2个规则，这两个steps不能重排序。而step 3是volatile变量读，step 4是普通变量读，符合第1个规则，同样不能重排序。</p>\n<p>但如果是下列情况：第一个操作是普通变量读，第二个操作是volatile变量读，那是可以重排序的：</p>\n<div><pre><code><span>// 声明变量</span>\n<span>int</span> a <span>=</span> <span>0</span><span>;</span> <span>// 声明普通变量</span>\n<span>volatile</span> <span>boolean</span> flag <span>=</span> <span>false</span><span>;</span> <span>// 声明volatile变量</span>\n\n<span>// 以下两个变量的读操作是可以重排序的</span>\n<span>int</span> i <span>=</span> a<span>;</span> <span>// 普通变量读</span>\n<span>boolean</span> j <span>=</span> flag<span>;</span> <span>// volatile变量读</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id=\"_8-3-volatile的用途\"> <strong>8.3 volatile的用途</strong></h4>\n<p>从volatile的内存语义上来看，volatile可以保证内存可见性且禁止重排序。</p>\n<p>在保证内存可见性这一点上，volatile有着与锁相同的内存语义，所以可以作为一个“轻量级”的锁来使用。但由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁可以保证整个<strong>临界区代码</strong>的执行具有原子性。所以<strong>在功能上，锁比volatile更强大；在性能上，volatile更有优势</strong>。</p>\n<p>在禁止重排序这一点上，volatile也是非常有用的。比如我们熟悉的单例模式，其中有一种实现方式是“双重锁检查”，比如这样的代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>\n\n    <span>private</span> <span>static</span> <span>Singleton</span> instance<span>;</span> <span>// 不使用volatile关键字</span>\n\n    <span>// 双重锁检验</span>\n    <span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span> <span>{</span> <span>// 第7行</span>\n            <span>synchronized</span> <span>(</span><span>Singleton</span><span>.</span><span>class</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                    instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span> <span>// 第10行</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> instance<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>如果这里的变量声明不使用volatile关键字，是可能会发生错误的。它可能会被重排序：</p>\n<div><pre><code>instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span> <span>// 第10行</span>\n\n<span>// 可以分解为以下三个步骤</span>\n<span>1</span> memory<span>=</span><span>allocate</span><span>(</span><span>)</span><span>;</span><span>// 分配内存 相当于c的malloc</span>\n<span>2</span> <span>ctorInstanc</span><span>(</span>memory<span>)</span> <span>//初始化对象</span>\n<span>3</span> s<span>=</span>memory <span>//设置s指向刚分配的地址</span>\n\n<span>// 上述三个步骤可能会被重排序为 1-3-2，也就是：</span>\n<span>1</span> memory<span>=</span><span>allocate</span><span>(</span><span>)</span><span>;</span><span>// 分配内存 相当于c的malloc</span>\n<span>3</span> s<span>=</span>memory <span>//设置s指向刚分配的地址</span>\n<span>2</span> <span>ctorInstanc</span><span>(</span>memory<span>)</span> <span>//初始化对象</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>而一旦假设发生了这样的重排序，比如线程A在第10行执行了步骤1和步骤3，但是步骤2还没有执行完。这个时候线程A执行到了第7行，它会判定instance不为空，然后直接返回了一个未初始化完成的instance！</p>\n<p>所以JSR-133对volatile做了增强后，volatile的禁止重排序功能还是非常有用的。</p>\n<h3 id=\"_9-synchronized与锁\"> 9 synchronized与锁</h3>\n<p>这篇文章我们来聊一聊Java多线程里面的“锁”。</p>\n<p>首先需要明确的一点是：<strong>Java多线程的锁都是基于对象的</strong>，Java中的每一个对象都可以作为一个锁。</p>\n<p>还有一点需要注意的是，我们常听到的<strong>类锁</strong>其实也是对象锁。</p>\n<p>Java类只有一个Class对象（可以有多个实例对象，多个实例共享这个Class对象），而Class对象也是特殊的Java对象。所以我们常说的类锁，其实就是Class对象的锁。</p>\n<h4 id=\"_9-1-synchronized关键字\"> <strong>9.1 Synchronized关键字</strong></h4>\n<p>说到锁，我们通常会谈到<code>synchronized</code>这个关键字。它翻译成中文就是“同步”的意思。</p>\n<p>我们通常使用<code>synchronized</code>关键字来给一段代码或一个方法上锁。它通常有以下三种形式：</p>\n<div><pre><code><span>// 关键字在实例方法上，锁为当前实例</span>\n<span>public</span> <span>synchronized</span> <span>void</span> <span>instanceLock</span><span>(</span><span>)</span> <span>{</span>\n    <span>// code</span>\n<span>}</span>\n\n<span>// 关键字在静态方法上，锁为当前Class对象</span>\n<span>public</span> <span>static</span> <span>synchronized</span> <span>void</span> <span>classLock</span><span>(</span><span>)</span> <span>{</span>\n    <span>// code</span>\n<span>}</span>\n\n<span>// 关键字在代码块上，锁为括号里面的对象</span>\n<span>public</span> <span>void</span> <span>blockLock</span><span>(</span><span>)</span> <span>{</span>\n    <span>Object</span> o <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>\n    <span>synchronized</span> <span>(</span>o<span>)</span> <span>{</span>\n        <span>// code</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>我们这里介绍一下“临界区”的概念。所谓“临界区”，指的是某一块代码区域，它同一时刻只能由一个线程执行。在上面的例子中，如果<code>synchronized</code>关键字在方法上，那临界区就是整个方法内部。而如果是使用synchronized代码块，那临界区就指的是代码块内部的区域。</p>\n<p>通过上面的例子我们可以看到，下面这两个写法其实是等价的作用：</p>\n<div><pre><code><span>// 关键字在实例方法上，锁为当前实例</span>\n<span>public</span> <span>synchronized</span> <span>void</span> <span>instanceLock</span><span>(</span><span>)</span> <span>{</span>\n    <span>// code</span>\n<span>}</span>\n\n<span>// 关键字在代码块上，锁为括号里面的对象</span>\n<span>public</span> <span>void</span> <span>blockLock</span><span>(</span><span>)</span> <span>{</span>\n    <span>synchronized</span> <span>(</span><span>this</span><span>)</span> <span>{</span>\n        <span>// code</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>同理，下面这两个方法也应该是等价的：</p>\n<div><pre><code><span>// 关键字在静态方法上，锁为当前Class对象</span>\n<span>public</span> <span>static</span> <span>synchronized</span> <span>void</span> <span>classLock</span><span>(</span><span>)</span> <span>{</span>\n    <span>// code</span>\n<span>}</span>\n\n<span>// 关键字在代码块上，锁为括号里面的对象</span>\n<span>public</span> <span>void</span> <span>blockLock</span><span>(</span><span>)</span> <span>{</span>\n    <span>synchronized</span> <span>(</span><span>this</span><span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>// code</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id=\"_9-2-几种锁\"> <strong>9.2 几种锁</strong></h4>\n<p>Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁“。在Java 6 以前，所有的锁都是”重量级“锁。所以在Java 6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：</p>\n<ol>\n<li>无锁状态</li>\n<li>偏向锁状态</li>\n<li>轻量级锁状态</li>\n<li>重量级锁状态</li>\n</ol>\n<p>无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它，无锁在这里不再细讲。</p>\n<p>几种锁会随着竞争情况逐渐升级，锁的升级很容易发生，但是锁降级发生的条件会比较苛刻，锁降级发生在Stop The World期间，当JVM进入安全点的时候，会检查是否有闲置的锁，然后进行降级。</p>\n<blockquote>\n<p>关于锁降级有两点说明：</p>\n<p>1.不同于大部分文章说锁不能降级，实际上HotSpot JVM 是支持锁降级的，文末有链接。</p>\n<p>2.上面提到的Stop The World期间，以及安全点，这些知识是属于JVM的知识范畴，本文不做细讲。</p>\n</blockquote>\n<p>下面分别介绍这几种锁以及它们之间的升级。</p>\n<h5 id=\"_9-2-1-java对象头\"> <strong>9.2.1 Java对象头</strong></h5>\n<p>前面我们提到，Java的锁都是基于对象的。首先我们来看看一个对象的“锁”的信息是存放在什么地方的。</p>\n<p>每个Java对象都有对象头。如果是非数组类型，则用2个字宽来存储对象头，如果是数组，则会用3个字宽来存储对象头。在32位处理器中，一个字宽是32位；在64位虚拟机中，一个字宽是64位。对象头的内容如下表：</p>\n<table>\n<thead>\n<tr>\n<th>长度</th>\n<th>内容</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>32/64bit</td>\n<td>Mark Word</td>\n<td>存储对象的hashCode或锁信息等</td>\n</tr>\n<tr>\n<td>32/64bit</td>\n<td>Class Metadata Address</td>\n<td>存储到对象类型数据的指针</td>\n</tr>\n<tr>\n<td>32/64bit</td>\n<td>Array length</td>\n<td>数组的长度（如果是数组）</td>\n</tr>\n</tbody>\n</table>\n<p>我们主要来看看Mark Word的格式：</p>\n<table>\n<thead>\n<tr>\n<th>锁状态</th>\n<th>29 bit 或 61 bit</th>\n<th>1 bit 是否是偏向锁？</th>\n<th>2 bit 锁标志位</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>无锁</td>\n<td></td>\n<td>0</td>\n<td>01</td>\n</tr>\n<tr>\n<td>偏向锁</td>\n<td>线程ID</td>\n<td>1</td>\n<td>01</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td>指向栈中锁记录的指针</td>\n<td>此时这一位不用于标识偏向锁</td>\n<td>00</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td>指向互斥量（重量级锁）的指针</td>\n<td>此时这一位不用于标识偏向锁</td>\n<td>10</td>\n</tr>\n<tr>\n<td>GC标记</td>\n<td></td>\n<td>此时这一位不用于标识偏向锁</td>\n<td>11</td>\n</tr>\n</tbody>\n</table>\n<p>可以看到，当对象状态为偏向锁时，<code>Mark Word</code>存储的是偏向的线程ID；当状态为轻量级锁时，<code>Mark Word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；当状态为重量级锁时，<code>Mark Word</code>为指向堆中的monitor对象的指针。</p>\n<h5 id=\"_9-2-2-偏向锁\"> <strong>9.2.2 偏向锁</strong></h5>\n<p>Hotspot的作者经过以往的研究发现大多数情况下<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，于是引入了偏向锁。</p>\n<p>偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也就是说，<strong>偏向锁在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。</strong></p>\n<blockquote>\n<p>大白话就是对锁置个变量，如果发现为true，代表资源无竞争，则无需再走各种加锁/解锁流程。如果为false，代表存在其他线程竞争资源，那么就会走后面的流程。</p>\n</blockquote>\n<h6 id=\"实现原理\"> <strong>实现原理</strong></h6>\n<p>一个线程在第一次进入同步块时，会在对象头和栈帧中的锁记录里存储锁的偏向的线程ID。当下次该线程进入这个同步块时，会去检查锁的Mark Word里面是不是放的自己的线程ID。</p>\n<p>如果是，表明该线程已经获得了锁，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁 ；如果不是，就代表有另一个线程来竞争这个偏向锁。这个时候会尝试使用CAS来替换Mark Word里面的线程ID为新线程的ID，这个时候要分两种情况：</p>\n<ul>\n<li>成功，表示之前的线程不存在了， Mark Word里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁；</li>\n<li>失败，表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为0，并设置锁标志位为00，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。</li>\n</ul>\n<blockquote>\n<p>CAS: Compare and Swap</p>\n<p>比较并设置。用于在硬件层面上提供原子性操作。在 Intel 处理器中，比较并交换通过指令cmpxchg实现。 比较是否和给定的数值一致，如果一致则修改，不一致则不修改。</p>\n</blockquote>\n<p>线程竞争偏向锁的过程如下：</p>\n<p><img src=\"https://gblobscdn.gitbook.com/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJcrxgO7BhuMHkor%2F偏向锁2.jpg?alt=media\" alt=\"img\" /></p>\n<p>图中涉及到了lock record指针指向当前堆栈中的最近一个lock record，是轻量级锁按照先来先服务的模式进行了轻量级锁的加锁。</p>\n<h6 id=\"撤销偏向锁\"> <strong>撤销偏向锁</strong></h6>\n<p>偏向锁使用了一种<strong>等到竞争出现才释放锁的机制</strong>，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。</p>\n<p>偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：</p>\n<ol>\n<li>在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。</li>\n<li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态。</li>\n<li>唤醒被停止的线程，将当前锁升级成轻量级锁。</li>\n</ol>\n<p>所以，如果应用程序里所有的锁通常出于竞争状态，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭：</p>\n<div><pre><code><span>-</span>XX<span>:</span><span>UseBiasedLocking</span><span>=</span><span>false</span>。\n</code></pre>\n<div><span>1</span><br></div></div><p>下面这个经典的图总结了偏向锁的获得和撤销：</p>\n<p><img src=\"https://gblobscdn.gitbook.com/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJctbmT4TYol6GFi%2F偏向锁.png?alt=media\" alt=\"img\" /></p>\n<h5 id=\"_9-2-3-轻量级锁\"> <strong>9.2.3 轻量级锁</strong></h5>\n<p>多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM采用轻量级锁来避免线程的阻塞与唤醒。</p>\n<h6 id=\"轻量级锁的加锁\"> <strong>轻量级锁的加锁</strong></h6>\n<p>JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，我们称为Displaced Mark Word。如果一个线程获得锁的时候发现是轻量级锁，会把锁的Mark Word复制到自己的Displaced Mark Word里面。</p>\n<p>然后线程尝试用CAS将锁的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</p>\n<blockquote>\n<p>自旋：不断尝试去获取锁，一般用循环来实现。</p>\n</blockquote>\n<p>自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。</p>\n<p>但是JDK采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p>\n<p>自旋也不是一直进行下去的，如果自旋到一定程度（和JVM、操作系统相关），依然没有获取到锁，称为自旋失败，那么这个线程会阻塞。同时这个锁就会<strong>升级成重量级锁</strong>。</p>\n<p><strong>轻量级锁的释放：</strong></p>\n<p>在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程。</p>\n<p>一张图说明加锁和释放锁的过程：</p>\n<p><img src=\"https://gblobscdn.gitbook.com/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJcvhlUdgfv1YFly%2F轻量级锁流程图.png?alt=media\" alt=\"img\" /></p>\n<h5 id=\"_9-2-4-重量级锁\"> <strong>9.2.4 重量级锁</strong></h5>\n<p>重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。</p>\n<p>前面说到，每一个对象都可以当做一个锁，当多个线程同时请求某个对象锁时，对象锁会设置几种状态用来区分请求的线程：</p>\n<div><pre><code><span>Contention</span> <span>List</span>：所有请求锁的线程将被首先放置到该竞争队列\n<span>Entry</span> <span>List</span>：<span>Contention</span> <span>List</span>中那些有资格成为候选人的线程被移到<span>Entry</span> <span>List</span>\n<span>Wait</span> <span>Set</span>：那些调用wait方法被阻塞的线程被放置到<span>Wait</span> <span>Set</span>\n<span>OnDeck</span>：任何时刻最多只能有一个线程正在竞争锁，该线程称为<span>OnDeck</span>\n<span>Owner</span>：获得锁的线程称为<span>Owner</span>\n<span>!</span><span>Owner</span>：释放锁的线程\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个<code>ObjectWaiter</code>对象插入到Contention List的队列的队首，然后调用<code>park</code>函数挂起当前线程。</p>\n<p>当线程释放锁时，会从Contention List或EntryList中挑选一个线程唤醒，被选中的线程叫做<code>Heir presumptive</code>即假定继承人，假定继承人被唤醒后会尝试获得锁，但<code>synchronized</code>是非公平的，所以假定继承人不一定能获得锁。这是因为对于重量级锁，线程先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销。如果自旋不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平，还有一个不公平的地方是自旋线程可能会抢占了Ready线程的锁。</p>\n<p>果线程获得锁后调用<code>Object.wait</code>方法，则会将线程加入到WaitSet中，当被<code>Object.notify</code>唤醒后，会将线程从WaitSet移动到Contention List或EntryList中去。需要注意的是，当调用一个锁对象的<code>wait</code>或<code>notify</code>方法时，<strong>如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁</strong>。</p>\n<h5 id=\"_9-2-5-总结锁的升级流程\"> <strong>9.2.5 总结锁的升级流程</strong></h5>\n<p>每一个线程在准备获取共享资源时： 第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁” 。</p>\n<p>第二步，如果MarkWord不是自己的ThreadId，锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。</p>\n<p>第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord。</p>\n<p>第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋 。</p>\n<p>第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 。</p>\n<p>第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。</p>\n<h5 id=\"_9-2-6-各种锁的优缺点对比\"> <strong>9.2.6 各种锁的优缺点对比</strong></h5>\n<p>下表来自《Java并发编程的艺术》：</p>\n<table>\n<thead>\n<tr>\n<th>锁</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>偏向锁</td>\n<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>\n<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>\n<td>适用于只有一个线程访问同步块场景。</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>\n<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td>\n<td>追求响应时间。同步块执行速度非常快。</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td>线程竞争不使用自旋，不会消耗CPU。</td>\n<td>线程阻塞，响应时间缓慢。</td>\n<td>追求吞吐量。同步块执行速度较长。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_10-cas与原子操作\"> 10 CAS与原子操作</h3>\n<h4 id=\"第十章-乐观锁和悲观锁\"> <strong>第十章 乐观锁和悲观锁</strong></h4>\n<h4 id=\"_10-1-乐观锁与悲观锁的概念\"> <strong>10.1 乐观锁与悲观锁的概念</strong></h4>\n<p>锁可以从不同的角度分类。其中，乐观锁和悲观锁是一种分类方式。</p>\n<p><strong>悲观锁：</strong></p>\n<p>悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</p>\n<p><strong>乐观锁：</strong></p>\n<p>乐观锁又称为“无锁”，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为CAS的技术来保证线程执行的安全性。</p>\n<p>由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说<strong>乐观锁天生免疫死锁</strong>。</p>\n<p>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。</p>\n<h4 id=\"_10-2-cas的概念\"> <strong>10.2 CAS的概念</strong></h4>\n<p>CAS的全称是：比较并交换（Compare And Swap）。在CAS中，有这样三个值：</p>\n<ul>\n<li>V：要更新的变量(var)</li>\n<li>E：预期值(expected)</li>\n<li>N：新值(new)</li>\n</ul>\n<p>比较并交换的过程如下：</p>\n<p>判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。</p>\n<p>所以这里的<strong>预期值E本质上指的是“旧值”</strong>。</p>\n<p>我们以一个简单的例子来解释这个过程：</p>\n<ol>\n<li>如果有一个多个线程共享的变量<code>i</code>原本等于5，我现在在线程A中，想把它设置为新的值6;</li>\n<li>我们使用CAS来做这个事情；</li>\n<li>首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，<code>i</code>的值被设置成了6；</li>\n<li>如果不等于5，说明<code>i</code>被其它线程改过了（比如现在<code>i</code>的值为2），那么我就什么也不做，此次CAS失败，<code>i</code>的值仍然为2。</li>\n</ol>\n<p>在这个例子中，<code>i</code>就是V，5就是E，6就是N。</p>\n<p>那有没有可能我在判断了<code>i</code>为5之后，正准备更新它的新值的时候，被其它线程更改了<code>i</code>的值呢？</p>\n<p>不会的。因为CAS是一种原子操作，它是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性</p>\n<p><strong>当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</strong></p>\n<h4 id=\"_10-3-java实现cas的原理-unsafe类\"> <strong>10.3 Java实现CAS的原理 - Unsafe类</strong></h4>\n<p>前面提到，CAS是一种原子操作。那么Java是怎样来使用CAS的呢？我们知道，在Java中，如果一个方法是native的，那Java就不负责具体实现它，而是交给底层的JVM使用c或者c++去实现。</p>\n<p>在Java中，有一个<code>Unsafe</code>类，它在<code>sun.misc</code>包中。它里面是一些<code>native</code>方法，其中就有几个关于CAS的：</p>\n<div><pre><code><span>boolean</span> <span>compareAndSwapObject</span><span>(</span><span>Object</span> o<span>,</span> <span>long</span> offset<span>,</span><span>Object</span> expected<span>,</span> <span>Object</span> x<span>)</span><span>;</span>\n<span>boolean</span> <span>compareAndSwapInt</span><span>(</span><span>Object</span> o<span>,</span> <span>long</span> offset<span>,</span><span>int</span> expected<span>,</span><span>int</span> x<span>)</span><span>;</span>\n<span>boolean</span> <span>compareAndSwapLong</span><span>(</span><span>Object</span> o<span>,</span> <span>long</span> offset<span>,</span><span>long</span> expected<span>,</span><span>long</span> x<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当然，他们都是<code>public native</code>的。</p>\n<p>Unsafe中对CAS的实现是C++写的，它的具体实现和操作系统、CPU都有关系。</p>\n<p>Linux的X86下主要是通过<code>cmpxchgl</code>这个指令在CPU级完成CAS操作的，但在多处理器情况下必须使用<code>lock</code>指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同，大家可以自行了解。</p>\n<p>当然，Unsafe类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的<code>park</code>和<code>unpark</code>， LockSupport类底层就是调用了这两个方法。还有支持反射操作的<code>allocateInstance()</code>方法。</p>\n<h4 id=\"_10-4-原子操作-atomicinteger类源码简析\"> <strong>10.4 原子操作-AtomicInteger类源码简析</strong></h4>\n<p>上面介绍了Unsafe类的几个支持CAS的方法。那Java具体是如何使用这几个方法来实现原子操作的呢？</p>\n<p>JDK提供了一些用于原子操作的类，在<code>java.util.concurrent.atomic</code>包下面。在JDK 11中，有如下17个类：</p>\n<p><img src=\"https://gblobscdn.gitbook.com/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJH5r93uLYB5jEEg%2F原子类.jpg?alt=media\" alt=\"img\" /></p>\n<p>原子类</p>\n<p>从名字就可以看得出来这些类大概的用途：</p>\n<ul>\n<li>原子更新基本类型</li>\n<li>原子更新数组</li>\n<li>原子更新引用</li>\n<li>原子更新字段（属性）</li>\n</ul>\n<p>这里我们以<code>AtomicInteger</code>类的<code>getAndAdd(int delta)</code>方法为例，来看看Java是如何实现原子操作的。</p>\n<p>先看看这个方法的源码：</p>\n<div><pre><code><span>public</span> <span>final</span> <span>int</span> <span>getAndAdd</span><span>(</span><span>int</span> delta<span>)</span> <span>{</span>\n    <span>return</span> <span>U</span><span>.</span><span>getAndAddInt</span><span>(</span><span>this</span><span>,</span> VALUE<span>,</span> delta<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这里的U其实就是一个<code>Unsafe</code>对象：</p>\n<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span><span>jdk<span>.</span>internal<span>.</span>misc<span>.</span></span>Unsafe</span> <span>U</span> <span>=</span> <span><span>jdk<span>.</span>internal<span>.</span>misc<span>.</span></span>Unsafe</span><span>.</span><span>getUnsafe</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>所以其实<code>AtomicInteger</code>类的<code>getAndAdd(int delta)</code>方法是调用<code>Unsafe</code>类的方法来实现的：</p>\n<div><pre><code><span>@HotSpotIntrinsicCandidate</span>\n<span>public</span> <span>final</span> <span>int</span> <span>getAndAddInt</span><span>(</span><span>Object</span> o<span>,</span> <span>long</span> offset<span>,</span> <span>int</span> delta<span>)</span> <span>{</span>\n    <span>int</span> v<span>;</span>\n    <span>do</span> <span>{</span>\n        v <span>=</span> <span>getIntVolatile</span><span>(</span>o<span>,</span> offset<span>)</span><span>;</span>\n    <span>}</span> <span>while</span> <span>(</span><span>!</span><span>weakCompareAndSetInt</span><span>(</span>o<span>,</span> offset<span>,</span> v<span>,</span> v <span>+</span> delta<span>)</span><span>)</span><span>;</span>\n    <span>return</span> v<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>注：这个方法是在JDK 1.8才新增的。在JDK1.8之前，<code>AtomicInteger</code>源码实现有所不同，是基于for死循环的，有兴趣的读者可以自行了解一下。</p>\n</blockquote>\n<p>我们来一步步解析这段源码。首先，对象<code>o</code>是<code>this</code>，也就是一个<code>AtomicInteger</code>对象。然后<code>offset</code>是一个常量<code>VALUE</code>。这个常量是在<code>AtomicInteger</code>类中声明的：</p>\n<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>long</span> VALUE <span>=</span> <span>U</span><span>.</span><span>objectFieldOffset</span><span>(</span><span>AtomicInteger</span><span>.</span><span>class</span><span>,</span> <span>\"value\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>同样是调用的<code>Unsafe</code>的方法。从方法名字上来看，是得到了一个对象字段偏移量。</p>\n<blockquote>\n<p>用于获取某个字段相对Java对象的“起始地址”的偏移量。</p>\n<p>一个java对象可以看成是一段内存，各个字段都得按照一定的顺序放在这段内存里，同时考虑到对齐要求，可能这些字段不是连续放置的，</p>\n<p>用这个方法能准确地告诉你某个字段相对于对象的起始内存地址的字节偏移量，因为是相对偏移量，所以它其实跟某个具体对象又没什么太大关系，跟class的定义和虚拟机的内存模型的实现细节更相关。</p>\n</blockquote>\n<p>继续看源码。前面我们讲到，CAS是“无锁”的基础，它允许更新失败。所以经常会与while循环搭配，在失败后不断去重试。</p>\n<p>这里声明了一个v，也就是要返回的值。从<code>getAndAddInt</code>来看，它返回的应该是原来的值，而新的值的<code>v + delta</code>。</p>\n<p>这里使用的是<strong>do-while循环</strong>。这种循环不多见，它的目的是<strong>保证循环体内的语句至少会被执行一遍</strong>。这样才能保证return 的值<code>v</code>是我们期望的值。</p>\n<p>循环体的条件是一个CAS方法：</p>\n<div><pre><code><span>public</span> <span>final</span> <span>boolean</span> <span>weakCompareAndSetInt</span><span>(</span><span>Object</span> o<span>,</span> <span>long</span> offset<span>,</span>\n                                          <span>int</span> expected<span>,</span>\n                                          <span>int</span> x<span>)</span> <span>{</span>\n    <span>return</span> <span>compareAndSetInt</span><span>(</span>o<span>,</span> offset<span>,</span> expected<span>,</span> x<span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>final</span> <span>native</span> <span>boolean</span> <span>compareAndSetInt</span><span>(</span><span>Object</span> o<span>,</span> <span>long</span> offset<span>,</span>\n                                             <span>int</span> expected<span>,</span>\n                                             <span>int</span> x<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>可以看到，最终其实是调用的我们之前说到了CAS <code>native</code>方法。那为什么要经过一层<code>weakCompareAndSetInt</code>呢？从JDK源码上看不出来什么。在JDK 8及之前的版本，这两个方法是一样的。</p>\n<blockquote>\n<p>而在JDK 9开始，这两个方法上面增加了@HotSpotIntrinsicCandidate注解。这个注解允许HotSpot VM自己来写汇编或IR编译器来实现该方法以提供性能。也就是说虽然外面看到的在JDK9中weakCompareAndSet和compareAndSet底层依旧是调用了一样的代码，但是不排除HotSpot VM会手动来实现weakCompareAndSet真正含义的功能的可能性。</p>\n</blockquote>\n<p>根据本文第一篇参考文章（文末链接），它跟<code>volitile</code>有关。</p>\n<p>简单来说，<code>weakCompareAndSet</code>操作仅保留了<code>volatile</code>自身变量的特性，而出去了happens-before规则带来的内存语义。也就是说，<code>weakCompareAndSet</code>**无法保证处理操作目标的volatile变量外的其他变量的执行顺序( 编译器和处理器为了优化程序性能而对指令序列进行重新排序 )，同时也无法保证这些变量的可见性。**这在一定程度上可以提高性能。</p>\n<p>再回到循环条件上来，可以看到它是在不断尝试去用CAS更新。如果更新失败，就继续重试。那为什么要把获取“旧值”v的操作放到循环体内呢？其实这也很好理解。前面我们说了，CAS如果旧值V不等于预期值E，它就会更新失败。说明旧的值发生了变化。那我们当然需要返回的是被其他线程改变之后的旧值了，因此放在了do循环体内。</p>\n<h4 id=\"_10-5-cas实现原子操作的三大问题\"> <strong>10.5 CAS实现原子操作的三大问题</strong></h4>\n<p>这里介绍一下CAS实现原子操作的三大问题及其解决方案。</p>\n<h5 id=\"_10-5-1-aba问题\"> <strong>10.5.1 ABA问题</strong></h5>\n<p>所谓ABA问题，就是一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次。</p>\n<p>ABA问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。从JDK 1.5开始，JDK的atomic包里提供了一个类<code>AtomicStampedReference</code>类来解决ABA问题。</p>\n<p>这个类的<code>compareAndSet</code>方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用CAS设置为新的值和标志。</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>compareAndSet</span><span>(</span><span>V</span>   expectedReference<span>,</span>\n                             <span>V</span>   newReference<span>,</span>\n                             <span>int</span> expectedStamp<span>,</span>\n                             <span>int</span> newStamp<span>)</span> <span>{</span>\n    <span>Pair</span><span><span>&lt;</span><span>V</span><span>></span></span> current <span>=</span> pair<span>;</span>\n    <span>return</span>\n        expectedReference <span>==</span> current<span>.</span>reference <span>&amp;&amp;</span>\n        expectedStamp <span>==</span> current<span>.</span>stamp <span>&amp;&amp;</span>\n        <span>(</span><span>(</span>newReference <span>==</span> current<span>.</span>reference <span>&amp;&amp;</span>\n          newStamp <span>==</span> current<span>.</span>stamp<span>)</span> <span>||</span>\n         <span>casPair</span><span>(</span>current<span>,</span> <span>Pair</span><span>.</span><span>of</span><span>(</span>newReference<span>,</span> newStamp<span>)</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h5 id=\"_10-5-2-循环时间长开销大\"> <strong>10.5.2 循环时间长开销大</strong></h5>\n<p>CAS多与自旋结合。如果自旋CAS长时间不成功，会占用大量的CPU资源。</p>\n<p>解决思路是让JVM支持处理器提供的<strong>pause指令</strong>。</p>\n<p>pause指令能让自旋失败时cpu睡眠一小段时间再继续自旋，从而使得读操作的频率低很多,为解决内存顺序冲突而导致的CPU流水线重排的代价也会小很多。</p>\n<h5 id=\"_10-5-3-只能保证一个共享变量的原子操作\"> <strong>10.5.3 只能保证一个共享变量的原子操作</strong></h5>\n<p>这个问题你可能已经知道怎么解决了。有两种解决方案：</p>\n<ol>\n<li>使用JDK 1.5开始就提供的<code>AtomicReference</code>类保证对象之间的原子性，把多个变量放到一个对象里面进行CAS操作；</li>\n<li>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</li>\n</ol>\n<h3 id=\"_11-aqs\"> 11 AQS</h3>\n<h4 id=\"_11-1-aqs简介\"> <strong>11.1 AQS简介</strong></h4>\n<p><strong>AQS</strong>是<code>AbstractQueuedSynchronizer</code>的简称，即<code>抽象队列同步器</code>，从字面意思上理解:</p>\n<ul>\n<li>抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；</li>\n<li>队列：使用先进先出（FIFO）队列存储数据；</li>\n<li>同步：实现了同步的功能。</li>\n</ul>\n<p>那AQS有什么用呢？AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的同步器，比如我们提到的ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。</p>\n<p>当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器，只要之类实现它的几个<code>protected</code>方法就可以了，在下文会有详细的介绍。</p>\n<h4 id=\"_11-2-aqs的数据结构\"> <strong>11.2 AQS的数据结构</strong></h4>\n<p>AQS内部使用了一个volatile的变量state来作为资源的标识。同时定义了几个获取和改版state的protected方法，子类可以覆盖这些方法来实现自己的逻辑：</p>\n<div><pre><code><span>getState</span><span>(</span><span>)</span>\n<span>setState</span><span>(</span><span>)</span>\n<span>compareAndSetState</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这三种叫做均是原子操作，其中compareAndSetState的实现依赖于Unsafe的compareAndSwapInt()方法。</p>\n<p>而AQS类本身实现的是一些排队和阻塞的机制，比如具体线程等待队列的维护（如获取资源失败入队/唤醒出队等）。它内部使用了一个先进先出（FIFO）的双端队列，并使用了两个指针head和tail用于标识队列的头部和尾部。其数据结构如图：</p>\n<p><img src=\"https://gblobscdn.gitbook.com/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJQjOPACL_iNG1yE%2FAQS数据结构.png?alt=media\" alt=\"img\" /></p>\n<p>img</p>\n<p>但它并不是直接储存线程，而是储存拥有线程的Node节点。</p>\n<h4 id=\"_11-3-资源共享模式\"> <strong>11.3 资源共享模式</strong></h4>\n<p>资源有两种共享模式，或者说两种同步方式：</p>\n<ul>\n<li>独占模式（Exclusive）：资源是独占的，一次只能一个线程获取。如ReentrantLock。</li>\n<li>共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如Semaphore/CountDownLatch。</li>\n</ul>\n<p>一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如<code>ReadWriteLock</code>。</p>\n<p>AQS中关于这两种资源共享模式的定义源码（均在内部类Node中）。我们来看看Node的结构：</p>\n<div><pre><code><span>static</span> <span>final</span> <span>class</span> <span>Node</span> <span>{</span>\n    <span>// 标记一个结点（对应的线程）在共享模式下等待</span>\n    <span>static</span> <span>final</span> <span>Node</span> SHARED <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>)</span><span>;</span>\n    <span>// 标记一个结点（对应的线程）在独占模式下等待</span>\n    <span>static</span> <span>final</span> <span>Node</span> EXCLUSIVE <span>=</span> <span>null</span><span>;</span> \n\n    <span>// waitStatus的值，表示该结点（对应的线程）已被取消</span>\n    <span>static</span> <span>final</span> <span>int</span> CANCELLED <span>=</span> <span>1</span><span>;</span> \n    <span>// waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span>\n    <span>static</span> <span>final</span> <span>int</span> SIGNAL <span>=</span> <span>-</span><span>1</span><span>;</span>\n    <span>// waitStatus的值，表示该结点（对应的线程）在等待某一条件</span>\n    <span>static</span> <span>final</span> <span>int</span> CONDITION <span>=</span> <span>-</span><span>2</span><span>;</span>\n    <span>/*waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点（共享模式下，多线程并发释放资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；设置新的head结点时，会继续唤醒其后继结点）*/</span>\n    <span>static</span> <span>final</span> <span>int</span> PROPAGATE <span>=</span> <span>-</span><span>3</span><span>;</span>\n\n    <span>// 等待状态，取值范围，-3，-2，-1，0，1</span>\n    <span>volatile</span> <span>int</span> waitStatus<span>;</span>\n    <span>volatile</span> <span>Node</span> prev<span>;</span> <span>// 前驱结点</span>\n    <span>volatile</span> <span>Node</span> next<span>;</span> <span>// 后继结点</span>\n    <span>volatile</span> <span>Thread</span> thread<span>;</span> <span>// 结点对应的线程</span>\n    <span>Node</span> nextWaiter<span>;</span> <span>// 等待队列里下一个等待条件的结点</span>\n\n\n    <span>// 判断共享模式的方法</span>\n    <span>final</span> <span>boolean</span> <span>isShared</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> nextWaiter <span>==</span> SHARED<span>;</span>\n    <span>}</span>\n\n    <span>Node</span><span>(</span><span>Thread</span> thread<span>,</span> <span>Node</span> mode<span>)</span> <span>{</span>     <span>// Used by addWaiter</span>\n        <span>this</span><span>.</span>nextWaiter <span>=</span> mode<span>;</span>\n        <span>this</span><span>.</span>thread <span>=</span> thread<span>;</span>\n    <span>}</span>\n\n    <span>// 其它方法忽略，可以参考具体的源码</span>\n<span>}</span>\n\n<span>// AQS里面的addWaiter私有方法</span>\n<span>private</span> <span>Node</span> <span>addWaiter</span><span>(</span><span>Node</span> mode<span>)</span> <span>{</span>\n    <span>// 使用了Node的这个构造函数</span>\n    <span>Node</span> node <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>,</span> mode<span>)</span><span>;</span>\n    <span>// 其它代码省略</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><blockquote>\n<p>注意：通过Node我们可以实现两个队列，一是通过prev和next实现CLH队列(线程同步队列,双向队列)，二是nextWaiter实现Condition条件上的等待线程队列(单向队列)，这个Condition主要用在ReentrantLock类中。</p>\n</blockquote>\n<h4 id=\"_11-4-aqs的主要方法源码解析\"> <strong>11.4 AQS的主要方法源码解析</strong></h4>\n<p>AQS的设计是基于<strong>模板方法模式</strong>的，它有一些方法必须要子类去实现的，它们主要有：</p>\n<ul>\n<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>\n<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>\n<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>\n<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>\n<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>\n</ul>\n<p>这些方法虽然都是<code>protected</code>方法，但是它们并没有在AQS具体实现，而是直接抛出异常（虽然不知道这里为什么不使用抽象方法的实现方式）：</p>\n<div><pre><code><span>protected</span> <span>boolean</span> <span>tryAcquire</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>\n    <span>throw</span> <span>new</span> <span>UnsupportedOperationException</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>而AQS实现了一系列主要的逻辑。下面我们从源码来分析一下获取和释放资源的主要逻辑：</p>\n<h5 id=\"_11-4-1-获取资源\"> <strong>11.4.1 获取资源</strong></h5>\n<p>获取资源的入口是acquire(int arg)方法。arg是要获取的资源的个数，在独占模式下始终为1。我们先来看看这个方法的逻辑：</p>\n<div><pre><code><span>public</span> <span>final</span> <span>void</span> <span>acquire</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>!</span><span>tryAcquire</span><span>(</span>arg<span>)</span> <span>&amp;&amp;</span>\n        <span>acquireQueued</span><span>(</span><span>addWaiter</span><span>(</span><span>Node</span><span>.</span>EXCLUSIVE<span>)</span><span>,</span> arg<span>)</span><span>)</span>\n        <span>selfInterrupt</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>首先调用tryAcquire(arg)尝试去获取资源。前面提到了这个方法是在子类具体实现的。</p>\n<p>如果获取资源失败，就通过addWaiter(Node.EXCLUSIVE)方法把这个线程插入到等待队列中。其中传入的参数代表要插入的Node是独占式的。这个方法的具体实现：</p>\n<div><pre><code><span>private</span> <span>Node</span> <span>addWaiter</span><span>(</span><span>Node</span> mode<span>)</span> <span>{</span>\n    <span>// 生成该线程对应的Node节点</span>\n    <span>Node</span> node <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>,</span> mode<span>)</span><span>;</span>\n    <span>// 将Node插入队列中</span>\n    <span>Node</span> pred <span>=</span> tail<span>;</span>\n    <span>if</span> <span>(</span>pred <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        node<span>.</span>prev <span>=</span> pred<span>;</span>\n        <span>// 使用CAS尝试，如果成功就返回</span>\n        <span>if</span> <span>(</span><span>compareAndSetTail</span><span>(</span>pred<span>,</span> node<span>)</span><span>)</span> <span>{</span>\n            pred<span>.</span>next <span>=</span> node<span>;</span>\n            <span>return</span> node<span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>// 如果等待队列为空或者上述CAS失败，再自旋CAS插入</span>\n    <span>enq</span><span>(</span>node<span>)</span><span>;</span>\n    <span>return</span> node<span>;</span>\n<span>}</span>\n\n<span>// 自旋CAS插入等待队列</span>\n<span>private</span> <span>Node</span> <span>enq</span><span>(</span><span>final</span> <span>Node</span> node<span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n        <span>Node</span> t <span>=</span> tail<span>;</span>\n        <span>if</span> <span>(</span>t <span>==</span> <span>null</span><span>)</span> <span>{</span> <span>// Must initialize</span>\n            <span>if</span> <span>(</span><span>compareAndSetHead</span><span>(</span><span>new</span> <span>Node</span><span>(</span><span>)</span><span>)</span><span>)</span>\n                tail <span>=</span> head<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            node<span>.</span>prev <span>=</span> t<span>;</span>\n            <span>if</span> <span>(</span><span>compareAndSetTail</span><span>(</span>t<span>,</span> node<span>)</span><span>)</span> <span>{</span>\n                t<span>.</span>next <span>=</span> node<span>;</span>\n                <span>return</span> t<span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><blockquote>\n<p>上面的两个函数比较好理解，就是在队列的尾部插入新的Node节点，但是需要注意的是由于AQS中会存在多个线程同时争夺资源的情况，因此肯定会出现多个线程同时插入节点的操作，在这里是通过CAS自旋的方式保证了操作的线程安全性。</p>\n</blockquote>\n<p>OK，现在回到最开始的aquire(int arg)方法。现在通过addWaiter方法，已经把一个Node放到等待队列尾部了。而处于等待队列的结点是从头结点一个一个去获取资源的。具体的实现我们来看看acquireQueued方法</p>\n<div><pre><code><span>final</span> <span>boolean</span> <span>acquireQueued</span><span>(</span><span>final</span> <span>Node</span> node<span>,</span> <span>int</span> arg<span>)</span> <span>{</span>\n    <span>boolean</span> failed <span>=</span> <span>true</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>boolean</span> interrupted <span>=</span> <span>false</span><span>;</span>\n        <span>// 自旋</span>\n        <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n            <span>final</span> <span>Node</span> p <span>=</span> node<span>.</span><span>predecessor</span><span>(</span><span>)</span><span>;</span>\n            <span>// 如果node的前驱结点p是head，表示node是第二个结点，就可以尝试去获取资源了</span>\n            <span>if</span> <span>(</span>p <span>==</span> head <span>&amp;&amp;</span> <span>tryAcquire</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>\n                <span>// 拿到资源后，将head指向该结点。</span>\n                <span>// 所以head所指的结点，就是当前获取到资源的那个结点或null。</span>\n                <span>setHead</span><span>(</span>node<span>)</span><span>;</span> \n                p<span>.</span>next <span>=</span> <span>null</span><span>;</span> <span>// help GC</span>\n                failed <span>=</span> <span>false</span><span>;</span>\n                <span>return</span> interrupted<span>;</span>\n            <span>}</span>\n            <span>// 如果自己可以休息了，就进入waiting状态，直到被unpark()</span>\n            <span>if</span> <span>(</span><span>shouldParkAfterFailedAcquire</span><span>(</span>p<span>,</span> node<span>)</span> <span>&amp;&amp;</span>\n                <span>parkAndCheckInterrupt</span><span>(</span><span>)</span><span>)</span>\n                interrupted <span>=</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        <span>if</span> <span>(</span>failed<span>)</span>\n            <span>cancelAcquire</span><span>(</span>node<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><blockquote>\n<p>这里parkAndCheckInterrupt方法内部使用到了LockSupport.park(this)，顺便简单介绍一下park。</p>\n<p>LockSupport类是Java 6 引入的一个类，提供了基本的线程同步原语。LockSupport实际上是调用了Unsafe类里的函数，归结到Unsafe里，只有两个函数：</p>\n<ul>\n<li>park(boolean isAbsolute, long time)：阻塞当前线程</li>\n<li>unpark(Thread jthread)：使给定的线程停止阻塞</li>\n</ul>\n</blockquote>\n<p>所以<strong>结点进入等待队列后，是调用park使它进入阻塞状态的。只有头结点的线程是处于活跃状态的</strong>。</p>\n<p>当然，获取资源的方法除了acquire外，还有以下三个：</p>\n<ul>\n<li>acquireInterruptibly：申请可中断的资源（独占模式）</li>\n<li>acquireShared：申请共享模式的资源</li>\n<li>acquireSharedInterruptibly：申请可中断的资源（共享模式）</li>\n</ul>\n<blockquote>\n<p>可中断的意思是，在线程中断时可能会抛出<code>InterruptedException</code></p>\n</blockquote>\n<p>总结起来的一个流程图：</p>\n<p><img src=\"https://gblobscdn.gitbook.com/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJQpo8U_q8r9AJ5q%2Facquire流程.jpg?alt=media\" alt=\"img\" /></p>\n<p>acquire流程</p>\n<h5 id=\"_11-4-2-释放资源\"> <strong>11.4.2 释放资源</strong></h5>\n<p>释放资源相比于获取资源来说，会简单许多。在AQS中只有一小段实现。源码：</p>\n<div><pre><code><span>public</span> <span>final</span> <span>boolean</span> <span>release</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>tryRelease</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>\n        <span>Node</span> h <span>=</span> head<span>;</span>\n        <span>if</span> <span>(</span>h <span>!=</span> <span>null</span> <span>&amp;&amp;</span> h<span>.</span>waitStatus <span>!=</span> <span>0</span><span>)</span>\n            <span>unparkSuccessor</span><span>(</span>h<span>)</span><span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n\n<span>private</span> <span>void</span> <span>unparkSuccessor</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>\n    <span>// 如果状态是负数，尝试把它设置为0</span>\n    <span>int</span> ws <span>=</span> node<span>.</span>waitStatus<span>;</span>\n    <span>if</span> <span>(</span>ws <span>&lt;</span> <span>0</span><span>)</span>\n        <span>compareAndSetWaitStatus</span><span>(</span>node<span>,</span> ws<span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>// 得到头结点的后继结点head.next</span>\n    <span>Node</span> s <span>=</span> node<span>.</span>next<span>;</span>\n    <span>// 如果这个后继结点为空或者状态大于0</span>\n    <span>// 通过前面的定义我们知道，大于0只有一种可能，就是这个结点已被取消</span>\n    <span>if</span> <span>(</span>s <span>==</span> <span>null</span> <span>||</span> s<span>.</span>waitStatus <span>></span> <span>0</span><span>)</span> <span>{</span>\n        s <span>=</span> <span>null</span><span>;</span>\n        <span>// 等待队列中所有还有用的结点，都向前移动</span>\n        <span>for</span> <span>(</span><span>Node</span> t <span>=</span> tail<span>;</span> t <span>!=</span> <span>null</span> <span>&amp;&amp;</span> t <span>!=</span> node<span>;</span> t <span>=</span> t<span>.</span>prev<span>)</span>\n            <span>if</span> <span>(</span>t<span>.</span>waitStatus <span>&lt;=</span> <span>0</span><span>)</span>\n                s <span>=</span> t<span>;</span>\n    <span>}</span>\n    <span>// 如果后继结点不为空，</span>\n    <span>if</span> <span>(</span>s <span>!=</span> <span>null</span><span>)</span>\n        <span>LockSupport</span><span>.</span><span>unpark</span><span>(</span>s<span>.</span>thread<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id=\"第三篇-jdk工具篇\"> 第三篇 JDK工具篇</h2>\n<h3 id=\"_12-线程池原理\"> 12 线程池原理</h3>\n<h4 id=\"_12-1-为什么要使用线程池\"> <strong>12.1 为什么要使用线程池</strong></h4>\n<p>使用线程池主要有以下三个原因：</p>\n<ol>\n<li>创建/销毁线程需要消耗系统资源，线程池可以<strong>复用已创建的线程</strong>。</li>\n<li><strong>控制并发的数量</strong>。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）</li>\n<li><strong>可以对线程做统一管理</strong>。</li>\n</ol>\n<h4 id=\"_12-2-线程池的原理\"> <strong>12.2 线程池的原理</strong></h4>\n<p>Java中的线程池顶层接口是<code>Executor</code>接口，<code>ThreadPoolExecutor</code>是这个接口的实现类。</p>\n<p>我们先看看<code>ThreadPoolExecutor</code>类。</p>\n<h5 id=\"_12-2-1-threadpoolexecutor提供的构造方法\"> <strong>12.2.1 ThreadPoolExecutor提供的构造方法</strong></h5>\n<p>一共有四个构造方法：</p>\n<div><pre><code><span>// 五个参数的构造函数</span>\n<span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>\n                          <span>int</span> maximumPoolSize<span>,</span>\n                          <span>long</span> keepAliveTime<span>,</span>\n                          <span>TimeUnit</span> unit<span>,</span>\n                          <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>)</span>\n\n<span>// 六个参数的构造函数-1</span>\n<span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>\n                          <span>int</span> maximumPoolSize<span>,</span>\n                          <span>long</span> keepAliveTime<span>,</span>\n                          <span>TimeUnit</span> unit<span>,</span>\n                          <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>,</span>\n                          <span>ThreadFactory</span> threadFactory<span>)</span>\n\n<span>// 六个参数的构造函数-2</span>\n<span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>\n                          <span>int</span> maximumPoolSize<span>,</span>\n                          <span>long</span> keepAliveTime<span>,</span>\n                          <span>TimeUnit</span> unit<span>,</span>\n                          <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>,</span>\n                          <span>RejectedExecutionHandler</span> handler<span>)</span>\n\n<span>// 七个参数的构造函数</span>\n<span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>\n                          <span>int</span> maximumPoolSize<span>,</span>\n                          <span>long</span> keepAliveTime<span>,</span>\n                          <span>TimeUnit</span> unit<span>,</span>\n                          <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>,</span>\n                          <span>ThreadFactory</span> threadFactory<span>,</span>\n                          <span>RejectedExecutionHandler</span> handler<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>涉及到5~7个参数，我们先看看必须的5个参数是什么意思：</p>\n<ul>\n<li>\n<p><strong>int corePoolSize</strong>：该线程池中<strong>核心线程数最大值</strong></p>\n<blockquote>\n<p>核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>int maximumPoolSize</strong>：该线程池中<strong>线程总数最大值</strong> 。</p>\n<blockquote>\n<p>该值等于核心线程数量 + 非核心线程数量。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>long keepAliveTime</strong>：<strong>非核心线程闲置超时时长</strong>。</p>\n<blockquote>\n<p>非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>TimeUnit unit</strong>：keepAliveTime的单位。</p>\n</li>\n</ul>\n<p>TimeUnit是一个枚举类型 ，包括以下属性：</p>\n<blockquote>\n<p>NANOSECONDS ： 1微毫秒 = 1微秒 / 1000 MICROSECONDS ： 1微秒 = 1毫秒 / 1000 MILLISECONDS ： 1毫秒 = 1秒 /1000 SECONDS ： 秒 MINUTES ： 分 HOURS ： 小时 DAYS ： 天</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>BlockingQueue workQueue</strong>：阻塞队列，维护着<strong>等待执行的Runnable任务对象</strong>。</p>\n<p>常用的几个阻塞队列：</p>\n<ol>\n<li>\n<p><strong>LinkedBlockingQueue</strong></p>\n<p>链式阻塞队列，底层数据结构是链表，默认大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。</p>\n</li>\n<li>\n<p><strong>ArrayBlockingQueue</strong></p>\n<p>数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</p>\n</li>\n<li>\n<p><strong>SynchronousQueue</strong></p>\n<p>同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</p>\n</li>\n<li>\n<p><strong>DelayQueue</strong></p>\n<p>延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。</p>\n</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>我们将在下一章中重点介绍各种阻塞队列</p>\n</blockquote>\n<p>好了，介绍完5个必须的参数之后，还有两个非必须的参数。</p>\n<ul>\n<li>\n<p><strong>ThreadFactory threadFactory</strong></p>\n<p>创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。</p>\n</li>\n</ul>\n<div><pre><code><span>static</span> <span>class</span> <span>DefaultThreadFactory</span> <span>implements</span> <span>ThreadFactory</span> <span>{</span>\n    <span>// 省略属性</span>\n    <span>// 构造函数</span>\n    <span>DefaultThreadFactory</span><span>(</span><span>)</span> <span>{</span>\n        <span>SecurityManager</span> s <span>=</span> <span>System</span><span>.</span><span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n        group <span>=</span> <span>(</span>s <span>!=</span> <span>null</span><span>)</span> <span>?</span> s<span>.</span><span>getThreadGroup</span><span>(</span><span>)</span> <span>:</span>\n        <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>;</span>\n        namePrefix <span>=</span> <span>\"pool-\"</span> <span>+</span>\n            poolNumber<span>.</span><span>getAndIncrement</span><span>(</span><span>)</span> <span>+</span>\n            <span>\"-thread-\"</span><span>;</span>\n    <span>}</span>\n\n    <span>// 省略</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ul>\n<li>\n<p><strong>RejectedExecutionHandler handler</strong></p>\n<p><strong>拒绝处理策略</strong>，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ：</p>\n<ol>\n<li><strong>ThreadPoolExecutor.AbortPolicy</strong>：<strong>默认拒绝处理策略</strong>，丢弃任务并抛出RejectedExecutionException异常。</li>\n<li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常。</li>\n<li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</li>\n<li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：由调用线程处理该任务。</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"_12-2-2-threadpoolexecutor的策略\"> <strong>12.2.2 ThreadPoolExecutor的策略</strong></h5>\n<p>线程池本身有一个调度线程，这个线程就是用于管理布控整个线程池里的各种任务和事务，例如创建线程、销毁线程、任务队列管理、线程队列管理等等。</p>\n<p>故线程池也有自己的状态。<code>ThreadPoolExecutor</code>类中定义了一个<code>volatile int</code>变量<strong>runState</strong>来表示线程池的状态 ，分别为RUNNING、SHURDOWN、STOP、TIDYING 、TERMINATED。</p>\n<ul>\n<li>\n<p>线程池创建后处于<strong>RUNNING</strong>状态。</p>\n</li>\n<li>\n<p>调用shutdown()方法后处于<strong>SHUTDOWN</strong>状态，线程池不能接受新的任务，清除一些空闲worker,会等待阻塞队列的任务完成。</p>\n</li>\n<li>\n<p>调用shutdownNow()方法后处于<strong>STOP</strong>状态，线程池不能接受新的任务，中断所有线程，阻塞队列中没有被执行的任务全部丢弃。此时，poolsize=0,阻塞队列的size也为0。</p>\n</li>\n<li>\n<p>当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为<strong>TIDYING</strong>状态。接着会执行terminated()函数。</p>\n<blockquote>\n<p>ThreadPoolExecutor中有一个控制状态的属性叫ctl，它是一个AtomicInteger类型的变量。</p>\n</blockquote>\n</li>\n<li>\n<p>线程池处在TIDYING状态时，<strong>执行完terminated()方法之后</strong>，就会由 <strong>TIDYING -&gt; TERMINATED</strong>， 线程池被设置为TERMINATED状态。</p>\n</li>\n</ul>\n<h5 id=\"_12-2-3-线程池主要的任务处理流程\"> <strong>12.2.3 线程池主要的任务处理流程</strong></h5>\n<p>处理任务的核心方法是<code>execute</code>，我们看看 JDK 1.8 源码中<code>ThreadPoolExecutor</code>是如何处理线程任务的：</p>\n<div><pre><code><span>// JDK 1.8 </span>\n<span>public</span> <span>void</span> <span>execute</span><span>(</span><span>Runnable</span> command<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>command <span>==</span> <span>null</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>   \n    <span>int</span> c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n    <span>// 1.当前线程数小于corePoolSize,则调用addWorker创建核心线程执行任务</span>\n    <span>if</span> <span>(</span><span>workerCountOf</span><span>(</span>c<span>)</span> <span>&lt;</span> corePoolSize<span>)</span> <span>{</span>\n       <span>if</span> <span>(</span><span>addWorker</span><span>(</span>command<span>,</span> <span>true</span><span>)</span><span>)</span>\n           <span>return</span><span>;</span>\n       c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>// 2.如果不小于corePoolSize，则将任务添加到workQueue队列。</span>\n    <span>if</span> <span>(</span><span>isRunning</span><span>(</span>c<span>)</span> <span>&amp;&amp;</span> workQueue<span>.</span><span>offer</span><span>(</span>command<span>)</span><span>)</span> <span>{</span>\n        <span>int</span> recheck <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n        <span>// 2.1 如果isRunning返回false(状态检查)，则remove这个任务，然后执行拒绝策略。</span>\n        <span>if</span> <span>(</span><span>!</span> <span>isRunning</span><span>(</span>recheck<span>)</span> <span>&amp;&amp;</span> <span>remove</span><span>(</span>command<span>)</span><span>)</span>\n            <span>reject</span><span>(</span>command<span>)</span><span>;</span>\n            <span>// 2.2 线程池处于running状态，但是没有线程，则创建线程</span>\n        <span>else</span> <span>if</span> <span>(</span><span>workerCountOf</span><span>(</span>recheck<span>)</span> <span>==</span> <span>0</span><span>)</span>\n            <span>addWorker</span><span>(</span><span>null</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>// 3.如果放入workQueue失败，则创建非核心线程执行任务，</span>\n    <span>// 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。</span>\n    <span>else</span> <span>if</span> <span>(</span><span>!</span><span>addWorker</span><span>(</span>command<span>,</span> <span>false</span><span>)</span><span>)</span>\n         <span>reject</span><span>(</span>command<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p><code>ctl.get()</code>是获取线程池状态，用<code>int</code>类型表示。第二步中，入队前进行了一次<code>isRunning</code>判断，入队之后，又进行了一次<code>isRunning</code>判断。</p>\n<p><strong>为什么要二次检查线程池的状态?</strong></p>\n<p>在多线程的环境下，线程池的状态是时刻发生变化的。很有可能刚获取线程池状态后线程池状态就改变了。判断是否将<code>command</code>加入<code>workqueue</code>是线程池之前的状态。倘若没有二次检查，万一线程池处于非<strong>RUNNING</strong>状态（在多线程环境下很有可能发生），那么<code>command</code>永远不会执行。</p>\n<p><strong>总结一下处理流程</strong></p>\n<ol>\n<li>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。<strong>注意，这一步需要获得全局锁。</strong></li>\n<li>线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了<strong>线程复用</strong>）。</li>\n<li>当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。<strong>注意，这一步需要获得全局锁。</strong></li>\n<li>缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</li>\n</ol>\n<p>整个过程如图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/chenxiao19920206/RedSpiderArticlePhotos/master/java-base/multi-thread/线程池主要的处理流程.png\" alt=\"img\" /></p>\n<h5 id=\"_12-2-4-threadpoolexecutor如何做到线程复用的\"> <strong>12.2.4 ThreadPoolExecutor如何做到线程复用的？</strong></h5>\n<p>我们知道，一个线程在创建的时候会指定一个线程任务，当执行完这个线程任务之后，线程自动销毁。但是线程池却可以复用线程，即一个线程执行完线程任务后不销毁，继续执行另外的线程任务。<strong>那么，线程池如何做到线程复用呢？</strong></p>\n<p>原来，ThreadPoolExecutor在创建线程时，会将线程封装成<strong>工作线程worker</strong>,并放入<strong>工作线程组</strong>中，然后这个worker反复从阻塞队列中拿任务去执行。话不多说，我们继续看看源码（一定要仔细看，前后有联系）</p>\n<p>这里的<code>addWorker</code>方法是在上面提到的<code>execute</code>方法里面调用的，先看看上半部分：</p>\n<div><pre><code><span>// ThreadPoolExecutor.addWorker方法源码上半部分</span>\n<span>private</span> <span>boolean</span> <span>addWorker</span><span>(</span><span>Runnable</span> firstTask<span>,</span> <span>boolean</span> core<span>)</span> <span>{</span>\n    retry<span>:</span>\n    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n        <span>int</span> c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> rs <span>=</span> <span>runStateOf</span><span>(</span>c<span>)</span><span>;</span>\n\n        <span>// Check if queue empty only if necessary.</span>\n        <span>if</span> <span>(</span>rs <span>>=</span> SHUTDOWN <span>&amp;&amp;</span>\n            <span>!</span> <span>(</span>rs <span>==</span> SHUTDOWN <span>&amp;&amp;</span>\n               firstTask <span>==</span> <span>null</span> <span>&amp;&amp;</span>\n               <span>!</span> workQueue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>)</span>\n            <span>return</span> <span>false</span><span>;</span>\n\n        <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n            <span>int</span> wc <span>=</span> <span>workerCountOf</span><span>(</span>c<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>wc <span>>=</span> CAPACITY <span>||</span>\n                <span>// 1.如果core是ture,证明需要创建的线程为核心线程，则先判断当前线程是否大于核心线程</span>\n                <span>// 如果core是false,证明需要创建的是非核心线程，则先判断当前线程数是否大于总线程数</span>\n                <span>// 如果不小于，则返回false</span>\n                wc <span>>=</span> <span>(</span>core <span>?</span> corePoolSize <span>:</span> maximumPoolSize<span>)</span><span>)</span>\n                <span>return</span> <span>false</span><span>;</span>\n            <span>if</span> <span>(</span><span>compareAndIncrementWorkerCount</span><span>(</span>c<span>)</span><span>)</span>\n                <span>break</span> retry<span>;</span>\n            c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>  <span>// Re-read ctl</span>\n            <span>if</span> <span>(</span><span>runStateOf</span><span>(</span>c<span>)</span> <span>!=</span> rs<span>)</span>\n                <span>continue</span> retry<span>;</span>\n            <span>// else CAS failed due to workerCount change; retry inner loop</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>上半部分主要是判断线程数量是否超出阈值，超过了就返回false。我们继续看下半部分:</p>\n<div><pre><code>    <span>// ThreadPoolExecutor.addWorker方法源码下半部分</span>\n    <span>boolean</span> workerStarted <span>=</span> <span>false</span><span>;</span>\n    <span>boolean</span> workerAdded <span>=</span> <span>false</span><span>;</span>\n    <span>Worker</span> w <span>=</span> <span>null</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>// 1.创建一个worker对象</span>\n        w <span>=</span> <span>new</span> <span>Worker</span><span>(</span>firstTask<span>)</span><span>;</span>\n        <span>// 2.实例化一个Thread对象</span>\n        <span>final</span> <span>Thread</span> t <span>=</span> w<span>.</span>thread<span>;</span>\n        <span>if</span> <span>(</span>t <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>// 3.线程池全局锁</span>\n            <span>final</span> <span>ReentrantLock</span> mainLock <span>=</span> <span>this</span><span>.</span>mainLock<span>;</span>\n            mainLock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n            <span>try</span> <span>{</span>\n                <span>// Recheck while holding lock.</span>\n                <span>// Back out on ThreadFactory failure or if</span>\n                <span>// shut down before lock acquired.</span>\n                <span>int</span> rs <span>=</span> <span>runStateOf</span><span>(</span>ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n                <span>if</span> <span>(</span>rs <span>&lt;</span> SHUTDOWN <span>||</span>\n                    <span>(</span>rs <span>==</span> SHUTDOWN <span>&amp;&amp;</span> firstTask <span>==</span> <span>null</span><span>)</span><span>)</span> <span>{</span>\n                    <span>if</span> <span>(</span>t<span>.</span><span>isAlive</span><span>(</span><span>)</span><span>)</span> <span>// precheck that t is startable</span>\n                        <span>throw</span> <span>new</span> <span>IllegalThreadStateException</span><span>(</span><span>)</span><span>;</span>\n                    workers<span>.</span><span>add</span><span>(</span>w<span>)</span><span>;</span>\n                    <span>int</span> s <span>=</span> workers<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n                    <span>if</span> <span>(</span>s <span>></span> largestPoolSize<span>)</span>\n                        largestPoolSize <span>=</span> s<span>;</span>\n                    workerAdded <span>=</span> <span>true</span><span>;</span>\n                <span>}</span>\n            <span>}</span> <span>finally</span> <span>{</span>\n                mainLock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>if</span> <span>(</span>workerAdded<span>)</span> <span>{</span>\n                <span>// 4.启动这个线程</span>\n                t<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n                workerStarted <span>=</span> <span>true</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        <span>if</span> <span>(</span><span>!</span> workerStarted<span>)</span>\n            <span>addWorkerFailed</span><span>(</span>w<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> workerStarted<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p>创建<code>worker</code>对象，并初始化一个<code>Thread</code>对象，然后启动这个线程对象。</p>\n<p>我们接着看看<code>Worker</code>类，仅展示部分源码：</p>\n<div><pre><code><span>// Worker类部分源码</span>\n<span>private</span> <span>final</span> <span>class</span> <span>Worker</span> <span>extends</span> <span>AbstractQueuedSynchronizer</span> <span>implements</span> <span>Runnable</span><span>{</span>\n    <span>final</span> <span>Thread</span> thread<span>;</span>\n    <span>Runnable</span> firstTask<span>;</span>\n\n    <span>Worker</span><span>(</span><span>Runnable</span> firstTask<span>)</span> <span>{</span>\n        <span>setState</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span> <span>// inhibit interrupts until runWorker</span>\n        <span>this</span><span>.</span>firstTask <span>=</span> firstTask<span>;</span>\n        <span>this</span><span>.</span>thread <span>=</span> <span>getThreadFactory</span><span>(</span><span>)</span><span>.</span><span>newThread</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>runWorker</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>//其余代码略...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><code>Worker</code>类实现了<code>Runnable</code>接口，所以<code>Worker</code>也是一个线程任务。在构造方法中，创建了一个线程，线程的任务就是自己。故<code>addWorker</code>方法调用addWorker方法源码下半部分中的第4步<code>t.start</code>，会触发<code>Worker</code>类的<code>run</code>方法被JVM调用。</p>\n<p>我们再看看<code>runWorker</code>的逻辑：</p>\n<div><pre><code><span>// Worker.runWorker方法源代码</span>\n<span>final</span> <span>void</span> <span>runWorker</span><span>(</span><span>Worker</span> w<span>)</span> <span>{</span>\n    <span>Thread</span> wt <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>\n    <span>Runnable</span> task <span>=</span> w<span>.</span>firstTask<span>;</span>\n    w<span>.</span>firstTask <span>=</span> <span>null</span><span>;</span>\n    <span>// 1.线程启动之后，通过unlock方法释放锁</span>\n    w<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span> <span>// allow interrupts</span>\n    <span>boolean</span> completedAbruptly <span>=</span> <span>true</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>// 2.Worker执行firstTask或从workQueue中获取任务，如果getTask方法不返回null,循环不退出</span>\n        <span>while</span> <span>(</span>task <span>!=</span> <span>null</span> <span>||</span> <span>(</span>task <span>=</span> <span>getTask</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>// 2.1进行加锁操作，保证thread不被其他线程中断（除非线程池被中断）</span>\n            w<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n            <span>// If pool is stopping, ensure thread is interrupted;</span>\n            <span>// if not, ensure thread is not interrupted.  This</span>\n            <span>// requires a recheck in second case to deal with</span>\n            <span>// shutdownNow race while clearing interrupt</span>\n            <span>// 2.2检查线程池状态，倘若线程池处于中断状态，当前线程将中断。 </span>\n            <span>if</span> <span>(</span><span>(</span><span>runStateAtLeast</span><span>(</span>ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>,</span> STOP<span>)</span> <span>||</span>\n                 <span>(</span><span>Thread</span><span>.</span><span>interrupted</span><span>(</span><span>)</span> <span>&amp;&amp;</span>\n                  <span>runStateAtLeast</span><span>(</span>ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>,</span> STOP<span>)</span><span>)</span><span>)</span> <span>&amp;&amp;</span>\n                <span>!</span>wt<span>.</span><span>isInterrupted</span><span>(</span><span>)</span><span>)</span>\n                wt<span>.</span><span>interrupt</span><span>(</span><span>)</span><span>;</span>\n            <span>try</span> <span>{</span>\n                <span>// 2.3执行beforeExecute </span>\n                <span>beforeExecute</span><span>(</span>wt<span>,</span> task<span>)</span><span>;</span>\n                <span>Throwable</span> thrown <span>=</span> <span>null</span><span>;</span>\n                <span>try</span> <span>{</span>\n                    <span>// 2.4执行任务</span>\n                    task<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>RuntimeException</span> x<span>)</span> <span>{</span>\n                    thrown <span>=</span> x<span>;</span> <span>throw</span> x<span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>Error</span> x<span>)</span> <span>{</span>\n                    thrown <span>=</span> x<span>;</span> <span>throw</span> x<span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> x<span>)</span> <span>{</span>\n                    thrown <span>=</span> x<span>;</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span>x<span>)</span><span>;</span>\n                <span>}</span> <span>finally</span> <span>{</span>\n                    <span>// 2.5执行afterExecute方法 </span>\n                    <span>afterExecute</span><span>(</span>task<span>,</span> thrown<span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span> <span>finally</span> <span>{</span>\n                task <span>=</span> <span>null</span><span>;</span>\n                w<span>.</span>completedTasks<span>++</span><span>;</span>\n                <span>// 2.6解锁操作</span>\n                w<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        completedAbruptly <span>=</span> <span>false</span><span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        <span>processWorkerExit</span><span>(</span>w<span>,</span> completedAbruptly<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><p>首先去执行创建这个worker时就有的任务，当执行完这个任务后，worker的生命周期并没有结束，在<code>while</code>循环中，worker会不断地调用<code>getTask</code>方法从<strong>阻塞队列</strong>中获取任务然后调用<code>task.run()</code>执行任务,从而达到<strong>复用线程</strong>的目的。只要<code>getTask</code>方法不返回<code>null</code>,此线程就不会退出。</p>\n<p>当然，核心线程池中创建的线程想要拿到阻塞队列中的任务，先要判断线程池的状态，如果<strong>STOP</strong>或者<strong>TERMINATED</strong>，返回<code>null</code>。</p>\n<p>最后看看<code>getTask</code>方法的实现:</p>\n<div><pre><code><span>// Worker.getTask方法源码</span>\n<span>private</span> <span>Runnable</span> <span>getTask</span><span>(</span><span>)</span> <span>{</span>\n    <span>boolean</span> timedOut <span>=</span> <span>false</span><span>;</span> <span>// Did the last poll() time out?</span>\n\n    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n        <span>int</span> c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> rs <span>=</span> <span>runStateOf</span><span>(</span>c<span>)</span><span>;</span>\n\n        <span>// Check if queue empty only if necessary.</span>\n        <span>if</span> <span>(</span>rs <span>>=</span> SHUTDOWN <span>&amp;&amp;</span> <span>(</span>rs <span>>=</span> STOP <span>||</span> workQueue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            <span>decrementWorkerCount</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>}</span>\n\n        <span>int</span> wc <span>=</span> <span>workerCountOf</span><span>(</span>c<span>)</span><span>;</span>\n\n        <span>// Are workers subject to culling?</span>\n        <span>// 1.allowCoreThreadTimeOut变量默认是false,核心线程即使空闲也不会被销毁</span>\n        <span>// 如果为true,核心线程在keepAliveTime内仍空闲则会被销毁。 </span>\n        <span>boolean</span> timed <span>=</span> allowCoreThreadTimeOut <span>||</span> wc <span>></span> corePoolSize<span>;</span>\n        <span>// 2.如果运行线程数超过了最大线程数，但是缓存队列已经空了，这时递减worker数量。 </span>\n　　　　 <span>// 如果有设置允许线程超时或者线程数量超过了核心线程数量，</span>\n        <span>// 并且线程在规定时间内均未poll到任务且队列为空则递减worker数量</span>\n        <span>if</span> <span>(</span><span>(</span>wc <span>></span> maximumPoolSize <span>||</span> <span>(</span>timed <span>&amp;&amp;</span> timedOut<span>)</span><span>)</span>\n            <span>&amp;&amp;</span> <span>(</span>wc <span>></span> <span>1</span> <span>||</span> workQueue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span><span>compareAndDecrementWorkerCount</span><span>(</span>c<span>)</span><span>)</span>\n                <span>return</span> <span>null</span><span>;</span>\n            <span>continue</span><span>;</span>\n        <span>}</span>\n\n        <span>try</span> <span>{</span>\n            <span>// 3.如果timed为true(想想哪些情况下timed为true),则会调用workQueue的poll方法获取任务.</span>\n            <span>// 超时时间是keepAliveTime。如果超过keepAliveTime时长，</span>\n            <span>// poll返回了null，上边提到的while循序就会退出，线程也就执行完了。</span>\n            <span>// 如果timed为false（allowCoreThreadTimeOut为falsefalse</span>\n            <span>// 且wc > corePoolSize为false），则会调用workQueue的take方法阻塞在当前。</span>\n            <span>// 队列中有任务加入时，线程被唤醒，take方法返回任务，并执行。</span>\n            <span>Runnable</span> r <span>=</span> timed <span>?</span>\n                workQueue<span>.</span><span>poll</span><span>(</span>keepAliveTime<span>,</span> <span>TimeUnit</span><span>.</span>NANOSECONDS<span>)</span> <span>:</span>\n                workQueue<span>.</span><span>take</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>r <span>!=</span> <span>null</span><span>)</span>\n                <span>return</span> r<span>;</span>\n            timedOut <span>=</span> <span>true</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> retry<span>)</span> <span>{</span>\n            timedOut <span>=</span> <span>false</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><p>核心线程的会一直卡在<code>workQueue.take</code>方法，被阻塞并挂起，不会占用CPU资源，直到拿到<code>Runnable</code> 然后返回（当然如果<strong>allowCoreThreadTimeOut</strong>设置为<code>true</code>,那么核心线程就会去调用<code>poll</code>方法，因为<code>poll</code>可能会返回<code>null</code>,所以这时候核心线程满足超时条件也会被销毁）。</p>\n<p>非核心线程会workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) ，如果超时还没有拿到，下一次循环判断<strong>compareAndDecrementWorkerCount</strong>就会返回<code>null</code>,Worker对象的<code>run()</code>方法循环体的判断为<code>null</code>,任务结束，然后线程被系统回收 。</p>\n<p>源码解析完毕，你理解的源码是否和图中的处理流程一致？如果不一致，那么就多看两遍吧，加油。</p>\n<h4 id=\"_12-3-四种常见的线程池\"> <strong>12.3 四种常见的线程池</strong></h4>\n<p><code>Executors</code>类中提供的几个静态方法来创建线程池。大家到了这一步，如果看懂了前面讲的<code>ThreadPoolExecutor</code>构造方法中各种参数的意义，那么一看到<code>Executors</code>类中提供的线程池的源码就应该知道这个线程池是干嘛的。</p>\n<h5 id=\"_12-3-1-newcachedthreadpool\"> <strong>12.3.1 newCachedThreadPool</strong></h5>\n<div><pre><code><span>public</span> <span>static</span> <span>ExecutorService</span> <span>newCachedThreadPool</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>0</span><span>,</span> <span>Integer</span><span>.</span>MAX_VALUE<span>,</span>\n                                  <span>60L</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span>\n                                  <span>new</span> <span>SynchronousQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>CacheThreadPool</code>的<strong>运行流程</strong>如下：</p>\n<ol>\n<li>提交任务进线程池。</li>\n<li>因为<strong>corePoolSize</strong>为0的关系，不创建核心线程，线程池最大为Integer.MAX_VALUE。</li>\n<li>尝试将任务添加到<strong>SynchronousQueue</strong>队列。</li>\n<li>如果SynchronousQueue入列成功，等待被当前运行的线程空闲后拉取执行。如果当前没有空闲线程，那么就创建一个非核心线程，然后从SynchronousQueue拉取任务并在当前线程执行。</li>\n<li>如果SynchronousQueue已有任务在等待，入列操作将会阻塞。</li>\n</ol>\n<p>当需要执行很多<strong>短时间</strong>的任务时，CacheThreadPool的线程复用率比较高， 会显著的<strong>提高性能</strong>。而且线程60s后会回收，意味着即使没有任务进来，CacheThreadPool并不会占用很多资源。</p>\n<h5 id=\"_12-3-2-newfixedthreadpool\"> <strong>12.3.2 newFixedThreadPool</strong></h5>\n<div><pre><code><span>public</span> <span>static</span> <span>ExecutorService</span> <span>newFixedThreadPool</span><span>(</span><span>int</span> nThreads<span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>nThreads<span>,</span> nThreads<span>,</span>\n                                      <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>\n                                      <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>核心线程数量和总线程数量相等，都是传入的参数nThreads，所以只能创建核心线程，不能创建非核心线程。因为LinkedBlockingQueue的默认大小是Integer.MAX_VALUE，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。</p>\n<p><strong>与CachedThreadPool的区别</strong>：</p>\n<ul>\n<li>因为 corePoolSize == maximumPoolSize ，所以FixedThreadPool只会创建核心线程。 而CachedThreadPool因为corePoolSize=0，所以只会创建非核心线程。</li>\n<li>在 getTask() 方法，如果队列里没有任务可取，线程会一直阻塞在 LinkedBlockingQueue.take() ，线程不会被回收。 CachedThreadPool会在60s后收回。</li>\n<li>由于线程不会被回收，会一直卡在阻塞，所以<strong>没有任务的情况下， FixedThreadPool占用资源更多</strong>。</li>\n<li>都几乎不会触发拒绝策略，但是原理不同。FixedThreadPool是因为阻塞队列可以很大（最大为Integer最大值），故几乎不会触发拒绝策略；CachedThreadPool是因为线程池很大（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。</li>\n</ul>\n<h5 id=\"_12-3-3-newsinglethreadexecutor\"> <strong>12.3.3 newSingleThreadExecutor</strong></h5>\n<div><pre><code><span>public</span> <span>static</span> <span>ExecutorService</span> <span>newSingleThreadExecutor</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>new</span> <span>FinalizableDelegatedExecutorService</span>\n        <span>(</span><span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span>\n                                <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>\n                                <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>有且仅有一个核心线程（ corePoolSize == maximumPoolSize=1），使用了LinkedBlockingQueue（容量很大），所以，<strong>不会创建非核心线程</strong>。所有任务按照<strong>先来先执行</strong>的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。</p>\n<h5 id=\"_12-3-4-newscheduledthreadpool\"> <strong>12.3.4 newScheduledThreadPool</strong></h5>\n<p>创建一个定长线程池，支持定时及周期性任务执行。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>ScheduledExecutorService</span> <span>newScheduledThreadPool</span><span>(</span><span>int</span> corePoolSize<span>)</span> <span>{</span>\n    <span>return</span> <span>new</span> <span>ScheduledThreadPoolExecutor</span><span>(</span>corePoolSize<span>)</span><span>;</span>\n<span>}</span>\n\n<span>//ScheduledThreadPoolExecutor():</span>\n<span>public</span> <span>ScheduledThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>)</span> <span>{</span>\n    <span>super</span><span>(</span>corePoolSize<span>,</span> <span>Integer</span><span>.</span>MAX_VALUE<span>,</span>\n          DEFAULT_KEEPALIVE_MILLIS<span>,</span> MILLISECONDS<span>,</span>\n          <span>new</span> <span>DelayedWorkQueue</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>四种常见的线程池基本够我们使用了，但是《阿里把把开发手册》不建议我们直接使用Executors类中的线程池，而是通过<code>ThreadPoolExecutor</code>的方式，这样的处理方式让写的同学需要更加明确线程池的运行规则，规避资源耗尽的风险。</p>\n<p>但如果你及团队本身对线程池非常熟悉，又确定业务规模不会大到资源耗尽的程度（比如线程数量或任务队列长度可能达到Integer.MAX_VALUE）时，其实是可以使用JDK提供的这几个接口的，它能让我们的代码具有更强的可读性。</p>\n<h3 id=\"_13-阻塞队列\"> 13 阻塞队列</h3>\n<h4 id=\"_13-1-阻塞队列的由来\"> <strong>13.1 阻塞队列的由来</strong></h4>\n<p>我们假设一种场景，生产者一直生产资源，消费者一直消费资源，资源存储在一个缓冲池中，生产者将生产的资源存进缓冲池中，消费者从缓冲池中拿到资源进行消费，这就是大名鼎鼎的<strong>生产者-消费者模式</strong>。</p>\n<p>该模式能够简化开发过程，一方面消除了生产者类与消费者类之间的代码依赖性，另一方面将生产数据的过程与使用数据的过程解耦简化负载。</p>\n<p>我们自己coding实现这个模式的时候，因为需要让<strong>多个线程操作共享变量</strong>（即资源），所以很容易引发<strong>线程安全问题</strong>，造成<strong>重复消费</strong>和<strong>死锁</strong>，尤其是生产者和消费者存在多个的情况。另外，当缓冲池空了，我们需要阻塞消费者，唤醒生产者；当缓冲池满了，我们需要阻塞生产者，唤醒消费者，这些个<strong>等待-唤醒</strong>逻辑都需要自己实现。（这块不明白的同学，可以看最下方结语部分的链接）</p>\n<p>这么容易出错的事情，JDK当然帮我们做啦，这就是阻塞队列(BlockingQueue)，<strong>你只管往里面存、取就行，而不用担心多线程环境下存、取共享变量的线程安全问题。</strong></p>\n<blockquote>\n<p>BlockingQueue是Java util.concurrent包下重要的数据结构，区别于普通的队列，BlockingQueue提供了<strong>线程安全的队列访问方式</strong>，并发包下很多高级同步类的实现都是基于BlockingQueue实现的。</p>\n</blockquote>\n<p>BlockingQueue一般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。<strong>BlockingQueue就是存放元素的容器</strong>。</p>\n<h4 id=\"_13-2-blockingqueue的操作方法\"> <strong>13.2 BlockingQueue的操作方法</strong></h4>\n<p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p>\n<table>\n<thead>\n<tr>\n<th>方法\\处理方式</th>\n<th>抛出异常</th>\n<th>返回特殊值</th>\n<th>一直阻塞</th>\n<th>超时退出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>插入方法</td>\n<td>add(e)</td>\n<td>offer(e)</td>\n<td><strong>put(e)</strong></td>\n<td>offer(e,time,unit)</td>\n</tr>\n<tr>\n<td>移除方法</td>\n<td>remove()</td>\n<td>poll()</td>\n<td><strong>take()</strong></td>\n<td>poll(time,unit)</td>\n</tr>\n<tr>\n<td>检查方法</td>\n<td>element()</td>\n<td>peek()</td>\n<td>-</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>抛出异常：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li>\n<li>返回特殊值：如果试图的操作无法立即执行，返回一个特殊值，通常是true / false。</li>\n<li>一直阻塞：如果试图的操作无法立即执行，则一直阻塞或者响应中断。</li>\n<li>超时退出：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 true / false。</li>\n</ul>\n<p><strong>注意之处</strong></p>\n<ul>\n<li>不能往阻塞队列中插入null,会抛出空指针异常。</li>\n<li>可以访问阻塞队列中的任意元素，调用remove(o)可以将队列之中的特定对象移除，但并不高效，尽量避免使用。</li>\n</ul>\n<h4 id=\"_13-3-blockingqueue的实现类\"> <strong>13.3 BlockingQueue的实现类</strong></h4>\n<h5 id=\"_13-3-1-arrayblockingqueue\"> <strong>13.3.1 ArrayBlockingQueue</strong></h5>\n<p>由<strong>数组</strong>结构组成的<strong>有界</strong>阻塞队列。内部结构是数组，故具有数组的特性。</p>\n<div><pre><code><span>public</span> <span>ArrayBlockingQueue</span><span>(</span><span>int</span> capacity<span>,</span> <span>boolean</span> fair<span>)</span><span>{</span>\n    <span>//..省略代码</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以初始化队列大小， 且一旦初始化不能改变。构造方法中的fair表示控制对象的内部锁是否采用公平锁，默认是<strong>非公平锁</strong>。</p>\n<h5 id=\"_13-3-2-linkedblockingqueue\"> <strong>13.3.2 LinkedBlockingQueue</strong></h5>\n<p>由<strong>链表</strong>结构组成的<strong>有界</strong>阻塞队列。内部结构是链表，具有链表的特性。默认队列的大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。此队列按照<strong>先进先出</strong>的原则对元素进行排序。</p>\n<h5 id=\"_13-3-3-delayqueue\"> <strong>13.3.3 DelayQueue</strong></h5>\n<div><pre><code>该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。 \n\nDelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。 \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h5 id=\"_13-3-4-priorityblockingqueue\"> <strong>13.3.4 PriorityBlockingQueue</strong></h5>\n<div><pre><code>基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），内部控制线程同步的锁采用的是公平锁。\n</code></pre>\n<div><span>1</span><br></div></div><h5 id=\"_13-3-5-synchronousqueue\"> <strong>13.3.5 SynchronousQueue</strong></h5>\n<p>这个队列比较特殊，<strong>没有任何内部容量</strong>，甚至连一个队列的容量都没有。并且每个 put 必须等待一个 take，反之亦然。</p>\n<p>需要区别容量为1的ArrayBlockingQueue、LinkedBlockingQueue。</p>\n<p>以下方法的返回值，可以帮助理解这个队列：</p>\n<ul>\n<li>iterator() 永远返回空，因为里面没有东西</li>\n<li>peek() 永远返回null</li>\n<li>put() 往queue放进去一个element以后就一直wait直到有其他thread进来把这个element取走。</li>\n<li>offer() 往queue里放一个element后立即返回，如果碰巧这个element被另一个thread取走了，offer方法返回true，认为offer成功；否则返回false。</li>\n<li>take() 取出并且remove掉queue里的element，取不到东西他会一直等。</li>\n<li>poll() 取出并且remove掉queue里的element，只有到碰巧另外一个线程正在往queue里offer数据或者put数据的时候，该方法才会取到东西。否则立即返回null。</li>\n<li>isEmpty() 永远返回true</li>\n<li>remove()&amp;removeAll() 永远返回false</li>\n</ul>\n<p><strong>注意</strong></p>\n<p><strong>PriorityBlockingQueue</strong>不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，<strong>生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。<strong>对于使用默认大小的</strong>LinkedBlockingQueue</strong>也是一样的。</p>\n<h4 id=\"_13-5-阻塞队列的原理\"> <strong>13.5 阻塞队列的原理</strong></h4>\n<p>阻塞队列的原理很简单，利用了Lock锁的多条件（Condition）阻塞控制。接下来我们分析ArrayBlockingQueue JDK 1.8 的源码。</p>\n<p>首先是构造器，除了初始化队列的大小和是否是公平锁之外，还对同一个锁（lock）初始化了两个监视器，分别是notEmpty和notFull。这两个监视器的作用目前可以简单理解为标记分组，当该线程是put操作时，给他加上监视器notFull,标记这个线程是一个生产者；当线程是take操作时，给他加上监视器notEmpty，标记这个线程是消费者。</p>\n<div><pre><code><span>//数据元素数组</span>\n<span>final</span> <span>Object</span><span>[</span><span>]</span> items<span>;</span>\n<span>//下一个待取出元素索引</span>\n<span>int</span> takeIndex<span>;</span>\n<span>//下一个待添加元素索引</span>\n<span>int</span> putIndex<span>;</span>\n<span>//元素个数</span>\n<span>int</span> count<span>;</span>\n<span>//内部锁</span>\n<span>final</span> <span>ReentrantLock</span> lock<span>;</span>\n<span>//消费者监视器</span>\n<span>private</span> <span>final</span> <span>Condition</span> notEmpty<span>;</span>\n<span>//生产者监视器</span>\n<span>private</span> <span>final</span> <span>Condition</span> notFull<span>;</span>  \n\n<span>public</span> <span>ArrayBlockingQueue</span><span>(</span><span>int</span> capacity<span>,</span> <span>boolean</span> fair<span>)</span> <span>{</span>\n    <span>//..省略其他代码</span>\n    lock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span>fair<span>)</span><span>;</span>\n    notEmpty <span>=</span> lock<span>.</span><span>newCondition</span><span>(</span><span>)</span><span>;</span>\n    notFull <span>=</span>  lock<span>.</span><span>newCondition</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p><strong>put操作的源码</strong></p>\n<div><pre><code><span>public</span> <span>void</span> <span>put</span><span>(</span><span>E</span> e<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n    <span>checkNotNull</span><span>(</span>e<span>)</span><span>;</span>\n    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>\n    <span>// 1.自旋拿锁</span>\n    lock<span>.</span><span>lockInterruptibly</span><span>(</span><span>)</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>// 2.判断队列是否满了</span>\n        <span>while</span> <span>(</span>count <span>==</span> items<span>.</span>length<span>)</span>\n            <span>// 2.1如果满了，阻塞该线程，并标记为notFull线程，</span>\n            <span>// 等待notFull的唤醒，唤醒之后继续执行while循环。</span>\n            notFull<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n        <span>// 3.如果没有满，则进入队列</span>\n        <span>enqueue</span><span>(</span>e<span>)</span><span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>private</span> <span>void</span> <span>enqueue</span><span>(</span><span>E</span> x<span>)</span> <span>{</span>\n    <span>// assert lock.getHoldCount() == 1;</span>\n    <span>// assert items[putIndex] == null;</span>\n    <span>final</span> <span>Object</span><span>[</span><span>]</span> items <span>=</span> <span>this</span><span>.</span>items<span>;</span>\n    items<span>[</span>putIndex<span>]</span> <span>=</span> x<span>;</span>\n    <span>if</span> <span>(</span><span>++</span>putIndex <span>==</span> items<span>.</span>length<span>)</span>\n        putIndex <span>=</span> <span>0</span><span>;</span>\n    count<span>++</span><span>;</span>\n    <span>// 4 唤醒一个等待的线程</span>\n    notEmpty<span>.</span><span>signal</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>总结put的流程：</p>\n<ol>\n<li>所有执行put操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</li>\n<li>判断阻塞队列是否满了，如果满了，则调用await方法阻塞这个线程，并标记为notFull（生产者）线程，同时释放lock锁,等待被消费者线程唤醒。</li>\n<li>如果没有满，则调用enqueue方法将元素put进阻塞队列。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</li>\n<li>唤醒一个标记为notEmpty（消费者）的线程。</li>\n</ol>\n<p><strong>take操作的源码</strong></p>\n<div><pre><code><span>public</span> <span>E</span> <span>take</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>\n    lock<span>.</span><span>lockInterruptibly</span><span>(</span><span>)</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>while</span> <span>(</span>count <span>==</span> <span>0</span><span>)</span>\n            notEmpty<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> <span>dequeue</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>private</span> <span>E</span> <span>dequeue</span><span>(</span><span>)</span> <span>{</span>\n    <span>// assert lock.getHoldCount() == 1;</span>\n    <span>// assert items[takeIndex] != null;</span>\n    <span>final</span> <span>Object</span><span>[</span><span>]</span> items <span>=</span> <span>this</span><span>.</span>items<span>;</span>\n    <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n    <span>E</span> x <span>=</span> <span>(</span><span>E</span><span>)</span> items<span>[</span>takeIndex<span>]</span><span>;</span>\n    items<span>[</span>takeIndex<span>]</span> <span>=</span> <span>null</span><span>;</span>\n    <span>if</span> <span>(</span><span>++</span>takeIndex <span>==</span> items<span>.</span>length<span>)</span>\n        takeIndex <span>=</span> <span>0</span><span>;</span>\n    count<span>--</span><span>;</span>\n    <span>if</span> <span>(</span>itrs <span>!=</span> <span>null</span><span>)</span>\n        itrs<span>.</span><span>elementDequeued</span><span>(</span><span>)</span><span>;</span>\n    notFull<span>.</span><span>signal</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> x<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>take操作和put操作的流程是类似的，总结一下take操作的流程：</p>\n<ol>\n<li>所有执行take操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</li>\n<li>判断阻塞队列是否为空，如果是空，则调用await方法阻塞这个线程，并标记为notEmpty（消费者）线程，同时释放lock锁,等待被生产者线程唤醒。</li>\n<li>如果没有空，则调用dequeue方法。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</li>\n<li>唤醒一个标记为notFull（生产者）的线程。</li>\n</ol>\n<p><strong>注意</strong></p>\n<ol>\n<li>put和tack操作都需要<strong>先获取锁</strong>，没有获取到锁的线程会被挡在第一道大门之外自旋拿锁，直到获取到锁。</li>\n<li>就算拿到锁了之后，也<strong>不一定</strong>会顺利进行put/take操作，需要判断<strong>队列是否可用</strong>（是否满/空），如果不可用，则会被阻塞，<strong>并释放锁</strong>。</li>\n<li>在第2点被阻塞的线程会被唤醒，但是在唤醒之后，<strong>依然需要拿到锁</strong>才能继续往下执行，否则，自旋拿锁，拿到锁了再while判断队列是否可用（这也是为什么不用if判断，而使用while判断的原因）。</li>\n</ol>\n<h4 id=\"_13-6-示例和使用场景\"> <strong>13.6 示例和使用场景</strong></h4>\n<h5 id=\"_13-6-1-生产者-消费者模型\"> <strong>13.6.1 生产者-消费者模型</strong></h5>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n    <span>private</span> <span>int</span> queueSize <span>=</span> <span>10</span><span>;</span>\n    <span>private</span> <span>ArrayBlockingQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> queue <span>=</span> <span>new</span> <span>ArrayBlockingQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span>queueSize<span>)</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span>  <span>{</span>\n        <span>Test</span> test <span>=</span> <span>new</span> <span>Test</span><span>(</span><span>)</span><span>;</span>\n        <span>Producer</span> producer <span>=</span> test<span>.</span><span>new</span> <span>Producer</span><span>(</span><span>)</span><span>;</span>\n        <span>Consumer</span> consumer <span>=</span> test<span>.</span><span>new</span> <span>Consumer</span><span>(</span><span>)</span><span>;</span>\n\n        producer<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        consumer<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>class</span> <span>Consumer</span> <span>extends</span> <span>Thread</span><span>{</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>consume</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>private</span> <span>void</span> <span>consume</span><span>(</span><span>)</span> <span>{</span>\n            <span>while</span><span>(</span><span>true</span><span>)</span><span>{</span>\n                <span>try</span> <span>{</span>\n                    queue<span>.</span><span>take</span><span>(</span><span>)</span><span>;</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"从队列取走一个元素，队列剩余\"</span><span>+</span>queue<span>.</span><span>size</span><span>(</span><span>)</span><span>+</span><span>\"个元素\"</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>class</span> <span>Producer</span> <span>extends</span> <span>Thread</span><span>{</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>produce</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>private</span> <span>void</span> <span>produce</span><span>(</span><span>)</span> <span>{</span>\n            <span>while</span><span>(</span><span>true</span><span>)</span><span>{</span>\n                <span>try</span> <span>{</span>\n                    queue<span>.</span><span>put</span><span>(</span><span>1</span><span>)</span><span>;</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"向队列取中插入一个元素，队列剩余空间：\"</span><span>+</span><span>(</span>queueSize<span>-</span>queue<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><p>下面是这个例子的输出片段：</p>\n<div><pre><code>从队列取走一个元素，队列剩余<span>0</span>个元素\n从队列取走一个元素，队列剩余<span>0</span>个元素\n向队列取中插入一个元素，队列剩余空间：<span>9</span>\n向队列取中插入一个元素，队列剩余空间：<span>9</span>\n向队列取中插入一个元素，队列剩余空间：<span>9</span>\n向队列取中插入一个元素，队列剩余空间：<span>8</span>\n向队列取中插入一个元素，队列剩余空间：<span>7</span>\n向队列取中插入一个元素，队列剩余空间：<span>6</span>\n向队列取中插入一个元素，队列剩余空间：<span>5</span>\n向队列取中插入一个元素，队列剩余空间：<span>4</span>\n向队列取中插入一个元素，队列剩余空间：<span>3</span>\n向队列取中插入一个元素，队列剩余空间：<span>2</span>\n向队列取中插入一个元素，队列剩余空间：<span>1</span>\n向队列取中插入一个元素，队列剩余空间：<span>0</span>\n从队列取走一个元素，队列剩余<span>1</span>个元素\n从队列取走一个元素，队列剩余<span>9</span>个元素\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>注意，这个例子中的输出结果看起来可能有问题，比如有几行在插入一个元素之后，队列的剩余空间不变。这是由于<strong>System.out.println语句没有锁</strong>。考虑到这样的情况：线程1在执行完put/take操作后立即失去CPU时间片，然后切换到线程2执行put/take操作，执行完毕后回到线程1的System.out.println语句并输出，发现这个时候阻塞队列的size已经被线程2改变了，所以这个时候输出的size并不是当时线程1执行完put/take操作之后阻塞队列的size，但可以确保的是size不会超过10个。实际上使用阻塞队列是没有问题的。</p>\n<h5 id=\"_13-6-2-线程池中使用阻塞队列\"> <strong>13.6.2 线程池中使用阻塞队列</strong></h5>\n<div><pre><code> <span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>\n                           <span>int</span> maximumPoolSize<span>,</span>\n                           <span>long</span> keepAliveTime<span>,</span>\n                           <span>TimeUnit</span> unit<span>,</span>\n                           <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>)</span> <span>{</span>\n        <span>this</span><span>(</span>corePoolSize<span>,</span> maximumPoolSize<span>,</span> keepAliveTime<span>,</span> unit<span>,</span> workQueue<span>,</span>\n             <span>Executors</span><span>.</span><span>defaultThreadFactory</span><span>(</span><span>)</span><span>,</span> defaultHandler<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>Java中的线程池就是使用阻塞队列实现的，我们在了解阻塞队列之后，无论是使用Exectors类中已经提供的线程池，还是自己通过ThreadPoolExecutor实现线程池，都会更加得心应手，想要了解线程池的同学，可以看<a href=\"https://github.com/yasinshaw/concurrent/tree/c0f458769a889c236292ec0e20e376aae9aee21b/article/03/12.html\" target=\"_blank\" rel=\"noopener noreferrer\">第十二站</a>：线程池原理。</p>\n<blockquote>\n<p>注：上面提到了生产者-消费者模式，大家可以参考<a href=\"http://note.youdao.com/noteshare?id=b4babef5d090f87cea8a97632f380c00\" target=\"_blank\" rel=\"noopener noreferrer\">生产者-消费者模型</a>，可以更好的理解阻塞队列。</p>\n</blockquote>\n<h3 id=\"_14-锁接口和类\"> 14 锁接口和类</h3>\n<p>前面我们介绍了Java原生的锁——基于对象的锁，它一般是配合synchronized关键字来使用的。实际上，Java在<code>java.util.concurrent.locks</code>包下，还为我们提供了几个关于锁的类和接口。它们有更强大的功能或更高的性能。</p>\n<h4 id=\"_14-1-synchronized的不足之处\"> <strong>14.1 synchronized的不足之处</strong></h4>\n<p>我们先来看看<code>synchronized</code>有什么不足之处。</p>\n<ul>\n<li>如果临界区是只读操作，其实可以多线程一起执行，但使用synchronized的话，<strong>同一时间只能有一个线程执行</strong>。</li>\n<li>synchronized无法知道线程有没有成功获取到锁</li>\n<li>使用synchronized，如果临界区因为IO或者sleep方法等原因阻塞了，而当前线程又没有释放锁，就会导致<strong>所有线程等待</strong>。</li>\n</ul>\n<p>而这些都是locks包下的锁可以解决的。</p>\n<h4 id=\"_14-2-锁的几种分类\"> <strong>14.2 锁的几种分类</strong></h4>\n<p>锁可以根据以下几种方式来进行分类，下面我们逐一介绍。</p>\n<h5 id=\"_14-2-1-可重入锁和非可重入锁\"> <strong>14.2.1 可重入锁和非可重入锁</strong></h5>\n<p>所谓重入锁，顾名思义。就是支持重新进入的锁，也就是说这个锁支持一个<strong>线程对资源重复加锁</strong>。</p>\n<p>synchronized关键字就是使用的重入锁。比如说，你在一个synchronized实例方法里面调用另一个本实例的synchronized实例方法，它可以重新进入这个锁，不会出现任何异常。</p>\n<p>如果我们自己在继承AQS实现同步器的时候，没有考虑到占有锁的线程再次获取锁的场景，可能就会导致线程阻塞，那这个就是一个“非可重入锁”。</p>\n<p><code>ReentrantLock</code>的中文意思就是可重入锁。也说本文后续要介绍的重点类。</p>\n<h5 id=\"_14-2-2-公平锁与非公平锁\"> <strong>14.2.2 公平锁与非公平锁</strong></h5>\n<p>这里的“公平”，其实通俗意义来说就是“先来后到”，也就是FIFO。如果对一个锁来说，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足，那这个锁就是公平的。反之，那就是不公平的。</p>\n<p>一般情况下，<strong>非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况</strong>。所以要根据实际的需求来选择非公平锁和公平锁。</p>\n<p>ReentrantLock支持非公平锁和公平锁两种。</p>\n<h5 id=\"_14-2-3-读写锁和排它锁\"> <strong>14.2.3 读写锁和排它锁</strong></h5>\n<p>我们前面讲到的synchronized用的锁和ReentrantLock，其实都是“排它锁”。也就是说，这些锁在同一时刻只允许一个线程进行访问。</p>\n<p>而读写锁可以再同一时刻允许多个读线程访问。Java提供了ReentrantReadWriteLock类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。</p>\n<blockquote>\n<p>注意，即使用读写锁，在写线程访问时，所有的读线程和其它写线程均被阻塞。</p>\n</blockquote>\n<p><strong>可见，只是synchronized是远远不能满足多样化的业务对锁的要求的</strong>。接下来我们介绍一下JDK中有关锁的一些接口和类。</p>\n<h4 id=\"_14-3-jdk中有关锁的一些接口和类\"> <strong>14.3 JDK中有关锁的一些接口和类</strong></h4>\n<p>众所周知，JDK中关于并发的类大多都在<code>java.util.concurrent</code>（以下简称juc）包下。而juc.locks包看名字就知道，是提供了一些并发锁的工具类的。前面我们介绍的AQS（AbstractQueuedSynchronizer）就是在这个包下。下面分别介绍一下这个包下的类和接口以及它们之间的关系。</p>\n<h5 id=\"_14-3-1-抽象类aqs-aqls-aos\"> <strong>14.3.1 抽象类AQS/AQLS/AOS</strong></h5>\n<p>这三个抽象类有一定的关系，所以这里放到一起讲。</p>\n<p>首先我们看<strong>AQS</strong>（AbstractQueuedSynchronizer），之前专门有章节介绍这个类，它是在JDK 1.5 发布的，提供了一个“队列同步器”的基本功能实现。而AQS里面的“资源”是用一个<code>int</code>类型的数据来表示的，有时候我们的业务需求资源的数量超出了<code>int</code>的范围，所以在JDK 1.6 中，多了一个<strong>AQLS</strong>（AbstractQueuedLongSynchronizer）。它的代码跟AQS几乎一样，只是把资源的类型变成了<code>long</code>类型。</p>\n<p>AQS和AQLS都继承了一个类叫<strong>AOS</strong>（AbstractOwnableSynchronizer）。这个类也是在JDK 1.6 中出现的。这个类只有几行简单的代码。从源码类上的注释可以知道，它是用于表示锁与持有者之间的关系（独占模式）。可以看一下它的主要方法：</p>\n<div><pre><code><span>// 独占模式，锁的持有者  </span>\n<span>private</span> <span>transient</span> <span>Thread</span> exclusiveOwnerThread<span>;</span>  \n\n<span>// 设置锁持有者  </span>\n<span>protected</span> <span>final</span> <span>void</span> <span>setExclusiveOwnerThread</span><span>(</span><span>Thread</span> t<span>)</span> <span>{</span>  \n    exclusiveOwnerThread <span>=</span> t<span>;</span>  \n<span>}</span>  \n\n<span>// 获取锁的持有线程  </span>\n<span>protected</span> <span>final</span> <span>Thread</span> <span>getExclusiveOwnerThread</span><span>(</span><span>)</span> <span>{</span>  \n    <span>return</span> exclusiveOwnerThread<span>;</span>  \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h5 id=\"_14-3-2-接口condition-lock-readwritelock\"> <strong>14.3.2 接口Condition/Lock/ReadWriteLock</strong></h5>\n<p>juc.locks包下共有三个接口：<code>Condition</code>、<code>Lock</code>、<code>ReadWriteLock</code>。其中，Lock和ReadWriteLock从名字就可以看得出来，分别是锁和读写锁的意思。Lock接口里面有一些获取锁和释放锁的方法声明，而ReadWriteLock里面只有两个方法，分别返回“读锁”和“写锁”：</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ReadWriteLock</span> <span>{</span>\n    <span>Lock</span> <span>readLock</span><span>(</span><span>)</span><span>;</span>\n    <span>Lock</span> <span>writeLock</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Lock接口中有一个方法是可以获得一个<code>Condition</code>:</p>\n<div><pre><code><span>Condition</span> <span>newCondition</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>之前我们提到了每个对象都可以用继承自<code>Object</code>的<strong>wait/notify</strong>方法来实现<strong>等待/通知机制</strong>。而Condition接口也提供了类似Object监视器的方法，通过与<strong>Lock</strong>配合来实现等待/通知模式。</p>\n<p>那为什么既然有Object的监视器方法了，还要用Condition呢？这里有一个二者简单的对比：</p>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>Object监视器</th>\n<th>Condition</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>前置条件</td>\n<td>获取对象的锁</td>\n<td>调用Lock.lock获取锁，调用Lock.newCondition获取Condition对象</td>\n</tr>\n<tr>\n<td>调用方式</td>\n<td>直接调用，比如object.notify()</td>\n<td>直接调用，比如condition.await()</td>\n</tr>\n<tr>\n<td>等待队列的个数</td>\n<td>一个</td>\n<td>多个</td>\n</tr>\n<tr>\n<td>当前线程释放锁进入等待状态</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>当前线程释放锁进入等待状态，在等待状态中不中断</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>当前线程释放锁并进入超时等待状态</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>当前线程释放锁并进入等待状态直到将来的某个时间</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>唤醒等待队列中的一个线程</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>唤醒等待队列中的全部线程</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n</tbody>\n</table>\n<p>Condition和Object的wait/notify基本相似。其中，Condition的await方法对应的是Object的wait方法，而Condition的<strong>signal/signalAll</strong>方法则对应Object的notify/notifyAll()。但Condition类似于Object的等待/通知机制的加强版。我们来看看主要的方法：</p>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>await()</td>\n<td>当前线程进入等待状态直到被通知（signal）或者中断；当前线程进入运行状态并从await()方法返回的场景包括：（1）其他线程调用相同Condition对象的signal/signalAll方法，并且当前线程被唤醒；（2）其他线程调用interrupt方法中断当前线程；</td>\n</tr>\n<tr>\n<td>awaitUninterruptibly()</td>\n<td>当前线程进入等待状态直到被通知，在此过程中对中断信号不敏感，不支持中断当前线程</td>\n</tr>\n<tr>\n<td>awaitNanos(long)</td>\n<td>当前线程进入等待状态，直到被通知、中断或者超时。如果返回值小于等于0，可以认定就是超时了</td>\n</tr>\n<tr>\n<td>awaitUntil(Date)</td>\n<td>当前线程进入等待状态，直到被通知、中断或者超时。如果没到指定时间被通知，则返回true，否则返回false</td>\n</tr>\n<tr>\n<td>signal()</td>\n<td>唤醒一个等待在Condition上的线程，被唤醒的线程在方法返回前必须获得与Condition对象关联的锁</td>\n</tr>\n<tr>\n<td>signalAll()</td>\n<td>唤醒所有等待在Condition上的线程，能够从await()等方法返回的线程必须先获得与Condition对象关联的锁</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"_14-3-3-reentrantlock\"> <strong>14.3.3 ReentrantLock</strong></h5>\n<p>ReentrantLock是一个非抽象类，它是Lock接口的JDK默认实现，实现了锁的基本功能。从名字上看，它是一个”可重入“锁，从源码上看，它内部有一个抽象类<code>Sync</code>，是继承了AQS，自己实现的一个同步器。同时，ReentrantLock内部有两个非抽象类<code>NonfairSync</code>和<code>FairSync</code>，它们都继承了Sync。从名字上看得出，分别是”非公平同步器“和”公平同步器“的意思。这意味着ReentrantLock可以支持”公平锁“和”非公平锁“。</p>\n<p>通过看着两个同步器的源码可以发现，它们的实现都是”独占“的。都调用了AOS的<code>setExclusiveOwnerThread</code>方法，所以ReentrantLock的锁的”独占“的，也就是说，它的锁都是”排他锁“，不能共享。</p>\n<p>在ReentrantLock的构造方法里，可以传入一个<code>boolean</code>类型的参数，来指定它是否是一个公平锁，默认情况下是非公平的。这个参数一旦实例化后就不能修改，只能通过<code>isFair()</code>方法来查看。</p>\n<h5 id=\"_14-3-4-reentrantreadwritelock\"> <strong>14.3.4 ReentrantReadWriteLock</strong></h5>\n<p>这个类也是一个非抽象类，它是ReadWriteLock接口的JDK默认实现。它与ReentrantLock的功能类似，同样是可重入的，支持非公平锁和公平锁。不同的是，它还支持”读写锁“。</p>\n<p>ReentrantReadWriteLock内部的结构大概是这样：</p>\n<div><pre><code><span>// 内部结构</span>\n<span>private</span> <span>final</span> <span>ReentrantReadWriteLock<span>.</span>ReadLock</span> readerLock<span>;</span>\n<span>private</span> <span>final</span> <span>ReentrantReadWriteLock<span>.</span>WriteLock</span> writerLock<span>;</span>\n<span>final</span> <span>Sync</span> sync<span>;</span>\n<span>abstract</span> <span>static</span> <span>class</span> <span>Sync</span> <span>extends</span> <span>AbstractQueuedSynchronizer</span> <span>{</span>\n    <span>// 具体实现</span>\n<span>}</span>\n<span>static</span> <span>final</span> <span>class</span> <span>NonfairSync</span> <span>extends</span> <span>Sync</span> <span>{</span>\n    <span>// 具体实现</span>\n<span>}</span>\n<span>static</span> <span>final</span> <span>class</span> <span>FairSync</span> <span>extends</span> <span>Sync</span> <span>{</span>\n    <span>// 具体实现</span>\n<span>}</span>\n<span>public</span> <span>static</span> <span>class</span> <span>ReadLock</span> <span>implements</span> <span>Lock</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span> <span>{</span>\n    <span>private</span> <span>final</span> <span>Sync</span> sync<span>;</span>\n    <span>protected</span> <span>ReadLock</span><span>(</span><span>ReentrantReadWriteLock</span> lock<span>)</span> <span>{</span>\n            sync <span>=</span> lock<span>.</span>sync<span>;</span>\n    <span>}</span>\n    <span>// 具体实现</span>\n<span>}</span>\n<span>public</span> <span>static</span> <span>class</span> <span>WriteLock</span> <span>implements</span> <span>Lock</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span> <span>{</span>\n    <span>private</span> <span>final</span> <span>Sync</span> sync<span>;</span>\n    <span>protected</span> <span>WriteLock</span><span>(</span><span>ReentrantReadWriteLock</span> lock<span>)</span> <span>{</span>\n            sync <span>=</span> lock<span>.</span>sync<span>;</span>\n    <span>}</span>\n    <span>// 具体实现</span>\n<span>}</span>\n\n<span>// 构造方法，初始化两个锁</span>\n<span>public</span> <span>ReentrantReadWriteLock</span><span>(</span><span>boolean</span> fair<span>)</span> <span>{</span>\n    sync <span>=</span> fair <span>?</span> <span>new</span> <span>FairSync</span><span>(</span><span>)</span> <span>:</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>)</span><span>;</span>\n    readerLock <span>=</span> <span>new</span> <span>ReadLock</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    writerLock <span>=</span> <span>new</span> <span>WriteLock</span><span>(</span><span>this</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 获取读锁和写锁的方法</span>\n<span>public</span> <span>ReentrantReadWriteLock<span>.</span>WriteLock</span> <span>writeLock</span><span>(</span><span>)</span> <span>{</span> <span>return</span> writerLock<span>;</span> <span>}</span>\n<span>public</span> <span>ReentrantReadWriteLock<span>.</span>ReadLock</span>  <span>readLock</span><span>(</span><span>)</span>  <span>{</span> <span>return</span> readerLock<span>;</span> <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>可以看到，它同样是内部维护了两个同步器。且维护了两个Lock的实现类ReadLock和WriteLock。从源码可以发现，这两个内部类用的是外部类的同步器。</p>\n<p>ReentrantReadWriteLock实现了读写锁，但它有一个小弊端，就是在“写”操作的时候，其它线程不能写也不能读。我们称这种现象为“写饥饿”，将在后文的StampedLock类继续讨论这个问题。</p>\n<h5 id=\"_14-3-5-stampedlock\"> <strong>14.3.5 StampedLock</strong></h5>\n<p><code>StampedLock</code>类是在Java 8 才发布的，也是Doug Lea大神所写，有人号称它为锁的性能之王。它没有实现Lock接口和ReadWriteLock接口，但它其实是实现了“读写锁”的功能，并且性能比ReentrantReadWriteLock更高。StampedLock还把读锁分为了“乐观读锁”和“悲观读锁”两种。</p>\n<p>前面提到了ReentrantReadWriteLock会发生“写饥饿”的现象，但StampedLock不会。它是怎么做到的呢？它的核心思想在于，<strong>在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。这种模式也就是典型的无锁编程思想，和CAS自旋的思想一样</strong>。这种操作方式决定了StampedLock在读线程非常多而写线程非常少的场景下非常适用，同时还避免了写饥饿情况的发生。</p>\n<p>这里篇幅有限，就不介绍StampedLock的源码了，只是分析一下官方提供的用法（在JDK源码类声明的上方或Javadoc里可以找到）。</p>\n<div><pre><code><span>class</span> <span>Point</span> <span>{</span>\n   <span>private</span> <span>double</span> x<span>,</span> y<span>;</span>\n   <span>private</span> <span>final</span> <span>StampedLock</span> sl <span>=</span> <span>new</span> <span>StampedLock</span><span>(</span><span>)</span><span>;</span>\n\n   <span>// 写锁的使用</span>\n   <span>void</span> <span>move</span><span>(</span><span>double</span> deltaX<span>,</span> <span>double</span> deltaY<span>)</span> <span>{</span>\n     <span>long</span> stamp <span>=</span> sl<span>.</span><span>writeLock</span><span>(</span><span>)</span><span>;</span> <span>// 获取写锁</span>\n     <span>try</span> <span>{</span>\n       x <span>+=</span> deltaX<span>;</span>\n       y <span>+=</span> deltaY<span>;</span>\n     <span>}</span> <span>finally</span> <span>{</span>\n       sl<span>.</span><span>unlockWrite</span><span>(</span>stamp<span>)</span><span>;</span> <span>// 释放写锁</span>\n     <span>}</span>\n   <span>}</span>\n\n   <span>// 乐观读锁的使用</span>\n   <span>double</span> <span>distanceFromOrigin</span><span>(</span><span>)</span> <span>{</span>\n     <span>long</span> stamp <span>=</span> sl<span>.</span><span>tryOptimisticRead</span><span>(</span><span>)</span><span>;</span> <span>// 获取乐观读锁</span>\n     <span>double</span> currentX <span>=</span> x<span>,</span> currentY <span>=</span> y<span>;</span>\n     <span>if</span> <span>(</span><span>!</span>sl<span>.</span><span>validate</span><span>(</span>stamp<span>)</span><span>)</span> <span>{</span> <span>// //检查乐观读锁后是否有其他写锁发生，有则返回false</span>\n        stamp <span>=</span> sl<span>.</span><span>readLock</span><span>(</span><span>)</span><span>;</span> <span>// 获取一个悲观读锁</span>\n        <span>try</span> <span>{</span>\n          currentX <span>=</span> x<span>;</span>\n          currentY <span>=</span> y<span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n           sl<span>.</span><span>unlockRead</span><span>(</span>stamp<span>)</span><span>;</span> <span>// 释放悲观读锁</span>\n        <span>}</span>\n     <span>}</span>\n     <span>return</span> <span>Math</span><span>.</span><span>sqrt</span><span>(</span>currentX <span>*</span> currentX <span>+</span> currentY <span>*</span> currentY<span>)</span><span>;</span>\n   <span>}</span>\n\n   <span>// 悲观读锁以及读锁升级写锁的使用</span>\n   <span>void</span> <span>moveIfAtOrigin</span><span>(</span><span>double</span> newX<span>,</span> <span>double</span> newY<span>)</span> <span>{</span>\n     <span>long</span> stamp <span>=</span> sl<span>.</span><span>readLock</span><span>(</span><span>)</span><span>;</span> <span>// 悲观读锁</span>\n     <span>try</span> <span>{</span>\n       <span>while</span> <span>(</span>x <span>==</span> <span>0.0</span> <span>&amp;&amp;</span> y <span>==</span> <span>0.0</span><span>)</span> <span>{</span>\n         <span>// 读锁尝试转换为写锁：转换成功后相当于获取了写锁，转换失败相当于有写锁被占用</span>\n         <span>long</span> ws <span>=</span> sl<span>.</span><span>tryConvertToWriteLock</span><span>(</span>stamp<span>)</span><span>;</span> \n\n         <span>if</span> <span>(</span>ws <span>!=</span> <span>0L</span><span>)</span> <span>{</span> <span>// 如果转换成功</span>\n           stamp <span>=</span> ws<span>;</span> <span>// 读锁的票据更新为写锁的</span>\n           x <span>=</span> newX<span>;</span>\n           y <span>=</span> newY<span>;</span>\n           <span>break</span><span>;</span>\n         <span>}</span>\n         <span>else</span> <span>{</span> <span>// 如果转换失败</span>\n           sl<span>.</span><span>unlockRead</span><span>(</span>stamp<span>)</span><span>;</span> <span>// 释放读锁</span>\n           stamp <span>=</span> sl<span>.</span><span>writeLock</span><span>(</span><span>)</span><span>;</span> <span>// 强制获取写锁</span>\n         <span>}</span>\n       <span>}</span>\n     <span>}</span> <span>finally</span> <span>{</span>\n       sl<span>.</span><span>unlock</span><span>(</span>stamp<span>)</span><span>;</span> <span>// 释放所有锁</span>\n     <span>}</span>\n   <span>}</span>\n<span>}</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><blockquote>\n<p>乐观读锁的意思就是先假定在这个锁获取期间，共享变量不会被改变，既然假定不会被改变，那就不需要上锁。在获取乐观读锁之后进行了一些操作，然后又调用了validate方法，这个方法就是用来验证tryOptimisticRead之后，是否有写操作执行过，如果有，则获取一个悲观读锁，这里的悲观读锁和ReentrantReadWriteLock中的读锁类似，也是个共享锁。</p>\n</blockquote>\n<p>可以看到，StampedLock获取锁会返回一个<code>long</code>类型的变量，释放锁的时候再把这个变量传进去。简单看看源码：</p>\n<div><pre><code><span>// 用于操作state后获取stamp的值</span>\n<span>private</span> <span>static</span> <span>final</span> <span>int</span> LG_READERS <span>=</span> <span>7</span><span>;</span>\n<span>private</span> <span>static</span> <span>final</span> <span>long</span> RUNIT <span>=</span> <span>1L</span><span>;</span>               <span>//0000 0000 0001</span>\n<span>private</span> <span>static</span> <span>final</span> <span>long</span> WBIT  <span>=</span> <span>1L</span> <span>&lt;&lt;</span> LG_READERS<span>;</span> <span>//0000 1000 0000</span>\n<span>private</span> <span>static</span> <span>final</span> <span>long</span> RBITS <span>=</span> WBIT <span>-</span> <span>1L</span><span>;</span>        <span>//0000 0111 1111</span>\n<span>private</span> <span>static</span> <span>final</span> <span>long</span> RFULL <span>=</span> RBITS <span>-</span> <span>1L</span><span>;</span>       <span>//0000 0111 1110</span>\n<span>private</span> <span>static</span> <span>final</span> <span>long</span> ABITS <span>=</span> RBITS <span>|</span> WBIT<span>;</span>     <span>//0000 1111 1111</span>\n<span>private</span> <span>static</span> <span>final</span> <span>long</span> SBITS <span>=</span> <span>~</span>RBITS<span>;</span>           <span>//1111 1000 0000</span>\n\n<span>// 初始化时state的值</span>\n<span>private</span> <span>static</span> <span>final</span> <span>long</span> ORIGIN <span>=</span> WBIT <span>&lt;&lt;</span> <span>1</span><span>;</span>       <span>//0001 0000 0000</span>\n\n<span>// 锁共享变量state</span>\n<span>private</span> <span>transient</span> <span>volatile</span> <span>long</span> state<span>;</span>\n<span>// 读锁溢出时用来存储多出的读锁</span>\n<span>private</span> <span>transient</span> <span>int</span> readerOverflow<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>StampedLock用这个long类型的变量的前7位（LG_READERS）来表示读锁，每获取一个悲观读锁，就加1（RUNIT），每释放一个悲观读锁，就减1。而悲观读锁最多只能装128个（7位限制），很容易溢出，所以用一个int类型的变量来存储溢出的悲观读锁。</p>\n<p>写锁用state变量剩下的位来表示，每次获取一个写锁，就加0000 1000 0000（WBIT）。需要注意的是，<strong>写锁在释放的时候，并不是减WBIT，而是再加WBIT</strong>。这是为了<strong>让每次写锁都留下痕迹</strong>，解决CAS中的ABA问题，也为<strong>乐观锁检查变化</strong>validate方法提供基础。</p>\n<p>乐观读锁就比较简单了，并没有真正改变state的值，而是在获取锁的时候记录state的写状态，在操作完成后去检查state的写状态部分是否发生变化，上文提到了，每次写锁都会留下痕迹，也是为了这里乐观锁检查变化提供方便。</p>\n<p>总的来说，StampedLock的性能是非常优异的，基本上可以取代ReentrantReadWriteLock的作用。</p>\n<h3 id=\"_15-并发集合容器简介\"> 15 并发集合容器简介</h3>\n<h4 id=\"_15-1-同步容器与并发容器\"> <strong>15.1 同步容器与并发容器</strong></h4>\n<p>我们知道在java.util包下提供了一些容器类，而Vector和HashTable是线程安全的容器类，但是这些容器实现同步的方式是通过对方法加锁(sychronized)方式实现的，这样读写均需要锁操作，导致性能低下。</p>\n<p>而即使是Vector这样线程安全的类，在面对多线程下的复合操作的时候也是需要通过客户端加锁的方式保证原子性。如下面例子说明:</p>\n<div><pre><code><span>public</span> <span>class</span> <span>TestVector</span> <span>{</span>\n    <span>private</span> <span>Vector</span><span><span>&lt;</span><span>String</span><span>></span></span> vector<span>;</span>\n\n    <span>//方法一</span>\n    <span>public</span>  <span>Object</span> <span>getLast</span><span>(</span><span>Vector</span> vector<span>)</span> <span>{</span>\n        <span>int</span> lastIndex <span>=</span> vector<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>\n        <span>return</span> vector<span>.</span><span>get</span><span>(</span>lastIndex<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>//方法二</span>\n    <span>public</span>  <span>void</span> <span>deleteLast</span><span>(</span><span>Vector</span> vector<span>)</span> <span>{</span>\n        <span>int</span> lastIndex <span>=</span> vector<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>\n        vector<span>.</span><span>remove</span><span>(</span>lastIndex<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>//方法三</span>\n    <span>public</span>  <span>Object</span> <span>getLastSysnchronized</span><span>(</span><span>Vector</span> vector<span>)</span> <span>{</span>\n        <span>synchronized</span><span>(</span>vector<span>)</span><span>{</span>\n            <span>int</span> lastIndex <span>=</span> vector<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>\n            <span>return</span> vector<span>.</span><span>get</span><span>(</span>lastIndex<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>//方法四</span>\n    <span>public</span>  <span>void</span> <span>deleteLastSysnchronized</span><span>(</span><span>Vector</span> vector<span>)</span> <span>{</span>\n        <span>synchronized</span> <span>(</span>vector<span>)</span><span>{</span>\n            <span>int</span> lastIndex <span>=</span> vector<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>\n            vector<span>.</span><span>remove</span><span>(</span>lastIndex<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>如果方法一和方法二为一个组合的话。那么当方法一获取到了<code>vector</code>的size之后，方法二已经执行完毕，这样就导致程序的错误。</p>\n<p>如果方法三与方法四组合的话。通过锁机制保证了在<code>vector</code>上的操作的原子性。</p>\n<p>并发容器是Java 5 提供的在多线程编程下用于代替同步容器，针对不同的应用场景进行设计，提高容器的并发访问性，同时定义了线程安全的复合操作。</p>\n<h4 id=\"_15-2-并发容器类介绍\"> <strong>15.2 并发容器类介绍</strong></h4>\n<p>整体架构(列举常用的容器类) <img src=\"https://firebasestorage.googleapis.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TIqiTZQ7Me5TObhp%2F并发容器.png?generation=1551665549655423&alt=media\" alt=\"img\" /></p>\n<p>其中，阻塞队列（BlockingQueue）在<a href=\"https://github.com/yasinshaw/concurrent/tree/c0f458769a889c236292ec0e20e376aae9aee21b/article/03/13.html\" target=\"_blank\" rel=\"noopener noreferrer\">第十三章</a>有介绍，CopyOnWrite容器（CopyOnWritexxx）在<a href=\"https://github.com/yasinshaw/concurrent/tree/c0f458769a889c236292ec0e20e376aae9aee21b/article/03/16.html\" target=\"_blank\" rel=\"noopener noreferrer\">第十六章</a>有介绍，这里不做过多介绍。</p>\n<p>下面分别介绍一些常用的并发容器类和接口，因篇幅原因，这里只介绍这些类的用途和基本的原理，不做过多的源码解析。</p>\n<h5 id=\"_15-2-1-并发map\"> <strong>15.2.1 并发Map</strong></h5>\n<h6 id=\"concurrentmap接口\"> <strong>ConcurrentMap接口</strong></h6>\n<p>ConcurrentMap接口继承了Map接口，在Map接口的基础上又定义了四个方法：</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ConcurrentMap</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> <span>extends</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> <span>{</span>\n\n    <span>//插入元素</span>\n    <span>V</span> <span>putIfAbsent</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span><span>;</span>\n\n    <span>//移除元素</span>\n    <span>boolean</span> <span>remove</span><span>(</span><span>Object</span> key<span>,</span> <span>Object</span> value<span>)</span><span>;</span>\n\n    <span>//替换元素</span>\n    <span>boolean</span> <span>replace</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> oldValue<span>,</span> <span>V</span> newValue<span>)</span><span>;</span>\n\n    <span>//替换元素</span>\n    <span>V</span> <span>replace</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>**putIfAbsent：**与原有put方法不同的是，putIfAbsent方法中如果插入的key相同，则不替换原有的value值；</p>\n<p>**remove：**与原有remove方法不同的是，新remove方法中增加了对value的判断，如果要删除的key-value不能与Map中原有的key-value对应上，则不会删除该元素;</p>\n<p>**replace(K,V,V)：**增加了对value值的判断，如果key-oldValue能与Map中原有的key-value对应上，才进行替换操作；</p>\n<p>**replace(K,V)：**与上面的replace不同的是，此replace不会对Map中原有的key-value进行比较，如果key存在则直接替换；</p>\n<h6 id=\"concurrenthashmap类\"> <strong>ConcurrentHashMap类</strong></h6>\n<p>ConcurrentHashMap同HashMap一样也是基于散列表的map，但是它提供了一种与HashTable完全不同的加锁策略提供更高效的并发性和伸缩性。</p>\n<p>ConcurrentHashMap提供了一种粒度更细的加锁机制来实现在多线程下更高的性能，这种机制叫分段锁(Lock Striping)。</p>\n<p>提供的优点是：在并发环境下将实现更高的吞吐量，而在单线程环境下只损失非常小的性能。</p>\n<p>可以这样理解分段锁，就是<strong>将数据分段，对每一段数据分配一把锁</strong>。当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>\n<p>有些方法需要跨段，比如size()、isEmpty()、containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。如下图： <img src=\"https://github.com/yasinshaw/concurrent/tree/c0f458769a889c236292ec0e20e376aae9aee21b/Users/yxiao/book/concurrent/article/03/imgs/分段锁机制.png\" alt=\"img\" /></p>\n<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，HashEntry则用于存储键值对数据。</p>\n<p>一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构（同HashMap一样，它也会在长度达到8的时候转化为红黑树）的元素， 每个Segment守护者一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>\n<h6 id=\"concurrentnavigablemap接口与concurrentskiplistmap类\"> <strong>ConcurrentNavigableMap接口与ConcurrentSkipListMap类</strong></h6>\n<p>ConcurrentNavigableMap接口继承了NavigableMap接口，这个接口提供了针对给定搜索目标返回最接近匹配项的导航方法。</p>\n<p>ConcurrentNavigableMap接口的主要实现类是ConcurrentSkipListMap类。从名字上来看，它的底层使用的是跳表（SkipList）的数据结构。关于跳表的数据结构这里不做太多介绍，它是一种”空间换时间“的数据结构，可以使用CAS来保证并发安全性。</p>\n<h5 id=\"_15-2-2-并发queue\"> <strong>15.2.2 并发Queue</strong></h5>\n<p>JDK并没有提供线程安全的List类，因为对List来说，<strong>很难去开发一个通用并且没有并发瓶颈的线程安全的List</strong>。因为即使简单的读操作，拿contains() 这样一个操作来说，很难搜索的时候如何避免锁住整个list。</p>\n<p>所以退一步，JDK提供了对队列和双端队列的线程安全的类：ConcurrentLinkedDeque和ConcurrentLinkedQueue。因为队列相对于List来说，有更多的限制。这两个类是使用CAS来实现线程安全的。</p>\n<h5 id=\"_15-2-3-并发set\"> <strong>15.2.3 并发Set</strong></h5>\n<p>JDK提供了ConcurrentSkipListSet，是线程安全的有序的集合。底层是使用ConcurrentSkipListMap实现。</p>\n<p>谷歌的guava框架实现了一个线程安全的ConcurrentHashSet：</p>\n<div><pre><code><span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> s <span>=</span> <span>Sets</span><span>.</span><span>newConcurrentHashSet</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_16-copyonwrite\"> 16 CopyOnWrite</h3>\n<h4 id=\"_16-1-什么是copyonwrite容器\"> <strong>16.1 什么是CopyOnWrite容器</strong></h4>\n<p>在说到CopyOnWrite容器之前我们先来谈谈什么是CopyOnWrite机制，CopyOnWrite是计算机设计领域中的一种优化策略，也是一种在并发场景下常用的设计思想——写入时复制思想。</p>\n<p>那什么是写入时复制思想呢？就是当有多个调用者同时去请求一个资源数据的时候，有一个调用者出于某些原因需要对当前的数据源进行修改，这个时候系统将会复制一个当前数据源的副本给调用者修改。</p>\n<p>CopyOnWrite容器即<strong>写时复制的容器</strong>,当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。</p>\n<p>这样做的好处在于，我们可以在并发的场景下对容器进行&quot;读操作&quot;而不需要&quot;加锁&quot;，从而达到读写分离的目的。从JDK 1.5 开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器 ，分别是CopyOnWriteArrayList和CopyOnWriteArraySet 。我们着重给大家介绍一下CopyOnWriteArrayList。</p>\n<h4 id=\"_16-2-copyonwritearraylist\"> <strong>16.2 CopyOnWriteArrayList</strong></h4>\n<p><strong>优点</strong>： CopyOnWriteArrayList经常被用于“读多写少”的并发场景，是因为CopyOnWriteArrayList无需任何同步措施，大大增强了读的性能。在Java中遍历线程非安全的List(如：ArrayList和 LinkedList)的时候，若中途有别的线程对List容器进行修改，那么会抛出ConcurrentModificationException异常。CopyOnWriteArrayList由于其&quot;读写分离&quot;，遍历和修改操作分别作用在不同的List容器，所以在使用迭代器遍历的时候，则不会抛出异常。</p>\n<p><strong>缺点</strong>： 第一个缺点是CopyOnWriteArrayList每次执行写操作都会将原容器进行拷贝了一份，数据量大的时候，内存会存在较大的压力，可能会引起频繁Full GC（ZGC因为没有使用Full GC）。比如这些对象占用的内存比较大200M左右，那么再写入100M数据进去，内存就会多占用300M。</p>\n<p>第二个缺点是CopyOnWriteArrayList由于实现的原因，写和读分别作用在不同新老容器上，在写操作执行过程中，读不会阻塞，但读取到的却是老容器的数据。</p>\n<p>现在我们来看一下CopyOnWriteArrayList的add操作源码，它的逻辑很清晰，就是先把原容器进行copy，然后在新的副本上进行“写操作”，最后再切换引用，在此过程中是加了锁的。</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>\n\n    <span>// ReentrantLock加锁，保证线程安全</span>\n    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>\n    lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>Object</span><span>[</span><span>]</span> elements <span>=</span> <span>getArray</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> len <span>=</span> elements<span>.</span>length<span>;</span>\n        <span>// 拷贝原容器，长度为原容器长度加一</span>\n        <span>Object</span><span>[</span><span>]</span> newElements <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elements<span>,</span> len <span>+</span> <span>1</span><span>)</span><span>;</span>\n        <span>// 在新副本上执行添加操作</span>\n        newElements<span>[</span>len<span>]</span> <span>=</span> e<span>;</span>\n        <span>// 将原容器引用指向新副本</span>\n        <span>setArray</span><span>(</span>newElements<span>)</span><span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        <span>// 解锁</span>\n        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>我们再来看一下remove操作的源码，remove的逻辑是将要remove元素之外的其他元素拷贝到新的副本中，然后切换引用，再将原容器的引用指向新的副本中，因为remove操作也是“写操作”所以也是要加锁的。</p>\n<div><pre><code><span>public</span> <span>E</span> <span>remove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n\n        <span>// 加锁</span>\n        <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>\n        lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>Object</span><span>[</span><span>]</span> elements <span>=</span> <span>getArray</span><span>(</span><span>)</span><span>;</span>\n            <span>int</span> len <span>=</span> elements<span>.</span>length<span>;</span>\n            <span>E</span> oldValue <span>=</span> <span>get</span><span>(</span>elements<span>,</span> index<span>)</span><span>;</span>\n            <span>int</span> numMoved <span>=</span> len <span>-</span> index <span>-</span> <span>1</span><span>;</span>\n            <span>if</span> <span>(</span>numMoved <span>==</span> <span>0</span><span>)</span>\n                <span>// 如果要删除的是列表末端数据，拷贝前len-1个数据到新副本上，再切换引用</span>\n                <span>setArray</span><span>(</span><span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elements<span>,</span> len <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>\n            <span>else</span> <span>{</span>\n                <span>// 否则，将除要删除元素之外的其他元素拷贝到新副本中，并切换引用</span>\n                <span>Object</span><span>[</span><span>]</span> newElements <span>=</span> <span>new</span> <span>Object</span><span>[</span>len <span>-</span> <span>1</span><span>]</span><span>;</span>\n                <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elements<span>,</span> <span>0</span><span>,</span> newElements<span>,</span> <span>0</span><span>,</span> index<span>)</span><span>;</span>\n                <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elements<span>,</span> index <span>+</span> <span>1</span><span>,</span> newElements<span>,</span> index<span>,</span>\n                                 numMoved<span>)</span><span>;</span>\n                <span>setArray</span><span>(</span>newElements<span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> oldValue<span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            <span>// 解锁</span>\n            lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>我们再来看看CopyOnWriteArrayList效率最高的读操作的源码</p>\n<div><pre><code><span>public</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n    <span>return</span> <span>get</span><span>(</span><span>getArray</span><span>(</span><span>)</span><span>,</span> index<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code> <span>private</span> <span>E</span> <span>get</span><span>(</span><span>Object</span><span>[</span><span>]</span> a<span>,</span> <span>int</span> index<span>)</span> <span>{</span>\n     <span>return</span> <span>(</span><span>E</span><span>)</span> a<span>[</span>index<span>]</span><span>;</span>\n <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>由上可见“读操作”是没有加锁，直接读取。</p>\n<h4 id=\"_16-3-copyonwrite的业务中实现\"> <strong>16.3 CopyOnWrite的业务中实现</strong></h4>\n<p>接下来，我们来具体结合业务场景实现一个CopyOnWriteMap的并发容器并且来使用它。</p>\n<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Collection</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Map</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Set</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>CopyOnWriteMap</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> <span>implements</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span><span>,</span> <span>Cloneable</span> <span>{</span>\n    <span>private</span> <span>volatile</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> internalMap<span>;</span>\n\n    <span>public</span> <span>CopyOnWriteMap</span><span>(</span><span>)</span> <span>{</span>\n        internalMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>\n        <span>synchronized</span> <span>(</span><span>this</span><span>)</span> <span>{</span>\n            <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> newMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span><span>(</span>internalMap<span>)</span><span>;</span>\n            <span>V</span> val <span>=</span> newMap<span>.</span><span>put</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n            internalMap <span>=</span> newMap<span>;</span>\n            <span>return</span> val<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n        <span>return</span> internalMap<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>putAll</span><span>(</span><span>Map</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> newData<span>)</span> <span>{</span>\n        <span>synchronized</span> <span>(</span><span>this</span><span>)</span> <span>{</span>\n            <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> newMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span><span>(</span>internalMap<span>)</span><span>;</span>\n            newMap<span>.</span><span>putAll</span><span>(</span>newData<span>)</span><span>;</span>\n            internalMap <span>=</span> newMap<span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>上面就是参考CopyOnWriteArrayList实现的CopyOnWriteMap，我们可以用这个容器来做什么呢？结合我们之前说的CopyOnWrite的复制思想，它最适用于“读多写少”的并发场景。</p>\n<p>**场景：**假如我们有一个搜索的网站需要屏蔽一些“关键字”，“黑名单”每晚定时更新，每当用户搜索的时候，“黑名单”中的关键字不会出现在搜索结果当中，并且提示用户敏感字。</p>\n<div><pre><code><span>// 黑名单服务</span>\n<span>public</span> <span>class</span> <span>BlackListServiceImpl</span> <span>{</span>\n    <span>//　减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</span>\n    <span>private</span> <span>static</span> <span>CopyOnWriteMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Boolean</span><span>></span></span> blackListMap <span>=</span> \n        <span>new</span> <span>CopyOnWriteMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Boolean</span><span>></span></span><span>(</span><span>1000</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>boolean</span> <span>isBlackList</span><span>(</span><span>String</span> id<span>)</span> <span>{</span>\n        <span>return</span> blackListMap<span>.</span><span>get</span><span>(</span>id<span>)</span> <span>==</span> <span>null</span> <span>?</span> <span>false</span> <span>:</span> <span>true</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>addBlackList</span><span>(</span><span>String</span> id<span>)</span> <span>{</span>\n        blackListMap<span>.</span><span>put</span><span>(</span>id<span>,</span> <span>Boolean</span><span>.</span>TRUE<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 批量添加黑名单\n     * (使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。\n     * 如使用上面代码里的addBlackList方法)\n     * @param ids\n     */</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>addBlackList</span><span>(</span><span>Map</span><span><span>&lt;</span><span>String</span><span>,</span><span>Boolean</span><span>></span></span> ids<span>)</span> <span>{</span>\n        blackListMap<span>.</span><span>putAll</span><span>(</span>ids<span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>这里需要各位小伙伴特别特别注意一个问题，此处的场景是每晚凌晨“黑名单”定时更新，原因是CopyOnWrite容器有<strong>数据一致性</strong>的问题，它只能保证<strong>最终数据一致性</strong>。</p>\n<p>所以如果我们希望写入的数据马上能准确地读取，请不要使用CopyOnWrite容器。</p>\n<h3 id=\"_17-通信工具类\"> 17 通信工具类</h3>\n<p>JDK中提供了一些工具类以供开发者使用。这样的话我们在遇到一些常见的应用场景时就可以使用这些工具类，而不用自己再重复造轮子了。</p>\n<p>它们都在java.util.concurrent包下。先总体概括一下都有哪些工具类，它们有什么作用，然后再分别介绍它们的主要使用方法和原理。</p>\n<table>\n<thead>\n<tr>\n<th>类</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Semaphore</td>\n<td>限制线程的数量</td>\n</tr>\n<tr>\n<td>Exchanger</td>\n<td>两个线程交换数据</td>\n</tr>\n<tr>\n<td>CountDownLatch</td>\n<td>线程等待直到计数器减为0时开始工作</td>\n</tr>\n<tr>\n<td>CyclicBarrier</td>\n<td>作用跟CountDownLatch类似，但是可以重复使用</td>\n</tr>\n<tr>\n<td>Phaser</td>\n<td>增强的CyclicBarrier</td>\n</tr>\n</tbody>\n</table>\n<p>下面分别介绍这几个类。</p>\n<h4 id=\"_17-1-semaphore\"> <strong>17.1 Semaphore</strong></h4>\n<h5 id=\"_17-1-1-semaphore介绍\"> <strong>17.1.1 Semaphore介绍</strong></h5>\n<p>Semaphore翻译过来是信号的意思。顾名思义，这个工具类提供的功能就是多个线程彼此“打信号”。而这个“信号”是一个<code>int</code>类型的数据，也可以看成是一种“资源”。</p>\n<p>可以在构造函数中传入初始资源总数，以及是否使用“公平”的同步器。默认情况下，是非公平的。</p>\n<div><pre><code><span>// 默认情况下使用非公平</span>\n<span>public</span> <span>Semaphore</span><span>(</span><span>int</span> <span>permits</span><span>)</span> <span>{</span>\n    sync <span>=</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>permits</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>Semaphore</span><span>(</span><span>int</span> <span>permits</span><span>,</span> <span>boolean</span> fair<span>)</span> <span>{</span>\n    sync <span>=</span> fair <span>?</span> <span>new</span> <span>FairSync</span><span>(</span><span>permits</span><span>)</span> <span>:</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>permits</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>最主要的方法是acquire方法和release方法。acquire()方法会申请一个permit，而release方法会释放一个permit。当然，你也可以申请多个acquire(int permits)或者释放多个release(int permits)。</p>\n<p>每次acquire，permits就会减少一个或者多个。如果减少到了0，再有其他线程来acquire，那就要阻塞这个线程直到有其它线程release permit为止。</p>\n<h5 id=\"_17-1-2-semaphore案例\"> <strong>17.1.2 Semaphore案例</strong></h5>\n<p>Semaphore往往用于资源有限的场景中，去限制线程的数量。举个例子，我想限制同时只能有3个线程在工作：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>SemaphoreDemo</span> <span>{</span>\n    <span>static</span> <span>class</span> <span>MyThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n\n        <span>private</span> <span>int</span> value<span>;</span>\n        <span>private</span> <span>Semaphore</span> semaphore<span>;</span>\n\n        <span>public</span> <span>MyThread</span><span>(</span><span>int</span> value<span>,</span> <span>Semaphore</span> semaphore<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>value <span>=</span> value<span>;</span>\n            <span>this</span><span>.</span>semaphore <span>=</span> semaphore<span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                semaphore<span>.</span><span>acquire</span><span>(</span><span>)</span><span>;</span> <span>// 获取permit</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"当前线程是%d, 还剩%d个资源，还有%d个线程在等待\"</span><span>,</span>\n                        value<span>,</span> semaphore<span>.</span><span>availablePermits</span><span>(</span><span>)</span><span>,</span> semaphore<span>.</span><span>getQueueLength</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n                <span>// 睡眠随机时间，打乱释放顺序</span>\n                <span>Random</span> random <span>=</span><span>new</span> <span>Random</span><span>(</span><span>)</span><span>;</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span>random<span>.</span><span>nextInt</span><span>(</span><span>1000</span><span>)</span><span>)</span><span>;</span>\n                semaphore<span>.</span><span>release</span><span>(</span><span>)</span><span>;</span> <span>// 释放permit</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"线程%d释放了资源\"</span><span>,</span> value<span>)</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Semaphore</span> semaphore <span>=</span> <span>new</span> <span>Semaphore</span><span>(</span><span>3</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>MyThread</span><span>(</span>i<span>,</span> semaphore<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>输出：</p>\n<blockquote>\n<p>当前线程是1, 还剩2个资源，还有0个线程在等待</p>\n<p>当前线程是0, 还剩1个资源，还有0个线程在等待</p>\n<p>当前线程是6, 还剩0个资源，还有0个线程在等待</p>\n<p>线程6释放了资源</p>\n<p>当前线程是2, 还剩0个资源，还有6个线程在等待</p>\n<p>线程2释放了资源</p>\n<p>当前线程是4, 还剩0个资源，还有5个线程在等待</p>\n<p>线程0释放了资源</p>\n<p>当前线程是7, 还剩0个资源，还有4个线程在等待</p>\n<p>线程1释放了资源</p>\n<p>当前线程是8, 还剩0个资源，还有3个线程在等待</p>\n<p>线程7释放了资源</p>\n<p>当前线程是5, 还剩0个资源，还有2个线程在等待</p>\n<p>线程4释放了资源</p>\n<p>当前线程是3, 还剩0个资源，还有1个线程在等待</p>\n<p>线程8释放了资源</p>\n<p>当前线程是9, 还剩0个资源，还有0个线程在等待</p>\n<p>线程9释放了资源</p>\n<p>线程5释放了资源 线程3释放了资源</p>\n</blockquote>\n<p>可以看到，在这次运行中，最开始是1, 0, 6这三个线程获得了资源，而其它线程进入了等待队列。然后当某个线程释放资源后，就会有等待队列中的线程获得资源。</p>\n<p>当然，Semaphore默认的acquire方法是会让线程进入等待队列，且会抛出中断异常。但它还有一些方法可以忽略中断或不进入阻塞队列：</p>\n<div><pre><code><span>// 忽略中断</span>\n<span>public</span> <span>void</span> <span>acquireUninterruptibly</span><span>(</span><span>)</span>\n<span>public</span> <span>void</span> <span>acquireUninterruptibly</span><span>(</span><span>int</span> <span>permits</span><span>)</span>\n\n<span>// 不进入等待队列，底层使用CAS</span>\n<span>public</span> <span>boolean</span> tryAcquire\n<span>public</span> <span>boolean</span> <span>tryAcquire</span><span>(</span><span>int</span> <span>permits</span><span>)</span>\n<span>public</span> <span>boolean</span> <span>tryAcquire</span><span>(</span><span>int</span> <span>permits</span><span>,</span> <span>long</span> timeout<span>,</span> <span>TimeUnit</span> unit<span>)</span>\n        <span>throws</span> <span>InterruptedException</span>\n<span>public</span> <span>boolean</span> <span>tryAcquire</span><span>(</span><span>long</span> timeout<span>,</span> <span>TimeUnit</span> unit<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h5 id=\"_17-1-3-semaphore原理\"> <strong>17.1.3 Semaphore原理</strong></h5>\n<p>Semaphore内部有一个继承了AQS的同步器Sync，重写了<code>tryAcquireShared</code>方法。在这个方法里，会去尝试获取资源。</p>\n<p>如果获取失败（想要的资源数量小于目前已有的资源数量），就会返回一个负数（代表尝试获取资源失败）。然后当前线程就会进入AQS的等待队列。</p>\n<h4 id=\"_17-2-exchanger\"> <strong>17.2 Exchanger</strong></h4>\n<p>Exchanger类用于两个线程交换数据。它支持泛型，也就是说你可以在两个线程之间传送任何数据。先来一个案例看看如何使用，比如两个线程之间想要传送字符串：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ExchangerDemo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>Exchanger</span><span><span>&lt;</span><span>String</span><span>></span></span> exchanger <span>=</span> <span>new</span> <span>Exchanger</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"这是线程A，得到了另一个线程的数据：\"</span>\n                        <span>+</span> exchanger<span>.</span><span>exchange</span><span>(</span><span>\"这是来自线程A的数据\"</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"这个时候线程A是阻塞的，在等待线程B的数据\"</span><span>)</span><span>;</span>\n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"这是线程B，得到了另一个线程的数据：\"</span>\n                        <span>+</span> exchanger<span>.</span><span>exchange</span><span>(</span><span>\"这是来自线程B的数据\"</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>输出：</p>\n<blockquote>\n<p>这个时候线程A是阻塞的，在等待线程B的数据 这是线程B，得到了另一个线程的数据：这是来自线程A的数据 这是线程A，得到了另一个线程的数据：这是来自线程B的数据</p>\n</blockquote>\n<p>可以看到，当一个线程调用exchange方法后，它是处于阻塞状态的，只有当另一个线程也调用了exchange方法，它才会继续向下执行。看源码可以发现它是使用park/unpark来实现等待状态的切换的，但是在使用park/unpark方法之前，使用了CAS检查，估计是为了提高性能。</p>\n<p>Exchanger一般用于两个线程之间更方便地在内存中交换数据，因为其支持泛型，所以我们可以传输任何的数据，比如IO流或者IO缓存。根据JDK里面的注释的说法，可以总结为一下特性：</p>\n<ul>\n<li>此类提供对外的操作是同步的；</li>\n<li>用于成对出现的线程之间交换数据；</li>\n<li>可以视作双向的同步队列；</li>\n<li>可应用于基因算法、流水线设计等场景。</li>\n</ul>\n<p>Exchanger类还有一个有超时参数的方法，如果在指定时间内没有另一个线程调用exchange，就会抛出一个超时异常。</p>\n<div><pre><code><span>public</span> <span>V</span> <span>exchange</span><span>(</span><span>V</span> x<span>,</span> <span>long</span> timeout<span>,</span> <span>TimeUnit</span> unit<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>那么问题来了，Exchanger只能是两个线程交换数据吗？那三个调用同一个实例的exchange方法会发生什么呢？答案是只有前两个线程会交换数据，第三个线程会进入阻塞状态。</p>\n<p>需要注意的是，exchange是可以重复使用的。也就是说。两个线程可以使用Exchanger在内存中不断地再交换数据。</p>\n<h4 id=\"_17-3-countdownlatch\"> <strong>17.3 CountDownLatch</strong></h4>\n<h5 id=\"_17-3-1-countdownlatch介绍\"> <strong>17.3.1 CountDownLatch介绍</strong></h5>\n<p>先来解读一下CountDownLatch这个类名字的意义。CountDown代表计数递减，Latch是“门闩”的意思。也有人把它称为“屏障”。而CountDownLatch这个类的作用也很贴合这个名字的意义，假设某个线程在执行任务之前，需要等待其它线程完成一些前置任务，必须等所有的前置任务都完成，才能开始执行本线程的任务。</p>\n<p>CountDownLatch的方法也很简单，如下：</p>\n<div><pre><code><span>// 构造方法：</span>\n<span>public</span> <span>CountDownLatch</span><span>(</span><span>int</span> count<span>)</span>\n\n<span>public</span> <span>void</span> <span>await</span><span>(</span><span>)</span> <span>// 等待</span>\n<span>public</span> <span>boolean</span> <span>await</span><span>(</span><span>long</span> timeout<span>,</span> <span>TimeUnit</span> unit<span>)</span> <span>// 超时等待</span>\n<span>public</span> <span>void</span> <span>countDown</span><span>(</span><span>)</span> <span>// count - 1</span>\n<span>public</span> <span>long</span> <span>getCount</span><span>(</span><span>)</span> <span>// 获取当前还有多少count</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"_17-3-2-countdownlatch案例\"> <strong>17.3.2  CountDownLatch案例</strong></h5>\n<p>我们知道，玩游戏的时候，在游戏真正开始之前，一般会等待一些前置任务完成，比如“加载地图数据”，“加载人物模型”，“加载背景音乐”等等。只有当所有的东西都加载完成后，玩家才能真正进入游戏。下面我们就来模拟一下这个demo。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>CountDownLatchDemo</span> <span>{</span>\n    <span>// 定义前置任务线程</span>\n    <span>static</span> <span>class</span> <span>PreTaskThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n\n        <span>private</span> <span>String</span> task<span>;</span>\n        <span>private</span> <span>CountDownLatch</span> countDownLatch<span>;</span>\n\n        <span>public</span> <span>PreTaskThread</span><span>(</span><span>String</span> task<span>,</span> <span>CountDownLatch</span> countDownLatch<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>task <span>=</span> task<span>;</span>\n            <span>this</span><span>.</span>countDownLatch <span>=</span> countDownLatch<span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>Random</span> random <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>;</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span>random<span>.</span><span>nextInt</span><span>(</span><span>1000</span><span>)</span><span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>task <span>+</span> <span>\" - 任务完成\"</span><span>)</span><span>;</span>\n                countDownLatch<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>// 假设有三个模块需要加载</span>\n        <span>CountDownLatch</span> countDownLatch <span>=</span> <span>new</span> <span>CountDownLatch</span><span>(</span><span>3</span><span>)</span><span>;</span>\n\n        <span>// 主任务</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"等待数据加载...\"</span><span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"还有%d个前置任务\"</span><span>,</span> countDownLatch<span>.</span><span>getCount</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n                countDownLatch<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"数据加载完成，正式开始游戏！\"</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// 前置任务</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>\"加载地图数据\"</span><span>,</span> countDownLatch<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>\"加载人物模型\"</span><span>,</span> countDownLatch<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>\"加载背景音乐\"</span><span>,</span> countDownLatch<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p>输出：</p>\n<blockquote>\n<p>等待数据加载... 还有3个前置任务 加载人物模型 - 任务完成 加载背景音乐 - 任务完成 加载地图数据 - 任务完成 数据加载完成，正式开始游戏！</p>\n</blockquote>\n<h5 id=\"_17-3-3-countdownlatch原理\"> <strong>17.3.3 CountDownLatch原理</strong></h5>\n<p>其实CountDownLatch类的原理挺简单的，内部同样是一个基层了AQS的实现类Sync，且实现起来还很简单，可能是JDK里面AQS的子类中最简单的实现了，有兴趣的读者可以去看看这个内部类的源码。</p>\n<p>需要注意的是构造器中的<strong>计数值（count）实际上就是闭锁需要等待的线程数量</strong>。这个值只能被设置一次，而且CountDownLatch<strong>没有提供任何机制去重新设置这个计数值</strong>。</p>\n<h4 id=\"_17-4-cyclicbarrier\"> <strong>17.4 CyclicBarrier</strong></h4>\n<h5 id=\"_17-4-1-cyclicbarrier介绍\"> <strong>17.4.1 CyclicBarrier介绍</strong></h5>\n<p>CyclicBarrirer从名字上来理解是“循环的屏障”的意思。前面提到了CountDownLatch一旦计数值<code>count</code>被降为0后，就不能再重新设置了，它只能起一次“屏障”的作用。而CyclicBarrier拥有CountDownLatch的所有功能，还可以使用<code>reset()</code>方法重置屏障。</p>\n<h5 id=\"_17-4-2-cyclicbarrier-barrier被破坏\"> <strong>17.4.2 CyclicBarrier Barrier被破坏</strong></h5>\n<p>如果在参与者（线程）在等待的过程中，Barrier被破坏，就会抛出BrokenBarrierException。可以用<code>isBroken()</code>方法检测Barrier是否被破坏。</p>\n<ol>\n<li>如果有线程已经处于等待状态，调用reset方法会导致已经在等待的线程出现BrokenBarrierException异常。并且由于出现了BrokenBarrierException，将会导致始终无法等待。</li>\n<li>如果在等待的过程中，线程被中断，也会抛出BrokenBarrierException异常，并且这个异常会传播到其他所有的线程。</li>\n<li>如果在执行屏障操作过程中发生异常，则该异常将传播到当前线程中，其他线程会抛出BrokenBarrierException，屏障被损坏。</li>\n<li>如果超出指定的等待时间，当前线程会抛出 TimeoutException 异常，其他线程会抛出BrokenBarrierException异常。</li>\n</ol>\n<h5 id=\"_17-4-3-cyclicbarrier案例\"> <strong>17.4.3 CyclicBarrier案例</strong></h5>\n<p>我们同样用玩游戏的例子。如果玩一个游戏有多个“关卡”，那使用CountDownLatch显然不太合适，那需要为每个关卡都创建一个实例。那我们可以使用CyclicBarrier来实现每个关卡的数据加载等待功能。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>CyclicBarrierDemo</span> <span>{</span>\n    <span>static</span> <span>class</span> <span>PreTaskThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n\n        <span>private</span> <span>String</span> task<span>;</span>\n        <span>private</span> <span>CyclicBarrier</span> cyclicBarrier<span>;</span>\n\n        <span>public</span> <span>PreTaskThread</span><span>(</span><span>String</span> task<span>,</span> <span>CyclicBarrier</span> cyclicBarrier<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>task <span>=</span> task<span>;</span>\n            <span>this</span><span>.</span>cyclicBarrier <span>=</span> cyclicBarrier<span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>// 假设总共三个关卡</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                    <span>Random</span> random <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>;</span>\n                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span>random<span>.</span><span>nextInt</span><span>(</span><span>1000</span><span>)</span><span>)</span><span>;</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"关卡%d的任务%s完成\"</span><span>,</span> i<span>,</span> task<span>)</span><span>)</span><span>;</span>\n                    cyclicBarrier<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> <span>|</span> <span>BrokenBarrierException</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n                cyclicBarrier<span>.</span><span>reset</span><span>(</span><span>)</span><span>;</span> <span>// 重置屏障</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>CyclicBarrier</span> cyclicBarrier <span>=</span> <span>new</span> <span>CyclicBarrier</span><span>(</span><span>3</span><span>,</span> <span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"本关卡所有前置任务完成，开始游戏...\"</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>\"加载地图数据\"</span><span>,</span> cyclicBarrier<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>\"加载人物模型\"</span><span>,</span> cyclicBarrier<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>\"加载背景音乐\"</span><span>,</span> cyclicBarrier<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>输出：</p>\n<blockquote>\n<p>关卡1的任务加载地图数据完成 关卡1的任务加载背景音乐完成 关卡1的任务加载人物模型完成 本关卡所有前置任务完成，开始游戏... 关卡2的任务加载地图数据完成 关卡2的任务加载背景音乐完成 关卡2的任务加载人物模型完成 本关卡所有前置任务完成，开始游戏... 关卡3的任务加载人物模型完成 关卡3的任务加载地图数据完成 关卡3的任务加载背景音乐完成 本关卡所有前置任务完成，开始游戏...</p>\n</blockquote>\n<p>注意这里跟CountDownLatch的代码有一些不同。CyclicBarrier没有分为<code>await()</code>和<code>countDown()</code>，而是只有单独的一个<code>await()</code>方法。</p>\n<p>一旦调用await()方法的线程数量等于构造方法中传入的任务总量（这里是3），就代表达到屏障了。CyclicBarrier允许我们在达到屏障的时候可以执行一个任务，可以在构造方法传入一个Runnable类型的对象。上述案例就是在达到屏障时，输出“本关卡所有前置任务完成，开始游戏...”。</p>\n<div><pre><code><span>// 构造方法</span>\n<span>public</span> <span>CyclicBarrier</span><span>(</span><span>int</span> parties<span>)</span> <span>{</span>\n    <span>this</span><span>(</span>parties<span>,</span> <span>null</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>CyclicBarrier</span><span>(</span><span>int</span> parties<span>,</span> <span>Runnable</span> barrierAction<span>)</span> <span>{</span>\n    <span>// 具体实现</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"_17-4-4-cyclicbarrier原理\"> <strong>17.4.4 CyclicBarrier原理</strong></h5>\n<p>CyclicBarrier虽说功能与CountDownLatch类似，但是实现原理却完全不同，CyclicBarrier内部使用的是Lock + Condition实现的等待/通知模式。详情可以查看这个方法的源码：</p>\n<div><pre><code><span>private</span> <span>int</span> <span>dowait</span><span>(</span><span>boolean</span> timed<span>,</span> <span>long</span> nanos<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_17-5-phaser\"> <strong>17.5 Phaser</strong></h4>\n<h5 id=\"_17-5-1-phaser介绍\"> <strong>17.5.1 Phaser介绍</strong></h5>\n<p>Phaser这个单词是“移相器，相位器”的意思（好吧，笔者并不懂这是什么玩意，下方资料来自百度百科）。这个类是从JDK 1.7 中出现的。</p>\n<blockquote>\n<p>移相器（Phaser）能够对波的相位进行调整的一种装置。任何传输介质对在其中传导的波动都会引入相移，这是早期模拟移相器的原理；现代电子技术发展后利用A/D、D/A转换实现了数字移相，顾名思义，它是一种不连续的移相技术，但特点是移相精度高。 移相器在雷达、导弹姿态控制、加速器、通信、仪器仪表甚至于音乐等领域都有着广泛的应用</p>\n</blockquote>\n<p>Phaser类有点复杂，这里只介绍一些基本的用法和知识点。详情可以查看JDK文档，文档里有这个类非常详尽的介绍。</p>\n<p>前面我们介绍了CyclicBarrier，可以发现它在构造方法里传入“任务总量”<code>parties</code>之后，就不能修改这个值了，并且每次调用<code>await()</code>方法也只能消耗一个<code>parties</code>计数。但Phaser可以动态地调整任务总量！</p>\n<p>名词解释：</p>\n<ul>\n<li>party：对应一个线程，数量可以通过register或者构造参数传入;</li>\n<li>arrive：对应一个party的状态，初始时是unarrived，当调用<code>arriveAndAwaitAdvance()</code>或者 <code>arriveAndDeregister()</code>进入arrive状态，可以通过<code>getUnarrivedParties()</code>获取当前未到达的数量;</li>\n<li>register：注册一个party，每一阶段必须所有注册的party都到达才能进入下一阶段;</li>\n<li>deRegister：减少一个party。</li>\n<li>phase：阶段，当所有注册的party都arrive之后，将会调用Phaser的<code>onAdvance()</code>方法来判断是否要进入下一阶段。</li>\n</ul>\n<p>Phaser终止的两种途径，Phaser维护的线程执行完毕或者<code>onAdvance()</code>返回<code>true</code> 此外Phaser还能维护一个树状的层级关系，构造的时候new Phaser(parentPhaser)，对于Task执行时间短的场景（竞争激烈），也就是说有大量的<strong>party</strong>, 那可以把每个Phaser的任务量设置较小，多个Phaser共同继承一个父Phaser。</p>\n<blockquote>\n<p>Phasers with large numbers of parties that would otherwise experience heavy synchronization contention costs may instead be set up so that groups of sub-phasers share a common parent. This may greatly increase throughput even though it incurs greater per-operation overhead.</p>\n<p>翻译：如果有大量的party，那许多线程可能同步的竞争成本比较高。所以可以拆分成多个子Phaser共享一个共同的父Phaser。这可能会大大增加吞吐量，即使它会带来更多的每次操作开销。</p>\n</blockquote>\n<h5 id=\"_17-5-2-phaser案例\"> <strong>17.5.2 Phaser案例</strong></h5>\n<p>还是游戏的案例。假设我们游戏有三个关卡，但只有第一个关卡有新手教程，需要加载新手教程模块。但后面的第二个关卡和第三个关卡都不需要。我们可以用Phaser来做这个需求。</p>\n<p>代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>PhaserDemo</span> <span>{</span>\n    <span>static</span> <span>class</span> <span>PreTaskThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n\n        <span>private</span> <span>String</span> task<span>;</span>\n        <span>private</span> <span>Phaser</span> phaser<span>;</span>\n\n        <span>public</span> <span>PreTaskThread</span><span>(</span><span>String</span> task<span>,</span> <span>Phaser</span> phaser<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>task <span>=</span> task<span>;</span>\n            <span>this</span><span>.</span>phaser <span>=</span> phaser<span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                    <span>// 第二次关卡起不加载NPC，跳过</span>\n                    <span>if</span> <span>(</span>i <span>>=</span> <span>2</span> <span>&amp;&amp;</span> <span>\"加载新手教程\"</span><span>.</span><span>equals</span><span>(</span>task<span>)</span><span>)</span> <span>{</span>\n                        <span>continue</span><span>;</span>\n                    <span>}</span>\n                    <span>Random</span> random <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>;</span>\n                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span>random<span>.</span><span>nextInt</span><span>(</span><span>1000</span><span>)</span><span>)</span><span>;</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"关卡%d，需要加载%d个模块，当前模块【%s】\"</span><span>,</span>\n                            i<span>,</span> phaser<span>.</span><span>getRegisteredParties</span><span>(</span><span>)</span><span>,</span> task<span>)</span><span>)</span><span>;</span>\n\n                    <span>// 从第二个关卡起，不加载NPC</span>\n                    <span>if</span> <span>(</span>i <span>==</span> <span>1</span> <span>&amp;&amp;</span> <span>\"加载新手教程\"</span><span>.</span><span>equals</span><span>(</span>task<span>)</span><span>)</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"下次关卡移除加载【新手教程】模块\"</span><span>)</span><span>;</span>\n                        phaser<span>.</span><span>arriveAndDeregister</span><span>(</span><span>)</span><span>;</span> <span>// 移除一个模块</span>\n                    <span>}</span> <span>else</span> <span>{</span>\n                        phaser<span>.</span><span>arriveAndAwaitAdvance</span><span>(</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Phaser</span> phaser <span>=</span> <span>new</span> <span>Phaser</span><span>(</span><span>4</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>protected</span> <span>boolean</span> <span>onAdvance</span><span>(</span><span>int</span> phase<span>,</span> <span>int</span> registeredParties<span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"第%d次关卡准备完成\"</span><span>,</span> phase <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span>\n                <span>return</span> phase <span>==</span> <span>3</span> <span>||</span> registeredParties <span>==</span> <span>0</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>;</span>\n\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>\"加载地图数据\"</span><span>,</span> phaser<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>\"加载人物模型\"</span><span>,</span> phaser<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>\"加载背景音乐\"</span><span>,</span> phaser<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>\"加载新手教程\"</span><span>,</span> phaser<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><p>输出：</p>\n<blockquote>\n<p>关卡1，需要加载4个模块，当前模块【加载背景音乐】</p>\n<p>关卡1，需要加载4个模块，当前模块【加载新手教程】</p>\n<p>下次关卡移除加载【新手教程】模块</p>\n<p>关卡1，需要加载3个模块，当前模块【加载地图数据】</p>\n<p>关卡1，需要加载3个模块，当前模块【加载人物模型】</p>\n<p>第1次关卡准备完成</p>\n<p>关卡2，需要加载3个模块，当前模块【加载地图数据】</p>\n<p>关卡2，需要加载3个模块，当前模块【加载背景音乐】</p>\n<p>关卡2，需要加载3个模块，当前模块【加载人物模型】</p>\n<p>第2次关卡准备完成</p>\n<p>关卡3，需要加载3个模块，当前模块【加载人物模型】</p>\n<p>关卡3，需要加载3个模块，当前模块【加载地图数据】</p>\n<p>关卡3，需要加载3个模块，当前模块【加载背景音乐】</p>\n<p>第3次关卡准备完成</p>\n</blockquote>\n<p>这里要注意关卡1的输出，在“加载新手教程”线程中调用了<code>arriveAndDeregister()</code>减少一个party之后，后面的线程使用<code>getRegisteredParties()</code>得到的是已经被修改后的parties了。但是当前这个阶段(phase)，仍然是需要4个parties都arrive才触发屏障的。从下一个阶段开始，才需要3个parties都arrive就触发屏障。</p>\n<p>另外Phaser类用来控制某个阶段的线程数量很有用，但它并在意这个阶段具体有哪些线程arrive，只要达到它当前阶段的parties值，就触发屏障。所以我这里的案例虽然制定了特定的线程（加载新手教程）来更直观地表述Phaser的功能，但是其实Phaser是没有分辨具体是哪个线程的功能的，它在意的只是数量，这一点需要读者注意。</p>\n<h5 id=\"_17-5-3-phaser原理\"> <strong>17.5.3 Phaser原理</strong></h5>\n<p>Phaser类的原理相比起来要复杂得多。它内部使用了两个基于Fork-Join框架的原子类辅助：</p>\n<div><pre><code><span>private</span> <span>final</span> <span>AtomicReference</span><span><span>&lt;</span><span>QNode</span><span>></span></span> evenQ<span>;</span>\n<span>private</span> <span>final</span> <span>AtomicReference</span><span><span>&lt;</span><span>QNode</span><span>></span></span> oddQ<span>;</span>\n\n<span>static</span> <span>final</span> <span>class</span> <span>QNode</span> <span>implements</span> <span>ForkJoinPool<span>.</span>ManagedBlocker</span> <span>{</span>\n    <span>// 实现代码</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>有兴趣的读者可以去看看JDK源代码，这里不做过多叙述。</p>\n<p>总的来说，CountDownLatch，CyclicBarrier，Phaser是一个比一个强大，但也一个比一个复杂。根据自己的业务需求合理选择即可。</p>\n<h3 id=\"_18-fork-join框架\"> 18 Fork/Join框架</h3>\n<h4 id=\"_18-1-什么是fork-join\"> <strong>18.1 什么是Fork/Join</strong></h4>\n<p>Fork/Join框架是一个实现了ExecutorService接口的多线程处理器，它专为那些可以通过递归分解成更细小的任务而设计，最大化的利用多核处理器来提高应用程序的性能。</p>\n<p>与其他ExecutorService相关的实现相同的是，Fork/Join框架会将任务分配给线程池中的线程。而与之不同的是，Fork/Join框架在执行任务时使用了<strong>工作窃取算法</strong>。</p>\n<p><strong>fork</strong>在英文里有分叉的意思，<strong>join</strong>在英文里连接、结合的意思。顾名思义，fork就是要使一个大任务分解成若干个小任务，而join就是最后将各个小任务的结果结合起来得到大任务的结果。</p>\n<p>Fork/Join的运行流程大致如下所示：</p>\n<p><img src=\"https://gblobscdn.gitbook.com/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJw4VyRYbSwAlVTD%2Ffork_join流程图.png?alt=media\" alt=\"img\" /></p>\n<p>fork/join流程图</p>\n<p>需要注意的是，图里的次级子任务可以一直分下去，一直分到子任务足够小为止。用伪代码来表示如下：</p>\n<div><pre><code><span>solve</span><span>(</span>任务<span>)</span><span>:</span>\n    <span>if</span><span>(</span>任务已经划分到足够小<span>)</span><span>:</span>\n        顺序执行任务\n    <span>else</span><span>:</span>\n        <span>for</span><span>(</span>划分任务得到子任务<span>)</span>\n            <span>solve</span><span>(</span>子任务<span>)</span>\n        结合所有子任务的结果到上一层循环\n        <span>return</span> 最终结合的结果\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>通过上面伪代码可以看出，我们通过递归嵌套的计算得到最终结果，这里有体现<strong>分而治之(divide and conquer)</strong> 的算法思想。</p>\n<h4 id=\"_18-2-工作窃取算法\"> <strong>18.2 工作窃取算法</strong></h4>\n<p>工作窃取算法指的是在多线程执行不同任务队列的过程中，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行。</p>\n<p>工作窃取流程如下图所示：</p>\n<p><img src=\"https://gblobscdn.gitbook.com/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJw6YndJTY5WsZJH%2F工作窃取算法运行流程图.png?alt=media\" alt=\"img\" /></p>\n<p>工作窃取算法流程</p>\n<p>值得注意的是，当一个线程窃取另一个线程的时候，为了减少两个任务线程之间的竞争，我们通常使用<strong>双端队列</strong>来存储任务。被窃取的任务线程都从双端队列的<strong>头部</strong>拿任务执行，而窃取其他任务的线程从双端队列的<strong>尾部</strong>执行任务。</p>\n<p>另外，当一个线程在窃取任务时要是没有其他可用的任务了，这个线程会进入<strong>阻塞状态</strong>以等待再次“工作”。</p>\n<h4 id=\"_18-3-fork-join的具体实现\"> <strong>18.3 Fork/Join的具体实现</strong></h4>\n<p>前面我们说Fork/Join框架简单来讲就是对任务的分割与子任务的合并，所以要实现这个框架，先得有<strong>任务</strong>。在Fork/Join框架里提供了抽象类<code>ForkJoinTask</code>来实现任务。</p>\n<h5 id=\"_18-3-1-forkjointask\"> <strong>18.3.1 ForkJoinTask</strong></h5>\n<p>ForkJoinTask是一个类似普通线程的实体，但是比普通线程轻量得多。</p>\n<p><strong>fork()方法</strong>:使用线程池中的空闲线程异步提交任务</p>\n<div><pre><code><span>// 本文所有代码都引自Java 8</span>\n<span>public</span> <span>final</span> <span>ForkJoinTask</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>fork</span><span>(</span><span>)</span> <span>{</span>\n    <span>Thread</span> t<span>;</span>\n    <span>// ForkJoinWorkerThread是执行ForkJoinTask的专有线程，由ForkJoinPool管理</span>\n    <span>// 先判断当前线程是否是ForkJoin专有线程，如果是，则将任务push到当前线程所负责的队列里去</span>\n    <span>if</span> <span>(</span><span>(</span>t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>)</span> <span>instanceof</span> <span>ForkJoinWorkerThread</span><span>)</span>\n        <span>(</span><span>(</span><span>ForkJoinWorkerThread</span><span>)</span>t<span>)</span><span>.</span>workQueue<span>.</span><span>push</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    <span>else</span>\n         <span>// 如果不是则将线程加入队列</span>\n        <span>// 没有显式创建ForkJoinPool的时候走这里，提交任务到默认的common线程池中</span>\n        <span>ForkJoinPool</span><span>.</span>common<span>.</span><span>externalPush</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>其实fork()只做了一件事，那就是<strong>把任务推入当前工作线程的工作队列里</strong>。</p>\n<p><strong>join()方法</strong>：等待处理任务的线程处理完毕，获得返回值。</p>\n<p>来看下join()的源码：</p>\n<div><pre><code><span>public</span> <span>final</span> <span>V</span> <span>join</span><span>(</span><span>)</span> <span>{</span>\n    <span>int</span> s<span>;</span>\n    <span>// doJoin()方法来获取当前任务的执行状态</span>\n    <span>if</span> <span>(</span><span>(</span>s <span>=</span> <span>doJoin</span><span>(</span><span>)</span> <span>&amp;</span> DONE_MASK<span>)</span> <span>!=</span> NORMAL<span>)</span>\n        <span>// 任务异常，抛出异常</span>\n        <span>reportException</span><span>(</span>s<span>)</span><span>;</span>\n    <span>// 任务正常完成，获取返回值</span>\n    <span>return</span> <span>getRawResult</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>/**\n * doJoin()方法用来返回当前任务的执行状态\n **/</span>\n<span>private</span> <span>int</span> <span>doJoin</span><span>(</span><span>)</span> <span>{</span>\n    <span>int</span> s<span>;</span> <span>Thread</span> t<span>;</span> <span>ForkJoinWorkerThread</span> wt<span>;</span> <span>ForkJoinPool<span>.</span>WorkQueue</span> w<span>;</span>\n    <span>// 先判断任务是否执行完毕，执行完毕直接返回结果（执行状态）</span>\n    <span>return</span> <span>(</span>s <span>=</span> status<span>)</span> <span>&lt;</span> <span>0</span> <span>?</span> s <span>:</span>\n    <span>// 如果没有执行完毕，先判断是否是ForkJoinWorkThread线程</span>\n    <span>(</span><span>(</span>t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>)</span> <span>instanceof</span> <span>ForkJoinWorkerThread</span><span>)</span> <span>?</span>\n        <span>// 如果是，先判断任务是否处于工作队列顶端（意味着下一个就执行它）</span>\n        <span>// tryUnpush()方法判断任务是否处于当前工作队列顶端，是返回true</span>\n        <span>// doExec()方法执行任务</span>\n        <span>(</span>w <span>=</span> <span>(</span>wt <span>=</span> <span>(</span><span>ForkJoinWorkerThread</span><span>)</span>t<span>)</span><span>.</span>workQueue<span>)</span><span>.</span>\n        <span>// 如果是处于顶端并且任务执行完毕，返回结果</span>\n        <span>tryUnpush</span><span>(</span><span>this</span><span>)</span> <span>&amp;&amp;</span> <span>(</span>s <span>=</span> <span>doExec</span><span>(</span><span>)</span><span>)</span> <span>&lt;</span> <span>0</span> <span>?</span> s <span>:</span>\n        <span>// 如果不在顶端或者在顶端却没未执行完毕，那就调用awitJoin()执行任务</span>\n        <span>// awaitJoin()：使用自旋使任务执行完成，返回结果</span>\n        wt<span>.</span>pool<span>.</span><span>awaitJoin</span><span>(</span>w<span>,</span> <span>this</span><span>,</span> <span>0L</span><span>)</span> <span>:</span>\n    <span>// 如果不是ForkJoinWorkThread线程，执行externalAwaitDone()返回任务结果</span>\n    <span>externalAwaitDone</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>我们在之前介绍过说Thread.join()会使线程阻塞，而ForkJoinPool.join()会使线程免于阻塞，下面是ForkJoinPool.join()的流程图： <img src=\"https://firebasestorage.googleapis.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJw8LyHRE6UzozUK%2Fjoin流程图.png?generation=1551665550925818&alt=media\" alt=\"join流程图\" /></p>\n<p><strong>RecursiveAction和RecursiveTask</strong></p>\n<p>通常情况下，在创建任务的时候我们一般不直接继承ForkJoinTask，而是继承它的子类<strong>RecursiveAction</strong>和<strong>RecursiveTask</strong>。</p>\n<p>两个都是ForkJoinTask的子类，<strong>RecursiveAction可以看做是无返回值的ForkJoinTask，RecursiveRask是有返回值的ForkJoinTask</strong>。</p>\n<p>此外，两个子类都有执行主要计算的方法compute()，当然，RecursiveAction的compute()返回void，RecursiveTask的compute()有具体的返回值。</p>\n<h5 id=\"_18-3-2-forkjoinpool\"> <strong>18.3.2 ForkJoinPool</strong></h5>\n<p>ForkJoinPool是用于执行ForkJoinTask任务的执行（线程）池。</p>\n<p>ForkJoinPool管理着执行池中的线程和任务队列，此外，执行池是否还接受任务，显示线程的运行状态也是在这里处理。</p>\n<p>我们来大致看下ForkJoinPool的源码：</p>\n<div><pre><code><span>@sun.misc.Contended</span>\n<span>public</span> <span>class</span> <span>ForkJoinPool</span> <span>extends</span> <span>AbstractExecutorService</span> <span>{</span>\n    <span>// 任务队列</span>\n    <span>volatile</span> <span>WorkQueue</span><span>[</span><span>]</span> workQueues<span>;</span>   \n\n    <span>// 线程的运行状态</span>\n    <span>volatile</span> <span>int</span> runState<span>;</span>  \n\n    <span>// 创建ForkJoinWorkerThread的默认工厂，可以通过构造函数重写</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>ForkJoinWorkerThreadFactory</span> defaultForkJoinWorkerThreadFactory<span>;</span>\n\n    <span>// 公用的线程池，其运行状态不受shutdown()和shutdownNow()的影响</span>\n    <span>static</span> <span>final</span> <span>ForkJoinPool</span> common<span>;</span>\n\n    <span>// 私有构造方法，没有任何安全检查和参数校验，由makeCommonPool直接调用</span>\n    <span>// 其他构造方法都是源自于此方法</span>\n    <span>// parallelism: 并行度，</span>\n    <span>// 默认调用java.lang.Runtime.availableProcessors() 方法返回可用处理器的数量</span>\n    <span>private</span> <span>ForkJoinPool</span><span>(</span><span>int</span> parallelism<span>,</span>\n                         <span>ForkJoinWorkerThreadFactory</span> factory<span>,</span> <span>// 工作线程工厂</span>\n                         <span>UncaughtExceptionHandler</span> handler<span>,</span> <span>// 拒绝任务的handler</span>\n                         <span>int</span> mode<span>,</span> <span>// 同步模式</span>\n                         <span>String</span> workerNamePrefix<span>)</span> <span>{</span> <span>// 线程名prefix</span>\n        <span>this</span><span>.</span>workerNamePrefix <span>=</span> workerNamePrefix<span>;</span>\n        <span>this</span><span>.</span>factory <span>=</span> factory<span>;</span>\n        <span>this</span><span>.</span>ueh <span>=</span> handler<span>;</span>\n        <span>this</span><span>.</span>config <span>=</span> <span>(</span>parallelism <span>&amp;</span> SMASK<span>)</span> <span>|</span> mode<span>;</span>\n        <span>long</span> np <span>=</span> <span>(</span><span>long</span><span>)</span><span>(</span><span>-</span>parallelism<span>)</span><span>;</span> <span>// offset ctl counts</span>\n        <span>this</span><span>.</span>ctl <span>=</span> <span>(</span><span>(</span>np <span>&lt;&lt;</span> AC_SHIFT<span>)</span> <span>&amp;</span> AC_MASK<span>)</span> <span>|</span> <span>(</span><span>(</span>np <span>&lt;&lt;</span> TC_SHIFT<span>)</span> <span>&amp;</span> TC_MASK<span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h6 id=\"workqueue\"> <strong>WorkQueue</strong></h6>\n<p>双端队列，ForkJoinTask存放在这里。</p>\n<p>当工作线程在处理自己的工作队列时，会从队列尾取任务来执行（LIFO）；如果是窃取其他队列的任务时，窃取的任务位于所属任务队列的队首（FIFO）。</p>\n<p>ForkJoinPool与传统线程池最显著的区别就是它维护了一个<strong>工作队列数组</strong>（volatile WorkQueue[] workQueues，ForkJoinPool中的<strong>每个工作线程都维护着一个工作队列</strong>）。</p>\n<h6 id=\"runstate\"> <strong>runState</strong></h6>\n<p>ForkJoinPool的运行状态。<strong>SHUTDOWN</strong>状态用负数表示，其他用2的幂次表示。</p>\n<h4 id=\"_18-4-fork-join的使用\"> <strong>18.4 Fork/Join的使用</strong></h4>\n<p>上面我们说ForkJoinPool负责管理线程和任务，ForkJoinTask实现fork和join操作，所以要使用Fork/Join框架就离不开这两个类了，只是在实际开发中我们常用ForkJoinTask的子类RecursiveTask 和RecursiveAction来替代ForkJoinTask。</p>\n<p>下面我们用一个计算斐波那契数列第n项的例子来看一下Fork/Join的使用：</p>\n<blockquote>\n<p>斐波那契数列数列是一个线性递推数列，从第三项开始，每一项的值都等于前两项之和：</p>\n<p>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89······</p>\n<p>如果设f(n）为该数列的第n项（n∈N*），那么有：f(n) = f(n-1) + f(n-2)。</p>\n</blockquote>\n<div><pre><code><span>public</span> <span>class</span> <span>FibonacciTest</span> <span>{</span>\n\n    <span>class</span> <span>Fibonacci</span> <span>extends</span> <span>RecursiveTask</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>\n\n        <span>int</span> n<span>;</span>\n\n        <span>public</span> <span>Fibonacci</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>n <span>=</span> n<span>;</span>\n        <span>}</span>\n\n        <span>// 主要的实现逻辑都在compute()里</span>\n        <span>@Override</span>\n        <span>protected</span> <span>Integer</span> <span>compute</span><span>(</span><span>)</span> <span>{</span>\n            <span>// 这里先假设 n >= 0</span>\n            <span>if</span> <span>(</span>n <span>&lt;=</span> <span>1</span><span>)</span> <span>{</span>\n                <span>return</span> n<span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>// f(n-1)</span>\n                <span>Fibonacci</span> f1 <span>=</span> <span>new</span> <span>Fibonacci</span><span>(</span>n <span>-</span> <span>1</span><span>)</span><span>;</span>\n                f1<span>.</span><span>fork</span><span>(</span><span>)</span><span>;</span>\n                <span>// f(n-2)</span>\n                <span>Fibonacci</span> f2 <span>=</span> <span>new</span> <span>Fibonacci</span><span>(</span>n <span>-</span> <span>2</span><span>)</span><span>;</span>\n                f2<span>.</span><span>fork</span><span>(</span><span>)</span><span>;</span>\n                <span>// f(n) = f(n-1) + f(n-2)</span>\n                <span>return</span> f1<span>.</span><span>join</span><span>(</span><span>)</span> <span>+</span> f2<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testFib</span><span>(</span><span>)</span> <span>throws</span> <span>ExecutionException</span><span>,</span> <span>InterruptedException</span> <span>{</span>\n        <span>ForkJoinPool</span> forkJoinPool <span>=</span> <span>new</span> <span>ForkJoinPool</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"CPU核数：\"</span> <span>+</span> <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>availableProcessors</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>long</span> start <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n        <span>Fibonacci</span> fibonacci <span>=</span> <span>new</span> <span>Fibonacci</span><span>(</span><span>40</span><span>)</span><span>;</span>\n        <span>Future</span><span><span>&lt;</span><span>Integer</span><span>></span></span> future <span>=</span> forkJoinPool<span>.</span><span>submit</span><span>(</span>fibonacci<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>future<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>long</span> end <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"耗时：%d millis\"</span><span>,</span> end <span>-</span> start<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>上面例子在本机的输出：</p>\n<div><pre><code>CPU核数：<span>4</span>\n计算结果：<span>102334155</span>\n耗时：<span>9490</span> millis\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>需要注意的是，上述计算时间复杂度为<code>O(2^n)</code>，随着n的增长计算效率会越来越低，这也是上面的例子中n不敢取太大的原因。</p>\n<p>此外，也并不是所有的任务都适合Fork/Join框架，比如上面的例子任务划分过于细小反而体现不出效率，下面我们试试用普通的递归来求f(n)的值，看看是不是要比使用Fork/Join快：</p>\n<div><pre><code><span>// 普通递归，复杂度为O(2^n)</span>\n<span>public</span> <span>int</span> <span>plainRecursion</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>n <span>==</span> <span>1</span> <span>||</span> n <span>==</span> <span>2</span><span>)</span> <span>{</span>\n        <span>return</span> <span>1</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>return</span> <span>plainRecursion</span><span>(</span>n <span>-</span><span>1</span><span>)</span> <span>+</span> <span>plainRecursion</span><span>(</span>n <span>-</span> <span>2</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>testPlain</span><span>(</span><span>)</span> <span>{</span>\n    <span>long</span> start <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n    <span>int</span> result <span>=</span> <span>plainRecursion</span><span>(</span><span>40</span><span>)</span><span>;</span>\n    <span>long</span> end <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"计算结果:\"</span> <span>+</span> result<span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"耗时：%d millis\"</span><span>,</span>  end <span>-</span>start<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>普通递归的例子输出：</p>\n<div><pre><code>计算结果<span>:</span><span>102334155</span>\n耗时：<span>436</span> millis\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>通过输出可以很明显的看出来，使用普通递归的效率都要比使用Fork/Join框架要高很多。</p>\n<p>这里我们再用另一种思路来计算：</p>\n<div><pre><code><span>// 通过循环来计算，复杂度为O(n)</span>\n<span>private</span> <span>int</span> <span>computeFibonacci</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n    <span>// 假设n >= 0</span>\n    <span>if</span> <span>(</span>n <span>&lt;=</span> <span>1</span><span>)</span> <span>{</span>\n        <span>return</span> n<span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>int</span> first <span>=</span> <span>1</span><span>;</span>\n        <span>int</span> second <span>=</span> <span>1</span><span>;</span>\n        <span>int</span> third <span>=</span> <span>0</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>3</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i <span>++</span><span>)</span> <span>{</span>\n            <span>// 第三个数是前两个数之和</span>\n            third <span>=</span> first <span>+</span> second<span>;</span>\n            <span>// 前两个数右移</span>\n            first <span>=</span> second<span>;</span>\n            second <span>=</span> third<span>;</span>\n        <span>}</span>\n        <span>return</span> third<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>@Test</span>\n<span>public</span> <span>void</span> <span>testComputeFibonacci</span><span>(</span><span>)</span> <span>{</span>\n    <span>long</span> start <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n    <span>int</span> result <span>=</span> <span>computeFibonacci</span><span>(</span><span>40</span><span>)</span><span>;</span>\n    <span>long</span> end <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"计算结果:\"</span> <span>+</span> result<span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"耗时：%d millis\"</span><span>,</span>  end <span>-</span>start<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>上面例子在笔者所用电脑的输出为：</p>\n<div><pre><code>计算结果<span>:</span><span>102334155</span>\n耗时：<span>0</span> millis\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>这里耗时为0不代表没有耗时，是表明这里计算的耗时几乎可以忽略不计，大家可以在自己的电脑试试，即使是n取大很多量级的数据（注意int溢出的问题）耗时也是很短的，或者可以用System.nanoTime()统计纳秒的时间。</p>\n<p>为什么在这里普通的递归或循环效率更快呢？因为Fork/Join是使用多个线程协作来计算的，所以会有线程通信和线程切换的开销。</p>\n<p>如果要计算的任务比较简单（比如我们案例中的斐波那契数列），那当然是直接使用单线程会更快一些。但如果要计算的东西比较复杂，计算机又是多核的情况下，就可以充分利用多核CPU来提高计算速度。</p>\n<p>另外，Java 8 Stream的并行操作底层就是用到了Fork/Join框架，下一章我们将从源码及案例两方面介绍Java 8 Stream的并行操作。</p>\n<h3 id=\"_19-java-8-stream并行计算原理\"> 19 Java 8 Stream并行计算原理</h3>\n<h4 id=\"_19-1-java-8-stream简介\"> <strong>19.1 Java 8 Stream简介</strong></h4>\n<p>从Java 8 开始，我们可以使用<code>Stream</code>接口以及<strong>lambda表达式</strong>进行“流式计算”。它可以让我们对集合的操作更加简洁、更加可读、更加高效。</p>\n<p>Stream接口有非常多用于集合计算的方法，比如判空操作empty、过滤操作filter、求最max值、查找操作findFirst和findAny等等。</p>\n<h4 id=\"_19-2-stream单线程串行计算\"> <strong>19.2 Stream单线程串行计算</strong></h4>\n<p>Stream接口默认是使用串行的方式，也就是说在一个线程里执行。下面举一个例子：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>StreamDemo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Stream</span><span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>)</span>\n                <span>.</span><span>reduce</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>-></span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"%s: %d + %d = %d\"</span><span>,</span>\n                            <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> a<span>,</span> b<span>,</span> a <span>+</span> b<span>)</span><span>)</span><span>;</span>\n                    <span>return</span> a <span>+</span> b<span>;</span>\n                <span>}</span><span>)</span>\n                <span>.</span><span>ifPresent</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>我们来理解一下这个方法。首先我们用整数1~9创建了一个<code>Stream</code>。这里的Stream.of(T... values)方法是Stream接口的一个静态方法，其底层调用的是Arrays.stream(T[] array)方法。</p>\n<p>然后我们使用了<code>reduce</code>方法来计算这个集合的累加和。<code>reduce</code>方法这里做的是：从前两个元素开始，进行某种操作（我这里进行的是加法操作）后，返回一个结果，然后再拿这个结果跟第三个元素执行同样的操作，以此类推，直到最后的一个元素。</p>\n<p>我们来打印一下当前这个reduce操作的线程以及它们被操作的元素和返回的结果以及最后所有reduce方法的结果，也就代表的是数字1到9的累加和。</p>\n<blockquote>\n<p>main: 1 + 2 = 3</p>\n<p>main: 3 + 3 = 6</p>\n<p>main: 6 + 4 = 10</p>\n<p>main: 10 + 5 = 15</p>\n<p>main: 15 + 6 = 21</p>\n<p>main: 21 + 7 = 28</p>\n<p>main: 28 + 8 = 36</p>\n<p>main: 36 + 9 = 45 45</p>\n</blockquote>\n<p>可以看到，默认情况下，它是在一个单线程运行的，也就是<strong>main</strong>线程。然后每次reduce操作都是串行起来的，首先计算前两个数字的和，然后再往后依次计算。</p>\n<h4 id=\"_19-3-stream多线程并行计算\"> <strong>19.3 Stream多线程并行计算</strong></h4>\n<p>我们思考上面一个例子，是不是一定要在单线程里进行串行地计算呢？假如我的计算机是一个多核计算机，我们在理论上能否利用多核来进行并行计算，提高计算效率呢？</p>\n<p>当然可以，比如我们在计算前两个元素1 + 2 = 3的时候，其实我们也可以同时在另一个核计算 3 + 4 = 7。然后等它们都计算完成之后，再计算 3 + 7 = 10的操作。</p>\n<p>是不是很熟悉这样的操作手法？没错，它就是ForkJoin框架的思想。下面小小地修改一下上面的代码，增加一行代码，使Stream使用多线程来并行计算：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>StreamParallelDemo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Stream</span><span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>)</span>\n                <span>.</span><span>parallel</span><span>(</span><span>)</span>\n                <span>.</span><span>reduce</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>-></span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"%s: %d + %d = %d\"</span><span>,</span>\n                            <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> a<span>,</span> b<span>,</span> a <span>+</span> b<span>)</span><span>)</span><span>;</span>\n                    <span>return</span> a <span>+</span> b<span>;</span>\n                <span>}</span><span>)</span>\n                <span>.</span><span>ifPresent</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>可以看到，与上一个案例的代码只有一点点区别，就是在reduce方法被调用之前，调用了parallel()方法。下面来看看这个方法的输出：</p>\n<blockquote>\n<p>ForkJoinPool.commonPool-worker-1: 3 + 4 = 7</p>\n<p>ForkJoinPool.commonPool-worker-4: 8 + 9 = 17</p>\n<p>ForkJoinPool.commonPool-worker-2: 5 + 6 = 11</p>\n<p>ForkJoinPool.commonPool-worker-3: 1 + 2 = 3</p>\n<p>ForkJoinPool.commonPool-worker-4: 7 + 17 = 24</p>\n<p>ForkJoinPool.commonPool-worker-4: 11 + 24 = 35</p>\n<p>ForkJoinPool.commonPool-worker-3: 3 + 7 = 10</p>\n<p>ForkJoinPool.commonPool-worker-3: 10 + 35 = 45 45</p>\n</blockquote>\n<p>可以很明显地看到，它使用的线程是<code>ForkJoinPool</code>里面的<code>commonPool</code>里面的<strong>worker</strong>线程。并且它们是并行计算的，并不是串行计算的。但由于Fork/Join框架的作用，它最终能很好的协调计算结果，使得计算结果完全正确。</p>\n<p>如果我们用Fork/Join代码去实现这样一个功能，那无疑是非常复杂的。但Java8提供了并行式的流式计算，大大简化了我们的代码量，使得我们只需要写很少很简单的代码就可以利用计算机底层的多核资源。</p>\n<h4 id=\"_19-4-从源码看stream并行计算原理\"> <strong>19.4 从源码看Stream并行计算原理</strong></h4>\n<p>上面我们通过在控制台输出线程的名字，看到了Stream的并行计算底层其实是使用的Fork/Join框架。那它到底是在哪使用Fork/Join的呢？我们从源码上来解析一下上述案例。</p>\n<p><code>Stream.of</code>方法就不说了，它只是生成一个简单的Stream。先来看看<code>parallel()</code>方法的源码。这里由于我的数据是<code>int</code>类型的，所以它其实是使用的<code>BaseStream</code>接口的<code>parallel()</code>方法。而<code>BaseStream</code>接口的JDK唯一实现类是一个叫<code>AbstractPipeline</code>的类。下面我们来看看这个类的<code>parallel()</code>方法的代码：</p>\n<div><pre><code><span>public</span> <span>final</span> <span>S</span> <span>parallel</span><span>(</span><span>)</span> <span>{</span>\n    sourceStage<span>.</span>parallel <span>=</span> <span>true</span><span>;</span>\n    <span>return</span> <span>(</span><span>S</span><span>)</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这个方法很简单，就是把一个标识<code>sourceStage.parallel</code>设置为<code>true</code>。然后返回实例本身。</p>\n<p>接着我们再来看<code>reduce</code>这个方法的内部实现。</p>\n<p>Stream.reduce()方法的具体实现是交给了<code>ReferencePipeline</code>这个抽象类，它是继承了<code>AbstractPipeline</code>这个类的:</p>\n<div><pre><code><span>// ReferencePipeline抽象类的reduce方法</span>\n<span>@Override</span>\n<span>public</span> <span>final</span> <span>Optional</span><span><span>&lt;</span>P_OUT<span>></span></span> <span>reduce</span><span>(</span><span>BinaryOperator</span><span><span>&lt;</span>P_OUT<span>></span></span> accumulator<span>)</span> <span>{</span>\n    <span>// 调用evaluate方法</span>\n    <span>return</span> <span>evaluate</span><span>(</span><span>ReduceOps</span><span>.</span><span>makeRef</span><span>(</span>accumulator<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>final</span> <span><span>&lt;</span><span>R</span><span>></span></span> <span>R</span> <span>evaluate</span><span>(</span><span>TerminalOp</span><span><span>&lt;</span>E_OUT<span>,</span> <span>R</span><span>></span></span> terminalOp<span>)</span> <span>{</span>\n    <span>assert</span> <span>getOutputShape</span><span>(</span><span>)</span> <span>==</span> terminalOp<span>.</span><span>inputShape</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>linkedOrConsumed<span>)</span>\n        <span>throw</span> <span>new</span> <span>IllegalStateException</span><span>(</span>MSG_STREAM_LINKED<span>)</span><span>;</span>\n    linkedOrConsumed <span>=</span> <span>true</span><span>;</span>\n\n    <span>return</span> <span>isParallel</span><span>(</span><span>)</span> <span>// 调用isParallel()判断是否使用并行模式</span>\n        <span>?</span> terminalOp<span>.</span><span>evaluateParallel</span><span>(</span><span>this</span><span>,</span> <span>sourceSpliterator</span><span>(</span>terminalOp<span>.</span><span>getOpFlags</span><span>(</span><span>)</span><span>)</span><span>)</span>\n        <span>:</span> terminalOp<span>.</span><span>evaluateSequential</span><span>(</span><span>this</span><span>,</span> <span>sourceSpliterator</span><span>(</span>terminalOp<span>.</span><span>getOpFlags</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>@Override</span>\n<span>public</span> <span>final</span> <span>boolean</span> <span>isParallel</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 根据之前在parallel()方法设置的那个flag来判断。</span>\n    <span>return</span> sourceStage<span>.</span>parallel<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>从它的源码可以知道，reduce方法调用了evaluate方法，而evaluate方法会先去检查当前的flag，是否使用并行模式，如果是则会调用<code>evaluateParallel</code>方法执行并行计算，否则，会调用<code>evaluateSequential</code>方法执行串行计算。</p>\n<p>这里我们再看看<code>TerminalOp</code>（注意这里是字母l O，而不是数字1 0）接口的<code>evaluateParallel</code>方法。<code>TerminalOp</code>接口的实现类有这样几个内部类：</p>\n<ul>\n<li>java.util.stream.FindOps.FindOp</li>\n<li>java.util.stream.ForEachOps.ForEachOp</li>\n<li>java.util.stream.MatchOps.MatchOp</li>\n<li>java.util.stream.ReduceOps.ReduceOp</li>\n</ul>\n<p>可以看到，对应的是Stream的几种主要的计算操作。我们这里的示例代码使用的是reduce计算，那我们就看看ReduceOp类的这个方法的源码：</p>\n<div><pre><code><span>// java.util.stream.ReduceOps.ReduceOp.evaluateParallel</span>\n<span>@Override</span>\n<span>public</span> <span><span>&lt;</span>P_IN<span>></span></span> <span>R</span> <span>evaluateParallel</span><span>(</span><span>PipelineHelper</span><span><span>&lt;</span><span>T</span><span>></span></span> helper<span>,</span>\n                                 <span>Spliterator</span><span><span>&lt;</span>P_IN<span>></span></span> spliterator<span>)</span> <span>{</span>\n    <span>return</span> <span>new</span> <span>ReduceTask</span><span><span>&lt;</span><span>></span></span><span>(</span><span>this</span><span>,</span> helper<span>,</span> spliterator<span>)</span><span>.</span><span>invoke</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>evaluateParallel方法创建了一个新的ReduceTask实例，并且调用了invoke()方法后再调用get()方法，然后返回这个结果。那这个ReduceTask是什么呢？它的invoke方法内部又是什么呢？</p>\n<p>追溯源码我们可以发现，ReduceTask类是ReduceOps类的一个内部类，它继承了AbstractTask类，而AbstractTask类又继承了CountedCompleter类，而CountedCompleter类又继承了ForkJoinTask类！</p>\n<p>它们的继承关系如下：</p>\n<blockquote>\n<p>ReduceTask -&gt; AbstractTask -&gt; CountedCompleter -&gt; ForkJoinTask</p>\n</blockquote>\n<p>这里的ReduceTask的invoke方法，其实是调用的ForkJoinTask的invoke方法，中间三层继承并没有覆盖这个方法的实现。</p>\n<p>所以这就从源码层面解释了Stream并行的底层原理是使用了Fork/Join框架。</p>\n<h4 id=\"_19-5-stream并行计算的性能提升\"> <strong>19.5 Stream并行计算的性能提升</strong></h4>\n<p>我们可以在本地测试一下如果在多核情况下，Stream并行计算会给我们的程序带来多大的效率上的提升。用以下示例代码来计算一千万个随机数的和：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>StreamParallelDemo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"本计算机的核数：%d\"</span><span>,</span> <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>availableProcessors</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n\n        <span>// 产生100w个随机数(1 ~ 100)，组成列表</span>\n        <span>Random</span> random <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>1000_0000</span><span>)</span><span>;</span>\n\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>1000_0000</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            list<span>.</span><span>add</span><span>(</span>random<span>.</span><span>nextInt</span><span>(</span><span>100</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>long</span> prevTime <span>=</span> <span>getCurrentTime</span><span>(</span><span>)</span><span>;</span>\n        list<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>reduce</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>-></span> a <span>+</span> b<span>)</span><span>.</span><span>ifPresent</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"单线程计算耗时：%d\"</span><span>,</span> <span>getCurrentTime</span><span>(</span><span>)</span> <span>-</span> prevTime<span>)</span><span>)</span><span>;</span>\n\n        prevTime <span>=</span> <span>getCurrentTime</span><span>(</span><span>)</span><span>;</span>\n        list<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>parallel</span><span>(</span><span>)</span><span>.</span><span>reduce</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>-></span> a <span>+</span> b<span>)</span><span>.</span><span>ifPresent</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"多线程计算耗时：%d\"</span><span>,</span> <span>getCurrentTime</span><span>(</span><span>)</span> <span>-</span> prevTime<span>)</span><span>)</span><span>;</span>\n\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>long</span> <span>getCurrentTime</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>输出：</p>\n<blockquote>\n<p>本计算机的核数：8 495156156</p>\n<p>单线程计算耗时：223 495156156</p>\n<p>多线程计算耗时：95</p>\n</blockquote>\n<p>所以在多核的情况下，使用Stream的并行计算确实比串行计算能带来很大效率上的提升，并且也能保证结果计算完全准确。</p>\n<p>本文一直在强调的“多核”的情况。其实可以看到，我的本地电脑有8核，但并行计算耗时并不是单线程计算耗时除以8，因为线程的创建、销毁以及维护线程上下文的切换等等都有一定的开销。所以如果你的服务器并不是多核服务器，那也没必要用Stream的并行计算。因为在单核的情况下，往往Stream的串行计算比并行计算更快，因为它不需要线程切换的开销。</p>\n<h4 id=\"_20-计划任务\"> 20 计划任务</h4>\n<p>自JDK 1.5 开始，JDK提供了<code>ScheduledThreadPoolExecutor</code>类用于计划任务（又称定时任务），这个类有两个用途：</p>\n<ul>\n<li>在给定的延迟之后运行任务</li>\n<li>周期性重复执行任务</li>\n</ul>\n<p>在这之前，是使用<code>Timer</code>类来完成定时任务的，但是<code>Timer</code>有缺陷：</p>\n<ul>\n<li>Timer是<strong>单线程</strong>模式；</li>\n<li>如果在执行任务期间某个TimerTask耗时较久，那么就会影响其它任务的调度；</li>\n<li>Timer的任务调度是基于绝对时间的，对<strong>系统时间</strong>敏感；</li>\n<li>Timer不会捕获执行TimerTask时所抛出的<strong>异常</strong>，由于Timer是单线程，所以一旦出现异常，则线程就会终止，其他任务也得不到执行。</li>\n</ul>\n<p>所以JDK 1.5之后，大家就摒弃<code>Timer</code>,使用<code>ScheduledThreadPoolExecutor</code>吧。</p>\n<h4 id=\"_20-1-使用案例\"> <strong>20.1 使用案例</strong></h4>\n<p>假设我有一个需求，指定时间给大家发送消息。那么我们会将消息（包含发送时间）存储在数据库中，然后想用一个定时任务，每隔1秒检查数据库在当前时间有没有需要发送的消息，那这个计划任务怎么写？下面是一个Demo:</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadPool</span> <span>{</span>\n\n    <span>private</span> <span>static</span> <span>final</span> <span>ScheduledExecutorService</span> executor <span>=</span> <span>new</span>\n        <span>ScheduledThreadPoolExecutor</span><span>(</span><span>1</span><span>,</span> <span>Executors</span><span>.</span><span>defaultThreadFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>static</span> <span>SimpleDateFormat</span> df <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>\"yyyy-MM-dd HH:mm:ss\"</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>\n        <span>// 新建一个固定延迟时间的计划任务</span>\n        executor<span>.</span><span>scheduleWithFixedDelay</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span><span>haveMsgAtCurrentTime</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>df<span>.</span><span>format</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"大家注意了，我要发消息了\"</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>boolean</span> <span>haveMsgAtCurrentTime</span><span>(</span><span>)</span><span>{</span>\n        <span>//查询数据库，有没有当前时间需要发送的消息</span>\n        <span>//这里省略实现，直接返回true</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>下面截取前面的输出（这个demo会一直运行下去）：</p>\n<div><pre><code><span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>48</span>\n大家注意了，我要发消息了\n<span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>49</span>\n大家注意了，我要发消息了\n<span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>50</span>\n大家注意了，我要发消息了\n<span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>51</span>\n大家注意了，我要发消息了\n<span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>52</span>\n大家注意了，我要发消息了\n<span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>53</span>\n大家注意了，我要发消息了\n<span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>54</span>\n大家注意了，我要发消息了\n<span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>55</span>\n大家注意了，我要发消息了\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>这就是<code>ScheduledThreadPoolExecutor</code>的一个简单运用，想要知道奥秘，接下来的东西需要仔细的看哦。</p>\n<h4 id=\"_20-2-类结构\"> <strong>20.2 类结构</strong></h4>\n<div><pre><code><span>public</span> <span>class</span> <span>ScheduledThreadPoolExecutor</span> <span>extends</span> <span>ThreadPoolExecutor</span>\n    <span>implements</span> <span>ScheduledExecutorService</span> <span>{</span>\n\n    <span>public</span> <span>ScheduledThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span><span>ThreadFactory</span> threadFactory<span>)</span> <span>{</span>\n         <span>super</span><span>(</span>corePoolSize<span>,</span> <span>Integer</span><span>.</span>MAX_VALUE<span>,</span> <span>0</span><span>,</span> NANOSECONDS<span>,</span>\n              <span>new</span> <span>DelayedWorkQueue</span><span>(</span><span>)</span><span>,</span> threadFactory<span>)</span><span>;</span>\n    <span>}</span>\n    <span>//……</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>ScheduledThreadPoolExecutor</code>继承了<code>ThreadPoolExecutor</code>，实现了<code>ScheduledExecutorService</code>。 线程池在之前的章节介绍过了，我们先看看<code>ScheduledExecutorService</code>。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ScheduledExecutorService</span> <span>extends</span> <span>ExecutorService</span> <span>{</span>\n\n    <span>public</span> <span>ScheduledFuture</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>schedule</span><span>(</span><span>Runnable</span> command<span>,</span><span>long</span> delay<span>,</span> <span>TimeUnit</span> unit<span>)</span><span>;</span>\n\n    <span>public</span> <span><span>&lt;</span><span>V</span><span>></span></span> <span>ScheduledFuture</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>schedule</span><span>(</span><span>Callable</span><span><span>&lt;</span><span>V</span><span>></span></span> callable<span>,</span><span>long</span> delay<span>,</span> <span>TimeUnit</span> unit<span>)</span><span>;</span>\n\n    <span>public</span> <span>ScheduledFuture</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>scheduleAtFixedRate</span><span>(</span><span>Runnable</span> command<span>,</span>\n                                                  <span>long</span> initialDelay<span>,</span>\n                                                  <span>long</span> period<span>,</span>\n                                                  <span>TimeUnit</span> unit<span>)</span><span>;</span>\n\n    <span>public</span> <span>ScheduledFuture</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>scheduleWithFixedDelay</span><span>(</span><span>Runnable</span> command<span>,</span>\n                                                     <span>long</span> initialDelay<span>,</span>\n                                                     <span>long</span> delay<span>,</span>\n                                                     <span>TimeUnit</span> unit<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><code>ScheduledExecutorService</code>实现了<code>ExecutorService</code> ,并增加若干定时相关的接口。 前两个方法用于单次调度执行任务，区别是有没有返回值。</p>\n<p>重点理解一下后面两个方法：</p>\n<ul>\n<li>\n<p>scheduleAtFixedRate</p>\n<p>该方法在<code>initialDelay</code>时长后第一次执行任务，以后每隔<code>period</code>时长，再次执行任务。注意，period是从<strong>任务开始执行算起</strong>的。开始执行任务后，定时器每隔period时长<strong>检查该任务是否完成</strong>，如果完成则再次启动任务，否则等该任务结束后才再次启动任务。</p>\n</li>\n<li>\n<p>scheduleWithFixDelay</p>\n<p>该方法在<code>initialDelay</code>时长后第一次执行任务，以后每当任务执行<strong>完成后</strong>，等待<code>delay</code>时长，再次执行任务。</p>\n</li>\n</ul>\n<h4 id=\"_20-3-主要方法介绍\"> <strong>20.3 主要方法介绍</strong></h4>\n<h5 id=\"_20-3-1-schedule\"> <strong>20.3.1 schedule</strong></h5>\n<div><pre><code><span>// delay时长后执行任务command，该任务只执行一次</span>\n<span>public</span> <span>ScheduledFuture</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>schedule</span><span>(</span><span>Runnable</span> command<span>,</span> <span>long</span> delay<span>,</span> <span>TimeUnit</span> unit<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>command <span>==</span> <span>null</span> <span>||</span> unit <span>==</span> <span>null</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>\n    <span>// 这里的decorateTask方法仅仅返回第二个参数</span>\n    <span>RunnableScheduledFuture</span><span><span>&lt;</span><span>?</span><span>></span></span> t <span>=</span> <span>decorateTask</span><span>(</span>command<span>,</span>\n                                           <span>new</span> <span>ScheduledFutureTask</span><span><span>&lt;</span><span>Void</span><span>></span></span><span>(</span>command<span>,</span> <span>null</span><span>,</span> <span>triggerTime</span><span>(</span>delay<span>,</span>unit<span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>// 延时或者周期执行任务的主要方法,稍后统一说明</span>\n    <span>delayedExecute</span><span>(</span>t<span>)</span><span>;</span>\n    <span>return</span> t<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>我们先看看里面涉及到的几个类和接口<code>ScheduledFuture</code>、 <code>RunnableScheduledFuture</code>、 <code>ScheduledFutureTask</code>的关系：</p>\n<p><img src=\"https://gblobscdn.gitbook.com/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJ7niT1mpiL66sgQ%2F类图.jpg?alt=media\" alt=\"img\" /></p>\n<p>类图</p>\n<p>我们先看看这几个接口和类：</p>\n<h6 id=\"delayed接口\"> <strong>Delayed接口</strong></h6>\n<div><pre><code><span>// 继承Comparable接口，表示该类对象支持排序</span>\n<span>public</span> <span>interface</span> <span>Delayed</span> <span>extends</span> <span>Comparable</span><span><span>&lt;</span><span>Delayed</span><span>></span></span> <span>{</span>\n    <span>// 返回该对象剩余时延</span>\n    <span>long</span> <span>getDelay</span><span>(</span><span>TimeUnit</span> unit<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>Delayed</code>接口很简单，继承了<code>Comparable</code>接口，表示对象是可以比较排序的。</p>\n<h6 id=\"scheduledfuture接口\"> <strong>ScheduledFuture接口</strong></h6>\n<div><pre><code><span>// 仅仅继承了Delayed和Future接口，自己没有任何代码</span>\n<span>public</span> <span>interface</span> <span>ScheduledFuture</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>extends</span> <span>Delayed</span><span>,</span> <span>Future</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>没有添加其他方法。</p>\n<h6 id=\"runnablescheduledfuture接口\"> <strong>RunnableScheduledFuture接口</strong></h6>\n<div><pre><code><span>public</span> <span>interface</span> <span>RunnableScheduledFuture</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>extends</span> <span>RunnableFuture</span><span><span>&lt;</span><span>V</span><span>></span></span><span>,</span> <span>ScheduledFuture</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>      \n    <span>// 是否是周期任务，周期任务可被调度运行多次，非周期任务只被运行一次   </span>\n    <span>boolean</span> <span>isPeriodic</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h6 id=\"scheduledfuturetask类\"> <strong>ScheduledFutureTask类</strong></h6>\n<p>回到<code>schecule</code>方法中，它创建了一个<code>ScheduledFutureTask</code>的对象，由上面的关系图可知，<code>ScheduledFutureTask</code>直接或者间接实现了很多接口，一起看看<code>ScheduledFutureTask</code>里面的实现方法吧。</p>\n<p><strong>构造方法</strong></p>\n<div><pre><code><span>ScheduledFutureTask</span><span>(</span><span>Runnable</span> r<span>,</span> <span>V</span> result<span>,</span> <span>long</span> ns<span>,</span> <span>long</span> period<span>)</span> <span>{</span>\n    <span>// 调用父类FutureTask的构造方法</span>\n    <span>super</span><span>(</span>r<span>,</span> result<span>)</span><span>;</span>\n    <span>// time表示任务下次执行的时间</span>\n    <span>this</span><span>.</span>time <span>=</span> ns<span>;</span>\n    <span>// 周期任务，正数表示按照固定速率，负数表示按照固定时延,0表示不是周期任务</span>\n    <span>this</span><span>.</span>period <span>=</span> period<span>;</span>\n    <span>// 任务的编号</span>\n    <span>this</span><span>.</span>sequenceNumber <span>=</span> sequencer<span>.</span><span>getAndIncrement</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>Delayed接口的实现</strong></p>\n<div><pre><code><span>// 实现Delayed接口的getDelay方法，返回任务开始执行的剩余时间</span>\n<span>public</span> <span>long</span> <span>getDelay</span><span>(</span><span>TimeUnit</span> unit<span>)</span> <span>{</span>\n    <span>return</span> unit<span>.</span><span>convert</span><span>(</span>time <span>-</span> <span>now</span><span>(</span><span>)</span><span>,</span> <span>TimeUnit</span><span>.</span>NANOSECONDS<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>Comparable接口的实现</strong></p>\n<div><pre><code><span>// Comparable接口的compareTo方法，比较两个任务的”大小”。</span>\n<span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>Delayed</span> other<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>other <span>==</span> <span>this</span><span>)</span>\n      <span>return</span> <span>0</span><span>;</span>\n    <span>if</span> <span>(</span>other <span>instanceof</span> <span>ScheduledFutureTask</span><span>)</span> <span>{</span>\n      <span>ScheduledFutureTask</span><span><span>&lt;</span><span>?</span><span>></span></span> x <span>=</span> <span>(</span><span>ScheduledFutureTask</span><span><span>&lt;</span><span>?</span><span>></span></span><span>)</span>other<span>;</span>\n      <span>long</span> diff <span>=</span> time <span>-</span> x<span>.</span>time<span>;</span>\n      <span>// 小于0，说明当前任务的执行时间点早于other，要排在延时队列other的前面</span>\n      <span>if</span> <span>(</span>diff <span>&lt;</span> <span>0</span><span>)</span>\n        <span>return</span> <span>-</span><span>1</span><span>;</span>\n      <span>// 大于0，说明当前任务的执行时间点晚于other，要排在延时队列other的后面</span>\n      <span>else</span> <span>if</span> <span>(</span>diff <span>></span> <span>0</span><span>)</span>\n        <span>return</span> <span>1</span><span>;</span>\n      <span>// 如果两个任务的执行时间点一样，比较两个任务的编号，编号小的排在队列前面，编号大的排在队列后面</span>\n      <span>else</span> <span>if</span> <span>(</span>sequenceNumber <span>&lt;</span> x<span>.</span>sequenceNumber<span>)</span>\n        <span>return</span> <span>-</span><span>1</span><span>;</span>\n      <span>else</span>\n        <span>return</span> <span>1</span><span>;</span>\n    <span>}</span>\n    <span>// 如果任务类型不是ScheduledFutureTask，通过getDelay方法比较</span>\n    <span>long</span> d <span>=</span> <span>(</span><span>getDelay</span><span>(</span><span>TimeUnit</span><span>.</span>NANOSECONDS<span>)</span> <span>-</span>\n              other<span>.</span><span>getDelay</span><span>(</span><span>TimeUnit</span><span>.</span>NANOSECONDS<span>)</span><span>)</span><span>;</span>\n    <span>return</span> <span>(</span>d <span>==</span> <span>0</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span><span>(</span>d <span>&lt;</span> <span>0</span><span>)</span> <span>?</span> <span>-</span><span>1</span> <span>:</span> <span>1</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>setNextRunTime</strong></p>\n<div><pre><code><span>// 任务执行完后，设置下次执行的时间</span>\n<span>private</span> <span>void</span> <span>setNextRunTime</span><span>(</span><span>)</span> <span>{</span>\n    <span>long</span> p <span>=</span> period<span>;</span>\n    <span>// p > 0，说明是固定速率运行的任务</span>\n    <span>// 在原来任务开始执行时间的基础上加上p即可</span>\n    <span>if</span> <span>(</span>p <span>></span> <span>0</span><span>)</span>\n      time <span>+=</span> p<span>;</span>\n    <span>// p &lt; 0，说明是固定时延运行的任务，</span>\n    <span>// 下次执行时间在当前时间(任务执行完成的时间)的基础上加上-p的时间</span>\n    <span>else</span>\n      time <span>=</span> <span>triggerTime</span><span>(</span><span>-</span>p<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>Runnable接口实现</strong></p>\n<div><pre><code><span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n    <span>boolean</span> periodic <span>=</span> <span>isPeriodic</span><span>(</span><span>)</span><span>;</span>\n    <span>// 如果当前状态下不能执行任务，则取消任务</span>\n    <span>if</span> <span>(</span><span>!</span><span>canRunInCurrentRunState</span><span>(</span>periodic<span>)</span><span>)</span>\n      <span>cancel</span><span>(</span><span>false</span><span>)</span><span>;</span>\n    <span>// 不是周期性任务，执行一次任务即可，调用父类的run方法</span>\n    <span>else</span> <span>if</span> <span>(</span><span>!</span>periodic<span>)</span>\n      <span>ScheduledFutureTask</span><span>.</span><span>super</span><span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n    <span>// 是周期性任务，调用FutureTask的runAndReset方法，方法执行完成后</span>\n    <span>// 重新设置任务下一次执行的时间，并将该任务重新入队，等待再次被调度</span>\n    <span>else</span> <span>if</span> <span>(</span><span>ScheduledFutureTask</span><span>.</span><span>super</span><span>.</span><span>runAndReset</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>setNextRunTime</span><span>(</span><span>)</span><span>;</span>\n      <span>reExecutePeriodic</span><span>(</span>outerTask<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>总结一下run方法的执行过程：</p>\n<ol>\n<li>如果当前线程池运行状态不可以执行任务，取消该任务，然后直接返回，否则执行步骤2；</li>\n<li>如果不是周期性任务，调用FutureTask中的run方法执行，会设置执行结果，然后直接返回，否则执行步骤3；</li>\n<li>如果是周期性任务，调用FutureTask中的runAndReset方法执行，不会设置执行结果，然后直接返回，否则执行步骤4和步骤5；</li>\n<li>计算下次执行该任务的具体时间；</li>\n<li>重复执行任务。</li>\n</ol>\n<p><code>runAndReset</code>方法是为任务多次执行而设计的。<code>runAndReset</code>方法执行完任务后不会设置任务的执行结果，也不会去更新任务的状态，维持任务的状态为初始状态（<strong>NEW</strong>状态），这也是该方法和<code>FutureTask</code>的<code>run</code>方法的区别。</p>\n<h5 id=\"_20-3-2-scheduledatfixedrate\"> <strong>20.3.2 scheduledAtFixedRate</strong></h5>\n<p>我们看一下代码：</p>\n<div><pre><code><span>// 注意，固定速率和固定时延，传入的参数都是Runnable，也就是说这种定时任务是没有返回值的</span>\n<span>public</span> <span>ScheduledFuture</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>scheduleAtFixedRate</span><span>(</span><span>Runnable</span> command<span>,</span>\n                                                  <span>long</span> initialDelay<span>,</span>\n                                                  <span>long</span> period<span>,</span>\n                                                  <span>TimeUnit</span> unit<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>command <span>==</span> <span>null</span> <span>||</span> unit <span>==</span> <span>null</span><span>)</span>\n      <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>period <span>&lt;=</span> <span>0</span><span>)</span>\n      <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>\n    <span>// 创建一个有初始延时和固定周期的任务</span>\n    <span>ScheduledFutureTask</span><span><span>&lt;</span><span>Void</span><span>></span></span> sft <span>=</span>\n      <span>new</span> <span>ScheduledFutureTask</span><span><span>&lt;</span><span>Void</span><span>></span></span><span>(</span>command<span>,</span>\n                                    <span>null</span><span>,</span>\n                                    <span>triggerTime</span><span>(</span>initialDelay<span>,</span> unit<span>)</span><span>,</span>\n                                    unit<span>.</span><span>toNanos</span><span>(</span>period<span>)</span><span>)</span><span>;</span>\n    <span>RunnableScheduledFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> t <span>=</span> <span>decorateTask</span><span>(</span>command<span>,</span> sft<span>)</span><span>;</span>\n    <span>// outerTask表示将会重新入队的任务</span>\n    sft<span>.</span>outerTask <span>=</span> t<span>;</span>\n    <span>// 稍后说明</span>\n    <span>delayedExecute</span><span>(</span>t<span>)</span><span>;</span>\n    <span>return</span> t<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><code>scheduleAtFixedRate</code>这个方法和<code>schedule</code>类似，不同点是<code>scheduleAtFixedRate</code>方法内部创建的是<code>ScheduledFutureTask</code>，带有初始延时和固定周期的任务 。</p>\n<h5 id=\"_20-3-3-scheduledatfixeddelay\"> <strong>20.3.3 scheduledAtFixedDelay</strong></h5>\n<p><code>FixedDelay</code>也是通过<code>ScheduledFutureTask</code>体现的，唯一不同的地方在于创建的<code>ScheduledFutureTask</code>不同 。这里不再展示源码。</p>\n<h5 id=\"_20-3-4-delayedexecute\"> <strong>20.3.4 delayedExecute</strong></h5>\n<p>前面讲到的<code>schedule</code>、<code>scheduleAtFixedRate</code>和<code>scheduleAtFixedDelay</code>最后都调用了<code>delayedExecute</code>方法，该方法是定时任务执行的主要方法。 一起来看看源码：</p>\n<div><pre><code><span>private</span> <span>void</span> <span>delayedExecute</span><span>(</span><span>RunnableScheduledFuture</span><span><span>&lt;</span><span>?</span><span>></span></span> task<span>)</span> <span>{</span>\n    <span>// 线程池已经关闭，调用拒绝执行处理器处理</span>\n    <span>if</span> <span>(</span><span>isShutdown</span><span>(</span><span>)</span><span>)</span>\n      <span>reject</span><span>(</span>task<span>)</span><span>;</span>\n    <span>else</span> <span>{</span>\n      <span>// 将任务加入到等待队列</span>\n      <span>super</span><span>.</span><span>getQueue</span><span>(</span><span>)</span><span>.</span><span>add</span><span>(</span>task<span>)</span><span>;</span>\n      <span>// 线程池已经关闭，且当前状态不能运行该任务，将该任务从等待队列移除并取消该任务</span>\n      <span>if</span> <span>(</span><span>isShutdown</span><span>(</span><span>)</span> <span>&amp;&amp;</span>\n          <span>!</span><span>canRunInCurrentRunState</span><span>(</span>task<span>.</span><span>isPeriodic</span><span>(</span><span>)</span><span>)</span> <span>&amp;&amp;</span>\n          <span>remove</span><span>(</span>task<span>)</span><span>)</span>\n        task<span>.</span><span>cancel</span><span>(</span><span>false</span><span>)</span><span>;</span>\n      <span>else</span>\n        <span>// 增加一个worker，就算corePoolSize=0也要增加一个worker</span>\n        <span>ensurePrestart</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><code>delayedExecute</code>方法的逻辑也很简单，主要就是将任务添加到等待队列，然后调用<code>ensurePrestart</code>方法。</p>\n<div><pre><code><span>void</span> <span>ensurePrestart</span><span>(</span><span>)</span> <span>{</span>\n    <span>int</span> wc <span>=</span> <span>workerCountOf</span><span>(</span>ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>wc <span>&lt;</span> corePoolSize<span>)</span>\n        <span>addWorker</span><span>(</span><span>null</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n    <span>else</span> <span>if</span> <span>(</span>wc <span>==</span> <span>0</span><span>)</span>\n        <span>addWorker</span><span>(</span><span>null</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>ensurePrestart</code>方法主要是调用了<code>addWorker</code>，线程池中的工作线程是通过该方法来启动并执行任务的。 具体可以查看前面讲的线程池章节。</p>\n<p>对于<code>ScheduledThreadPoolExecutor</code>，<code>worker</code>添加到线程池后会在等待队列上等待获取任务，这点是和<code>ThreadPoolExecutor</code>一致的。<strong>但是worker是怎么从等待队列取定时任务的？</strong></p>\n<p>因为<code>ScheduledThreadPoolExecutor</code>使用了<code>DelayedWorkQueue</code>保存等待的任务，该等待队列队首应该保存的是最近将要执行的任务，如果队首任务的开始执行时间还未到，<code>worker</code>也应该继续等待。</p>\n<h4 id=\"_20-4-delayedworkqueue\"> <strong>20.4 DelayedWorkQueue</strong></h4>\n<p><code>ScheduledThreadPoolExecutor</code>使用了<code>DelayedWorkQueue</code>保存等待的任务。</p>\n<p>该等待队列队首应该保存的是<strong>最近将要执行的任务</strong>，所以<code>worker</code>只关心队首任务即可，如果队首任务的开始执行时间还未到，worker也应该继续等待。</p>\n<p>DelayedWorkQueue是一个无界优先队列，使用数组存储，底层是使用堆结构来实现优先队列的功能。我们先看看DelayedWorkQueue的声明和成员变量：</p>\n<div><pre><code><span>static</span> <span>class</span> <span>DelayedWorkQueue</span> <span>extends</span> <span>AbstractQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span>\n<span>implements</span> <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> <span>{</span>\n    <span>// 队列初始容量</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> INITIAL_CAPACITY <span>=</span> <span>16</span><span>;</span>\n    <span>// 数组用来存储定时任务，通过数组实现堆排序</span>\n    <span>private</span> <span>RunnableScheduledFuture</span><span>[</span><span>]</span> queue <span>=</span> <span>new</span> <span>RunnableScheduledFuture</span><span>[</span>INITIAL_CAPACITY<span>]</span><span>;</span>\n    <span>// 当前在队首等待的线程</span>\n    <span>private</span> <span>Thread</span> leader <span>=</span> <span>null</span><span>;</span>\n    <span>// 锁和监视器，用于leader线程</span>\n    <span>private</span> <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>)</span><span>;</span>\n    <span>private</span> <span>final</span> <span>Condition</span> available <span>=</span> lock<span>.</span><span>newCondition</span><span>(</span><span>)</span><span>;</span>\n    <span>// 其他代码，略</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>当一个线程成为leader，它只要等待队首任务的delay时间即可，其他线程会无条件等待。leader取到任务返回前要通知其他线程，直到有线程成为新的leader。每当队首的定时任务被其他更早需要执行的任务替换时，leader设置为null，其他等待的线程（被当前leader通知）和当前的leader重新竞争成为leader。</p>\n<p>同时，定义了锁lock和监视器available用于线程竞争成为leader。</p>\n<p>当一个新的任务成为队首，或者需要有新的线程成为leader时，available监视器上的线程将会被通知，然后竞争称为leader线程。 有些类似于生产者-消费者模式。</p>\n<p>接下来看看<code>DelayedWorkQueue</code>中几个比较重要的方法</p>\n<h5 id=\"_20-4-1-take\"> <strong>20.4.1 take</strong></h5>\n<div><pre><code><span>public</span> <span>RunnableScheduledFuture</span> <span>take</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>\n    lock<span>.</span><span>lockInterruptibly</span><span>(</span><span>)</span><span>;</span>\n    <span>try</span> <span>{</span>\n      <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n        <span>// 取堆顶的任务，堆顶是最近要执行的任务</span>\n        <span>RunnableScheduledFuture</span> first <span>=</span> queue<span>[</span><span>0</span><span>]</span><span>;</span>\n        <span>// 堆顶为空，线程要在条件available上等待</span>\n        <span>if</span> <span>(</span>first <span>==</span> <span>null</span><span>)</span>\n          available<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n        <span>else</span> <span>{</span>\n          <span>// 堆顶任务还要多长时间才能执行</span>\n          <span>long</span> delay <span>=</span> first<span>.</span><span>getDelay</span><span>(</span><span>TimeUnit</span><span>.</span>NANOSECONDS<span>)</span><span>;</span>\n          <span>// 堆顶任务已经可以执行了，finishPoll会重新调整堆，使其满足最小堆特性，该方法设置任务在</span>\n          <span>// 堆中的index为-1并返回该任务</span>\n          <span>if</span> <span>(</span>delay <span>&lt;=</span> <span>0</span><span>)</span>\n            <span>return</span> <span>finishPoll</span><span>(</span>first<span>)</span><span>;</span>\n          <span>// 如果leader不为空，说明已经有线程成为leader并等待堆顶任务</span>\n          <span>// 到达执行时间，此时，其他线程都需要在available条件上等待</span>\n          <span>else</span> <span>if</span> <span>(</span>leader <span>!=</span> <span>null</span><span>)</span>\n            available<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n          <span>else</span> <span>{</span>\n            <span>// leader为空，当前线程成为新的leader</span>\n            <span>Thread</span> thisThread <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>\n            leader <span>=</span> thisThread<span>;</span>\n            <span>try</span> <span>{</span>\n              <span>// 当前线程已经成为leader了，只需要等待堆顶任务到达执行时间即可</span>\n              available<span>.</span><span>awaitNanos</span><span>(</span>delay<span>)</span><span>;</span>\n            <span>}</span> <span>finally</span> <span>{</span>\n              <span>// 返回堆顶元素之前将leader设置为空</span>\n              <span>if</span> <span>(</span>leader <span>==</span> thisThread<span>)</span>\n                leader <span>=</span> <span>null</span><span>;</span>\n            <span>}</span>\n          <span>}</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n      <span>// 通知其他在available条件等待的线程，这些线程可以去竞争成为新的leader</span>\n      <span>if</span> <span>(</span>leader <span>==</span> <span>null</span> <span>&amp;&amp;</span> queue<span>[</span><span>0</span><span>]</span> <span>!=</span> <span>null</span><span>)</span>\n        available<span>.</span><span>signal</span><span>(</span><span>)</span><span>;</span>\n      lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p><code>take</code>方法是什么时候调用的呢？在线程池的章节中，介绍了<code>getTask</code>方法，工作线程会循环地从<code>workQueue</code>中取任务。但计划任务却不同，因为如果一旦<code>getTask</code>方法取出了任务就开始执行了，而这时可能还没有到执行的时间，所以在<code>take</code>方法中，要保证只有在到指定的执行时间的时候任务才可以被取走。</p>\n<p>总结一下流程：</p>\n<ol>\n<li>如果堆顶元素为空，在available条件上等待。</li>\n<li>如果堆顶任务的执行时间已到，将堆顶元素替换为堆的最后一个元素并调整堆使其满足<strong>最小堆</strong>特性，同时设置任务在堆中索引为-1，返回该任务。</li>\n<li>如果leader不为空，说明已经有线程成为leader了，其他线程都要在available监视器上等待。</li>\n<li>如果leader为空，当前线程成为新的leader，并等待直到堆顶任务执行时间到达。</li>\n<li>take方法返回之前，将leader设置为空，并通知其他线程。</li>\n</ol>\n<p>再来说一下leader的作用，这里的leader是<strong>为了减少不必要的定时等待</strong>，当一个线程成为leader时，它只等待下一个节点的时间间隔，但其它线程无限期等待。 leader线程必须在从<code>take()</code>或<code>poll()</code>返回之前signal其它线程，除非其他线程成为了leader。</p>\n<p>举例来说，如果没有leader，那么在执行take时，都要执行<code>available.awaitNanos(delay)</code>，假设当前线程执行了该段代码，这时还没有signal，第二个线程也执行了该段代码，则第二个线程也要被阻塞。但只有一个线程返回队首任务，其他的线程在<code>awaitNanos(delay)</code>之后，继续执行for循环，因为队首任务已经被返回了，所以这个时候的for循环拿到的队首任务是新的，又需要重新判断时间，又要继续阻塞。</p>\n<p>所以，为了不让多个线程频繁的做无用的定时等待，这里增加了leader，如果leader不为空，则说明队列中第一个节点已经在等待出队，这时其它的线程会一直阻塞，减少了无用的阻塞（注意，在<code>finally</code>中调用了<code>signal()</code>来唤醒一个线程，而不是<code>signalAll()</code>）。</p>\n<h5 id=\"_20-4-2-offer\"> <strong>20.4.2 offer</strong></h5>\n<p>该方法往队列插入一个值，返回是否成功插入 。</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>offer</span><span>(</span><span>Runnable</span> x<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>x <span>==</span> <span>null</span><span>)</span>\n      <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>\n    <span>RunnableScheduledFuture</span> e <span>=</span> <span>(</span><span>RunnableScheduledFuture</span><span>)</span>x<span>;</span>\n    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>\n    lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n    <span>try</span> <span>{</span>\n      <span>int</span> i <span>=</span> size<span>;</span>\n      <span>// 队列元素已经大于等于数组的长度，需要扩容，新堆的容易是原来堆容量的1.5倍</span>\n      <span>if</span> <span>(</span>i <span>>=</span> queue<span>.</span>length<span>)</span>\n        <span>grow</span><span>(</span><span>)</span><span>;</span>\n      <span>// 堆中元素增加1</span>\n      size <span>=</span> i <span>+</span> <span>1</span><span>;</span>\n      <span>// 调整堆</span>\n      <span>if</span> <span>(</span>i <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        queue<span>[</span><span>0</span><span>]</span> <span>=</span> e<span>;</span>\n        <span>setIndex</span><span>(</span>e<span>,</span> <span>0</span><span>)</span><span>;</span>\n      <span>}</span> <span>else</span> <span>{</span>\n          <span>// 调整堆，使的满足最小堆，比较大小的方式就是上文提到的compareTo方法</span>\n        <span>siftUp</span><span>(</span>i<span>,</span> e<span>)</span><span>;</span>\n      <span>}</span>\n      <span>if</span> <span>(</span>queue<span>[</span><span>0</span><span>]</span> <span>==</span> e<span>)</span> <span>{</span>\n        leader <span>=</span> <span>null</span><span>;</span>\n        <span>// 通知其他在available条件上等待的线程，这些线程可以竞争成为新的leader</span>\n        available<span>.</span><span>signal</span><span>(</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n      lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>true</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>在堆中插入了一个节点，这个时候堆有可能不满足最小堆的定义，<code>siftUp</code>用于将堆调整为最小堆，这属于数据结构的基本内容，本文不做介绍。</p>\n<h4 id=\"_20-5-总结\"> <strong>20.5 总结</strong></h4>\n<p>内部使用优化的DelayQueue来实现，由于使用队列来实现定时器，有出入队调整堆等操作，所以定时并不是非常非常精确。</p>\n",
      "image": "https://gblobscdn.gitbook.com/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJM1VhwmwbNGzqwJ%2F%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png?alt=media",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "HashMap 简介",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/",
      "content_html": "<h2 id=\"hashmap-简介\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap?id=hashmap-%E7%AE%80%E4%BB%8B\" target=\"_blank\" rel=\"noopener noreferrer\">HashMap 简介</a></h2>\n<p>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。</p>\n<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间，具体可以参考 <code>treeifyBin</code>方法。</p>\n<h2 id=\"底层数据结构分析\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap?id=%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90\" target=\"_blank\" rel=\"noopener noreferrer\">底层数据结构分析</a></h2>\n<h3 id=\"jdk1-8之前\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap?id=jdk18%E4%B9%8B%E5%89%8D\" target=\"_blank\" rel=\"noopener noreferrer\">JDK1.8之前</a></h3>\n<p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>\n<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>\n<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>\n<p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>\n<div><pre><code>      <span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n        <span>int</span> h<span>;</span>\n        <span>// key.hashCode()：返回散列值也就是hashcode</span>\n        <span>// ^ ：按位异或</span>\n        <span>// >>>:无符号右移，忽略符号位，空位都以0补齐</span>\n        <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span>\n    <span>}</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p>\n<div><pre><code><span>static</span> <span>int</span> <span>hash</span><span>(</span><span>int</span> h<span>)</span> <span>{</span>\n    <span>// This function ensures that hashCodes that differ only by</span>\n    <span>// constant multiples at each bit position have a bounded</span>\n    <span>// number of collisions (approximately 8 at default load factor).</span>\n\n    h <span>^=</span> <span>(</span>h <span>>>></span> <span>20</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>12</span><span>)</span><span>;</span>\n    <span>return</span> h <span>^</span> <span>(</span>h <span>>>></span> <span>7</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>4</span><span>)</span><span>;</span>\n<span>}</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>\n<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/jdk1.8之前的内部结构.png\" alt=\"jdk1.8之前的内部结构\" /></p>\n<h3 id=\"jdk1-8之后\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap?id=jdk18%E4%B9%8B%E5%90%8E\" target=\"_blank\" rel=\"noopener noreferrer\">JDK1.8之后</a></h3>\n<p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/67233764.jpg\" alt=\"JDK1.8之后的HashMap底层数据结构\" /></p>\n<p><strong>类的属性：</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>HashMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>AbstractMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>implements</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>,</span> <span>Cloneable</span><span>,</span> <span>Serializable</span> <span>{</span>\n    <span>// 序列号</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>362498820763181265L</span><span>;</span>    \n    <span>// 默认的初始容量是16</span>\n    <span>static</span> <span>final</span> <span>int</span> DEFAULT_INITIAL_CAPACITY <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>4</span><span>;</span>   \n    <span>// 最大容量</span>\n    <span>static</span> <span>final</span> <span>int</span> MAXIMUM_CAPACITY <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>30</span><span>;</span> \n    <span>// 默认的填充因子</span>\n    <span>static</span> <span>final</span> <span>float</span> DEFAULT_LOAD_FACTOR <span>=</span> <span>0.75f</span><span>;</span>\n    <span>// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>\n    <span>static</span> <span>final</span> <span>int</span> TREEIFY_THRESHOLD <span>=</span> <span>8</span><span>;</span> \n    <span>// 当桶(bucket)上的结点数小于这个值时树转链表</span>\n    <span>static</span> <span>final</span> <span>int</span> UNTREEIFY_THRESHOLD <span>=</span> <span>6</span><span>;</span>\n    <span>// 桶中结构转化为红黑树对应的table的最小大小</span>\n    <span>static</span> <span>final</span> <span>int</span> MIN_TREEIFY_CAPACITY <span>=</span> <span>64</span><span>;</span>\n    <span>// 存储元素的数组，总是2的幂次倍</span>\n    <span>transient</span> <span>Node</span><span><span>&lt;</span>k<span>,</span>v<span>></span></span><span>[</span><span>]</span> table<span>;</span> \n    <span>// 存放具体元素的集</span>\n    <span>transient</span> <span>Set</span><span><span>&lt;</span>map<span>.</span>entry<span>&lt;</span>k<span>,</span>v<span>></span><span>></span></span> entrySet<span>;</span>\n    <span>// 存放元素的个数，注意这个不等于数组的长度。</span>\n    <span>transient</span> <span>int</span> size<span>;</span>\n    <span>// 每次扩容和更改map结构的计数器</span>\n    <span>transient</span> <span>int</span> modCount<span>;</span>   \n    <span>// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>\n    <span>int</span> threshold<span>;</span>\n    <span>// 加载因子</span>\n    <span>final</span> <span>float</span> loadFactor<span>;</span>\n<span>}</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><ul>\n<li>\n<p><strong>loadFactor加载因子</strong></p>\n<p>loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>\n<p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p>\n<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>\n</li>\n<li>\n<p><strong>threshold</strong></p>\n<p><strong>threshold = capacity * loadFactor</strong>，<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>\n</li>\n</ul>\n<p><strong>Node节点类源码:</strong></p>\n<div><pre><code><span>// 继承自 Map.Entry&lt;K,V></span>\n<span>static</span> <span>class</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>implements</span> <span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>{</span>\n       <span>final</span> <span>int</span> hash<span>;</span><span>// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>\n       <span>final</span> <span>K</span> key<span>;</span><span>//键</span>\n       <span>V</span> value<span>;</span><span>//值</span>\n       <span>// 指向下一个节点</span>\n       <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>;</span>\n       <span>Node</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>hash <span>=</span> hash<span>;</span>\n            <span>this</span><span>.</span>key <span>=</span> key<span>;</span>\n            <span>this</span><span>.</span>value <span>=</span> value<span>;</span>\n            <span>this</span><span>.</span>next <span>=</span> next<span>;</span>\n        <span>}</span>\n        <span>public</span> <span>final</span> <span>K</span> <span>getKey</span><span>(</span><span>)</span>        <span>{</span> <span>return</span> key<span>;</span> <span>}</span>\n        <span>public</span> <span>final</span> <span>V</span> <span>getValue</span><span>(</span><span>)</span>      <span>{</span> <span>return</span> value<span>;</span> <span>}</span>\n        <span>public</span> <span>final</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span> <span>return</span> key <span>+</span> <span>\"=\"</span> <span>+</span> value<span>;</span> <span>}</span>\n        <span>// 重写hashCode()方法</span>\n        <span>public</span> <span>final</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>Objects</span><span>.</span><span>hashCode</span><span>(</span>key<span>)</span> <span>^</span> <span>Objects</span><span>.</span><span>hashCode</span><span>(</span>value<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>public</span> <span>final</span> <span>V</span> <span>setValue</span><span>(</span><span>V</span> newValue<span>)</span> <span>{</span>\n            <span>V</span> oldValue <span>=</span> value<span>;</span>\n            value <span>=</span> newValue<span>;</span>\n            <span>return</span> oldValue<span>;</span>\n        <span>}</span>\n        <span>// 重写 equals() 方法</span>\n        <span>public</span> <span>final</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>o <span>==</span> <span>this</span><span>)</span>\n                <span>return</span> <span>true</span><span>;</span>\n            <span>if</span> <span>(</span>o <span>instanceof</span> <span>Map<span>.</span>Entry</span><span>)</span> <span>{</span>\n                <span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>?</span><span>,</span><span>?</span><span>></span></span> e <span>=</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>?</span><span>,</span><span>?</span><span>></span></span><span>)</span>o<span>;</span>\n                <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>equals</span><span>(</span>key<span>,</span> e<span>.</span><span>getKey</span><span>(</span><span>)</span><span>)</span> <span>&amp;&amp;</span>\n                    <span>Objects</span><span>.</span><span>equals</span><span>(</span>value<span>,</span> e<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>)</span>\n                    <span>return</span> <span>true</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n<span>}</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p><strong>树节点类源码:</strong></p>\n<div><pre><code><span>static</span> <span>final</span> <span>class</span> <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>LinkedHashMap<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>{</span>\n        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> parent<span>;</span>  <span>// 父</span>\n        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> left<span>;</span>    <span>// 左</span>\n        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> right<span>;</span>   <span>// 右</span>\n        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> prev<span>;</span>    <span>// needed to unlink next upon deletion</span>\n        <span>boolean</span> red<span>;</span>           <span>// 判断颜色</span>\n        <span>TreeNode</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> val<span>,</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>)</span> <span>{</span>\n            <span>super</span><span>(</span>hash<span>,</span> key<span>,</span> val<span>,</span> next<span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 返回根节点</span>\n        <span>final</span> <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>root</span><span>(</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> r <span>=</span> <span>this</span><span>,</span> p<span>;</span><span>;</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span><span>(</span>p <span>=</span> r<span>.</span>parent<span>)</span> <span>==</span> <span>null</span><span>)</span>\n                    <span>return</span> r<span>;</span>\n                r <span>=</span> p<span>;</span>\n       <span>}</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"hashmap源码分析\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap?id=hashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\" target=\"_blank\" rel=\"noopener noreferrer\">HashMap源码分析</a></h2>\n<h3 id=\"构造方法\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap?id=%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener noreferrer\">构造方法</a></h3>\n<p>HashMap 中有四个构造方法，它们分别如下：</p>\n<div><pre><code>    <span>// 默认构造函数。</span>\n    <span>public</span> <span>HashMap</span><span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>loadFactor <span>=</span> DEFAULT_LOAD_FACTOR<span>;</span> <span>// all   other fields defaulted</span>\n     <span>}</span>\n\n     <span>// 包含另一个“Map”的构造函数</span>\n     <span>public</span> <span>HashMap</span><span>(</span><span>Map</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> m<span>)</span> <span>{</span>\n         <span>this</span><span>.</span>loadFactor <span>=</span> DEFAULT_LOAD_FACTOR<span>;</span>\n         <span>putMapEntries</span><span>(</span>m<span>,</span> <span>false</span><span>)</span><span>;</span><span>//下面会分析到这个方法</span>\n     <span>}</span>\n\n     <span>// 指定“容量大小”的构造函数</span>\n     <span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>\n         <span>this</span><span>(</span>initialCapacity<span>,</span> DEFAULT_LOAD_FACTOR<span>)</span><span>;</span>\n     <span>}</span>\n\n     <span>// 指定“容量大小”和“加载因子”的构造函数</span>\n     <span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>,</span> <span>float</span> loadFactor<span>)</span> <span>{</span>\n         <span>if</span> <span>(</span>initialCapacity <span>&lt;</span> <span>0</span><span>)</span>\n             <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal initial capacity: \"</span> <span>+</span> initialCapacity<span>)</span><span>;</span>\n         <span>if</span> <span>(</span>initialCapacity <span>></span> MAXIMUM_CAPACITY<span>)</span>\n             initialCapacity <span>=</span> MAXIMUM_CAPACITY<span>;</span>\n         <span>if</span> <span>(</span>loadFactor <span>&lt;=</span> <span>0</span> <span>||</span> <span>Float</span><span>.</span><span>isNaN</span><span>(</span>loadFactor<span>)</span><span>)</span>\n             <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal load factor: \"</span> <span>+</span> loadFactor<span>)</span><span>;</span>\n         <span>this</span><span>.</span>loadFactor <span>=</span> loadFactor<span>;</span>\n         <span>this</span><span>.</span>threshold <span>=</span> <span>tableSizeFor</span><span>(</span>initialCapacity<span>)</span><span>;</span>\n     <span>}</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><strong>putMapEntries方法：</strong></p>\n<div><pre><code><span>final</span> <span>void</span> <span>putMapEntries</span><span>(</span><span>Map</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> m<span>,</span> <span>boolean</span> evict<span>)</span> <span>{</span>\n    <span>int</span> s <span>=</span> m<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>s <span>></span> <span>0</span><span>)</span> <span>{</span>\n        <span>// 判断table是否已经初始化</span>\n        <span>if</span> <span>(</span>table <span>==</span> <span>null</span><span>)</span> <span>{</span> <span>// pre-size</span>\n            <span>// 未初始化，s为m的实际元素个数</span>\n            <span>float</span> ft <span>=</span> <span>(</span><span>(</span><span>float</span><span>)</span>s <span>/</span> loadFactor<span>)</span> <span>+</span> <span>1.0F</span><span>;</span>\n            <span>int</span> t <span>=</span> <span>(</span><span>(</span>ft <span>&lt;</span> <span>(</span><span>float</span><span>)</span>MAXIMUM_CAPACITY<span>)</span> <span>?</span>\n                    <span>(</span><span>int</span><span>)</span>ft <span>:</span> MAXIMUM_CAPACITY<span>)</span><span>;</span>\n            <span>// 计算得到的t大于阈值，则初始化阈值</span>\n            <span>if</span> <span>(</span>t <span>></span> threshold<span>)</span>\n                threshold <span>=</span> <span>tableSizeFor</span><span>(</span>t<span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 已初始化，并且m元素个数大于阈值，进行扩容处理</span>\n        <span>else</span> <span>if</span> <span>(</span>s <span>></span> threshold<span>)</span>\n            <span>resize</span><span>(</span><span>)</span><span>;</span>\n        <span>// 将m中的所有元素添加至HashMap中</span>\n        <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> e <span>:</span> m<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>K</span> key <span>=</span> e<span>.</span><span>getKey</span><span>(</span><span>)</span><span>;</span>\n            <span>V</span> value <span>=</span> e<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>\n            <span>putVal</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> value<span>,</span> <span>false</span><span>,</span> evict<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id=\"put方法\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap?id=put%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener noreferrer\">put方法</a></h3>\n<p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p>\n<p><strong>对putVal方法添加元素的分析如下：</strong></p>\n<ul>\n<li>①如果定位到的数组位置没有元素 就直接插入。</li>\n<li>②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li>\n</ul>\n<p>ps:下图有一个小问题，来自 <a href=\"https://github.com/Snailclimb/JavaGuide/issues/608\" target=\"_blank\" rel=\"noopener noreferrer\">issue#608</a>指出：直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/put方法.png\" alt=\"put方法\" /></p>\n<div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>\n    <span>return</span> <span>putVal</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> value<span>,</span> <span>false</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>,</span>\n                   <span>boolean</span> evict<span>)</span> <span>{</span>\n    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>;</span> <span>int</span> n<span>,</span> i<span>;</span>\n    <span>// table未初始化或者长度为0，进行扩容</span>\n    <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>==</span> <span>null</span> <span>||</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>==</span> <span>0</span><span>)</span>\n        n <span>=</span> <span>(</span>tab <span>=</span> <span>resize</span><span>(</span><span>)</span><span>)</span><span>.</span>length<span>;</span>\n    <span>// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>\n    <span>if</span> <span>(</span><span>(</span>p <span>=</span> tab<span>[</span>i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>]</span><span>)</span> <span>==</span> <span>null</span><span>)</span>\n        tab<span>[</span>i<span>]</span> <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>\n    <span>// 桶中已经存在元素</span>\n    <span>else</span> <span>{</span>\n        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span> <span>K</span> k<span>;</span>\n        <span>// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>\n        <span>if</span> <span>(</span>p<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>\n            <span>(</span><span>(</span>k <span>=</span> p<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>\n                <span>// 将第一个元素赋值给e，用e来记录</span>\n                e <span>=</span> p<span>;</span>\n        <span>// hash值不相等，即key不相等；为红黑树结点</span>\n        <span>else</span> <span>if</span> <span>(</span>p <span>instanceof</span> <span>TreeNode</span><span>)</span>\n            <span>// 放入树中</span>\n            e <span>=</span> <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>p<span>)</span><span>.</span><span>putTreeVal</span><span>(</span><span>this</span><span>,</span> tab<span>,</span> hash<span>,</span> key<span>,</span> value<span>)</span><span>;</span>\n        <span>// 为链表结点</span>\n        <span>else</span> <span>{</span>\n            <span>// 在链表最末插入结点</span>\n            <span>for</span> <span>(</span><span>int</span> binCount <span>=</span> <span>0</span><span>;</span> <span>;</span> <span>++</span>binCount<span>)</span> <span>{</span>\n                <span>// 到达链表的尾部</span>\n                <span>if</span> <span>(</span><span>(</span>e <span>=</span> p<span>.</span>next<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                    <span>// 在尾部插入新结点</span>\n                    p<span>.</span>next <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>\n                    <span>// 结点数量达到阈值，转化为红黑树</span>\n                    <span>if</span> <span>(</span>binCount <span>>=</span> TREEIFY_THRESHOLD <span>-</span> <span>1</span><span>)</span> <span>// -1 for 1st</span>\n                        <span>treeifyBin</span><span>(</span>tab<span>,</span> hash<span>)</span><span>;</span>\n                    <span>// 跳出循环</span>\n                    <span>break</span><span>;</span>\n                <span>}</span>\n                <span>// 判断链表中结点的key值与插入的元素的key值是否相等</span>\n                <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>\n                    <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>\n                    <span>// 相等，跳出循环</span>\n                    <span>break</span><span>;</span>\n                <span>// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>\n                p <span>=</span> e<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>// 表示在桶中找到key值、hash值与插入元素相等的结点</span>\n        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span> \n            <span>// 记录e的value</span>\n            <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>\n            <span>// onlyIfAbsent为false或者旧值为null</span>\n            <span>if</span> <span>(</span><span>!</span>onlyIfAbsent <span>||</span> oldValue <span>==</span> <span>null</span><span>)</span>\n                <span>//用新值替换旧值</span>\n                e<span>.</span>value <span>=</span> value<span>;</span>\n            <span>// 访问后回调</span>\n            <span>afterNodeAccess</span><span>(</span>e<span>)</span><span>;</span>\n            <span>// 返回旧值</span>\n            <span>return</span> oldValue<span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>// 结构性修改</span>\n    <span>++</span>modCount<span>;</span>\n    <span>// 实际大小大于阈值则扩容</span>\n    <span>if</span> <span>(</span><span>++</span>size <span>></span> threshold<span>)</span>\n        <span>resize</span><span>(</span><span>)</span><span>;</span>\n    <span>// 插入后回调</span>\n    <span>afterNodeInsertion</span><span>(</span>evict<span>)</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div><p><strong>我们再来对比一下 JDK1.7 put方法的代码</strong></p>\n<p><strong>对于put方法的分析如下：</strong></p>\n<ul>\n<li>①如果定位到的数组位置没有元素 就直接插入。</li>\n<li>②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。</li>\n</ul>\n<div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span>\n    <span>if</span> <span>(</span>table <span>==</span> EMPTY_TABLE<span>)</span> <span>{</span> \n    <span>inflateTable</span><span>(</span>threshold<span>)</span><span>;</span> \n<span>}</span>  \n    <span>if</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span>\n        <span>return</span> <span>putForNullKey</span><span>(</span>value<span>)</span><span>;</span>\n    <span>int</span> hash <span>=</span> <span>hash</span><span>(</span>key<span>)</span><span>;</span>\n    <span>int</span> i <span>=</span> <span>indexFor</span><span>(</span>hash<span>,</span> table<span>.</span>length<span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> table<span>[</span>i<span>]</span><span>;</span> e <span>!=</span> <span>null</span><span>;</span> e <span>=</span> e<span>.</span>next<span>)</span> <span>{</span> <span>// 先遍历</span>\n        <span>Object</span> k<span>;</span>\n        <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span> <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span> <span>{</span>\n            <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>\n            e<span>.</span>value <span>=</span> value<span>;</span>\n            e<span>.</span><span>recordAccess</span><span>(</span><span>this</span><span>)</span><span>;</span>\n            <span>return</span> oldValue<span>;</span> \n        <span>}</span>\n    <span>}</span>\n\n    modCount<span>++</span><span>;</span>\n    <span>addEntry</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> i<span>)</span><span>;</span>  <span>// 再插入</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id=\"get方法\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap?id=get%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener noreferrer\">get方法</a></h3>\n<div><pre><code><span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span>\n    <span>return</span> <span>(</span>e <span>=</span> <span>getNode</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>)</span><span>)</span> <span>==</span> <span>null</span> <span>?</span> <span>null</span> <span>:</span> e<span>.</span>value<span>;</span>\n<span>}</span>\n\n<span>final</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>getNode</span><span>(</span><span>int</span> hash<span>,</span> <span>Object</span> key<span>)</span> <span>{</span>\n    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> first<span>,</span> e<span>;</span> <span>int</span> n<span>;</span> <span>K</span> k<span>;</span>\n    <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>></span> <span>0</span> <span>&amp;&amp;</span>\n        <span>(</span>first <span>=</span> tab<span>[</span><span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>// 数组元素相等</span>\n        <span>if</span> <span>(</span>first<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span> <span>// always check first node</span>\n            <span>(</span><span>(</span>k <span>=</span> first<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>\n            <span>return</span> first<span>;</span>\n        <span>// 桶中不止一个节点</span>\n        <span>if</span> <span>(</span><span>(</span>e <span>=</span> first<span>.</span>next<span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>// 在树中get</span>\n            <span>if</span> <span>(</span>first <span>instanceof</span> <span>TreeNode</span><span>)</span>\n                <span>return</span> <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>first<span>)</span><span>.</span><span>getTreeNode</span><span>(</span>hash<span>,</span> key<span>)</span><span>;</span>\n            <span>// 在链表中get</span>\n            <span>do</span> <span>{</span>\n                <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>\n                    <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>\n                    <span>return</span> e<span>;</span>\n            <span>}</span> <span>while</span> <span>(</span><span>(</span>e <span>=</span> e<span>.</span>next<span>)</span> <span>!=</span> <span>null</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id=\"resize方法\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap?id=resize%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener noreferrer\">resize方法</a></h3>\n<p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p>\n<div><pre><code><span>final</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> <span>resize</span><span>(</span><span>)</span> <span>{</span>\n    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> oldTab <span>=</span> table<span>;</span>\n    <span>int</span> oldCap <span>=</span> <span>(</span>oldTab <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> oldTab<span>.</span>length<span>;</span>\n    <span>int</span> oldThr <span>=</span> threshold<span>;</span>\n    <span>int</span> newCap<span>,</span> newThr <span>=</span> <span>0</span><span>;</span>\n    <span>if</span> <span>(</span>oldCap <span>></span> <span>0</span><span>)</span> <span>{</span>\n        <span>// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>\n        <span>if</span> <span>(</span>oldCap <span>>=</span> MAXIMUM_CAPACITY<span>)</span> <span>{</span>\n            threshold <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>\n            <span>return</span> oldTab<span>;</span>\n        <span>}</span>\n        <span>// 没超过最大值，就扩充为原来的2倍</span>\n        <span>else</span> <span>if</span> <span>(</span><span>(</span>newCap <span>=</span> oldCap <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;&amp;</span> oldCap <span>>=</span> DEFAULT_INITIAL_CAPACITY<span>)</span>\n            newThr <span>=</span> oldThr <span>&lt;&lt;</span> <span>1</span><span>;</span> <span>// double threshold</span>\n    <span>}</span>\n    <span>else</span> <span>if</span> <span>(</span>oldThr <span>></span> <span>0</span><span>)</span> <span>// initial capacity was placed in threshold</span>\n        newCap <span>=</span> oldThr<span>;</span>\n    <span>else</span> <span>{</span> \n        <span>// signifies using defaults</span>\n        newCap <span>=</span> DEFAULT_INITIAL_CAPACITY<span>;</span>\n        newThr <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span>DEFAULT_LOAD_FACTOR <span>*</span> DEFAULT_INITIAL_CAPACITY<span>)</span><span>;</span>\n    <span>}</span>\n    <span>// 计算新的resize上限</span>\n    <span>if</span> <span>(</span>newThr <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        <span>float</span> ft <span>=</span> <span>(</span><span>float</span><span>)</span>newCap <span>*</span> loadFactor<span>;</span>\n        newThr <span>=</span> <span>(</span>newCap <span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;&amp;</span> ft <span>&lt;</span> <span>(</span><span>float</span><span>)</span>MAXIMUM_CAPACITY <span>?</span> <span>(</span><span>int</span><span>)</span>ft <span>:</span> <span>Integer</span><span>.</span>MAX_VALUE<span>)</span><span>;</span>\n    <span>}</span>\n    threshold <span>=</span> newThr<span>;</span>\n    <span>@SuppressWarnings</span><span>(</span><span>{</span><span>\"rawtypes\"</span><span>,</span><span>\"unchecked\"</span><span>}</span><span>)</span>\n        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> newTab <span>=</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>Node</span><span>[</span>newCap<span>]</span><span>;</span>\n    table <span>=</span> newTab<span>;</span>\n    <span>if</span> <span>(</span>oldTab <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>// 把每个bucket都移动到新的buckets中</span>\n        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> oldCap<span>;</span> <span>++</span>j<span>)</span> <span>{</span>\n            <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span>\n            <span>if</span> <span>(</span><span>(</span>e <span>=</span> oldTab<span>[</span>j<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                oldTab<span>[</span>j<span>]</span> <span>=</span> <span>null</span><span>;</span>\n                <span>if</span> <span>(</span>e<span>.</span>next <span>==</span> <span>null</span><span>)</span>\n                    newTab<span>[</span>e<span>.</span>hash <span>&amp;</span> <span>(</span>newCap <span>-</span> <span>1</span><span>)</span><span>]</span> <span>=</span> e<span>;</span>\n                <span>else</span> <span>if</span> <span>(</span>e <span>instanceof</span> <span>TreeNode</span><span>)</span>\n                    <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>e<span>)</span><span>.</span><span>split</span><span>(</span><span>this</span><span>,</span> newTab<span>,</span> j<span>,</span> oldCap<span>)</span><span>;</span>\n                <span>else</span> <span>{</span> \n                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> loHead <span>=</span> <span>null</span><span>,</span> loTail <span>=</span> <span>null</span><span>;</span>\n                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> hiHead <span>=</span> <span>null</span><span>,</span> hiTail <span>=</span> <span>null</span><span>;</span>\n                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>;</span>\n                    <span>do</span> <span>{</span>\n                        next <span>=</span> e<span>.</span>next<span>;</span>\n                        <span>// 原索引</span>\n                        <span>if</span> <span>(</span><span>(</span>e<span>.</span>hash <span>&amp;</span> oldCap<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                            <span>if</span> <span>(</span>loTail <span>==</span> <span>null</span><span>)</span>\n                                loHead <span>=</span> e<span>;</span>\n                            <span>else</span>\n                                loTail<span>.</span>next <span>=</span> e<span>;</span>\n                            loTail <span>=</span> e<span>;</span>\n                        <span>}</span>\n                        <span>// 原索引+oldCap</span>\n                        <span>else</span> <span>{</span>\n                            <span>if</span> <span>(</span>hiTail <span>==</span> <span>null</span><span>)</span>\n                                hiHead <span>=</span> e<span>;</span>\n                            <span>else</span>\n                                hiTail<span>.</span>next <span>=</span> e<span>;</span>\n                            hiTail <span>=</span> e<span>;</span>\n                        <span>}</span>\n                    <span>}</span> <span>while</span> <span>(</span><span>(</span>e <span>=</span> next<span>)</span> <span>!=</span> <span>null</span><span>)</span><span>;</span>\n                    <span>// 原索引放到bucket里</span>\n                    <span>if</span> <span>(</span>loTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                        loTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>\n                        newTab<span>[</span>j<span>]</span> <span>=</span> loHead<span>;</span>\n                    <span>}</span>\n                    <span>// 原索引+oldCap放到bucket里</span>\n                    <span>if</span> <span>(</span>hiTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                        hiTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>\n                        newTab<span>[</span>j <span>+</span> oldCap<span>]</span> <span>=</span> hiHead<span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> newTab<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br></div></div><h2 id=\"hashmap常用方法测试\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap?id=hashmap%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95\" target=\"_blank\" rel=\"noopener noreferrer\">HashMap常用方法测试</a></h2>\n<div><pre><code><span>package</span> <span>map</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Collection</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>HashMap</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Set</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>HashMapDemo</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>// 键不能重复，值可以重复</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"san\"</span><span>,</span> <span>\"张三\"</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"si\"</span><span>,</span> <span>\"李四\"</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"wu\"</span><span>,</span> <span>\"王五\"</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"wang\"</span><span>,</span> <span>\"老王\"</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"wang\"</span><span>,</span> <span>\"老王2\"</span><span>)</span><span>;</span><span>// 老王被覆盖</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"lao\"</span><span>,</span> <span>\"老王\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"-------直接输出hashmap:-------\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>)</span><span>;</span>\n        <span>/**\n         * 遍历HashMap\n         */</span>\n        <span>// 1.获取Map中的所有键</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"-------foreach获取Map中所有的键:------\"</span><span>)</span><span>;</span>\n        <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> keys <span>=</span> map<span>.</span><span>keySet</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>String</span> key <span>:</span> keys<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>key<span>+</span><span>\"  \"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span><span>//换行</span>\n        <span>// 2.获取Map中所有值</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"-------foreach获取Map中所有的值:------\"</span><span>)</span><span>;</span>\n        <span>Collection</span><span><span>&lt;</span><span>String</span><span>></span></span> values <span>=</span> map<span>.</span><span>values</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>String</span> value <span>:</span> values<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>value<span>+</span><span>\"  \"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span><span>//换行</span>\n        <span>// 3.得到key的值的同时得到key所对应的值</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"-------得到key的值的同时得到key所对应的值:-------\"</span><span>)</span><span>;</span>\n        <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> keys2 <span>=</span> map<span>.</span><span>keySet</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>String</span> key <span>:</span> keys2<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>key <span>+</span> <span>\"：\"</span> <span>+</span> map<span>.</span><span>get</span><span>(</span>key<span>)</span><span>+</span><span>\"   \"</span><span>)</span><span>;</span>\n\n        <span>}</span>\n        <span>/**\n         * 如果既要遍历key又要value，那么建议这种方式，应为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。\n         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。\n         */</span>\n        <span>// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span>\n        <span>// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span>\n        <span>// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span>\n        <span>// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span>\n        <span>Set</span><span><span>&lt;</span><span><span>java<span>.</span>util<span>.</span></span>Map<span>.</span>Entry</span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span><span>></span></span> entrys <span>=</span> map<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span><span>java<span>.</span>util<span>.</span></span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> entry <span>:</span> entrys<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span> <span>+</span> <span>\"--\"</span> <span>+</span> entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>/**\n         * HashMap其他常用方法\n         */</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after map.size()：\"</span><span>+</span>map<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after map.isEmpty()：\"</span><span>+</span>map<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>.</span><span>remove</span><span>(</span><span>\"san\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after map.remove()：\"</span><span>+</span>map<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after map.get(si)：\"</span><span>+</span>map<span>.</span><span>get</span><span>(</span><span>\"si\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after map.containsKey(si)：\"</span><span>+</span>map<span>.</span><span>containsKey</span><span>(</span><span>\"si\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after containsValue(李四)：\"</span><span>+</span>map<span>.</span><span>containsValue</span><span>(</span><span>\"李四\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>.</span><span>replace</span><span>(</span><span>\"si\"</span><span>,</span> <span>\"李四2\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after map.replace(si, 李四2):\"</span><span>+</span>map<span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div>",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/jdk1.8%E4%B9%8B%E5%89%8D%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "什么是分布式协调技术",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/middleware/zookeeper/1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%8A%80%E6%9C%AF/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/middleware/zookeeper/1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%8A%80%E6%9C%AF/",
      "content_html": "<h1 id=\"什么是分布式协调技术\"> 什么是分布式协调技术</h1>\n<h2 id=\"概述\"> 概述</h2>\n<p>分布式协调技术主要用来解决分布式环境当中多个进程之间的同步控制，让他们有序的去访问某种临界资源，防止造成&quot;脏数据&quot;的后果。</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/import7841-1.png\" alt=\"img\" /></p>\n<p>在这图中有三台机器，每台机器各跑一个应用程序。然后我们将这三台机器通过网络将其连接起来，构成一个系统来为用户提供服务，对用户来说这个系统的架构是透明的，他感觉不到我这个系统是一个什么样的架构。那么我们就可以把这种系统称作一个<strong>分布式系统</strong>。</p>\n<p>在这个分布式系统中如何对进程进行调度，我假设在第一台机器上挂载了一个资源，然后这三个物理分布的进程都要竞争这个资源，但我们又不希望他们同时进行访问，这时候我们就需要一个<strong>协调器</strong>，来让他们有序的来访问这个资源。这个协调器就是我们经常提到的那个<strong>锁</strong>，比如说&quot;进程-1&quot;在使用该资源的时候，会先去获得锁，&quot;进程1&quot;获得锁以后会对该资源保持<strong>独占</strong>，这样其他进程就无法访问该资源，&quot;进程1&quot;用完该资源以后就将锁释放掉，让其他进程来获得锁，那么通过这个锁机制，我们就能保证了分布式系统中多个进程能够有序的访问该临界资源。那么我们把这个分布式环境下的这个锁叫作<strong>分布式锁</strong>。这个分布式锁也就是我们<strong>分布式协调技术</strong>实现的核心内容。</p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/import7841-1.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "什么是分布式锁",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/middleware/zookeeper/2.%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/middleware/zookeeper/2.%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/",
      "content_html": "<h1 id=\"什么是分布式锁\"> 什么是分布式锁</h1>\n<h2 id=\"概述\"> 概述</h2>\n<p>为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个<strong>分布式锁</strong>。</p>\n<h2 id=\"为什么要使用分布式锁\"> 为什么要使用分布式锁</h2>\n<p><img src=\"https://funtl.com/assets/Lusifer201810170001.png\" alt=\"img\" /></p>\n<ul>\n<li>成员变量 A 存在 JVM1、JVM2、JVM3 三个 JVM 内存中</li>\n<li>成员变量 A 同时都会在 JVM 分配一块内存，三个请求发过来同时对这个变量操作，显然结果是不对的</li>\n<li>不是同时发过来，三个请求分别操作三个不同 JVM 内存区域的数据，变量 A 之间不存在共享，也不具有可见性，处理的结果也是不对的 注：该成员变量 A 是一个有状态的对象</li>\n</ul>\n<p>如果我们业务中确实存在这个场景的话，我们就需要一种方法解决这个问题，<strong>这就是分布式锁要解决的问题</strong></p>\n<h2 id=\"分布式锁应该具备哪些条件\"> 分布式锁应该具备哪些条件</h2>\n<ul>\n<li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行</li>\n<li>高可用的获取锁与释放锁</li>\n<li>高性能的获取锁与释放锁</li>\n<li>具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误）</li>\n<li>具备锁失效机制，防止死锁</li>\n<li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败</li>\n</ul>\n<h2 id=\"分布式锁的实现有哪些\"> 分布式锁的实现有哪些</h2>\n<ul>\n<li>Memcached：利用 Memcached 的 <code>add</code> 命令。此命令是原子性操作，只有在 <code>key</code> 不存在的情况下，才能 <code>add</code> 成功，也就意味着线程得到了锁。</li>\n<li>Redis：和 Memcached 的方式类似，利用 Redis 的 <code>setnx</code> 命令。此命令同样是原子性操作，只有在 <code>key</code> 不存在的情况下，才能 <code>set</code> 成功。</li>\n<li><strong>Zookeeper</strong>：利用 Zookeeper 的顺序临时节点，来实现分布式锁和等待队列。Zookeeper 设计的初衷，就是为了实现分布式锁服务的。</li>\n<li>Chubby：Google 公司实现的粗粒度分布式锁服务，底层利用了 Paxos 一致性算法。</li>\n</ul>\n<h2 id=\"通过-redis-分布式锁的实现理解基本概念\"> 通过 Redis 分布式锁的实现理解基本概念</h2>\n<p>分布式锁实现的三个核心要素：</p>\n<h3 id=\"加锁\"> 加锁</h3>\n<p>最简单的方法是使用 <code>setnx</code> 命令。<code>key</code> 是锁的唯一标识，按业务来决定命名。比如想要给一种商品的秒杀活动加锁，可以给 <code>key</code> 命名为 “lock_sale_商品ID” 。而 <code>value</code> 设置成什么呢？我们可以姑且设置成 <code>1</code>。加锁的伪代码如下：</p>\n<div><pre><code>setnx（lock_sale_商品ID，1）\n</code></pre>\n<div><span>1</span><br></div></div><p>1</p>\n<p>当一个线程执行 <code>setnx</code> 返回 <code>1</code>，说明 <code>key</code> 原本不存在，该线程成功得到了锁；当一个线程执行 <code>setnx</code> 返回 <code>0</code>，说明 <code>key</code> 已经存在，该线程抢锁失败。</p>\n<h3 id=\"解锁\"> 解锁</h3>\n<p>有加锁就得有解锁。当得到锁的线程执行完任务，需要释放锁，以便其他线程可以进入。释放锁的最简单方式是执行 <code>del</code> 指令，伪代码如下：</p>\n<div><pre><code>del（lock_sale_商品ID）\n</code></pre>\n<div><span>1</span><br></div></div><p>1</p>\n<p>释放锁之后，其他线程就可以继续执行 <code>setnx</code> 命令来获得锁。</p>\n<h3 id=\"锁超时\"> <a href=\"https://funtl.com/zh/apache-dubbo-zookeeper/%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html#%E9%94%81%E8%B6%85%E6%97%B6\" target=\"_blank\" rel=\"noopener noreferrer\">#</a>锁超时</h3>\n<p>锁超时是什么意思呢？如果一个得到锁的线程在执行任务的过程中挂掉，来不及显式地释放锁，这块资源将会永远被锁住（<strong>死锁</strong>），别的线程再也别想进来。所以，<code>setnx</code> 的 <code>key</code> 必须设置一个超时时间，以保证即使没有被显式释放，这把锁也要在一定时间后自动释放。<code>setnx</code> 不支持超时参数，所以需要额外的指令，伪代码如下：</p>\n<div><pre><code>expire（lock_sale_商品ID， 30）\n</code></pre>\n<div><span>1</span><br></div></div><p>1</p>\n<p>综合伪代码如下：</p>\n<div><pre><code>if（setnx（lock_sale_商品ID，1） == 1）{\n    expire（lock_sale_商品ID，30）\n    try {\n        do something ......\n    } finally {\n        del（lock_sale_商品ID）\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>1\n2\n3\n4\n5\n6\n7\n8</p>\n<h3 id=\"存在什么问题\"> <a href=\"https://funtl.com/zh/apache-dubbo-zookeeper/%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html#%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\" target=\"_blank\" rel=\"noopener noreferrer\">#</a>存在什么问题</h3>\n<p>以上伪代码中存在三个致命问题</p>\n<h4 id=\"setnx-和-expire-的非原子性\"> <a href=\"https://funtl.com/zh/apache-dubbo-zookeeper/%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html#setnx-%E5%92%8C-expire-%E7%9A%84%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%80%A7\" target=\"_blank\" rel=\"noopener noreferrer\">#</a><code>setnx</code> 和 <code>expire</code> 的非原子性</h4>\n<p>设想一个极端场景，当某线程执行 <code>setnx</code>，成功得到了锁：</p>\n<p><img src=\"https://funtl.com/assets/Lusifer201810170002.png\" alt=\"img\" /></p>\n<p><code>setnx</code> 刚执行成功，还未来得及执行 <code>expire</code> 指令，节点 1 挂掉了。</p>\n<p><img src=\"https://funtl.com/assets/Lusifer201810170003.png\" alt=\"img\" /></p>\n<p>这样一来，这把锁就没有设置过期时间，变成<strong>死锁</strong>，别的线程再也无法获得锁了。</p>\n<p>怎么解决呢？<code>setnx</code> 指令本身是不支持传入超时时间的，<code>set</code> 指令增加了可选参数，伪代码如下：</p>\n<div><pre><code>set（lock_sale_商品ID，1，30，NX）\n</code></pre>\n<div><span>1</span><br></div></div><p>1</p>\n<p>这样就可以取代 <code>setnx</code> 指令。</p>\n<h4 id=\"del-导致误删\"> <a href=\"https://funtl.com/zh/apache-dubbo-zookeeper/%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html#del-%E5%AF%BC%E8%87%B4%E8%AF%AF%E5%88%A0\" target=\"_blank\" rel=\"noopener noreferrer\">#</a><code>del</code> 导致误删</h4>\n<p>又是一个极端场景，假如某线程成功得到了锁，并且设置的超时时间是 30 秒。</p>\n<p><img src=\"https://funtl.com/assets/Lusifer201810170004.png\" alt=\"img\" /></p>\n<p>如果某些原因导致线程 A 执行的很慢很慢，过了 30 秒都没执行完，这时候锁过期自动释放，线程 B 得到了锁。</p>\n<p><img src=\"https://funtl.com/assets/Lusifer201810170005.png\" alt=\"img\" /></p>\n<p>随后，线程 A 执行完了任务，线程 A 接着执行 <code>del</code> 指令来释放锁。但这时候线程 B 还没执行完，线程A实际上 <code>删除的是线程 B 加的锁</code>。</p>\n<p><img src=\"https://funtl.com/assets/Lusifer201810170006.png\" alt=\"img\" /></p>\n<p>怎么避免这种情况呢？可以在 <code>del</code> 释放锁之前做一个判断，验证当前的锁是不是自己加的锁。至于具体的实现，可以在加锁的时候把当前的线程 ID 当做 <code>value</code>，并在删除之前验证 <code>key</code> 对应的 <code>value</code> 是不是自己线程的 ID。</p>\n<p>加锁：</p>\n<div><pre><code>String threadId = Thread.currentThread().getId()\nset（key，threadId ，30，NX）\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>1\n2</p>\n<p>解锁：</p>\n<div><pre><code>if（threadId .equals(redisClient.get(key))）{\n    del(key)\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>1\n2\n3</p>\n<p>但是，这样做又隐含了一个新的问题，判断和释放锁是两个独立操作，不是原子性。</p>\n<h4 id=\"出现并发的可能性\"> <a href=\"https://funtl.com/zh/apache-dubbo-zookeeper/%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html#%E5%87%BA%E7%8E%B0%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8F%AF%E8%83%BD%E6%80%A7\" target=\"_blank\" rel=\"noopener noreferrer\">#</a>出现并发的可能性</h4>\n<p>还是刚才第二点所描述的场景，虽然我们避免了线程 A 误删掉 <code>key</code> 的情况，但是同一时间有 A，B 两个线程在访问代码块，仍然是不完美的。怎么办呢？我们可以让获得锁的线程开启一个<strong>守护线程</strong>，用来给快要过期的锁“续航”。</p>\n<p><img src=\"https://funtl.com/assets/Lusifer201810170004.png\" alt=\"img\" /></p>\n<p>当过去了 29 秒，线程 A 还没执行完，这时候守护线程会执行 <code>expire</code> 指令，为这把锁“续命”20 秒。守护线程从第 29 秒开始执行，每 20 秒执行一次。</p>\n<p><img src=\"https://funtl.com/assets/Lusifer201810170007.png\" alt=\"img\" /></p>\n<p>当线程 A 执行完任务，会显式关掉守护线程。</p>\n<p><img src=\"https://funtl.com/assets/Lusifer201810170008.png\" alt=\"img\" /></p>\n<p>另一种情况，如果节点 1 忽然断电，由于线程 A 和守护线程在同一个进程，守护线程也会停下。这把锁到了超时的时候，没人给它续命，也就自动释放了。</p>\n<p><img src=\"https://funtl.com/assets/Lusifer201810170009.png\" alt=\"img\" /></p>\n",
      "image": "https://funtl.com/assets/Lusifer201810170001.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "微服务优缺点",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BC%98%E7%BC%BA%E7%82%B9/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BC%98%E7%BC%BA%E7%82%B9/",
      "content_html": "<h1 id=\"微服务优缺点\"> 微服务优缺点</h1>\n<p><strong>微服务有什么好处</strong></p>\n<ol>\n<li>项目独立的可扩展性，每个微服务都可以独立进行横向或纵向扩展，根据业务实际增长情况来进行快速扩展；</li>\n<li>项目独立的可升级性，每个微服务都可以独立进行服务升级、更新，不用依赖于其它服务，结合持续集成工具可以进行持续发布，开发人员就可以独立快速完成服务升级发布流程；</li>\n<li>项目易维护性，每个微服务的代码均只专注于完成该单个业务范畴的事情，因此微服务项目代码数量将减少至IDE可以快速加载的大小，这样可以提高了代码的可读性，进而可以提高研发人员的生产效率；</li>\n<li>语言无关性，研发人员可以选用自己最为熟悉的语言和框架来完成他们的微服务项目（当然，一般根据每个公司的实际技术栈需要来了），这样在面对新技术或新框架的选用时，微服务能够更好地进行快速响应；</li>\n<li>故障和资源的隔离性，在系统中出现不好的资源操作行为时，例如内存泄露、数据库连接未关闭等情况，将仅仅只会影响单个微服务；</li>\n<li>优化跨团队沟通，如果要完全实践微服务架构设计风格，研发团队势必会按照新的原则来进行划分，由之前的按照技能、职能划分的方式变为按照业务（单个微服务）来进行划分，如此这般团队里将有各个方向技能的研发人员，沟通效率上来说要优于之前按照技能进行划分的组织架构；</li>\n<li>原生基于“云”的系统架构设计，基于微服务架构设计风格，我们能构建出来原生对于“云”具备超高友好度的系统，与常用容器工具如Docker能够很方便地结合，构建持续发布系统与IaaS、PaaS平台对接，使其能够方便的部署于各类“云”上，如公用云、私有云以及混合云。</li>\n</ol>\n<p><strong>微服务有什么缺点</strong></p>\n<ol>\n<li>增加了系统复杂性</li>\n<li>运维难度增加</li>\n<li>本地调用变成RPC调用，有些操作会比较耗时</li>\n<li>可能会引入分布式事务</li>\n</ol>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Python",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/python/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/python/",
      "content_html": "<h1 id=\"python\"> Python</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "单例模式",
      "url": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/1.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/1.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/",
      "content_html": "<h1 id=\"单例模式\"> 单例模式</h1>\n<h2 id=\"_1-单例设计模式介绍\"> 1. 单例设计模式介绍</h2>\n<p>所谓类的单例设计模式,就是采取一定的方法保证在整个的软件系统中,对某个类只能存在一个对象实例, 并且该类只提供一个取得其对象实例的方法(静态方法). 比如 Hibernate 的 SessionFactory,它充当数据存储源的代理,并负责创建 Session 对象.SessionFactory 并不是 轻量级的,一般情况下,一个项目通常只需要一个 SessionFactory 就够,这是就会使用到单例模式.</p>\n<h2 id=\"_2-单例设计模式八种方式\"> 2. 单例设计模式八种方式</h2>\n<p>单例模式有八种方式：</p>\n<ol>\n<li>饿汉式(静态常量)</li>\n<li>饿汉式(静态代码块)</li>\n<li>懒汉式(线程不安全)</li>\n<li>懒汉式(线程安全,同步方法)</li>\n<li>懒汉式(线程安全,同步代码块)</li>\n<li>双重检查</li>\n<li>静态内部类</li>\n<li>枚举</li>\n</ol>\n<h2 id=\"_3-代码实现\"> 3. 代码实现</h2>\n<h3 id=\"_1-饿汉式-静态常量\"> 1. 饿汉式(静态常量)</h3>\n<p>应用实例 步骤如下：</p>\n<ol>\n<li>在本类中添加一个本类作为属性，并且获取对象实例</li>\n<li>构造器私有化，防止外部new实例</li>\n<li>提供一个获取实例的静态方法</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>TestSingleton01</span> <span>{</span>\n    \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Singleton01</span> instance <span>=</span> <span>Singleton01</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>Singleton01</span> instance2 <span>=</span> <span>Singleton01</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>instance<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>instance2<span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n\n<span>/**\n * 单例模式 - 饿汉式\n */</span>\n<span>class</span> <span>Singleton01</span><span>{</span>\n    <span>//1. 在本类中添加一个本类作为属性，并且获取对象实例</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>Singleton01</span> instance <span>=</span> <span>new</span> <span>Singleton01</span><span>(</span><span>)</span><span>;</span>\n\n    <span>//2. 构造器私有化，防止外部new实例</span>\n    <span>private</span> <span>Singleton01</span><span>(</span><span>)</span><span>{</span>\n\n    <span>}</span>\n\n    <span>//3. 提供一个获取实例的静态方法</span>\n    <span>public</span> <span>static</span> <span>Singleton01</span> <span>getInstance</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> instance<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"_2-饿汉式-静态代码块\"> 2. 饿汉式(静态代码块)</h3>\n<p>应用实例 步骤如下：</p>\n<ol>\n<li>在本类中添加一个本类作为属性，并且获取对象实例</li>\n<li>在静态代码块中创建实例</li>\n<li>构造器私有化，防止外部new实例</li>\n<li>提供一个获取实例的静态方法</li>\n</ol>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>study<span>.</span>designpattern<span>.</span>singleton</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>TestSingleton02</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Singleton02</span> instance <span>=</span> <span>Singleton02</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>Singleton02</span> instance2 <span>=</span> <span>Singleton02</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>instance<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>instance2<span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n\n<span>/**\n * 单例模式 - 饿汉式（静态代码块方式）\n */</span>\n<span>class</span> <span>Singleton02</span> <span>{</span>\n    <span>//1. 在本类中添加一个本类作为属性，并且获取对象实例</span>\n    <span>private</span> <span>static</span> <span>Singleton02</span> instance<span>;</span>\n\n    <span>//2. 在静态代码块中创建实例</span>\n    <span>static</span> <span>{</span>\n        instance <span>=</span> <span>new</span> <span>Singleton02</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>//3. 构造器私有化，防止外部new实例</span>\n    <span>private</span> <span>Singleton02</span><span>(</span><span>)</span><span>{</span>\n\n    <span>}</span>\n\n    <span>//4. 提供一个获取实例的静态方法</span>\n    <span>public</span> <span>static</span> <span>Singleton02</span> <span>getInstance</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> instance<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><blockquote>\n<p>优缺点说明：</p>\n<ol>\n<li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</li>\n<li>结论：这种单例模式可用，但是可能造成内存浪费</li>\n</ol>\n</blockquote>\n<h3 id=\"_3-懒汉式-线程不安全版\"> 3. 懒汉式（线程不安全版）</h3>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>study<span>.</span>designpattern<span>.</span>singleton<span>.</span>type3</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>TestSingleton</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Singleton</span> instance <span>=</span> <span>Singleton</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>Singleton</span> instance2 <span>=</span> <span>Singleton</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>instance<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>instance2<span>)</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n\n<span>/**\n * 单例模式 - 懒汉式（线程不安全版）\n */</span>\n<span>class</span> <span>Singleton</span><span>{</span>\n    <span>private</span> <span>Singleton</span><span>(</span><span>)</span><span>{</span><span>}</span>\n\n    <span>private</span> <span>static</span> <span>Singleton</span> instance<span>;</span>\n\n    <span>//提供一个静态的公有方法,当使用到该方法时,才去创建 instance</span>\n    <span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span><span>{</span>\n        <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span><span>{</span>\n            instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>return</span> instance<span>;</span>\n    <span>}</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><blockquote>\n<p>优缺点说明：</p>\n<ol>\n<li>起到了 Lazy Loading 的效果,但是只能在单线程下使用</li>\n<li>如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过 了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</li>\n<li>结论：在实际开发中，不要使用这种方式</li>\n</ol>\n</blockquote>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "设计模式常用的七大原则:",
      "url": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/",
      "content_html": "<h1 id=\"设计模式常用的七大原则\"> 设计模式常用的七大原则:</h1>\n<ol>\n<li>单一职责原则</li>\n<li>接口隔离原则</li>\n<li>依赖倒转(倒置)原则</li>\n<li>里氏替换原则</li>\n<li>开闭原则</li>\n<li>迪米特法则</li>\n<li>合成复用原则</li>\n</ol>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "接口隔离原则",
      "url": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/design-principle/2.%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/design-principle/2.%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/",
      "content_html": "<h1 id=\"接口隔离原则\"> 接口隔离原则</h1>\n<h2 id=\"_1-基本介绍\"> 1. 基本介绍</h2>\n<ol>\n<li>\n<p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p>\n</li>\n<li>\n<p>先看一张图</p>\n</li>\n<li>\n<p>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类A 和类 C 来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法</p>\n</li>\n<li>\n<p>按隔离原则应当这样处理：将接口 Interface1 拆分为独立的几个接口(这里我们拆分成 3 个接口)，类 A 和类 C 分别与他们需要的接口建立 依赖关系，也就是采用接口隔离原则</p>\n</li>\n</ol>\n<h2 id=\"_2-应用实例\"> 2. 应用实例</h2>\n<p>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D</p>\n<ol>\n<li>\n<p>未使用接口隔离的代码</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Segregation1</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t\n\n\t<span>}</span>\n\n<span>}</span>\n\n<span>//接口</span>\n<span>interface</span> <span>Interface1</span> <span>{</span>\n\t<span>void</span> <span>operation1</span><span>(</span><span>)</span><span>;</span>\n\t<span>void</span> <span>operation2</span><span>(</span><span>)</span><span>;</span>\n\t<span>void</span> <span>operation3</span><span>(</span><span>)</span><span>;</span>\n\t<span>void</span> <span>operation4</span><span>(</span><span>)</span><span>;</span>\n\t<span>void</span> <span>operation5</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>class</span> <span>B</span> <span>implements</span> <span>Interface1</span> <span>{</span>\n\t<span>public</span> <span>void</span> <span>operation1</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B 实现了 operation1\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t\n\t<span>public</span> <span>void</span> <span>operation2</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B 实现了 operation2\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t<span>public</span> <span>void</span> <span>operation3</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B 实现了 operation3\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t<span>public</span> <span>void</span> <span>operation4</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B 实现了 operation4\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t<span>public</span> <span>void</span> <span>operation5</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B 实现了 operation5\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>class</span> <span>D</span> <span>implements</span> <span>Interface1</span> <span>{</span>\n\t<span>public</span> <span>void</span> <span>operation1</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"D 实现了 operation1\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t\n\t<span>public</span> <span>void</span> <span>operation2</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"D 实现了 operation2\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t<span>public</span> <span>void</span> <span>operation3</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"D 实现了 operation3\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t<span>public</span> <span>void</span> <span>operation4</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"D 实现了 operation4\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t<span>public</span> <span>void</span> <span>operation5</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"D 实现了 operation5\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>class</span> <span>A</span> <span>{</span> <span>//A 类通过接口Interface1 依赖(使用) B类，但是只会用到1,2,3方法</span>\n\t<span>public</span> <span>void</span> <span>depend1</span><span>(</span><span>Interface1</span> i<span>)</span> <span>{</span>\n\t\ti<span>.</span><span>operation1</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t<span>public</span> <span>void</span> <span>depend2</span><span>(</span><span>Interface1</span> i<span>)</span> <span>{</span>\n\t\ti<span>.</span><span>operation2</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t<span>public</span> <span>void</span> <span>depend3</span><span>(</span><span>Interface1</span> i<span>)</span> <span>{</span>\n\t\ti<span>.</span><span>operation3</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n  \n<span>class</span> <span>C</span> <span>{</span> <span>//C 类通过接口Interface1 依赖(使用) D类，但是只会用到1,4,5方法</span>\n\t<span>public</span> <span>void</span> <span>depend1</span><span>(</span><span>Interface1</span> i<span>)</span> <span>{</span>\n\t\ti<span>.</span><span>operation1</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t<span>public</span> <span>void</span> <span>depend4</span><span>(</span><span>Interface1</span> i<span>)</span> <span>{</span>\n\t\ti<span>.</span><span>operation4</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t<span>public</span> <span>void</span> <span>depend5</span><span>(</span><span>Interface1</span> i<span>)</span> <span>{</span>\n\t\ti<span>.</span><span>operation5</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br></div></div></li>\n<li>\n<p>使用接口隔离的代码</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Segregation1</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>// 使用一把</span>\n\t\t<span>A</span> a <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>\n\t\ta<span>.</span><span>depend1</span><span>(</span><span>new</span> <span>B</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// A类通过接口去依赖B类</span>\n\t\ta<span>.</span><span>depend2</span><span>(</span><span>new</span> <span>B</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\ta<span>.</span><span>depend3</span><span>(</span><span>new</span> <span>B</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n\t\t<span>C</span> c <span>=</span> <span>new</span> <span>C</span><span>(</span><span>)</span><span>;</span>\n\n\t\tc<span>.</span><span>depend1</span><span>(</span><span>new</span> <span>D</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// C类通过接口去依赖(使用)D类</span>\n\t\tc<span>.</span><span>depend4</span><span>(</span><span>new</span> <span>D</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\tc<span>.</span><span>depend5</span><span>(</span><span>new</span> <span>D</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n\t<span>}</span>\n\n<span>}</span>\n\n<span>// 接口1</span>\n<span>interface</span> <span>Interface1</span> <span>{</span>\n\t<span>void</span> <span>operation1</span><span>(</span><span>)</span><span>;</span>\n\n<span>}</span>\n\n<span>// 接口2</span>\n<span>interface</span> <span>Interface2</span> <span>{</span>\n\t<span>void</span> <span>operation2</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>void</span> <span>operation3</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 接口3</span>\n<span>interface</span> <span>Interface3</span> <span>{</span>\n\t<span>void</span> <span>operation4</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>void</span> <span>operation5</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>class</span> <span>B</span> <span>implements</span> <span>Interface1</span><span>,</span> <span>Interface2</span> <span>{</span>\n\t<span>public</span> <span>void</span> <span>operation1</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B 实现了 operation1\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>void</span> <span>operation2</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B 实现了 operation2\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>void</span> <span>operation3</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B 实现了 operation3\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n<span>}</span>\n\n<span>class</span> <span>D</span> <span>implements</span> <span>Interface1</span><span>,</span> <span>Interface3</span> <span>{</span>\n\t<span>public</span> <span>void</span> <span>operation1</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"D 实现了 operation1\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>void</span> <span>operation4</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"D 实现了 operation4\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>void</span> <span>operation5</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"D 实现了 operation5\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>class</span> <span>A</span> <span>{</span> <span>// A 类通过接口Interface1,Interface2 依赖(使用) B类，但是只会用到1,2,3方法</span>\n\t<span>public</span> <span>void</span> <span>depend1</span><span>(</span><span>Interface1</span> i<span>)</span> <span>{</span>\n\t\ti<span>.</span><span>operation1</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>void</span> <span>depend2</span><span>(</span><span>Interface2</span> i<span>)</span> <span>{</span>\n\t\ti<span>.</span><span>operation2</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>void</span> <span>depend3</span><span>(</span><span>Interface2</span> i<span>)</span> <span>{</span>\n\t\ti<span>.</span><span>operation3</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>class</span> <span>C</span> <span>{</span> <span>// C 类通过接口Interface1,Interface3 依赖(使用) D类，但是只会用到1,4,5方法</span>\n\t<span>public</span> <span>void</span> <span>depend1</span><span>(</span><span>Interface1</span> i<span>)</span> <span>{</span>\n\t\ti<span>.</span><span>operation1</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>void</span> <span>depend4</span><span>(</span><span>Interface3</span> i<span>)</span> <span>{</span>\n\t\ti<span>.</span><span>operation4</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>void</span> <span>depend5</span><span>(</span><span>Interface3</span> i<span>)</span> <span>{</span>\n\t\ti<span>.</span><span>operation5</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br></div></div><blockquote>\n<p><strong>说明</strong></p>\n<ol>\n<li>\n<p>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C 来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法</p>\n</li>\n<li>\n<p>将接口 Interface1 拆分为独立的几个接口，类 A 和类 C 分别与他们需要的接口建立依赖关系，也就是采用接口 隔离原则</p>\n</li>\n<li>\n<p>接口 Interface1 中出现的方法，根据实际情况拆分为三个接口</p>\n</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "单一职责原则",
      "url": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/design-principle/1.%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/design-principle/1.%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/",
      "content_html": "<h1 id=\"单一职责原则\"> 单一职责原则</h1>\n<h2 id=\"_1-基本介绍\"> 1. 基本介绍</h2>\n<p>对类来说的,即一个类应该只负责一项职责.如类 A 负责两个不同职责：职责 1,职责 2.当职责 1 需求变更 而改变 A 时,可能造成职责 2 执行错误,所以需要将类 A 的粒度分解为 A1,A2</p>\n<h2 id=\"_2-应用实例\"> 2. 应用实例</h2>\n<ol>\n<li>\n<p>未使用单一职责原则的代码</p>\n<div><pre><code><span>public</span> <span>class</span> <span>SingleResponsibility1</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>// TODO Auto-generated method stub</span>\n\t\t<span>Vehicle</span> vehicle <span>=</span> <span>new</span> <span>Vehicle</span><span>(</span><span>)</span><span>;</span>\n\t\tvehicle<span>.</span><span>run</span><span>(</span><span>\"摩托车\"</span><span>)</span><span>;</span>\n\t\tvehicle<span>.</span><span>run</span><span>(</span><span>\"汽车\"</span><span>)</span><span>;</span>\n\t\tvehicle<span>.</span><span>run</span><span>(</span><span>\"飞机\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n<span>}</span>\n\n<span>// 交通工具类</span>\n<span>// 方式1</span>\n<span>// 1. 在方式1 的run方法中，违反了单一职责原则</span>\n<span>// 2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</span>\n<span>class</span> <span>Vehicle</span> <span>{</span>\n\t<span>public</span> <span>void</span> <span>run</span><span>(</span><span>String</span> vehicle<span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>vehicle <span>+</span> <span>\" 在公路上运行....\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></li>\n<li>\n<p>使用单一职责原则方案1</p>\n<p>将类分解，同时修改客户端</p>\n<div><pre><code><span>public</span> <span>class</span> <span>SingleResponsibility2</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>// TODO Auto-generated method stub</span>\n\t\t<span>RoadVehicle</span> roadVehicle <span>=</span> <span>new</span> <span>RoadVehicle</span><span>(</span><span>)</span><span>;</span>\n\t\troadVehicle<span>.</span><span>run</span><span>(</span><span>\"摩托车\"</span><span>)</span><span>;</span>\n\t\troadVehicle<span>.</span><span>run</span><span>(</span><span>\"汽车\"</span><span>)</span><span>;</span>\n\t\t\n\t\t<span>AirVehicle</span> airVehicle <span>=</span> <span>new</span> <span>AirVehicle</span><span>(</span><span>)</span><span>;</span>\n\t\t\n\t\tairVehicle<span>.</span><span>run</span><span>(</span><span>\"飞机\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n<span>}</span>\n\n<span>//方案1的分析</span>\n<span>//1. 遵守单一职责原则</span>\n<span>//2. 但是这样做的改动很大，即将类分解，同时修改客户端</span>\n<span>//3. 改进：直接修改Vehicle 类，改动的代码会比较少=>方案2</span>\n\n<span>class</span> <span>RoadVehicle</span> <span>{</span>\n\t<span>public</span> <span>void</span> <span>run</span><span>(</span><span>String</span> vehicle<span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>vehicle <span>+</span> <span>\"公路运行\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>class</span> <span>AirVehicle</span> <span>{</span>\n\t<span>public</span> <span>void</span> <span>run</span><span>(</span><span>String</span> vehicle<span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>vehicle <span>+</span> <span>\"天空运行\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>class</span> <span>WaterVehicle</span> <span>{</span>\n\t<span>public</span> <span>void</span> <span>run</span><span>(</span><span>String</span> vehicle<span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>vehicle <span>+</span> <span>\"水中运行\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div></li>\n</ol>\n<p>}\n```</p>\n<div><pre><code>&gt; 方案1的分析\n&gt;\n&gt; 1. 遵守单一职责原则\n&gt; 2. 但是这样做的改动很大，即将类分解，同时修改客户端\n&gt; 3. 改进：直接修改Vehicle 类，改动的代码会比较少=&gt;方案2\n</code></pre>\n</div><ol start=\"3\">\n<li>\n<p>使用单一职责原则方案2</p>\n<div><pre><code><span>public</span> <span>class</span> <span>SingleResponsibility3</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>// TODO Auto-generated method stub</span>\n\t\t<span>Vehicle2</span> vehicle2  <span>=</span> <span>new</span> <span>Vehicle2</span><span>(</span><span>)</span><span>;</span>\n\t\tvehicle2<span>.</span><span>run</span><span>(</span><span>\"汽车\"</span><span>)</span><span>;</span>\n\t\tvehicle2<span>.</span><span>runWater</span><span>(</span><span>\"轮船\"</span><span>)</span><span>;</span>\n\t\tvehicle2<span>.</span><span>runAir</span><span>(</span><span>\"飞机\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n<span>}</span>\n\n\n<span>//方案2的分析</span>\n<span>//1. 这种修改方法没有对原来的类做大的修改，只是增加方法</span>\n<span>//2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</span>\n<span>class</span> <span>Vehicle2</span> <span>{</span>\n\t<span>public</span> <span>void</span> <span>run</span><span>(</span><span>String</span> vehicle<span>)</span> <span>{</span>\n\t\t<span>//处理</span>\n\t\t\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>vehicle <span>+</span> <span>\" 在公路上运行....\"</span><span>)</span><span>;</span>\n\t\t\n\t<span>}</span>\n\t\n\t<span>public</span> <span>void</span> <span>runAir</span><span>(</span><span>String</span> vehicle<span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>vehicle <span>+</span> <span>\" 在天空上运行....\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t\n\t<span>public</span> <span>void</span> <span>runWater</span><span>(</span><span>String</span> vehicle<span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>vehicle <span>+</span> <span>\" 在水中行....\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t\n\t<span>//方法2.</span>\n\t<span>//..</span>\n\t<span>//..</span>\n\t\n\t<span>//...</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><blockquote>\n<p>方案2的分析</p>\n<ol>\n<li>这种修改方法没有对原来的类做大的修改，只是增加方法</li>\n<li>这里虽然没有在类这个级别上遵守单一职责原则，但是在<strong>方法级别</strong>上，仍然是遵守单一职责</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"_3-单一职责原则注意事项和细节\"> 3. 单一职责原则注意事项和细节</h2>\n<ol>\n<li>降低类的复杂度，一个类只负责一项职责</li>\n<li>提高类的可读性，可维护性</li>\n<li>降低变更引起的风险</li>\n<li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中 方法数量足够少，可以在方法级别保持单一职责原则</li>\n</ol>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "依赖倒置原则",
      "url": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/design-principle/3.%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/design-principle/3.%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/",
      "content_html": "<h1 id=\"依赖倒置原则\"> 依赖倒置原则</h1>\n<h2 id=\"_1-基本介绍\"> 1. 基本介绍</h2>\n<p>依赖倒转原则(Dependence Inversion Principle)是指：</p>\n<ol>\n<li>高层模块不应该依赖低层模块,二者都应该依赖其抽象</li>\n<li>抽象不应该依赖细节,细节应该依赖抽象</li>\n<li>依赖倒转(倒置)的<strong>中心思想是面向接口编程</strong></li>\n<li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架 构比以细节为基础的架构要稳定的多。在 java 中,抽象指的是接口或抽象类,细节就是具体的实现类。</li>\n<li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完 成</li>\n</ol>\n<h2 id=\"_2-应用实例\"> 2. 应用实例</h2>\n<p>完成 Person 接收消息的功能。</p>\n<ol>\n<li>\n<p>使用依赖倒置原则方式1</p>\n<div><pre><code><span>public</span> <span>class</span> <span>DependecyInversion</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>Person</span> person <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>\n\t\tperson<span>.</span><span>receive</span><span>(</span><span>new</span> <span>Email</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n<span>}</span>\n\n\n<span>class</span> <span>Email</span> <span>{</span>\n\t<span>public</span> <span>String</span> <span>getInfo</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>return</span> <span>\"电子邮件信息: hello,world\"</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>//完成Person接收消息的功能</span>\n<span>//方式1分析</span>\n<span>//1. 简单，比较容易想到</span>\n<span>//2. 如果我们获取的对象是 微信，短信等等，则新增类，同时Perons也要增加相应的接收方法</span>\n<span>//3. 解决思路：引入一个抽象的接口IReceiver, 表示接收者, 这样Person类与接口IReceiver发生依赖</span>\n<span>//   因为Email, WeiXin 等等属于接收的范围，他们各自实现IReceiver 接口就ok, 这样我们就符号依赖倒转原则</span>\n<span>class</span> <span>Person</span> <span>{</span>\n\t<span>public</span> <span>void</span> <span>receive</span><span>(</span><span>Email</span> email <span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>email<span>.</span><span>getInfo</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><blockquote>\n<p>分析</p>\n<ol>\n<li>简单，比较容易想到</li>\n<li>如果我们获取的对象是 微信，短信等等，则新增类，同时Perons也要增加相应的接收方法</li>\n<li>解决思路：引入一个抽象的接口IReceiver，表示接收者, 这样Person类与接口IReceiver发生依赖，因为Email, WeiXin 等等属于接收的范围，他们各自实现IReceiver 接口就ok，这样我们就符合依赖倒置原则</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>使用依赖倒置原则方式2</p>\n<div><pre><code><span>public</span> <span>class</span> <span>DependecyInversion</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>//客户端无需改变</span>\n\t\t<span>Person</span> person <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>\n\t\tperson<span>.</span><span>receive</span><span>(</span><span>new</span> <span>Email</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\t\n\t\tperson<span>.</span><span>receive</span><span>(</span><span>new</span> <span>WeiXin</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n<span>}</span>\n\n<span>//定义接口</span>\n<span>interface</span> <span>IReceiver</span> <span>{</span>\n\t<span>public</span> <span>String</span> <span>getInfo</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>class</span> <span>Email</span> <span>implements</span> <span>IReceiver</span> <span>{</span>\n\t<span>public</span> <span>String</span> <span>getInfo</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>return</span> <span>\"电子邮件信息: hello,world\"</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>//增加微信</span>\n<span>class</span> <span>WeiXin</span> <span>implements</span> <span>IReceiver</span> <span>{</span>\n\t<span>public</span> <span>String</span> <span>getInfo</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>return</span> <span>\"微信信息: hello,ok\"</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>//方式2</span>\n<span>class</span> <span>Person</span> <span>{</span>\n\t<span>//这里我们是对接口的依赖</span>\n\t<span>public</span> <span>void</span> <span>receive</span><span>(</span><span>IReceiver</span> receiver <span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>receiver<span>.</span><span>getInfo</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div></li>\n</ol>\n<h2 id=\"_3-依赖关系传递的三种方式和应用案例\"> 3. 依赖关系传递的三种方式和应用案例</h2>\n<ol>\n<li>接口传递</li>\n<li>构造方法传递</li>\n<li>setter 方式传递</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>DependencyPass</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>ChangHong</span> changHong <span>=</span> <span>new</span> <span>ChangHong</span><span>(</span><span>)</span><span>;</span>\n        \n        <span>//通过接口进行依赖传递</span>\n  \t\t<span>OpenAndClose</span> openAndClose1 <span>=</span> <span>new</span> <span>OpenAndClose</span><span>(</span><span>)</span><span>;</span>\n  \t\topenAndClose1<span>.</span><span>open</span><span>(</span>changHong<span>)</span><span>;</span>\n\t\t\n\t\t<span>//通过构造器进行依赖传递</span>\n  \t\t<span>OpenAndClose</span> openAndClose2 <span>=</span> <span>new</span> <span>OpenAndClose</span><span>(</span>changHong<span>)</span><span>;</span>\n  \t\topenAndClose2<span>.</span><span>open</span><span>(</span><span>)</span><span>;</span>\n        \n\t\t<span>//通过setter方法进行依赖传递</span>\n\t\t<span>OpenAndClose</span> openAndClose3 <span>=</span> <span>new</span> <span>OpenAndClose</span><span>(</span><span>)</span><span>;</span>\n\t\topenAndClose3<span>.</span><span>setTv</span><span>(</span>changHong<span>)</span><span>;</span>\n\t\topenAndClose3<span>.</span><span>open</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>}</span>\n\n<span>}</span>\n\n<span>// 方式1： 通过接口传递实现依赖</span>\n<span>// 开关的接口</span>\n<span>interface</span> <span>IOpenAndClose</span> <span>{</span>\n\t<span>public</span> <span>void</span> <span>open</span><span>(</span><span>ITV</span> tv<span>)</span><span>;</span> <span>//抽象方法,接收接口</span>\n<span>}</span>\n\n<span>interface</span> ITV <span>{</span> <span>//ITV接口</span>\n\t<span>public</span> <span>void</span> <span>play</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>class</span> <span>ChangHong</span> <span>implements</span> ITV <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>play</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"长虹电视机，打开\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\t \n<span>}</span>\n<span>// 实现接口</span>\n<span>class</span> <span>OpenAndClose</span> <span>implements</span> <span>IOpenAndClose</span><span>{</span>\n    <span>public</span> <span>void</span> <span>open</span><span>(</span><span>ITV</span> tv<span>)</span><span>{</span>\n        tv<span>.</span><span>play</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>// 方式2: 通过构造方法依赖传递</span>\n<span>interface</span> <span>IOpenAndClose</span> <span>{</span>\n\t<span>public</span> <span>void</span> <span>open</span><span>(</span><span>)</span><span>;</span> <span>//抽象方法</span>\n<span>}</span>\n\n<span>interface</span> ITV <span>{</span> <span>//ITV接口</span>\n\t<span>public</span> <span>void</span> <span>play</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>class</span> <span>OpenAndClose</span> <span>implements</span> <span>IOpenAndClose</span><span>{</span>\n    <span>public</span> <span>ITV</span> tv<span>;</span> <span>//成员</span>\n    \n    <span>public</span> <span>OpenAndClose</span><span>(</span><span>ITV</span> tv<span>)</span><span>{</span> <span>//构造器</span>\n    \t<span>this</span><span>.</span>tv <span>=</span> tv<span>;</span>\n\t<span>}</span>\n    \n\t<span>public</span> <span>void</span> <span>open</span><span>(</span><span>)</span><span>{</span>\n    \t<span>this</span><span>.</span>tv<span>.</span><span>play</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n\n<span>// 方式3 , 通过setter方法传递</span>\n<span>interface</span> <span>IOpenAndClose</span> <span>{</span>\n\t<span>public</span> <span>void</span> <span>open</span><span>(</span><span>)</span><span>;</span> <span>// 抽象方法</span>\n\t<span>public</span> <span>void</span> <span>setTv</span><span>(</span><span>ITV</span> tv<span>)</span><span>;</span>\n<span>}</span>\n\n<span>interface</span> ITV <span>{</span> <span>// ITV接口</span>\n\t<span>public</span> <span>void</span> <span>play</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>class</span> <span>OpenAndClose</span> <span>implements</span> <span>IOpenAndClose</span> <span>{</span>\n\t<span>private</span> <span>ITV</span> tv<span>;</span>\n\n\t<span>public</span> <span>void</span> <span>setTv</span><span>(</span><span>ITV</span> tv<span>)</span> <span>{</span>\n\t\t<span>this</span><span>.</span>tv <span>=</span> tv<span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>void</span> <span>open</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>this</span><span>.</span>tv<span>.</span><span>play</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>class</span> <span>ChangHong</span> <span>implements</span> ITV <span>{</span>\n\n\t<span>@Override</span>\n\t<span>public</span> <span>void</span> <span>play</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>// TODO Auto-generated method stub</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"长虹电视机，打开\"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br></div></div><h2 id=\"_4-依赖倒转原则的注意事项和细节\"> 4. 依赖倒转原则的注意事项和细节</h2>\n<ol>\n<li>低层模块尽量都要有抽象类或接口，或者两者都有程，序稳定性更好</li>\n<li>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层,利于程序扩展 和优化</li>\n<li>继承时遵循里氏替换原则</li>\n</ol>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "开闭原则",
      "url": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/design-principle/5.%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/design-principle/5.%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/",
      "content_html": "<h1 id=\"开闭原则\"> 开闭原则</h1>\n<h2 id=\"_1-基本介绍\"> 1. 基本介绍</h2>\n<ol>\n<li>开闭原则(Open Closed Principle)是编程中最基础,最重要的设计原则</li>\n<li>一个软件实体如类,模块和函数应该对扩展开放(对提供方),对修改关闭(对使用方).用抽象构建框架,用实 现扩展细节.</li>\n<li>当软件需要变化时,尽量通过扩展软件实体的行为来实现变化,而不是通过修改已有的代码来实现变化.</li>\n<li>编程中遵循其它原则,以及使用设计模式的目的就是遵循开闭原则.</li>\n</ol>\n<h2 id=\"_2-应用实例\"> 2. 应用实例</h2>\n<p>看一个画图形的功能</p>\n<p>类图设计,如下:</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Ocp</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>//使用看看存在的问题</span>\n\t\t<span>GraphicEditor</span> graphicEditor <span>=</span> <span>new</span> <span>GraphicEditor</span><span>(</span><span>)</span><span>;</span>\n\t\tgraphicEditor<span>.</span><span>drawShape</span><span>(</span><span>new</span> <span>Rectangle</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\tgraphicEditor<span>.</span><span>drawShape</span><span>(</span><span>new</span> <span>Circle</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\tgraphicEditor<span>.</span><span>drawShape</span><span>(</span><span>new</span> <span>Triangle</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n<span>}</span>\n\n<span>//这是一个用于绘图的类 [使用方]</span>\n<span>class</span> <span>GraphicEditor</span> <span>{</span>\n\t<span>//接收Shape对象，然后根据type，来绘制不同的图形</span>\n\t<span>public</span> <span>void</span> <span>drawShape</span><span>(</span><span>Shape</span> s<span>)</span> <span>{</span>\n\t\t<span>if</span> <span>(</span>s<span>.</span>m_type <span>==</span> <span>1</span><span>)</span>\n\t\t\t<span>drawRectangle</span><span>(</span>s<span>)</span><span>;</span>\n\t\t<span>else</span> <span>if</span> <span>(</span>s<span>.</span>m_type <span>==</span> <span>2</span><span>)</span>\n\t\t\t<span>drawCircle</span><span>(</span>s<span>)</span><span>;</span>\n\t\t<span>else</span> <span>if</span> <span>(</span>s<span>.</span>m_type <span>==</span> <span>3</span><span>)</span>\n\t\t\t<span>drawTriangle</span><span>(</span>s<span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>//绘制矩形</span>\n\t<span>public</span> <span>void</span> <span>drawRectangle</span><span>(</span><span>Shape</span> r<span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\" 绘制矩形 \"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>//绘制圆形</span>\n\t<span>public</span> <span>void</span> <span>drawCircle</span><span>(</span><span>Shape</span> r<span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\" 绘制圆形 \"</span><span>)</span><span>;</span>\n\t<span>}</span>\n\t\n\t<span>//绘制三角形</span>\n\t<span>public</span> <span>void</span> <span>drawTriangle</span><span>(</span><span>Shape</span> r<span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\" 绘制三角形 \"</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>//Shape类，基类</span>\n<span>class</span> <span>Shape</span> <span>{</span>\n\t<span>int</span> m_type<span>;</span>\n<span>}</span>\n\n<span>class</span> <span>Rectangle</span> <span>extends</span> <span>Shape</span> <span>{</span>\n\t<span>Rectangle</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>super</span><span>.</span>m_type <span>=</span> <span>1</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Circle</span> <span>extends</span> <span>Shape</span> <span>{</span>\n\t<span>Circle</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>super</span><span>.</span>m_type <span>=</span> <span>2</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>//新增画三角形</span>\n<span>class</span> <span>Triangle</span> <span>extends</span> <span>Shape</span> <span>{</span>\n\t<span>Triangle</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>super</span><span>.</span>m_type <span>=</span> <span>3</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><blockquote>\n<p>优缺点分析</p>\n<ol>\n<li>优点是比较好理解,简单易操作</li>\n<li>缺点是违反了设计模式的 ocp 原则,即对扩展开放(提供方),对修改关闭(使用方).即当我们给类增加新功能的 时候,尽量不修改代码,或者尽可能少修改代码.</li>\n<li>比如我们这时要新增加一个图形种类 三角形,我们需要做如下修改,修改的地方较多</li>\n</ol>\n</blockquote>\n<p>改进上述代码</p>\n<p>思路：把创建 Shape 类做成抽象类,并提供一个抽象的 draw 方法,让子类去实现即可,这样我们有新的图形 种类时,只需要让新的图形类继承 Shape,并实现 draw 方法即可,使用方的代码就不需要修 -&gt; 满足了开闭原则</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Ocp</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>//使用看看存在的问题</span>\n\t\t<span>GraphicEditor</span> graphicEditor <span>=</span> <span>new</span> <span>GraphicEditor</span><span>(</span><span>)</span><span>;</span>\n\t\tgraphicEditor<span>.</span><span>drawShape</span><span>(</span><span>new</span> <span>Rectangle</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\tgraphicEditor<span>.</span><span>drawShape</span><span>(</span><span>new</span> <span>Circle</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\tgraphicEditor<span>.</span><span>drawShape</span><span>(</span><span>new</span> <span>Triangle</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\tgraphicEditor<span>.</span><span>drawShape</span><span>(</span><span>new</span> <span>OtherGraphic</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n<span>}</span>\n\n<span>//这是一个用于绘图的类 [使用方]</span>\n<span>class</span> <span>GraphicEditor</span> <span>{</span>\n\t<span>//接收Shape对象，调用draw方法</span>\n\t<span>public</span> <span>void</span> <span>drawShape</span><span>(</span><span>Shape</span> s<span>)</span> <span>{</span>\n\t\ts<span>.</span><span>draw</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>//Shape类，基类</span>\n<span>abstract</span> <span>class</span> <span>Shape</span> <span>{</span>\n\t<span>int</span> m_type<span>;</span>\n\t\n\t<span>public</span> <span>abstract</span> <span>void</span> <span>draw</span><span>(</span><span>)</span><span>;</span><span>//抽象方法</span>\n<span>}</span>\n\n<span>class</span> <span>Rectangle</span> <span>extends</span> <span>Shape</span> <span>{</span>\n\t<span>Rectangle</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>super</span><span>.</span>m_type <span>=</span> <span>1</span><span>;</span>\n\t<span>}</span>\n\n\t<span>@Override</span>\n\t<span>public</span> <span>void</span> <span>draw</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>// TODO Auto-generated method stub</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\" 绘制矩形 \"</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Circle</span> <span>extends</span> <span>Shape</span> <span>{</span>\n\t<span>Circle</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>super</span><span>.</span>m_type <span>=</span> <span>2</span><span>;</span>\n\t<span>}</span>\n\t<span>@Override</span>\n\t<span>public</span> <span>void</span> <span>draw</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>// TODO Auto-generated method stub</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\" 绘制圆形 \"</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>//新增画三角形</span>\n<span>class</span> <span>Triangle</span> <span>extends</span> <span>Shape</span> <span>{</span>\n\t<span>Triangle</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>super</span><span>.</span>m_type <span>=</span> <span>3</span><span>;</span>\n\t<span>}</span>\n\t<span>@Override</span>\n\t<span>public</span> <span>void</span> <span>draw</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>// TODO Auto-generated method stub</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\" 绘制三角形 \"</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>//新增一个图形</span>\n<span>class</span> <span>OtherGraphic</span> <span>extends</span> <span>Shape</span> <span>{</span>\n\t<span>OtherGraphic</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>super</span><span>.</span>m_type <span>=</span> <span>4</span><span>;</span>\n\t<span>}</span>\n\n\t<span>@Override</span>\n\t<span>public</span> <span>void</span> <span>draw</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>// TODO Auto-generated method stub</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\" 绘制其它图形 \"</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "里氏替换原则",
      "url": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/design-principle/4.%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/design-principle/4.%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/",
      "content_html": "<h1 id=\"里氏替换原则\"> 里氏替换原则</h1>\n<h2 id=\"_1-oo-中的继承性的思考和说明\"> 1. OO 中的继承性的思考和说明</h2>\n<ol>\n<li>继承包含这样一层含义：父类中凡是已经实现好的方法,实际上是在设定规范和契约,虽然它不强制要求所有 的子类必须遵循这些契约,但是如果子类对这些已经实现的方法任意修改,就会对整个继承体系造成破坏.</li>\n<li>继承在给程序设计带来便利的同时,也带来了弊端.比如使用继承会给程序带来侵入性,程序的可移植性降低, 增加对象间的耦合性,如果一个类被其他的类所继承,则当这个类需要修改时,必须考虑到所有的子类,并且父类修改后,所有涉及到子类的功能都有可能产生故障</li>\n<li>问题提出：在编程中,如何正确的使用继承? =&gt; 里氏替换原则</li>\n</ol>\n<h2 id=\"_2-基本介绍\"> 2. 基本介绍</h2>\n<ol>\n<li>里氏替换原则(Liskov Substitution Principle)在 1988 年,由麻省理工学院的以为姓里的女士提出的</li>\n<li>如果对每个类型为 T1 的对象 o1,都有类型为 T2 的对象 o2,使得以 T1 定义的所有程序 P 在所有的对象 o1 都 代换成 o2 时,程序 P 的行为没有发生变化,那么类型 T2 是类型 T1 的子类型.换句话说,所有引用基类的地方必须能透明地使用其子类的对象.</li>\n<li>在使用继承时,遵循里氏替换原则,在子类中尽量不要重写父类的方法</li>\n<li>里氏替换原则告诉我们,继承实际上让两个类耦合性增强了,在适当的情况下,可以通过聚合,组合,依赖 来 解决问题..</li>\n</ol>\n<h2 id=\"_3-应用实例\"> 3.应用实例</h2>\n<ol>\n<li>\n<p>未使用里氏替换原则</p>\n<p>该看个程序, 思考下问题和解决思路</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Liskov</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>// TODO Auto-generated method stub</span>\n\t\t<span>A</span> a <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"11-3=\"</span> <span>+</span> a<span>.</span><span>func1</span><span>(</span><span>11</span><span>,</span> <span>3</span><span>)</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"1-8=\"</span> <span>+</span> a<span>.</span><span>func1</span><span>(</span><span>1</span><span>,</span> <span>8</span><span>)</span><span>)</span><span>;</span>\n\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"-----------------------\"</span><span>)</span><span>;</span>\n\t\t<span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"11-3=\"</span> <span>+</span> b<span>.</span><span>func1</span><span>(</span><span>11</span><span>,</span> <span>3</span><span>)</span><span>)</span><span>;</span><span>//这里本意是求出11-3</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"1-8=\"</span> <span>+</span> b<span>.</span><span>func1</span><span>(</span><span>1</span><span>,</span> <span>8</span><span>)</span><span>)</span><span>;</span><span>// 1-8</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"11+3+9=\"</span> <span>+</span> b<span>.</span><span>func2</span><span>(</span><span>11</span><span>,</span> <span>3</span><span>)</span><span>)</span><span>;</span>\n\t\t\n\t<span>}</span>\n\n<span>}</span>\n\n<span>// A类</span>\n<span>class</span> <span>A</span> <span>{</span>\n\t<span>// 返回两个数的差</span>\n\t<span>public</span> <span>int</span> <span>func1</span><span>(</span><span>int</span> num1<span>,</span> <span>int</span> num2<span>)</span> <span>{</span>\n\t\t<span>return</span> num1 <span>-</span> num2<span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>// B类继承了A</span>\n<span>// 增加了一个新功能：完成两个数相加,然后和9求和</span>\n<span>class</span> <span>B</span> <span>extends</span> <span>A</span> <span>{</span>\n\t<span>//这里，重写了A类的方法, 可能是无意识</span>\n\t<span>public</span> <span>int</span> <span>func1</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n\t\t<span>return</span> a <span>+</span> b<span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>int</span> <span>func2</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n\t\t<span>return</span> <span>func1</span><span>(</span>a<span>,</span> b<span>)</span> <span>+</span> <span>9</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div></li>\n<li>\n<p>解决方法</p>\n<ol>\n<li>我们发现原来运行正常的相减功能发生了错误.原因就是类 B 无意中重写了父类的方法,造成原有功能出现错 误.在实际编程中,我们常常会通过重写父类的方法完成新的功能,这样写起来虽然简单,但整个继承体系的复用性会比较差.特别是运行多态比较频繁的时候</li>\n<li>通用的做法是：原来的父类和子类都继承一个更通俗的基类,原有的继承关系去掉,采用依赖,聚合,组合等 关系代替</li>\n</ol>\n</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>Liskov</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>// TODO Auto-generated method stub</span>\n\t\t<span>A</span> a <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"11-3=\"</span> <span>+</span> a<span>.</span><span>func1</span><span>(</span><span>11</span><span>,</span> <span>3</span><span>)</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"1-8=\"</span> <span>+</span> a<span>.</span><span>func1</span><span>(</span><span>1</span><span>,</span> <span>8</span><span>)</span><span>)</span><span>;</span>\n\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"-----------------------\"</span><span>)</span><span>;</span>\n\t\t<span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>//因为B类不再继承A类，因此调用者，不会再func1是求减法</span>\n\t\t<span>//调用完成的功能就会很明确</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"11+3=\"</span> <span>+</span> b<span>.</span><span>func1</span><span>(</span><span>11</span><span>,</span> <span>3</span><span>)</span><span>)</span><span>;</span><span>//这里本意是求出11+3</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"1+8=\"</span> <span>+</span> b<span>.</span><span>func1</span><span>(</span><span>1</span><span>,</span> <span>8</span><span>)</span><span>)</span><span>;</span><span>// 1+8</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"11+3+9=\"</span> <span>+</span> b<span>.</span><span>func2</span><span>(</span><span>11</span><span>,</span> <span>3</span><span>)</span><span>)</span><span>;</span>\n\t\t\n\t\t\n\t\t<span>//使用组合仍然可以使用到A类相关方法</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"11-3=\"</span> <span>+</span> b<span>.</span><span>func3</span><span>(</span><span>11</span><span>,</span> <span>3</span><span>)</span><span>)</span><span>;</span><span>// 这里本意是求出11-3</span>\n\t\t\n\n\t<span>}</span>\n\n<span>}</span>\n\n<span>//创建一个更加基础的基类</span>\n<span>class</span> <span>Base</span> <span>{</span>\n\t<span>//把更加基础的方法和成员写到Base类</span>\n<span>}</span>\n\n<span>// A类</span>\n<span>class</span> <span>A</span> <span>extends</span> <span>Base</span> <span>{</span>\n\t<span>// 返回两个数的差</span>\n\t<span>public</span> <span>int</span> <span>func1</span><span>(</span><span>int</span> num1<span>,</span> <span>int</span> num2<span>)</span> <span>{</span>\n\t\t<span>return</span> num1 <span>-</span> num2<span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>// B类继承了A</span>\n<span>// 增加了一个新功能：完成两个数相加,然后和9求和</span>\n<span>class</span> <span>B</span> <span>extends</span> <span>Base</span> <span>{</span>\n\t<span>//如果B需要使用A类的方法,使用组合关系</span>\n\t<span>private</span> <span>A</span> a <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>\n\t\n\t<span>//这里，重写了A类的方法, 可能是无意识</span>\n\t<span>public</span> <span>int</span> <span>func1</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n\t\t<span>return</span> a <span>+</span> b<span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>int</span> <span>func2</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n\t\t<span>return</span> <span>func1</span><span>(</span>a<span>,</span> b<span>)</span> <span>+</span> <span>9</span><span>;</span>\n\t<span>}</span>\n\t\n\t<span>//我们仍然想使用A的方法</span>\n\t<span>public</span> <span>int</span> <span>func3</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n\t\t<span>return</span> <span>this</span><span>.</span>a<span>.</span><span>func1</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "迪米特法则",
      "url": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/design-principle/6.%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/design-principle/6.%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/",
      "content_html": "<h1 id=\"迪米特法则\"> 迪米特法则</h1>\n<h2 id=\"_1-基本介绍\"> 1. 基本介绍</h2>\n<ol>\n<li>一个对象应该对其他对象保持最少的了解</li>\n<li>类与类关系越密切,耦合度越大</li>\n<li>迪米特法则(Demeter Principle)又叫最少知道原则,即一个类对自己依赖的类知道的越少越好.也就是说,对于 被依赖的类不管多么复杂,都尽量将逻辑封装在类的内部.对外除了提供的 public 方法,不对外泄露任何信息</li>\n<li>迪米特法则还有个更简单的定义：只与直接的朋友通信</li>\n<li>直接的朋友：每个对象都会与其他对象有耦合关系,只要两个对象之间有耦合关系,我们就说这两个对象之间 是朋友关系.耦合的方式很多,依赖,关联,组合,聚合等.其中,我们称出现成员变量,方法参数,方法返 回值中的类为直接的朋友,而出现在局部变量中的类不是直接的朋友.也就是说,陌生的类最好不要以局部变 量的形式出现在类的内部.</li>\n</ol>\n<h2 id=\"_2-应用实例\"> 2. 应用实例</h2>\n<p>有一个学校,下属有各个学院和总部,现要求打印出学校总部员工 ID 和学院员工的 id</p>\n<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>ArrayList</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>List</span><span>;</span>\n\n<span>//客户端</span>\n<span>public</span> <span>class</span> <span>Demeter1</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>//创建了一个 SchoolManager 对象</span>\n\t\t<span>SchoolManager</span> schoolManager <span>=</span> <span>new</span> <span>SchoolManager</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>//输出学院的员工id 和  学校总部的员工信息</span>\n\t\tschoolManager<span>.</span><span>printAllEmployee</span><span>(</span><span>new</span> <span>CollegeManager</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n\t<span>}</span>\n\n<span>}</span>\n\n\n<span>//学校总部员工类</span>\n<span>class</span> <span>Employee</span> <span>{</span>\n\t<span>private</span> <span>String</span> id<span>;</span>\n\n\t<span>public</span> <span>void</span> <span>setId</span><span>(</span><span>String</span> id<span>)</span> <span>{</span>\n\t\t<span>this</span><span>.</span>id <span>=</span> id<span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>String</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>return</span> id<span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n\n<span>//学院的员工类</span>\n<span>class</span> <span>CollegeEmployee</span> <span>{</span>\n\t<span>private</span> <span>String</span> id<span>;</span>\n\n\t<span>public</span> <span>void</span> <span>setId</span><span>(</span><span>String</span> id<span>)</span> <span>{</span>\n\t\t<span>this</span><span>.</span>id <span>=</span> id<span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>String</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>return</span> id<span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n\n<span>//管理学院员工的管理类</span>\n<span>class</span> <span>CollegeManager</span> <span>{</span>\n\t<span>//返回学院的所有员工</span>\n\t<span>public</span> <span>List</span><span><span>&lt;</span><span>CollegeEmployee</span><span>></span></span> <span>getAllEmployee</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>List</span><span><span>&lt;</span><span>CollegeEmployee</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>CollegeEmployee</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\t\t<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span> <span>//这里我们增加了10个员工到 list</span>\n\t\t\t<span>CollegeEmployee</span> emp <span>=</span> <span>new</span> <span>CollegeEmployee</span><span>(</span><span>)</span><span>;</span>\n\t\t\temp<span>.</span><span>setId</span><span>(</span><span>\"学院员工id= \"</span> <span>+</span> i<span>)</span><span>;</span>\n\t\t\tlist<span>.</span><span>add</span><span>(</span>emp<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>return</span> list<span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>//学校管理类</span>\n\n<span>//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span>\n<span>//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 </span>\n<span>class</span> <span>SchoolManager</span> <span>{</span>\n\t<span>//返回学校总部的员工</span>\n\t<span>public</span> <span>List</span><span><span>&lt;</span><span>Employee</span><span>></span></span> <span>getAllEmployee</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>List</span><span><span>&lt;</span><span>Employee</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Employee</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\t\t\n\t\t<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span> <span>//这里我们增加了5个员工到 list</span>\n\t\t\t<span>Employee</span> emp <span>=</span> <span>new</span> <span>Employee</span><span>(</span><span>)</span><span>;</span>\n\t\t\temp<span>.</span><span>setId</span><span>(</span><span>\"学校总部员工id= \"</span> <span>+</span> i<span>)</span><span>;</span>\n\t\t\tlist<span>.</span><span>add</span><span>(</span>emp<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>return</span> list<span>;</span>\n\t<span>}</span>\n\n\t<span>//该方法完成输出学校总部和学院员工信息(id)</span>\n\t<span>void</span> <span>printAllEmployee</span><span>(</span><span>CollegeManager</span> sub<span>)</span> <span>{</span>\n\t\t\n\t\t<span>//分析问题</span>\n\t\t<span>//1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友</span>\n\t\t<span>//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span>\n\t\t<span>//3. 违反了 迪米特法则 </span>\n\t\t\n\t\t<span>//获取到学院员工</span>\n\t\t<span>List</span><span><span>&lt;</span><span>CollegeEmployee</span><span>></span></span> list1 <span>=</span> sub<span>.</span><span>getAllEmployee</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"------------学院员工------------\"</span><span>)</span><span>;</span>\n\t\t<span>for</span> <span>(</span><span>CollegeEmployee</span> e <span>:</span> list1<span>)</span> <span>{</span>\n\t\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>e<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>//获取到学校总部员工</span>\n\t\t<span>List</span><span><span>&lt;</span><span>Employee</span><span>></span></span> list2 <span>=</span> <span>this</span><span>.</span><span>getAllEmployee</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"------------学校总部员工------------\"</span><span>)</span><span>;</span>\n\t\t<span>for</span> <span>(</span><span>Employee</span> e <span>:</span> list2<span>)</span> <span>{</span>\n\t\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>e<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br></div></div><p>改进</p>\n<ol>\n<li>前面设计的问题在于 SchoolManager 中,CollegeEmployee 类并不是 SchoolManager 类的直接朋友 (分析)</li>\n<li>按照迪米特法则,应该避免类中出现这样非直接朋友关系的耦合</li>\n</ol>\n<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>ArrayList</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>List</span><span>;</span>\n\n<span>//客户端</span>\n<span>public</span> <span>class</span> <span>Demeter1</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"~~~使用迪米特法则的改进~~~\"</span><span>)</span><span>;</span>\n\t\t<span>//创建了一个 SchoolManager 对象</span>\n\t\t<span>SchoolManager</span> schoolManager <span>=</span> <span>new</span> <span>SchoolManager</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>//输出学院的员工id 和  学校总部的员工信息</span>\n\t\tschoolManager<span>.</span><span>printAllEmployee</span><span>(</span><span>new</span> <span>CollegeManager</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n\t<span>}</span>\n\n<span>}</span>\n\n\n<span>//学校总部员工类</span>\n<span>class</span> <span>Employee</span> <span>{</span>\n\t<span>private</span> <span>String</span> id<span>;</span>\n\n\t<span>public</span> <span>void</span> <span>setId</span><span>(</span><span>String</span> id<span>)</span> <span>{</span>\n\t\t<span>this</span><span>.</span>id <span>=</span> id<span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>String</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>return</span> id<span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n\n<span>//学院的员工类</span>\n<span>class</span> <span>CollegeEmployee</span> <span>{</span>\n\t<span>private</span> <span>String</span> id<span>;</span>\n\n\t<span>public</span> <span>void</span> <span>setId</span><span>(</span><span>String</span> id<span>)</span> <span>{</span>\n\t\t<span>this</span><span>.</span>id <span>=</span> id<span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>String</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>return</span> id<span>;</span>\n\t<span>}</span>\n<span>}</span>\n\n\n<span>//管理学院员工的管理类</span>\n<span>class</span> <span>CollegeManager</span> <span>{</span>\n\t<span>//返回学院的所有员工</span>\n\t<span>public</span> <span>List</span><span><span>&lt;</span><span>CollegeEmployee</span><span>></span></span> <span>getAllEmployee</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>List</span><span><span>&lt;</span><span>CollegeEmployee</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>CollegeEmployee</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\t\t<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span> <span>//这里我们增加了10个员工到 list</span>\n\t\t\t<span>CollegeEmployee</span> emp <span>=</span> <span>new</span> <span>CollegeEmployee</span><span>(</span><span>)</span><span>;</span>\n\t\t\temp<span>.</span><span>setId</span><span>(</span><span>\"学院员工id= \"</span> <span>+</span> i<span>)</span><span>;</span>\n\t\t\tlist<span>.</span><span>add</span><span>(</span>emp<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>return</span> list<span>;</span>\n\t<span>}</span>\n\t\n\t<span>//输出学院员工的信息</span>\n\t<span>public</span> <span>void</span> <span>printEmployee</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>//获取到学院员工</span>\n\t\t<span>List</span><span><span>&lt;</span><span>CollegeEmployee</span><span>></span></span> list1 <span>=</span> <span>getAllEmployee</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"------------学院员工------------\"</span><span>)</span><span>;</span>\n\t\t<span>for</span> <span>(</span><span>CollegeEmployee</span> e <span>:</span> list1<span>)</span> <span>{</span>\n\t\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>e<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n<span>}</span>\n\n<span>//学校管理类</span>\n\n<span>//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span>\n<span>//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 </span>\n<span>class</span> <span>SchoolManager</span> <span>{</span>\n\t<span>//返回学校总部的员工</span>\n\t<span>public</span> <span>List</span><span><span>&lt;</span><span>Employee</span><span>></span></span> <span>getAllEmployee</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>List</span><span><span>&lt;</span><span>Employee</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Employee</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\t\t\n\t\t<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span> <span>//这里我们增加了5个员工到 list</span>\n\t\t\t<span>Employee</span> emp <span>=</span> <span>new</span> <span>Employee</span><span>(</span><span>)</span><span>;</span>\n\t\t\temp<span>.</span><span>setId</span><span>(</span><span>\"学校总部员工id= \"</span> <span>+</span> i<span>)</span><span>;</span>\n\t\t\tlist<span>.</span><span>add</span><span>(</span>emp<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>return</span> list<span>;</span>\n\t<span>}</span>\n\n\t<span>//该方法完成输出学校总部和学院员工信息(id)</span>\n\t<span>void</span> <span>printAllEmployee</span><span>(</span><span>CollegeManager</span> sub<span>)</span> <span>{</span>\n\t\t\n\t\t<span>//分析问题</span>\n\t\t<span>//1. 将输出学院的员工方法，封装到CollegeManager</span>\n\t\tsub<span>.</span><span>printEmployee</span><span>(</span><span>)</span><span>;</span>\n\t\n\t\t<span>//获取到学校总部员工</span>\n\t\t<span>List</span><span><span>&lt;</span><span>Employee</span><span>></span></span> list2 <span>=</span> <span>this</span><span>.</span><span>getAllEmployee</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"------------学校总部员工------------\"</span><span>)</span><span>;</span>\n\t\t<span>for</span> <span>(</span><span>Employee</span> e <span>:</span> list2<span>)</span> <span>{</span>\n\t\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>e<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br></div></div><h2 id=\"_3-迪米特法则注意事项和细节\"> 3. 迪米特法则注意事项和细节</h2>\n<ol>\n<li>迪米特法则的核心是降低类之间的耦合</li>\n<li>但是注意：由于每个类都减少了不必要的依赖,因此迪米特法则只是要求降低类间(对象间)耦合关系, 并不是 要求完全没有依赖关系</li>\n</ol>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "合成复用原则",
      "url": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/design-principle/7.%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/design-principle/7.%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/",
      "content_html": "<h1 id=\"合成复用原则\"> 合成复用原则</h1>\n<h2 id=\"_1-基本介绍\"> 1. 基本介绍</h2>\n<p>原则是尽量使用合成/聚合的方式，而不是使用继承</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "计算机网络",
      "url": "http://blog.alanlee.top/blog-vuepress/common/network/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/network/",
      "content_html": "<h1 id=\"计算机网络\"> 计算机网络</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "设计模式-单例模式",
      "url": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F01-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/design-pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F01-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/",
      "content_html": "<h1 id=\"设计模式-单例模式\"> 设计模式-单例模式</h1>\n<h2 id=\"知识点\"> 知识点</h2>\n<h3 id=\"什么是单例模式\"> 什么是单例模式？</h3>\n<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>\n<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>\n<p>单例模式有分为<strong>饿汉式</strong>和<strong>懒汉式</strong></p>\n<p><strong>特点：</strong></p>\n<ul>\n<li>1、单例类只能有一个实例。</li>\n<li>2、单例类必须自己创建自己的唯一实例。</li>\n<li>3、单例类必须给所有其他对象提供这一实例。</li>\n</ul>\n<p><strong>应用实例：</strong></p>\n<ul>\n<li>1、一个班级只有一个班主任。</li>\n<li>2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li>\n<li>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li>\n</ul>\n<p><strong>优点：</strong></p>\n<ul>\n<li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例）。</li>\n<li>2、避免对资源的多重占用（比如写文件操作）。</li>\n</ul>\n<p>**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>\n<p><strong>使用场景：</strong></p>\n<ul>\n<li>1、要求生产唯一序列号。</li>\n<li>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>\n<li>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li>\n</ul>\n<p>**注意事项：**getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>\n<h2 id=\"实例\"> 实例</h2>\n<h3 id=\"单例模式-饿汉式\"> 单例模式-饿汉式</h3>\n<p><strong>代码</strong></p>\n<div><pre><code><span>//单例模式-饿汉式</span>\n<span>public</span> <span>class</span> <span>SingletonDemo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>//编译错误：无法实例化</span>\n        <span>// Singleton singleton = new Singleton();</span>\n        \n        <span>//正确获取对象的方法</span>\n        <span>Singleton</span> singleton <span>=</span> <span>Singleton</span><span>.</span><span>getINSTANCE</span><span>(</span><span>)</span><span>;</span>\n        singleton<span>.</span><span>hello</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Singleton</span><span>{</span>\n    <span>//创建一个本身对象</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>Singleton</span> INSTANCE <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n\n    <span>//让构造方法为private，这样该类就不会被实例化</span>\n    <span>private</span> <span>Singleton</span><span>(</span><span>)</span><span>{</span><span>}</span>\n\n    <span>//创建一个获取对象的方法</span>\n    <span>public</span> <span>static</span> <span>Singleton</span> <span>getINSTANCE</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> INSTANCE<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>hello</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Hello World! ——单例模式-饿汉式\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code><span>Hello</span> <span>World</span><span>!</span> ——单例模式<span>-</span>饿汉式\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"单例模式-懒汉式-线程不安全版\"> 单例模式-懒汉式（线程不安全版）</h3>\n<p>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。\n这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p>\n<p><strong>代码</strong></p>\n<div><pre><code><span>//单例模式-懒汉式</span>\n<span>public</span> <span>class</span> <span>SingletonDemo2</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Singleton2</span> singleton <span>=</span> <span>Singleton2</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\n        singleton<span>.</span><span>hello</span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n\n<span>}</span>\n\n<span>class</span> <span>Singleton2</span><span>{</span>\n    <span>private</span> <span>static</span> <span>Singleton2</span> instance<span>;</span>\n    <span>private</span> <span>Singleton2</span><span>(</span><span>)</span><span>{</span><span>}</span>\n\n    <span>public</span> <span>static</span> <span>Singleton2</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span><span>{</span>\n            instance <span>=</span> <span>new</span> <span>Singleton2</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> instance<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>hello</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Hello World! ——单例模式-懒汉式\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code><span>Hello</span> <span>World</span><span>!</span> ——单例模式<span>-</span>懒汉式\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"单例模式-懒汉式-线程安全版\"> 单例模式-懒汉式（线程安全版）</h3>\n<p>**描述：**这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。\n**优点：**第一次调用才初始化，避免内存浪费。\n**缺点：**必须加锁 synchronized 才能保证单例，但加锁会影响效率。\ngetInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p>\n<p><strong>代码</strong></p>\n<div><pre><code><span>//单例模式-懒汉式</span>\n<span>public</span> <span>class</span> <span>SingletonDemo3</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Singleton3</span> singleton <span>=</span> <span>Singleton3</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\n        singleton<span>.</span><span>hello</span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n\n<span>}</span>\n\n<span>class</span> <span>Singleton3</span><span>{</span>\n    <span>private</span> <span>static</span> <span>Singleton3</span> instance<span>;</span>\n    <span>private</span> <span>Singleton3</span><span>(</span><span>)</span><span>{</span><span>}</span>\n\n    <span>public</span> <span>synchronized</span> <span>static</span> <span>Singleton3</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span><span>{</span>\n            instance <span>=</span> <span>new</span> <span>Singleton3</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> instance<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>hello</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Hello World! ——单例模式-懒汉式\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p><strong>结果</strong></p>\n<div><pre><code><span>Hello</span> <span>World</span><span>!</span> ——单例模式<span>-</span>懒汉式\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2020-01-30T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "TCP",
      "url": "http://blog.alanlee.top/blog-vuepress/common/network/tcp/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/network/tcp/",
      "content_html": "<h1 id=\"tcp\"> TCP</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "HTTP",
      "url": "http://blog.alanlee.top/blog-vuepress/common/network/http/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/network/http/",
      "content_html": "<h1 id=\"http\"> HTTP</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "计算机网络知识点总结",
      "url": "http://blog.alanlee.top/blog-vuepress/common/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/",
      "content_html": "<h1 id=\"计算机网络知识点总结\"> 计算机网络知识点总结</h1>\n<h5 id=\"_1-计算机概述\"> 1. <a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E5%B9%B2%E8%B4%A7%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.md#%E4%B8%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%BF%B0\" target=\"_blank\" rel=\"noopener noreferrer\">计算机概述</a></h5>\n<h5 id=\"_2-物理层\"> 2. <a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E5%B9%B2%E8%B4%A7%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.md#%E4%BA%8C%E7%89%A9%E7%90%86%E5%B1%82\" target=\"_blank\" rel=\"noopener noreferrer\">物理层</a></h5>\n<h5 id=\"_3-数据链路层\"> 3. <a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E5%B9%B2%E8%B4%A7%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.md#%E4%B8%89%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82\" target=\"_blank\" rel=\"noopener noreferrer\">数据链路层</a></h5>\n<h5 id=\"_4-网络层\"> 4. <a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E5%B9%B2%E8%B4%A7%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.md#%E5%9B%9B%E7%BD%91%E7%BB%9C%E5%B1%82\" target=\"_blank\" rel=\"noopener noreferrer\">网络层</a></h5>\n<h5 id=\"_5-运输层\"> 5. <a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E5%B9%B2%E8%B4%A7%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.md#%E4%BA%94%E8%BF%90%E8%BE%93%E5%B1%82\" target=\"_blank\" rel=\"noopener noreferrer\">运输层</a></h5>\n<h5 id=\"_6-应用层\"> 6. <a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E5%B9%B2%E8%B4%A7%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.md#%E5%85%AD%E5%BA%94%E7%94%A8%E5%B1%82\" target=\"_blank\" rel=\"noopener noreferrer\">应用层</a></h5>\n<h2 id=\"一、计算机概述\"> 一、计算机概述</h2>\n<h3 id=\"_1-基本术语\"> （1）基本术语</h3>\n<h4 id=\"结点-node\"> 结点 （node）：</h4>\n<div><pre><code>网络中的结点可以是计算机，集线器，交换机或路由器等。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"链路-link\"> 链路（link ）：</h4>\n<div><pre><code>从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"主机-host\"> 主机（host）：</h4>\n<div><pre><code>连接在因特网上的计算机.\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"isp-internet-service-provider\"> ISP（Internet Service Provider）：</h4>\n<div><pre><code>因特网服务提供者（提供商）.\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"ixp-internet-exchange-point\"> IXP（Internet eXchange Point）：</h4>\n<div><pre><code>互联网交换点IXP的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。.\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"rfc-request-for-comments\"> RFC(Request For Comments)</h4>\n<div><pre><code>意思是“请求评议”，包含了关于Internet几乎所有的重要的文字资料。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"广域网wan-wide-area-network\"> 广域网WAN（Wide Area Network）</h4>\n<div><pre><code>任务是通过长距离运送主机发送的数据\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"城域网man-metropolitan-area-network\"> 城域网MAN（Metropolitan Area Network）</h4>\n<div><pre><code>用来将多个局域网进行互连\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"局域网lan-local-area-network\"> 局域网LAN（Local Area Network）</h4>\n<div><pre><code> 学校或企业大多拥有多个互连的局域网\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"个人区域网pan-personal-area-network\"> 个人区域网PAN（Personal Area Network）</h4>\n<div><pre><code>在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络  \n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"端系统-end-system\"> 端系统（end system）：</h4>\n<div><pre><code>处在因特网边缘的部分即是连接在因特网上的所有的主机.\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"分组-packet\"> 分组（packet ）：</h4>\n<div><pre><code>因特网中传送的数据单元。由首部header和数据段组成。分组又称为包，首部可称为包头。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"存储转发-store-and-forward\"> 存储转发（store and forward ）:</h4>\n<div><pre><code>路由器收到一个分组，先存储下来，再检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"带宽-bandwidth\"> 带宽（bandwidth）：</h4>\n<div><pre><code>在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为b/s。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"吞吐量-throughput\"> 吞吐量（throughput ）：</h4>\n<div><pre><code>表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-重要知识点总结\"> （2）重要知识点总结</h3>\n<p>1，计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</p>\n<p>2，小写字母i开头的internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。</p>\n<p>大写字母I开头的Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用TCP/IP协议作为通信规则，其前身为ARPANET。Internet的推荐译名为因特网，现在一般流行称为互联网。</p>\n<p>3，路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</p>\n<p>4，互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。</p>\n<p>5，计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S方式）和对等连接方式（P2P方式）。</p>\n<p>6，客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</p>\n<p>7，按照作用范围的不同，计算机网络分为广域网WAN，城域网MAN，局域网LAN，个人区域网PAN。</p>\n<p>8，计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</p>\n<p>9，网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</p>\n<p>10，五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是TCP和UDP协议，网络层最重要的协议是IP协议。</p>\n<h2 id=\"二、物理层\"> 二、物理层</h2>\n<h3 id=\"_1-基本术语-2\"> （1）基本术语</h3>\n<h4 id=\"数据-data\"> 数据（data）：</h4>\n<div><pre><code>运送消息的实体。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"信号-signal\"> 信号（signal）：</h4>\n<div><pre><code>数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"码元-code\"> 码元（ code）：</h4>\n<div><pre><code>在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"单工-simplex\"> 单工（simplex ）：</h4>\n<div><pre><code>只能有一个方向的通信而没有反方向的交互。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"半双工-half-duplex\"> 半双工（half duplex ）：</h4>\n<div><pre><code>通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"全双工-full-duplex\"> 全双工（full duplex）：</h4>\n<div><pre><code>通信的双方可以同时发送和接收信息。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"奈氏准则\"> 奈氏准则：</h4>\n<div><pre><code>在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"基带信号-baseband-signal\"> 基带信号（baseband signal）：</h4>\n<div><pre><code>来自信源的信号。指没有经过调制的数字信号或模拟信号。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"带通-频带-信号-bandpass-signal\"> 带通（频带）信号（bandpass signal）：</h4>\n<div><pre><code>把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"调制-modulation\"> 调制（modulation ）：</h4>\n<div><pre><code>对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"信噪比-signal-to-noise-ratio\"> 信噪比（signal-to-noise ratio ）：</h4>\n<div><pre><code>指信号的平均功率和噪声的平均功率之比，记为S/N。信噪比（dB）=10*log10（S/N）\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"信道复用-channel-multiplexing\"> 信道复用（channel multiplexing ）：</h4>\n<div><pre><code>指多个用户共享同一个信道。（并不一定是同时）\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"比特率-bit-rate\"> 比特率（bit rate ）：</h4>\n<div><pre><code>单位时间（每秒）内传送的比特数。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"波特率-baud-rate\"> 波特率（baud rate）：</h4>\n<div><pre><code>单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"复用-multiplexing\"> 复用（multiplexing）：</h4>\n<div><pre><code>共享信道的方法\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"adsl-asymmetric-digital-subscriber-line\"> ADSL（Asymmetric Digital Subscriber Line ）：</h4>\n<div><pre><code>非对称数字用户线。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"光纤同轴混合网-hfc网\"> 光纤同轴混合网（HFC网）:</h4>\n<div><pre><code>在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-重要知识点总结-2\"> （2）重要知识点总结</h3>\n<p>1，物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</p>\n<p>2，一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</p>\n<p>3，通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电器或电磁的表现。</p>\n<p>4，根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</p>\n<p>5，根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</p>\n<p>6，来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</p>\n<p>7，要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</p>\n<p>8，传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</p>\n<p>9，为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络EPON和吉比特无源光网络GPON。</p>\n<h3 id=\"_3-最重要的知识点\"> （3）最重要的知识点</h3>\n<h4 id=\"_1物理层的任务\"> <strong>①物理层的任务</strong></h4>\n<p>透明地传送比特流。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能能的各种可能事件的出现顺序）。</p>\n<h4 id=\"拓展\"> 拓展：</h4>\n<p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</p>\n<h4 id=\"_2几种常用的信道复用技术\"> <strong>②几种常用的信道复用技术</strong></h4>\n<p><a href=\"https://camo.githubusercontent.com/47e7f195826449a3a89d7ba4988e803e76eaaf11/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376637613137306563363631313f773d3132343726683d34323526663d706e6726733d3336373436\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/47e7f195826449a3a89d7ba4988e803e76eaaf11/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376637613137306563363631313f773d3132343726683d34323526663d706e6726733d3336373436\" alt=\"这里写图片描述\" /></a></p>\n<h4 id=\"_3几种常用的宽带接入技术-主要是adsl和fttx\"> ③几种常用的宽带接入技术，主要是ADSL和FTTx</h4>\n<p>用户到互联网的宽带接入方法有非对称数字用户线ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ASDL的快速版本是甚高速数字用户线VDSL。），光纤同轴混合网HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和FTTx（即光纤到······）。</p>\n<h2 id=\"三、数据链路层\"> 三、数据链路层</h2>\n<h3 id=\"_1-基本术语-3\"> （1）基本术语</h3>\n<h4 id=\"链路-link-2\"> 链路（link）：</h4>\n<div><pre><code>一个结点到相邻结点的一段物理链路\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"数据链路-data-link\"> 数据链路（data link）：</h4>\n<div><pre><code>把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"循环冗余检验crc-cyclic-redundancy-check\"> 循环冗余检验CRC（Cyclic Redundancy Check）：</h4>\n<div><pre><code>为了保证数据传输的可靠性，CRC是数据链路层广泛使用的一种检错技术\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"帧-frame\"> 帧（frame）：</h4>\n<div><pre><code>一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"mtu-maximum-transfer-uint\"> MTU（Maximum Transfer Uint ）：</h4>\n<div><pre><code>最大传送单元。帧的数据部分的的长度上限。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"误码率ber-bit-error-rate\"> 误码率BER（Bit Error Rate ）：</h4>\n<div><pre><code>在一段时间内，传输错误的比特占所传输比特总数的比率。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"ppp-point-to-point-protocol\"> PPP（Point-to-Point Protocol ）：</h4>\n<div><pre><code>点对点协议。即用户计算机和ISP进行通信时所使用的数据链路层协议。以下是PPP帧的示意图:\n</code></pre>\n<div><span>1</span><br></div></div><p><a href=\"https://camo.githubusercontent.com/9416dd31ba2008abf8b4dfc125ed2c16260fe8cd/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376638323931633662303332633f773d36323426683d33353926663d6a70656726733d3434323731\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/9416dd31ba2008abf8b4dfc125ed2c16260fe8cd/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376638323931633662303332633f773d36323426683d33353926663d6a70656726733d3434323731\" alt=\"PPP\" /></a></p>\n<h4 id=\"mac地址-media-access-control或者medium-access-control\"> MAC地址（Media Access Control或者Medium Access Control）：</h4>\n<div><pre><code>意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。\n在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。\n因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址  。\n地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处”\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"网桥-bridge\"> 网桥（bridge）：</h4>\n<div><pre><code> 一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"交换机-switch\"> 交换机（switch ）：</h4>\n<div><pre><code>广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-重要知识点总结-3\"> （2）重要知识点总结</h3>\n<p>1，链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p>\n<p>2，数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</p>\n<p>3，数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></p>\n<p>4，<strong>循环冗余检验CRC</strong>是一种检错方法，而帧检验序列FCS是添加在数据后面的冗余码</p>\n<p>5，<strong>点对点协议PPP</strong>是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</p>\n<p>6，PPPoE是为宽带上网的主机使用的链路层协议</p>\n<p>7，局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</p>\n<p>8，共向媒体通信资源的方法有二：一是静态划分信道(各种复用技术)，而是动态媒体接入控制，又称为多点接入（随即接入或受控接入）</p>\n<p>9，计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的ROM中</strong>。</p>\n<p>10，以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</p>\n<p>11，以太网采用的协议是具有冲突检测的<strong>载波监听多点接入CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道</p>\n<p>12，以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</p>\n<p>13，使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</p>\n<h3 id=\"_3-最重要的知识点-2\"> （3）最重要的知识点</h3>\n<h4 id=\"_1-数据链路层的点对点信道和广播信道的特点-以及这两种信道所使用的协议-ppp协议以及csma-cd协议-的特点\"> ① 数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP协议以及CSMA/CD协议）的特点</h4>\n<h4 id=\"_2-数据链路层的三个基本问题-封装成帧-透明传输-差错检测\"> ② 数据链路层的三个基本问题：<strong>封装成帧</strong>，<strong>透明传输</strong>，<strong>差错检测</strong></h4>\n<h4 id=\"_3-以太网的mac层硬件地址\"> ③ 以太网的MAC层硬件地址</h4>\n<h4 id=\"_4-适配器-转发器-集线器-网桥-以太网交换机的作用以及适用场合\"> ④ 适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合</h4>\n<h2 id=\"四、网络层\"> 四、网络层</h2>\n<h3 id=\"_1-基本术语-4\"> （1）基本术语</h3>\n<h4 id=\"虚电路-virtual-circuit\"> 虚电路（Virtual Circuit）：</h4>\n<div><pre><code>在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"ip-internet-protocol\"> IP（Internet Protocol ）：</h4>\n<div><pre><code>网际协议 IP 是 TCP/IP体系中两个最主要的协议之一，是TCP/IP体系结构网际层的核心。配套的有ARP，RARP，ICMP，IGMP。\n</code></pre>\n<div><span>1</span><br></div></div><p><a href=\"https://camo.githubusercontent.com/96fd61e40c5c60eb8ef986a5876d9a4a5237f119/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376639326639383433363238363f773d34353326683d33333126663d6a70656726733d3237353335\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/96fd61e40c5c60eb8ef986a5876d9a4a5237f119/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376639326639383433363238363f773d34353326683d33333126663d6a70656726733d3237353335\" alt=\"这里写图片描述\" /></a></p>\n<h4 id=\"arp-address-resolution-protocol\"> ARP（Address Resolution Protocol）：</h4>\n<div><pre><code>地址解析协议\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"icmp-internet-control-message-protocol\"> ICMP（Internet Control Message Protocol ）：</h4>\n<div><pre><code>网际控制报文协议  （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。）\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"子网掩码-subnet-mask\"> 子网掩码（subnet mask ）：</h4>\n<div><pre><code>它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"cidr-classless-inter-domain-routing\"> CIDR（ Classless Inter-Domain Routing ）：</h4>\n<div><pre><code>无分类域间路由选择  （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"默认路由-default-route\"> 默认路由（default route）：</h4>\n<div><pre><code>当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"路由选择算法-virtual-circuit\"> 路由选择算法（Virtual Circuit）：</h4>\n<div><pre><code>路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-重要知识点总结-4\"> （2）重要知识点总结</h3>\n<p>1，TCP/IP协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</p>\n<p>2，在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</p>\n<p>3，分类的IP地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明IP地址的类别。IP地址是一种分等级的地址结构。IP地址管理机构分配IP地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的IP地址</p>\n<p>4，IP数据报分为首部和数据两部分。首部的前一部分是固定长度，共20字节，是所有IP数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP首部中的生存时间给出了IP数据报在互联网中所能经过的最大路由器数。可防止IP数据报在互联网中无限制的兜圈子。</p>\n<p>5，地址解析协议ARP把IP地址解析为硬件地址。ARP的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去广播方式发送ARP请求分组</p>\n<p>6，无分类域间路由选择CIDR是解决目前IP地址紧缺的一个好办法。CIDR记法把IP地址后面加上斜线“/”，然后写上前缀所所占的位数。前缀（或网络前缀用来指明网络），前缀后面的部分是后缀，用来指明主机。CIDR把前缀都相同的连续的IP地址组成一个“CIDR地址块”，IP地址分配都以CIDR地址块为单位。</p>\n<p>7， 网际控制报文协议是IP层的协议.ICMP报文作为IP数据报的数据，加上首部后组成IP数据报发送出去。使用ICMP数据报并不是为了实现可靠传输。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文的种类有两种 ICMP差错报告报文和ICMP询问报文。</p>\n<p>8，要解决IP地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本IP协议-IPv6。IPv6所带来的变化有①更大的地址空间（采用128位地址）②灵活的首部格式③改进的选项④支持即插即用⑤支持资源的预分配⑥IPv6的首部改为8字节对齐。另外IP数据报的目的地址可以是以下三种基本类型地址之一：单播，多播和任播</p>\n<p>9，虚拟专用网络VPN利用公用的互联网作为本机构专用网之间的通信载体。VPN内使用互联网的专用地址。一个VPN至少要有一个路由器具有合法的全球IP地址，这样才能和本系统的另一个VPN通过互联网进行通信。所有通过互联网传送的数据都需要加密</p>\n<p>10， MPLS的特点是：①支持面向连接的服务质量②支持流量工程，平衡网络负载③有效的支持虚拟专用网VPN。MPLS在入口节点给每一个IP数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</p>\n<h3 id=\"_3-最重要知识点\"> （3）最重要知识点</h3>\n<h4 id=\"_1-虚拟互联网络的概念\"> ① 虚拟互联网络的概念</h4>\n<h4 id=\"_2-ip地址和物理地址的关系\"> ② IP地址和物理地址的关系</h4>\n<h4 id=\"_3-传统的分类的ip地址-包括子网掩码-和无分类域间路由选择cidr\"> ③ 传统的分类的IP地址（包括子网掩码）和无分类域间路由选择CIDR</h4>\n<h4 id=\"_4-路由选择协议的工作原理\"> ④ 路由选择协议的工作原理</h4>\n<h2 id=\"五、运输层\"> 五、运输层</h2>\n<h3 id=\"_1-基本术语-5\"> （1）基本术语</h3>\n<h4 id=\"进程-process\"> 进程（process）：</h4>\n<div><pre><code>指计算机中正在运行的程序实体\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"应用进程互相通信\"> 应用进程互相通信：</h4>\n<div><pre><code>一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"传输层的复用与分用\"> 传输层的复用与分用：</h4>\n<div><pre><code>复用指发送方不同的进程都可以通过统一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。 \n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"tcp-transmission-control-protocol\"> TCP（Transmission Control Protocol）：</h4>\n<div><pre><code>传输控制协议\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"udp-user-datagram-protocol\"> UDP（User Datagram Protocol）：</h4>\n<div><pre><code>用户数据报协议\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"端口-port-link\"> 端口（port）（link）：</h4>\n<div><pre><code>端口的目的是为了确认对方机器是那个进程在于自己进行交互，比如MSN和QQ的端口不同，如果没有端口就可能出现QQ进程和MSN交互错误。端口又称协议端口号。 \n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"停止等待协议-link\"> 停止等待协议（link）：</h4>\n<div><pre><code>指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"流量控制-link\"> 流量控制（link）：</h4>\n<div><pre><code>就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"拥塞控制-link\"> 拥塞控制（link）：</h4>\n<div><pre><code>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-重要知识点总结-5\"> （2）重要知识点总结</h3>\n<p>1，运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</p>\n<p>2，网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</p>\n<p>3，运输层的两个重要协议是用户数据报协议UDP和传输控制协议TCP。按照OSI的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元TPDU（Transport Protocol Data Unit）。但在TCP/IP体系中，则根据所使用的协议是TCP或UDP，分别称之为TCP报文段或UDP用户数据报。</p>\n<p>4，UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式。 TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的传输服务，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</p>\n<p>5，硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP和TCP的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到IP层交上来的运输层报文时，就能够 根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方IP地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</p>\n<p>6，运输层用一个16位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由TCP和UDP来完成。</p>\n<p>7，运输层的端口号分为服务器端使用的端口号（0<s>1023指派给熟知端口，1024</s>49151是登记端口号）和客户端暂时使用的端口号（49152~65535）</p>\n<p>8，UDP的主要特点是①无连接②尽最大努力交付③面向报文④无拥塞控制⑤支持一对一，一对多，多对一和多对多的交互通信⑥首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</p>\n<p>9，TCP的主要特点是①面向连接②每一条TCP连接只能是一对一的③提供可靠交付④提供全双工通信⑤面向字节流</p>\n<p>10，TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP地址：端口号）来表示。每一条TCP连接唯一被通信两端的两个端点所确定。</p>\n<p>11，停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>\n<p>12，为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</p>\n<p>13，停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续ARQ协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>\n<p>14，TCP报文段的前20个字节是固定的，后面有4n字节是根据需要增加的选项。因此，TCP首部的最小长度是20字节。</p>\n<p>15，TCP使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>\n<p>16，在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>\n<p>17，为了进行拥塞控制，TCP发送方要维持一个拥塞窗口cwnd的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>\n<p>18，TCP的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理AQM），以减少网络拥塞的发生。</p>\n<p>19，运输连接的三个阶段，即：连接建立，数据传送和连接释放。</p>\n<p>20，主动发起TCP连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</p>\n<p>21，TCP的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了TCP连接</p>\n<h3 id=\"_3-最重要的知识点-3\"> （3）最重要的知识点</h3>\n<h4 id=\"_1-端口和套接字的意义\"> ① 端口和套接字的意义</h4>\n<h4 id=\"_2-无连接udp的特点\"> ② 无连接UDP的特点</h4>\n<h4 id=\"_3-面向连接tcp的特点\"> ③ 面向连接TCP的特点</h4>\n<h4 id=\"_4-在不可靠的网络上实现可靠传输的工作原理-停止等待协议和arq协议\"> ④ 在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议</h4>\n<h4 id=\"_1-tcp的滑动窗口-流量控制-拥塞控制和连接管理\"> ① TCP的滑动窗口，流量控制，拥塞控制和连接管理</h4>\n<h2 id=\"六、应用层\"> 六、应用层</h2>\n<h3 id=\"_1-基本术语-6\"> （1）基本术语</h3>\n<h4 id=\"域名系统-dns\"> 域名系统（DNS）：</h4>\n<div><pre><code>DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。\n通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。在RFC文档中RFC 2181对DNS有规范说明，RFC 2136对DNS的动态更新进行说明，RFC 2308对DNS查询的反向缓存进行说明。\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"文件传输协议-ftp\"> 文件传输协议（FTP）：</h4>\n<div><pre><code> FTP 是File TransferProtocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。\n 基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：&quot;下载&quot;（Download）和&quot;上传&quot;（Upload）。\n &quot;下载&quot;文件就是从远程主机拷贝文件至自己的计算机上；&quot;上传&quot;文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"简单文件传输协议-tftp\"> 简单文件传输协议（TFTP）：</h4>\n<div><pre><code>TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"远程终端协议-telenet\"> 远程终端协议（TELENET）：</h4>\n<div><pre><code>Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。\n在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。\n可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"万维网-www\"> 万维网（WWW）：</h4>\n<div><pre><code>WWW是环球信息网的缩写，（亦作“Web”、“WWW”、“&#39;W3&#39;”，英文全称为“World Wide Web”），中文名字为“万维网”，&quot;环球网&quot;等，常简称为Web。分为Web客户端和Web服务器程序。\nWWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。\n万维网联盟（英语：World Wide Web Consortium，简称W3C），又称W3C理事会。1994年10月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。\n万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"万维网的大致工作工程\"> 万维网的大致工作工程：</h4>\n<p><a href=\"https://camo.githubusercontent.com/25cd12cef72f4f0d410f94f4fb7d28c431fd07c8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376666393661393630383761663f773d38333926683d36313026663d6a70656726733d3836373033\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/25cd12cef72f4f0d410f94f4fb7d28c431fd07c8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376666393661393630383761663f773d38333926683d36313026663d6a70656726733d3836373033\" alt=\"万维网的大致工作工程\" /></a></p>\n<h4 id=\"统一资源定位符-url\"> 统一资源定位符（URL）：</h4>\n<div><pre><code>统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 \n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"超文本传输协议-http\"> 超文本传输协议（HTTP）：</h4>\n<div><pre><code>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。\n设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"代理服务器-proxy-server\"> 代理服务器（Proxy Server）：</h4>\n<div><pre><code> 代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。\n 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按URL的地址再次去互联网访问该资源。\n 代理服务器可在客户端或服务器工作，也可以在中间系统工作。 \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"http请求头\"> http请求头：</h4>\n<div><pre><code>http请求头，HTTP客户程序（例如浏览器），向服务器发送请求的时候必须指明请求类型（一般是GET或者POST）。如有必要，客户程序还可以选择发送其他的请求头。\n- Accept：浏览器可接受的MIME类型。\n- Accept-Charset：浏览器可接受的字符集。\n- Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。\n- Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。\n- Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。\n- Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。\n- Content-Length：表示请求消息正文的长度。\n- Cookie：这是最重要的请求头信息之一\n- From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。\n- Host：初始URL中的主机和端口。\n- If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。\n- Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。\n- Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。\n- User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id=\"简单邮件传输协议-smtp\"> 简单邮件传输协议(SMTP)：</h4>\n<div><pre><code> SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。\n SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。\n 通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"搜索引擎\"> 搜索引擎：</h4>\n<div><pre><code> 搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。\n 搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"全文索引\"> 全文索引：</h4>\n<div><pre><code> 全文索引技术是目前搜索引擎的关键技术。\n试想在1M大小的文件中搜索一个词，可能需要几秒，在100M的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。\n所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"目录索引\"> 目录索引：</h4>\n<div><pre><code>目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"垂直搜索引擎\"> 垂直搜索引擎：</h4>\n<div><pre><code>垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。\n垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。\n其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_2-重要知识点总结-6\"> （2）重要知识点总结</h3>\n<p>1，文件传输协议（FTP）使用TCP可靠的运输服务。FTP使用客户服务器方式。一个FTP服务器进程可以同时为多个用户提供服务。在进进行文件传输时，FTP的客户和服务器之间要先建立两个并行的TCP连接:控制连接和数据连接。实际用于传输文件的是数据连接。</p>\n<p>2，万维网客户程序与服务器之间进行交互使用的协议是超文本传输协议HTTP。HTTP使用TCP连接进行可靠传输。但HTTP本身是无连接、无状态的。HTTP/1.1协议使用了持续连接（分为非流水线方式和流水线方式）</p>\n<p>3，电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</p>\n<p>4，一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如SMTP，和邮件读取协议，如POP3和IMAP）。用户代理和邮件服务器都要运行这些协议。</p>\n<h3 id=\"_3-最重要知识点总结\"> （3）最重要知识点总结</h3>\n<h4 id=\"_1-域名系统-从域名解析出ip地址\"> ① 域名系统-从域名解析出IP地址</h4>\n<h4 id=\"_2-访问一个网站大致的过程\"> ② 访问一个网站大致的过程</h4>\n<h4 id=\"_3-系统调用和应用编程接口概念\"> ③ 系统调用和应用编程接口概念</h4>\n",
      "image": "https://camo.githubusercontent.com/47e7f195826449a3a89d7ba4988e803e76eaaf11/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376637613137306563363631313f773d3132343726683d34323526663d706e6726733d3336373436",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "计算机网络面试知识点总结",
      "url": "http://blog.alanlee.top/blog-vuepress/common/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/",
      "content_html": "<h1 id=\"计算机网络面试知识点总结\"> 计算机网络面试知识点总结</h1>\n<h2 id=\"一、osi与tcp-ip各层的结构与功能-都有哪些协议\"> 一、OSI与TCP/IP各层的结构与功能,都有哪些协议?</h2>\n<p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p>\n<p><img src=\"https://camo.githubusercontent.com/5bf7c14046570425f50bca412a3cf3710514ccff/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542412539342545352542312538322545342542442539332545372542332542422545372542422539332545362539452538342e706e67\" alt=\"\" /></p>\n<p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p>\n<h3 id=\"_1-1-应用层\"> 1.1 应用层</h3>\n<p>**应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。*<em>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如*<em>域名系统DNS</em></em>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p>\n<p><strong>域名系统</strong></p>\n<blockquote>\n<p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href=\"http://www.ibm.xn--comoracle-xj3h/\" target=\"_blank\" rel=\"noopener noreferrer\">www.ibm.com、Oracle</a> 公司的域名是 <a href=\"http://www.oracle.xn--comcisco-hm3g8360a63fhh376bwz2c1gzc/\" target=\"_blank\" rel=\"noopener noreferrer\">www.oracle.com、Cisco公司的域名是</a> <a href=\"http://www.cisco.com/\" target=\"_blank\" rel=\"noopener noreferrer\">www.cisco.com</a> 等。</p>\n</blockquote>\n<p><strong>HTTP协议</strong></p>\n<blockquote>\n<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p>\n</blockquote>\n<h3 id=\"_1-2-运输层\"> 1.2 运输层</h3>\n<p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>\n<p><strong>运输层主要使用以下两种协议:</strong></p>\n<ol>\n<li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）--提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li>\n<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）--提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li>\n</ol>\n<p><strong>TCP 与 UDP 的对比见问题三。</strong></p>\n<h3 id=\"_1-3-网络层\"> 1.3 网络层</h3>\n<p><strong>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p>\n<p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>\n<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p>\n<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p>\n<h3 id=\"_1-4-数据链路层\"> 1.4 数据链路层</h3>\n<p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>\n<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>\n<h3 id=\"_1-5-物理层\"> 1.5 物理层</h3>\n<p>在物理层上所传送的数据单位是比特。 <strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>\n<p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p>\n<h3 id=\"_1-6-总结一下\"> 1.6 总结一下</h3>\n<p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下（图片来源于网络）。</p>\n<p><a href=\"https://camo.githubusercontent.com/62a81cdf1d9840226e1a49625e5821f17e655cfd/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542382538332545352542312538322545342542442539332545372542332542422545372542422539332545362539452538342545352539422542452e706e67\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/62a81cdf1d9840226e1a49625e5821f17e655cfd/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542382538332545352542312538322545342542442539332545372542332542422545372542422539332545362539452538342545352539422542452e706e67\" alt=\"七层体系结构图\" /></a></p>\n<h2 id=\"二、tcp-三次握手和四次挥手-面试常客\"> 二、TCP 三次握手和四次挥手(面试常客)</h2>\n<p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>\n<h3 id=\"_2-1-tcp-三次握手漫画图解\"> 2.1 TCP 三次握手漫画图解</h3>\n<p>如下图所示，下面的两个机器人通过3次握手确定了对方能正确接收和发送消息(图片来源：《图解HTTP》)。 <a href=\"https://camo.githubusercontent.com/ce8b8f1b3c8d2fbe9e5798ceeef0f67e4725fe3a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542382538392545362541432541312545362538462541312545362538392538422e706e67\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/ce8b8f1b3c8d2fbe9e5798ceeef0f67e4725fe3a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542382538392545362541432541312545362538462541312545362538392538422e706e67\" alt=\"TCP三次握手\" /></a></p>\n<p><strong>简单示意图：</strong> <a href=\"https://camo.githubusercontent.com/f6dfce1f05e95f94dbcc4b0bee8c4e3acbfb9f30/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254534254238253839254536254143254131254536253846254131254536253839253842322e706e67\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/f6dfce1f05e95f94dbcc4b0bee8c4e3acbfb9f30/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254534254238253839254536254143254131254536253846254131254536253839253842322e706e67\" alt=\"TCP三次握手\" /></a></p>\n<ul>\n<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>\n<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>\n<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>\n</ul>\n<h3 id=\"_2-2-为什么要三次握手\"> 2.2 为什么要三次握手</h3>\n<p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>\n<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>\n<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>\n<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>\n<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>\n<h3 id=\"_2-3-第2次握手传回了ack-为什么还要传回syn\"> 2.3 第2次握手传回了ACK，为什么还要传回SYN？</h3>\n<p>接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。”</p>\n<blockquote>\n<p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>\n</blockquote>\n<h3 id=\"_2-5-为什么要四次挥手\"> 2.5 为什么要四次挥手</h3>\n<p><a href=\"https://camo.githubusercontent.com/66e3447783e22d736f7db9c7d121e8eba54f07c0/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f5443502545352539422539422545362541432541312545362538432541352545362538392538422e706e67\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/66e3447783e22d736f7db9c7d121e8eba54f07c0/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f5443502545352539422539422545362541432541312545362538432541352545362538392538422e706e67\" alt=\"TCP四次挥手\" /></a></p>\n<p>断开一个 TCP 连接则需要“四次挥手”：</p>\n<ul>\n<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>\n<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li>\n<li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>\n<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li>\n</ul>\n<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>\n<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>\n<p>上面讲的比较概括，推荐一篇讲的比较细致的文章：https://blog.csdn.net/qzcsu/article/details/72861891</p>\n<h2 id=\"三、tcp-udp-协议的区别\"> 三、TCP,UDP 协议的区别</h2>\n<p><a href=\"https://camo.githubusercontent.com/582cf0bd58f1b7859ff7696d0345200d133bee88/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f7463702d76732d7564702e6a7067\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/582cf0bd58f1b7859ff7696d0345200d133bee88/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f7463702d76732d7564702e6a7067\" alt=\"TCP、UDP协议的区别\" /></a></p>\n<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>\n<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>\n<h2 id=\"四-tcp-协议如何保证可靠传输\"> 四 TCP 协议如何保证可靠传输</h2>\n<ol>\n<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>\n<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>\n<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>\n<li>TCP 的接收端会丢弃重复的数据。</li>\n<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>\n<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>\n<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>\n<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>\n</ol>\n<h3 id=\"_4-1-arq协议\"> 4.1 ARQ协议</h3>\n<p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p>\n<h4 id=\"停止等待arq协议\"> 停止等待ARQ协议</h4>\n<ul>\n<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li>\n<li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li>\n</ul>\n<p><strong>优点：</strong> 简单</p>\n<p><strong>缺点：</strong> 信道利用率低，等待时间长</p>\n<p><strong>1) 无差错情况:</strong></p>\n<p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>\n<p><strong>2) 出现差错情况（超时重传）:</strong></p>\n<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>\n<p><strong>3) 确认丢失和确认迟到</strong></p>\n<ul>\n<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>\n<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li>\n</ul>\n<h4 id=\"连续arq协议\"> 连续ARQ协议</h4>\n<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>\n<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>\n<p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>\n<h3 id=\"_4-2-滑动窗口和流量控制\"> 4.2 滑动窗口和流量控制</h3>\n<p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>\n<h3 id=\"_4-3-拥塞控制\"> 4.3 拥塞控制</h3>\n<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>\n<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>\n<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>\n<ul>\n<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>\n<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li>\n<li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>\n</ul>\n<h2 id=\"五、在浏览器中输入url地址-显示主页的过程-面试常客\"> 五、在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)</h2>\n<p>百度好像最喜欢问这个问题。</p>\n<blockquote>\n<p>打开一个网页，整个过程会使用哪些协议？</p>\n</blockquote>\n<p>图解（图片来源：《图解HTTP》）：</p>\n<p><a href=\"https://camo.githubusercontent.com/07ae8275dfa810865986f72535ca7e242857038a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f75726ce8be93e585a5e588b0e5b195e7a4bae587bae69da5e79a84e8bf87e7a88b2e6a7067\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/07ae8275dfa810865986f72535ca7e242857038a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f75726ce8be93e585a5e588b0e5b195e7a4bae587bae69da5e79a84e8bf87e7a88b2e6a7067\" alt=\"img\" /></a></p>\n<blockquote>\n<p>上图有一个错误，请注意，是OSPF不是OPSF。 OSPF（Open Shortest Path Fitst，ospf）开放最短路径优先协议,是由Internet工程任务组开发的路由选择协议</p>\n</blockquote>\n<p>总体来说分为以下几个过程:</p>\n<ol>\n<li>DNS解析</li>\n<li>TCP连接</li>\n<li>发送HTTP请求</li>\n<li>服务器处理请求并返回HTTP报文</li>\n<li>浏览器解析渲染页面</li>\n<li>连接结束</li>\n</ol>\n<p>具体可以参考下面这篇文章：</p>\n<ul>\n<li>https://segmentfault.com/a/1190000006879700</li>\n</ul>\n<h2 id=\"六、状态码\"> 六、状态码</h2>\n<p><a href=\"https://camo.githubusercontent.com/08ea24912a75db4a06bfd17995ce464ee4b4af48/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545372538412542362545362538302538312545372541302538312e706e67\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/08ea24912a75db4a06bfd17995ce464ee4b4af48/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545372538412542362545362538302538312545372541302538312e706e67\" alt=\"状态码\" /></a></p>\n<h2 id=\"七、各种协议与http协议之间的关系\"> 七、各种协议与HTTP协议之间的关系</h2>\n<p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p>\n<p>图片来源：《图解HTTP》</p>\n<p><a href=\"https://camo.githubusercontent.com/d70c1d9edab4a7e4d8320e123e2935ef0375e8f5/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254535253930253834254537254137253844254535253844253846254538254145254145254534254238253845485454502545352538442538462545382541452541452545342542392538422545392539372542342545372539412538342545352538352542332545372542332542422e706e67\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/d70c1d9edab4a7e4d8320e123e2935ef0375e8f5/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254535253930253834254537254137253844254535253844253846254538254145254145254534254238253845485454502545352538442538462545382541452541452545342542392538422545392539372542342545372539412538342545352538352542332545372542332542422e706e67\" alt=\"各种协议与HTTP协议之间的关系\" /></a></p>\n<h2 id=\"八、http长连接-短连接\"> 八、HTTP长连接,短连接</h2>\n<p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>\n<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>\n<div><pre><code>Connection:keep-alive\n</code></pre>\n<div><span>1</span><br></div></div><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>\n<p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p>\n<p>—— <a href=\"https://www.cnblogs.com/gotodsp/p/6366163.html\" target=\"_blank\" rel=\"noopener noreferrer\">《HTTP长连接、短连接究竟是什么？》</a></p>\n<h2 id=\"九、http是不保存状态的协议-如何保存用户状态\"> 九、HTTP是不保存状态的协议,如何保存用户状态?</h2>\n<p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>\n<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>\n<p><strong>Cookie 被禁用怎么办?</strong></p>\n<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>\n<p><a href=\"https://camo.githubusercontent.com/bb933f4dcc039d22ffb579335038fb0e000c7051/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f485454502545362539382541462545362539372541302545372538412542362545362538302538312545372539412538342e706e67\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/bb933f4dcc039d22ffb579335038fb0e000c7051/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f485454502545362539382541462545362539372541302545372538412542362545362538302538312545372539412538342e706e67\" alt=\"HTTP是无状态协议\" /></a></p>\n<h2 id=\"十、cookie的作用是什么-和session有什么区别\"> 十、Cookie的作用是什么?和Session有什么区别？</h2>\n<p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>\n<p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>\n<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>\n<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>\n<h2 id=\"十一、http-1-0和http-1-1的主要区别是什么\"> 十一、HTTP 1.0和HTTP 1.1的主要区别是什么?</h2>\n<blockquote>\n<p>这部分回答引用这篇文章 https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A? 的一些内容。</p>\n</blockquote>\n<p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>\n<ol>\n<li><strong>长连接</strong> : <strong>在HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 <strong>HTTP/1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>\n<li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>\n<li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>\n<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>\n</ol>\n<h2 id=\"十二、uri和url的区别是什么\"> 十二、URI和URL的区别是什么?</h2>\n<ul>\n<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>\n<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>\n</ul>\n<p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>\n<h2 id=\"十三、http-和-https-的区别\"> 十三、HTTP 和 HTTPS 的区别？</h2>\n<ol>\n<li>\n<p><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p>\n</li>\n<li>\n<p>安全性和资源消耗：</p>\n<p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p>\n<ul>\n<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>\n<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"建议\"> 建议</h2>\n<p>非常推荐大家看一下 《图解HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p>\n",
      "image": "https://camo.githubusercontent.com/5bf7c14046570425f50bca412a3cf3710514ccff/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542412539342545352542312538322545342542442539332545372542332542422545372542422539332545362539452538342e706e67",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "阅读JDK源码",
      "url": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81/",
      "id": "http://blog.alanlee.top/blog-vuepress/back-end/java/read-source/%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81/",
      "content_html": "<h1 id=\"阅读jdk源码\"> 阅读JDK源码</h1>\n<h1 id=\"java-lang\"> java.lang</h1>\n<h2 id=\"_1-object类\"> 1.Object类</h2>\n<p>我们都知道:在Java中，所有的类都继承了Object这个基类，并且大家都知道，Object有几个比较通用的方法，如equals(),clone(),toString(),我们需要在使用它们的时候进行覆写，今天，我们就具体的探究下这几个方法。</p>\n<h3 id=\"void-registernatives\"> void registerNatives()</h3>\n<p>这是个Native方法，在静态块中调用，其目的是将hashCode,wait,notify,notifyAll和clone方法注册到本地。</p>\n<h3 id=\"class-getclass\"> Class&lt;?&gt; getClass()</h3>\n<p>同样是个Native方法,获取对象的Class。</p>\n<h3 id=\"int-hashcode\"> int hashCode()</h3>\n<p>Native方法，生成哈希码，其中注意三点</p>\n<ul>\n<li>\n<p>一个对象在同一个进程被多次调用，但是它的哈希码仍然应该是相同的。但是，当同一个对象在不同进程中执行，则哈希码有可能不同。JavaDoc原文如下</p>\n<p>Whenever it is invoked on the same object more than once during an execution of a Java application, the {@code hashCode} method must consistently return the same integer, provided no information used in {@code equals} comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</p>\n</li>\n<li>\n<p>如果两个对象通过equals()比较返回true，那么它们的哈希码应该相同。</p>\n</li>\n<li>\n<p>如果两个对象通过equals()比较返回false，那么它们的哈希码应该不同。</p>\n</li>\n</ul>\n<h3 id=\"boolean-equals-object-obj\"> boolean equals(Object obj)</h3>\n<p>这恐怕使我们最常用的方法之一了，我们在实际应用中，也经常遇到什么时候用equals()，什么时候用==的问题。一般来说，基本数据类型用==，因为这样可以直接比较它们的值，但是复合数据类型如果我们用==的话，那么实际上我们比较的就是它们的引用了，除非它们指向的是同一个对象，否则它们不可能相等，因此我们比较符合数据类型一般用equals()，并且我们应该覆写equals(),这是因为Object的equals()方法默认的也是用==进行判定:</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>this</span> <span>==</span> obj<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我们再来看看我们经常用的String是如何覆写equals()方法的:</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> anObject<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>this</span> <span>==</span> anObject<span>)</span> <span>{</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span>anObject <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>\n        <span>String</span> anotherString <span>=</span> <span>(</span><span>String</span><span>)</span>anObject<span>;</span>\n        <span>int</span> n <span>=</span> value<span>.</span>length<span>;</span>\n        <span>if</span> <span>(</span>n <span>==</span> anotherString<span>.</span>value<span>.</span>length<span>)</span> <span>{</span>\n            <span>char</span> v1<span>[</span><span>]</span> <span>=</span> value<span>;</span>\n            <span>char</span> v2<span>[</span><span>]</span> <span>=</span> anotherString<span>.</span>value<span>;</span>\n            <span>int</span> i <span>=</span> <span>0</span><span>;</span>\n            <span>while</span> <span>(</span>n<span>--</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>v1<span>[</span>i<span>]</span> <span>!=</span> v2<span>[</span>i<span>]</span><span>)</span>\n                    <span>return</span> <span>false</span><span>;</span>\n                i<span>++</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>在这里还有一个很有趣的问题，请看下面的例子</p>\n<div><pre><code><span>String</span> s1 <span>=</span> <span>\"String\"</span><span>;</span>\n<span>String</span> s2 <span>=</span> <span>\"String\"</span><span>;</span>\n\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"The result is \"</span> <span>+</span> s1<span>.</span><span>equals</span><span>(</span>s2<span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>你会发现返回值为True，这个就和我们上面讲的不一样了，按照我们上面的讲解，这时候应该返回false才对。其实是这样的，因为JVM中会维护一个字符串池，如果池中已经有包含此对象的字符串的时候，那么它就会返回池中的字符串(当然如果你new一个新的String对象的话就另当别论。)所以这个时候返回的是true。</p>\n<h3 id=\"object-clone\"> Object clone()</h3>\n<p>Native方法，我们一般用它来复制一个对象，并且用clone()可以实现深复制(将所有需要复制的对象都复制了一遍，而不单单是用引用指向原来的对象。)示例如下:</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Animal</span> <span>implements</span> <span>Cloneable</span> <span>{</span>\n    <span>private</span> <span>int</span> height<span>;</span>\n    <span>private</span> <span>int</span> age<span>;</span>\n\n    <span>public</span> <span>Animal</span><span>(</span><span>int</span> height<span>,</span> <span>int</span> age<span>)</span><span>{</span>\n        <span>this</span><span>.</span>height <span>=</span> height<span>;</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span> <span>{</span>\n        <span>return</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"Animal{\"</span> <span>+</span>\n                <span>\"height=\"</span> <span>+</span> height <span>+</span>\n                <span>\", age=\"</span> <span>+</span> age <span>+</span>\n                <span>'}'</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getHeight</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> height<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setHeight</span><span>(</span><span>int</span> height<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>height <span>=</span> height<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> age<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n\n<span>public</span> <span>class</span> <span>People</span> <span>implements</span> <span>Cloneable</span> <span>{</span>\n\n    <span>private</span> <span>int</span> height<span>;</span>\n    <span>private</span> <span>int</span> age<span>;</span>\n    <span>private</span> <span>Animal</span> a<span>;</span>\n\n\n    <span>public</span> <span>People</span><span>(</span><span>int</span> height<span>,</span> <span>int</span> age<span>,</span><span>Animal</span> a<span>)</span><span>{</span>\n        <span>this</span><span>.</span>height <span>=</span> height<span>;</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n        <span>this</span><span>.</span>a <span>=</span> a<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span> <span>{</span>\n        <span>People</span> p <span>=</span> <span>(</span><span>People</span><span>)</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>\n        p<span>.</span>a <span>=</span> <span>(</span><span>Animal</span><span>)</span> a<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> p<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"People{\"</span> <span>+</span>\n                <span>\"height=\"</span> <span>+</span> height <span>+</span>\n                <span>\", age=\"</span> <span>+</span> age <span>+</span>\n                <span>\", a=\"</span> <span>+</span> a <span>+</span>\n                <span>'}'</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getHeight</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> height<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setHeight</span><span>(</span><span>int</span> height<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>height <span>=</span> height<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> age<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>void</span> <span>setAnimalAge</span><span>(</span><span>int</span> a<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>a<span>.</span><span>setAge</span><span>(</span><span>5</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br></div></div><p>接下来我们这样调用:</p>\n<div><pre><code><span>Animal</span> a1 <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>100</span><span>,</span><span>3</span><span>)</span><span>;</span>\n<span>People</span> p1 <span>=</span> <span>new</span> <span>People</span><span>(</span><span>173</span><span>,</span><span>24</span><span>,</span>a1<span>)</span><span>;</span>\n\n<span>People</span> p2 <span>=</span> <span>(</span><span>People</span><span>)</span> p1<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>\np2<span>.</span><span>setAge</span><span>(</span><span>26</span><span>)</span><span>;</span>\np2<span>.</span><span>setHeight</span><span>(</span><span>181</span><span>)</span><span>;</span>\np2<span>.</span><span>setAnimalAge</span><span>(</span><span>6</span><span>)</span><span>;</span>\n\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p1<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p2<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这样我们就完成深复制了。</p>\n<h3 id=\"string-tostring\"> String toString()</h3>\n<p>最常用的方法，我们一般用它获取对象成员变量的值。Object的默认实现:</p>\n<div><pre><code><span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>getClass</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"@\"</span> <span>+</span> <span>Integer</span><span>.</span><span>toHexString</span><span>(</span><span>hashCode</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"void-notify-void-notifyall\"> void notify(),void notifyAll()</h3>\n<p>Native方法，多线程时应用，通知其他线程等待结束。</p>\n<h3 id=\"void-wait-long-void-wait-long-int-void-wait\"> void wait(long),void wait(long,int),void wait()</h3>\n<p>Native方法，通知线程等待。</p>\n<h3 id=\"void-finalize\"> void finalize()</h3>\n<p>垃圾回收。当JVM判断一个对象可以被垃圾回收时，那么JVM会调用finalize()方法，但是记住，它只能调用一次(所以如果你想这个对象不被垃圾清除的话，你就要在这里面做点事情了)，但是一般你不能依赖在这里做垃圾回收的工作，在《Java编程思想》中说明了有关finalize()的一个用法，那就是通过finalize()来进行对象终结对象的判断。</p>\n<h2 id=\"_2-string类\"> 2.String类</h2>\n<p>String类是我们日常开发中使用最频繁的类之一，曾今有人说String类用的好坏能评判你是否是一个合格的java程序员。</p>\n<h4 id=\"基础知识\"> 基础知识：</h4>\n<p>String对象的存放位置：大家都知道java中的对象大都是存放在堆中的，但是String对象是一个特例，它被存放在常量池中。\n当创建一个字面量String对象时，首先会去检查常量池中这个对象的存在与否。\njava本地方法：一个本地方法就是一个java调用非java代码的接口。该方法是非java实现，由C或C++语言实现。形式是：\n修饰符 native 返回值类型 本地方法名(); 如public native String intern();\n在我们看java源码时如果追溯到了本地方法，在java层面上就到头了，如果需要更深层次的了解本地方法的实现，就需要下载openjdk源码然后看它是如何实现的了。有兴趣的同学可以看<a href=\"https://www.jianshu.com/p/4f73957acc5b\" target=\"_blank\" rel=\"noopener noreferrer\">如何查看java本地方法</a>这篇文章。</p>\n<h4 id=\"string类\"> String类:</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>String</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span> <span>Comparable</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span>CharSequence</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>可以看到String类是final修饰的不能被继承，同时它实现了Serializable接口可以序列化和反序列化，实现了Comparable支持字符串的比较，实现了CharSequence接口说明它是一个字符序列。</p>\n<h4 id=\"成员变量\"> 成员变量:</h4>\n<div><pre><code><span>private</span> <span>final</span> <span>char</span> value<span>[</span><span>]</span><span>;</span><span>//存储字符串</span>\n<span>private</span> <span>int</span> hash<span>;</span> <span>//字符串的hash code 默认是0</span>\n<span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>-</span><span>6849794470754667710L</span><span>;</span><span>//序列化id</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>String对象的字符串实际是维护在一个字符数组中的。操作字符串实际上就是操作这个字符数组,而且这个数组也是final修饰的不能够被改变。</p>\n<h3 id=\"构造方法\"> 构造方法:</h3>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> <span>\"\"</span><span>.</span><span>value</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>无参构造方法，值为空串。基本不用。</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>String</span> original<span>)</span> <span>{</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> original<span>.</span><span>value</span><span>;</span>\n        <span>this</span><span>.</span>hash <span>=</span> original<span>.</span>hash<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>参数String对象参数来构造String对象，该构造函数经常被用来做面试题。问new String(&quot;abc&quot;);共创建了几个对象。答案是两个，字面量&quot;abc&quot;创建一个对象放在常量池中，new String()又创建一个对象放在堆中。</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>char</span> <span>value</span><span>[</span><span>]</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> Arrays<span>.</span><span>copyOf</span><span>(</span><span>value</span><span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>通过整个char数组参数来构造String对象，实际将参数char数组值复制给String对象的char数组。</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>char</span> <span>value</span><span>[</span><span>]</span><span>,</span> <span><span>int</span></span> offset<span>,</span> <span><span>int</span></span> count<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>offset <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>offset<span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>count <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>count <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>count<span>)</span><span>;</span>\n            <span>}</span>\n            <span>if</span> <span>(</span>offset <span>&lt;=</span> <span>value</span><span>.</span>length<span>)</span> <span>{</span>\n                <span>this</span><span>.</span><span>value</span> <span>=</span> <span>\"\"</span><span>.</span><span>value</span><span>;</span>\n                <span>return</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>// Note: offset or count might be near -1>>>1.</span>\n        <span>if</span> <span>(</span>offset <span>></span> <span>value</span><span>.</span>length <span>-</span> count<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>offset <span>+</span> count<span>)</span><span>;</span>\n        <span>}</span>\n    <span>this</span><span>.</span><span>value</span> <span>=</span> Arrays<span>.</span><span>copyOfRange</span><span>(</span><span>value</span><span>,</span> offset<span>,</span> offset<span>+</span>count<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>截取入参数组的一部分来构造String对象，具体哪一部分由offset和count决定，其中做了些参数检查，传入非法参数会报数组越界异常StringIndexOutOfBoundsException</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>byte</span> bytes<span>[</span><span>]</span><span>,</span> <span><span>int</span></span> offset<span>,</span> <span><span>int</span></span> length<span>,</span> <span>String</span> charsetName<span>)</span>\n            <span>throws</span> UnsupportedEncodingException <span>{</span>\n        <span>if</span> <span>(</span>charsetName <span>==</span> <span>null</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>\"charsetName\"</span><span>)</span><span>;</span>\n        <span>checkBounds</span><span>(</span>bytes<span>,</span> offset<span>,</span> length<span>)</span><span>;</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> StringCoding<span>.</span><span>decode</span><span>(</span>charsetName<span>,</span> bytes<span>,</span> offset<span>,</span> length<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>通过byte数组构造String对象，将入参byte数组中指定内容，用指定charsetName的字符集转换后构造String对象。\n其中StringCoding.decode(charsetName, bytes, offset, length)是根据指定编码对byte数组进行解码，解码返回char数组。\ncheckBounds(bytes, offset, length)是对参数进行检查(源码如下)，该方法是私有的只能在String类中调用。</p>\n<div><pre><code><span>private</span> <span>static</span> <span><span>void</span></span> <span>checkBounds</span><span>(</span><span><span>byte</span><span>[</span><span>]</span></span> bytes<span>,</span> <span><span>int</span></span> offset<span>,</span> <span><span>int</span></span> length<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>length <span>&lt;</span> <span>0</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>length<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>offset <span>&lt;</span> <span>0</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>offset<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>offset <span>></span> bytes<span>.</span>length <span>-</span> length<span>)</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>offset <span>+</span> length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>public</span> <span>String</span><span>(</span><span>byte</span> bytes<span>[</span><span>]</span><span>,</span> <span><span>int</span></span> offset<span>,</span> <span><span>int</span></span> length<span>,</span> <span>Charset</span> charset<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>charset <span>==</span> <span>null</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>\"charset\"</span><span>)</span><span>;</span>\n        <span>checkBounds</span><span>(</span>bytes<span>,</span> offset<span>,</span> length<span>)</span><span>;</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span>  StringCoding<span>.</span><span>decode</span><span>(</span>charset<span>,</span> bytes<span>,</span> offset<span>,</span> length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>该构造方法与上述构造方法类似，只不过这里的字符集是用Charset指定的，上述是用String指定的。Charset与charsetName是java中表示字符集的两种不同形式。它们之间相互转换如下：\n字符串转Charset对象:Charset charset = Charset.forName(&quot;UTF-8&quot;);\nCharset对象转字符串：String s = charset.displayName();</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>byte</span> bytes<span>[</span><span>]</span><span>,</span> <span>String</span> charsetName<span>)</span>\n            <span>throws</span> <span>UnsupportedEncodingException</span> <span>{</span>\n        <span>this</span><span>(</span>bytes<span>,</span> <span>0</span><span>,</span> bytes<span>.</span>length<span>,</span> charsetName<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>String</span><span>(</span><span>byte</span> bytes<span>[</span><span>]</span><span>,</span> <span>Charset</span> charset<span>)</span> <span>{</span>\n        <span>this</span><span>(</span>bytes<span>,</span> <span>0</span><span>,</span> bytes<span>.</span>length<span>,</span> charset<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这两个方法同上述两个方法类似，上述是转换byte数组中的部分数据构造String对象，这里是转换全部byte数组构造String对象。通过转换byte数组构造String对象在工作中还是挺常用的。</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>byte</span> bytes<span>[</span><span>]</span><span>,</span> <span><span>int</span></span> offset<span>,</span> <span><span>int</span></span> length<span>)</span> <span>{</span>\n        <span>checkBounds</span><span>(</span>bytes<span>,</span> offset<span>,</span> length<span>)</span><span>;</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> StringCoding<span>.</span><span>decode</span><span>(</span>bytes<span>,</span> offset<span>,</span> length<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>String</span><span>(</span><span>byte</span> bytes<span>[</span><span>]</span><span>)</span> <span>{</span>\n        <span>this</span><span>(</span>bytes<span>,</span> <span>0</span><span>,</span> bytes<span>.</span>length<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>通过byte数组，不指定字符集构造String对象。实际要在 StringCoding.decode(bytes, offset, length);解码byte数组的时候会构造默认的字符编码，默认的也就是系统默认的可能过GBK，可能过UTF-8,也可能是其它。可通过-Dfile.encoding=UTF-8进行修改系统默认编码。</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>StringBuffer</span> buffer<span>)</span> <span>{</span>\n        <span>synchronized</span><span>(</span>buffer<span>)</span> <span>{</span>\n            <span>this</span><span>.</span><span>value</span> <span>=</span> Arrays<span>.</span><span>copyOf</span><span>(</span>buffer<span>.</span><span>getValue</span><span>(</span><span>)</span><span>,</span> buffer<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>通过StringBuffer构造String对象，StringBuffer内部也是维护了一个char数组，这里将StringBuffer数组中的内容复制给String对象中的数组。而且StringBuffer是线程安全的，所以这里也加了synchronized块保证线程安全。</p>\n<div><pre><code><span>public</span> <span>String</span><span>(</span><span>StringBuilder</span> builder<span>)</span> <span>{</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> Arrays<span>.</span><span>copyOf</span><span>(</span>builder<span>.</span><span>getValue</span><span>(</span><span>)</span><span>,</span> builder<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>通过StringBuilder构造String对象，原理同StringBuffer一样，只不过StringBuilder是线程不安全的，所在这里没有加synchronized块。基础面试中面试官经常询问StringBuffer与StringBuilder的区别，有兴趣的同学可以搜一下。</p>\n<div><pre><code><span>String</span><span>(</span><span><span>char</span><span>[</span><span>]</span></span> <span>value</span><span>,</span> <span>boolean</span> share<span>)</span> <span>{</span>\n        <span>// assert share : \"unshared not supported\";</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> <span>value</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>乍一看不知道这个构造函数是用来干嘛的，仔细分析就知道这个函数大有作用。首先它同String(char[] value)函数相比多了个参数share，虽然在方法本身没有用到share，目前是只支持true，注释也说了不支持false。这个方法定义成这样应该是为了同String(char[] value)进行区分。否则没办法构成方法重载。再来看下这个方法的作用。它是直接将参数的地址传给了String对象，这样要比直接使用String(char[] value)的效率要高，因为String(char[] value)是逐一拷贝。有人会问这样Stirng对象和参数传过来的char[] value共享同一个数组，不就破坏了字符串的不可变性。设计都也考虑到了，所以它设置了保护用protected修饰而没有公开出去。所以从安全性角度考虑，他也是安全的。在java中也有很多地方用到了这种性能好的、节约内存的、安全的构造函数。如replace、concat、valueOf等方法。</p>\n<h3 id=\"其它方法\"> 其它方法</h3>\n<h4 id=\"length\"> length:</h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>length</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>value</span><span>.</span>length<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>获取字符串的长度，实际上就是返回内部数组的长度。因为char数组被final修饰是不可变的，只要构造完成char数组中的内容长度都不会改变，所以这里可以直接返回数组的长度。</p>\n<h4 id=\"isempty\"> isEmpty:</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>value</span><span>.</span>length <span>==</span> <span>0</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>判断字符串是否为空。同理如果char的长度为0则表示字符串空。</p>\n<h4 id=\"charat\"> charAt:</h4>\n<div><pre><code>    <span>public</span> <span><span>char</span></span> <span>charAt</span><span>(</span><span><span>int</span></span> index<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>(</span>index <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>index <span>>=</span> <span>value</span><span>.</span>length<span>)</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>value</span><span>[</span>index<span>]</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>获取字符串中指定索引位置的字符。先判断索引是否合法，不能小于0或是大于字符串长度。然后直接返回数组对应位置的字符。</p>\n<h4 id=\"codepointat\"> codePointAt:</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>codePointAt</span><span>(</span><span><span>int</span></span> index<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>(</span>index <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>index <span>>=</span> <span>value</span><span>.</span>length<span>)</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> Character<span>.</span><span>codePointAtImpl</span><span>(</span><span>value</span><span>,</span> index<span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>同charAt类似，获取字符串指定索引位置的字符的代码点。也就是将对应位置的字符转换成UniCode。</p>\n<h4 id=\"codepointbefore\"> codePointBefore:</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>codePointBefore</span><span>(</span><span><span>int</span></span> index<span>)</span> <span>{</span>\n        <span><span>int</span></span> i <span>=</span> index <span>-</span> <span>1</span><span>;</span>\n        <span>if</span> <span>(</span><span>(</span>i <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>i <span>>=</span> <span>value</span><span>.</span>length<span>)</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> Character<span>.</span><span>codePointBeforeImpl</span><span>(</span><span>value</span><span>,</span> index<span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>获取指定索引位置前一个位置的字符的代码点。</p>\n<h4 id=\"codepointcount\"> codePointCount:</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>codePointCount</span><span>(</span><span><span>int</span></span> beginIndex<span>,</span> <span><span>int</span></span> endIndex<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>beginIndex <span>&lt;</span> <span>0</span> <span>||</span> endIndex <span>></span> <span>value</span><span>.</span>length <span>||</span> beginIndex <span>></span> endIndex<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> Character<span>.</span><span>codePointCountImpl</span><span>(</span><span>value</span><span>,</span> beginIndex<span>,</span> endIndex <span>-</span> beginIndex<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>获取字符串代码点个数，是实际上的字符个数。length()方法返回的是使用的是UTF-16编码的字符代码单元数量，不一定是实际上我们认为的字符个数。如 String str = “/uD835/uDD6B”，那么机器会识别它是2个代码单元代理的1个代码点&quot;Z&quot;，故而，length的结果是代码单元数量2，而codePointCount()的结果是代码点数量1。</p>\n<h4 id=\"getchars-char-dst-int-dstbegin\"> getChars(char dst[], int dstBegin):</h4>\n<div><pre><code>    <span><span>void</span></span> <span>getChars</span><span>(</span><span>char</span> dst<span>[</span><span>]</span><span>,</span> <span><span>int</span></span> dstBegin<span>)</span> <span>{</span>\n        System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> <span>0</span><span>,</span> dst<span>,</span> dstBegin<span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>复制字符串中数组内容到指定字符数组指定位置中。该方法并没有范围检查，方法仅供内部使用不对外公开。</p>\n<h4 id=\"getchars-int-srcbegin-int-srcend-char-dst-int-dstbegin\"> getChars(int srcBegin, int srcEnd, char dst[], int dstBegin):</h4>\n<div><pre><code>    <span>public</span> <span><span>void</span></span> <span>getChars</span><span>(</span><span><span>int</span></span> srcBegin<span>,</span> <span><span>int</span></span> srcEnd<span>,</span> <span>char</span> dst<span>[</span><span>]</span><span>,</span> <span><span>int</span></span> dstBegin<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>srcBegin <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>srcBegin<span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>srcEnd <span>></span> <span>value</span><span>.</span>length<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>srcEnd<span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>srcBegin <span>></span> srcEnd<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>srcEnd <span>-</span> srcBegin<span>)</span><span>;</span>\n        <span>}</span>\n        System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> srcBegin<span>,</span> dst<span>,</span> dstBegin<span>,</span> srcEnd <span>-</span> srcBegin<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>获取字符串中指定位置的字符到目标字符数组中。该方法为公有的，做了范围检查。可以看到对外提供的方法还是要严谨一些。在工作中也是一样，内部使用的可以稍微宽松一些，对外提供的需要做严格的限制。</p>\n<h4 id=\"getbytes\"> getBytes:</h4>\n<div><pre><code>    <span>public</span> <span><span>byte</span><span>[</span><span>]</span></span> <span>getBytes</span><span>(</span><span>String</span> charsetName<span>)</span>\n            <span>throws</span> UnsupportedEncodingException <span>{</span>\n        <span>if</span> <span>(</span>charsetName <span>==</span> <span>null</span><span>)</span> <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> StringCoding<span>.</span><span>encode</span><span>(</span>charsetName<span>,</span> <span>value</span><span>,</span> <span>0</span><span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span><span>byte</span><span>[</span><span>]</span></span> <span>getBytes</span><span>(</span><span>Charset</span> charset<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>charset <span>==</span> <span>null</span><span>)</span> <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> StringCoding<span>.</span><span>encode</span><span>(</span>charset<span>,</span> <span>value</span><span>,</span> <span>0</span><span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span><span>byte</span><span>[</span><span>]</span></span> <span>getBytes</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> StringCoding<span>.</span><span>encode</span><span>(</span><span>value</span><span>,</span> <span>0</span><span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>获取字符串对应的字节数组。将字符串编码成byte数组并返回，其中前两个方法是调用者指定字符集，后一个方法使用系统默认的字符集。</p>\n<h4 id=\"equals\"> equals:</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> anObject<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>this</span> <span>==</span> anObject<span>)</span> <span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>anObject <span>instanceof</span> String<span>)</span> <span>{</span>\n            <span>String</span> anotherString <span>=</span> <span>(</span>String<span>)</span>anObject<span>;</span>\n            <span><span>int</span></span> n <span>=</span> <span>value</span><span>.</span>length<span>;</span>\n            <span>if</span> <span>(</span>n <span>==</span> anotherString<span>.</span><span>value</span><span>.</span>length<span>)</span> <span>{</span>\n                <span>char</span> v1<span>[</span><span>]</span> <span>=</span> <span>value</span><span>;</span>\n                <span>char</span> v2<span>[</span><span>]</span> <span>=</span> anotherString<span>.</span><span>value</span><span>;</span>\n                <span><span>int</span></span> i <span>=</span> <span>0</span><span>;</span>\n                <span>while</span> <span>(</span>n<span>--</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n                    <span>if</span> <span>(</span>v1<span>[</span>i<span>]</span> <span>!=</span> v2<span>[</span>i<span>]</span><span>)</span>\n                        <span>return</span> <span>false</span><span>;</span>\n                    i<span>++</span><span>;</span>\n                <span>}</span>\n                <span>return</span> <span>true</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>重写了Object类的equals方法，这里是比较两个字符器的内容是否完全相等。先判断长度是否相等，长度不相等字符串必然不相等。然后再逐一比较每个对应位置的字符是否相等，如果全部相等则返回true，否则返回false。</p>\n<h4 id=\"contentequals-stringbuffer-sb\"> contentEquals(StringBuffer sb) :</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>contentEquals</span><span>(</span><span>StringBuffer</span> sb<span>)</span> <span>{</span>\n        <span>return</span> <span>SequencontentEquals</span><span>(</span><span>(</span><span>Charce</span><span>)</span>sb<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>比较字符串与StringBuffer对象的内容是否相等，调用了contentEquals(CharSequence cs) 方法，该方法实现如下。</p>\n<h4 id=\"contentequals-charsequence-cs\"> contentEquals(CharSequence cs) :</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>contentEquals</span><span>(</span><span>CharSequence</span> cs<span>)</span> <span>{</span>\n        <span>// Argument is a StringBuffer, StringBuilder</span>\n        <span>if</span> <span>(</span>cs <span>instanceof</span> <span>AbstractStringBuilder</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>cs <span>instanceof</span> <span>StringBuffer</span><span>)</span> <span>{</span>\n                <span>synchronized</span><span>(</span>cs<span>)</span> <span>{</span>\n                   <span>return</span> <span>nonSyncContentEquals</span><span>(</span><span>(</span><span>AbstractStringBuilder</span><span>)</span>cs<span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>return</span> <span>nonSyncContentEquals</span><span>(</span><span>(</span><span>AbstractStringBuilder</span><span>)</span>cs<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>// Argument is a String</span>\n        <span>if</span> <span>(</span>cs <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>\n            <span>return</span> <span>equals</span><span>(</span>cs<span>)</span><span>;</span>\n        <span>}</span>\n        <span>// Argument is a generic CharSequence</span>\n        <span>char</span> v1<span>[</span><span>]</span> <span>=</span> value<span>;</span>\n        <span>int</span> n <span>=</span> v1<span>.</span>length<span>;</span>\n        <span>if</span> <span>(</span>n <span>!=</span> cs<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>v1<span>[</span>i<span>]</span> <span>!=</span> cs<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>)</span> <span>{</span>\n                <span>return</span> <span>false</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>比较字符串内容与字符序列内容是否相等。首先判断是否为AbstractStringBuilder类型，AbstractStringBuilder有两种实现方式，StringBuffer(线程安全的)和StringBuilder(线程不安全的)，如果是则判断是否为StringBuffer类型，此类判断需要加锁以保证线程安全，它们两个都调用了nonSyncContentEquals方法进行判断(见下)。其次判断是否为String类型,因为String类也实现了CharSequence接口，如果是则调用String类的equals方法。最后如果是其它字符序列，则逐一比较字符数组中每个位置的字符是否相等。</p>\n<h4 id=\"nonsynccontentequals\"> nonSyncContentEquals:</h4>\n<div><pre><code>    <span>private</span> <span>boolean</span> <span>nonSyncContentEquals</span><span>(</span><span>AbstractStringBuilder</span> sb<span>)</span> <span>{</span>\n        <span>char</span> v1<span>[</span><span>]</span> <span>=</span> <span>value</span><span>;</span>\n        <span>char</span> v2<span>[</span><span>]</span> <span>=</span> sb<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>\n        <span><span>int</span></span> n <span>=</span> v1<span>.</span>length<span>;</span>\n        <span>if</span> <span>(</span>n <span>!=</span> sb<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>for</span> <span>(</span><span><span>int</span></span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>v1<span>[</span>i<span>]</span> <span>!=</span> v2<span>[</span>i<span>]</span><span>)</span> <span>{</span>\n                <span>return</span> <span>false</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>该方法为私有的供String类内部使用，也使用了相同的逻辑，先判字符数组长度是否相等，再逐一进行比较。其实不论是String的equals方法，contentEquals(CharSequence cs) 方法还是nonSyncContentEquals方法里面的比较逻辑都差不多，是否可以考虑将这类似的逻辑抽取出来单独成立个方法呢。</p>\n<h4 id=\"equalsignorecase\"> equalsIgnoreCase:</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>equalsIgnoreCase</span><span>(</span><span>String</span> anotherString<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>this</span> <span>==</span> anotherString<span>)</span> <span>?</span> <span>true</span>\n                <span>:</span> <span>(</span>anotherString <span>!=</span> <span>null</span><span>)</span>\n                <span>&amp;&amp;</span> <span>(</span>anotherString<span>.</span><span>value</span><span>.</span>length <span>==</span> <span>value</span><span>.</span>length<span>)</span>\n                <span>&amp;&amp;</span> <span>regionMatches</span><span>(</span><span>true</span><span>,</span> <span>0</span><span>,</span> anotherString<span>,</span> <span>0</span><span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>从方法名也可以看出，该方法是忽略大小写比较字符串内容是否相同。先判断两个对象地址是否一样，地址一样内容自然也一样。再判断长度，如果长度一样再调用regionMatches方法进行比较(见后)。这里用了&amp;&amp;逻辑运算符的断路原理，如果前一个判断为假，后面的判断就没意义了。</p>\n<h4 id=\"compareto\"> compareTo:</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>compareTo</span><span>(</span><span>String</span> anotherString<span>)</span> <span>{</span>\n        <span><span>int</span></span> len1 <span>=</span> <span>value</span><span>.</span>length<span>;</span>\n        <span><span>int</span></span> len2 <span>=</span> anotherString<span>.</span><span>value</span><span>.</span>length<span>;</span>\n        <span><span>int</span></span> lim <span>=</span> Math<span>.</span><span>min</span><span>(</span>len1<span>,</span> len2<span>)</span><span>;</span>\n        <span>char</span> v1<span>[</span><span>]</span> <span>=</span> <span>value</span><span>;</span>\n        <span>char</span> v2<span>[</span><span>]</span> <span>=</span> anotherString<span>.</span><span>value</span><span>;</span>\n\n        <span><span>int</span></span> k <span>=</span> <span>0</span><span>;</span>\n        <span>while</span> <span>(</span>k <span>&lt;</span> lim<span>)</span> <span>{</span>\n            <span><span>char</span></span> c1 <span>=</span> v1<span>[</span>k<span>]</span><span>;</span>\n            <span><span>char</span></span> c2 <span>=</span> v2<span>[</span>k<span>]</span><span>;</span>\n            <span>if</span> <span>(</span>c1 <span>!=</span> c2<span>)</span> <span>{</span>\n                <span>return</span> c1 <span>-</span> c2<span>;</span>\n            <span>}</span>\n            k<span>++</span><span>;</span>\n        <span>}</span>\n        <span>return</span> len1 <span>-</span> len2<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>该方法是实现Comparable接口的方法，用于对字符串进行比较大小。逻辑是对两个字符串中的数组进行逐位比较大小，从第一位开始比较，大的字符串就大，如果相同就继续向下比较，直到比较出大小为止。这里取了两个字符串中长度较小的作为循环次数。从源码也可以看出字符串比较并不是我们表面上认为的先进行长度比较，长度不一样再进行每个位置的比较。</p>\n<h4 id=\"内部内\"> 内部内</h4>\n<div><pre><code>    <span>public</span> <span>static</span> <span>final</span> <span>Comparator</span><span><span>&lt;</span><span>String</span><span>></span></span> CASE_INSENSITIVE_ORDER\n                                         <span>=</span> <span>new</span> <span>CaseInsensitiveComparator</span><span>(</span><span>)</span><span>;</span>\n    <span>private</span> <span>static</span> <span>class</span> <span>CaseInsensitiveComparator</span>\n            <span>implements</span> <span>Comparator</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span> <span>{</span>\n        <span>// use serialVersionUID from JDK 1.2.2 for interoperability</span>\n        <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>8575799808933029326L</span><span>;</span>\n\n        <span>public</span> <span>int</span> <span>compare</span><span>(</span><span>String</span> s1<span>,</span> <span>String</span> s2<span>)</span> <span>{</span>\n            <span>int</span> n1 <span>=</span> s1<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n            <span>int</span> n2 <span>=</span> s2<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n            <span>int</span> min <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>n1<span>,</span> n2<span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> min<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>char</span> c1 <span>=</span> s1<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>\n                <span>char</span> c2 <span>=</span> s2<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>\n                <span>if</span> <span>(</span>c1 <span>!=</span> c2<span>)</span> <span>{</span>\n                    c1 <span>=</span> <span>Character</span><span>.</span><span>toUpperCase</span><span>(</span>c1<span>)</span><span>;</span>\n                    c2 <span>=</span> <span>Character</span><span>.</span><span>toUpperCase</span><span>(</span>c2<span>)</span><span>;</span>\n                    <span>if</span> <span>(</span>c1 <span>!=</span> c2<span>)</span> <span>{</span>\n                        c1 <span>=</span> <span>Character</span><span>.</span><span>toLowerCase</span><span>(</span>c1<span>)</span><span>;</span>\n                        c2 <span>=</span> <span>Character</span><span>.</span><span>toLowerCase</span><span>(</span>c2<span>)</span><span>;</span>\n                        <span>if</span> <span>(</span>c1 <span>!=</span> c2<span>)</span> <span>{</span>\n                            <span>// No overflow because of numeric promotion</span>\n                            <span>return</span> c1 <span>-</span> c2<span>;</span>\n                        <span>}</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n            <span>return</span> n1 <span>-</span> n2<span>;</span>\n        <span>}</span>   \n\n        <span>/** Replaces the de-serialized object. */</span>\n        <span>private</span> <span>Object</span> <span>readResolve</span><span>(</span><span>)</span> <span>{</span> <span>return</span> CASE_INSENSITIVE_ORDER<span>;</span> <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>该内部内实际上就是String类定义的一个内部比较器，私有的仅供内部使用，用于进行忽略大小写比较字符串是否相等。CaseInsensitiveComparator(大小写不敏感比较器)，只看名字不看其具体实现也能大致看出来其作用，可见起一个好的名字是多么的重要。比较逻辑是对每位字符逐一进行比较，如果不等则将字符转换为对应的大写字符再进行比较，如果还不等再转换为对应的小写进行比较，最后返回两个字符的大小即为整个字符串的大小。这里先转换为大写，再转换为小写的目的是不是所有的字符都是用英文字母进行表示的，比如汉字等。</p>\n<h4 id=\"comparetoignorecase\"> compareToIgnoreCase:</h4>\n<div><pre><code>    <span>public</span> <span>int</span> <span>compareToIgnoreCase</span><span>(</span>String str<span>)</span> <span>{</span>\n        <span>return</span> CASE_INSENSITIVE_ORDER<span>.</span><span>compare</span><span>(</span><span>this</span><span>,</span> str<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>忽略大小写比较两个字符串的大小，用到了上述内部内的比较逻辑。</p>\n<h4 id=\"regionmatches-int-toffset-string-other-int-ooffset-int-len\"> regionMatches(int toffset, String other, int ooffset,int len):</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>regionMatches</span><span>(</span><span><span>int</span></span> toffset<span>,</span> <span>String</span> other<span>,</span> <span><span>int</span></span> ooffset<span>,</span>\n            <span><span>int</span></span> len<span>)</span> <span>{</span>\n        <span>char</span> ta<span>[</span><span>]</span> <span>=</span> <span>value</span><span>;</span>\n        <span><span>int</span></span> to <span>=</span> toffset<span>;</span>\n        <span>char</span> pa<span>[</span><span>]</span> <span>=</span> other<span>.</span><span>value</span><span>;</span>\n        <span><span>int</span></span> po <span>=</span> ooffset<span>;</span>\n        <span>// Note: toffset, ooffset, or len might be near -1>>>1.</span>\n        <span>if</span> <span>(</span><span>(</span>ooffset <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>toffset <span>&lt;</span> <span>0</span><span>)</span>\n                <span>||</span> <span>(</span>toffset <span>></span> <span>(</span><span>long</span><span>)</span><span>value</span><span>.</span>length <span>-</span> len<span>)</span>\n                <span>||</span> <span>(</span>ooffset <span>></span> <span>(</span><span>long</span><span>)</span>other<span>.</span><span>value</span><span>.</span>length <span>-</span> len<span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>while</span> <span>(</span>len<span>--</span> <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>ta<span>[</span>to<span>++</span><span>]</span> <span>!=</span> pa<span>[</span>po<span>++</span><span>]</span><span>)</span> <span>{</span>\n                <span>return</span> <span>false</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>区域比较，比较两个字符串指定区域指定长度的内容是否相等。从指定区域，开始逐一比较指定长度字符数组内容是否相等。</p>\n<h4 id=\"regionmatches-boolean-ignorecase-int-toffset-string-other-int-ooffset-int-len\"> regionMatches(boolean ignoreCase, int toffset,String other, int ooffset, int len) :</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>regionMatches</span><span>(</span><span>boolean</span> ignoreCase<span>,</span> <span><span>int</span></span> toffset<span>,</span>\n            <span>String</span> other<span>,</span> <span><span>int</span></span> ooffset<span>,</span> <span><span>int</span></span> len<span>)</span> <span>{</span>\n        <span>char</span> ta<span>[</span><span>]</span> <span>=</span> <span>value</span><span>;</span>\n        <span><span>int</span></span> to <span>=</span> toffset<span>;</span>\n        <span>char</span> pa<span>[</span><span>]</span> <span>=</span> other<span>.</span><span>value</span><span>;</span>\n        <span><span>int</span></span> po <span>=</span> ooffset<span>;</span>\n        <span>// Note: toffset, ooffset, or len might be near -1>>>1.</span>\n        <span>if</span> <span>(</span><span>(</span>ooffset <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>toffset <span>&lt;</span> <span>0</span><span>)</span>\n                <span>||</span> <span>(</span>toffset <span>></span> <span>(</span><span>long</span><span>)</span><span>value</span><span>.</span>length <span>-</span> len<span>)</span>\n                <span>||</span> <span>(</span>ooffset <span>></span> <span>(</span><span>long</span><span>)</span>other<span>.</span><span>value</span><span>.</span>length <span>-</span> len<span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>while</span> <span>(</span>len<span>--</span> <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span><span>char</span></span> c1 <span>=</span> ta<span>[</span>to<span>++</span><span>]</span><span>;</span>\n            <span><span>char</span></span> c2 <span>=</span> pa<span>[</span>po<span>++</span><span>]</span><span>;</span>\n            <span>if</span> <span>(</span>c1 <span>==</span> c2<span>)</span> <span>{</span>\n                <span>continue</span><span>;</span>\n            <span>}</span>\n            <span>if</span> <span>(</span>ignoreCase<span>)</span> <span>{</span>\n                <span><span>char</span></span> u1 <span>=</span> Character<span>.</span><span>toUpperCase</span><span>(</span>c1<span>)</span><span>;</span>\n                <span><span>char</span></span> u2 <span>=</span> Character<span>.</span><span>toUpperCase</span><span>(</span>c2<span>)</span><span>;</span>\n                <span>if</span> <span>(</span>u1 <span>==</span> u2<span>)</span> <span>{</span>\n                    <span>continue</span><span>;</span>\n                <span>}</span>\n                <span>if</span> <span>(</span>Character<span>.</span><span>toLowerCase</span><span>(</span>u1<span>)</span> <span>==</span> Character<span>.</span><span>toLowerCase</span><span>(</span>u2<span>)</span><span>)</span> <span>{</span>\n                    <span>continue</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>该方法同上述方法类似，只是加了一个参数ignoreCase，是否忽略大小写，如果忽略大小写则还要将字符转换成对应的大写，小写进行比较。</p>\n<h4 id=\"startswith-string-prefix-int-toffset\"> startsWith(String prefix, int toffset)：</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>startsWith</span><span>(</span><span>String</span> prefix<span>,</span> <span><span>int</span></span> toffset<span>)</span> <span>{</span>\n        <span>char</span> ta<span>[</span><span>]</span> <span>=</span> <span>value</span><span>;</span>\n        <span><span>int</span></span> to <span>=</span> toffset<span>;</span>\n        <span>char</span> pa<span>[</span><span>]</span> <span>=</span> prefix<span>.</span><span>value</span><span>;</span>\n        <span><span>int</span></span> po <span>=</span> <span>0</span><span>;</span>\n        <span><span>int</span></span> pc <span>=</span> prefix<span>.</span><span>value</span><span>.</span>length<span>;</span>\n        <span>// Note: toffset might be near -1>>>1.</span>\n        <span>if</span> <span>(</span><span>(</span>toffset <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>toffset <span>></span> <span>value</span><span>.</span>length <span>-</span> pc<span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>while</span> <span>(</span><span>--</span>pc <span>>=</span> <span>0</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>ta<span>[</span>to<span>++</span><span>]</span> <span>!=</span> pa<span>[</span>po<span>++</span><span>]</span><span>)</span> <span>{</span>\n                <span>return</span> <span>false</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>判断字符串的子串是否以指定字符开始。如&quot;HelloWorld&quot;就是以指定前缀&quot;Hello&quot;开头。逻辑是先创建字符串与指定前缀的副本(目的是为了保护字符串和避免其它线程对字符串进行修改导致比较出错)，再从指定位置判断指定长度，也就是前缀长度字符串内容是否相等。</p>\n<h4 id=\"startswith-string-prefix\"> startsWith(String prefix):</h4>\n<div><pre><code>    <span>public</span> boolean <span>startsWith</span><span>(</span><span>String</span> <span>prefix</span><span>)</span> <span>{</span>\n        <span>return</span> <span>startsWith</span><span>(</span><span>prefix</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>同上述方法，只不过该方法的指定位置是从字符串的第0个位置开始。</p>\n<h4 id=\"endswith\"> endsWith:</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>endsWith</span><span>(</span><span>String</span> suffix<span>)</span> <span>{</span>\n        <span>return</span> <span>startsWith</span><span>(</span>suffix<span>,</span> <span>value</span><span>.</span>length <span>-</span> suffix<span>.</span><span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>判断字符串是否以指定字符结尾。调用了startsWith的判断逻辑。</p>\n<h4 id=\"hashcode\"> hashCode:</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>\n        <span><span>int</span></span> h <span>=</span> hash<span>;</span>\n        <span>if</span> <span>(</span>h <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>value</span><span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>char</span> val<span>[</span><span>]</span> <span>=</span> <span>value</span><span>;</span>\n\n            <span>for</span> <span>(</span><span><span>int</span></span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>value</span><span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                h <span>=</span> <span>31</span> <span>*</span> h <span>+</span> val<span>[</span>i<span>]</span><span>;</span>\n            <span>}</span>\n            hash <span>=</span> h<span>;</span>\n        <span>}</span>\n        <span>return</span> h<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>重写Object的hashCode方法。java中的hashCode有两个作用。一：Object的hashCode返回对象的内存地址。二：对象重写的hashCode配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable等。对于大量的元素比较时直接比较equals效率低下，可先判断hashCode再判断equals，因为不同的对象可能返回相同的hashCode(如&quot;Aa&quot;和&quot;BB&quot;的hashCode就一样),所以比较时有时需要再比较equals。hashCode只是起辅助作用。为了使字符串计算出来的hashCode尽可能的少重复，即降低哈希算法的冲突率，设计者选择了31这个乘数。选31有两个好处。1：31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一，其它的像37、41、43也是不错的乘数选择。2：31可以被 JVM 优化，31 * i = (i &lt;&lt; 5) - i。计算hashCode的原理也很简单，即用原hashCode乘以31再加上char数组的每位值。</p>\n<h4 id=\"indexof-int-ch\"> indexOf(int ch):</h4>\n<div><pre><code>    <span>public</span> <span>int</span> <span>indexOf</span><span>(</span><span>int</span> ch<span>)</span> <span>{</span>\n        <span>return</span> <span>indexOf</span><span>(</span>ch<span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>获取指定字符在字符串中第一次出现的索引位置。具体调用了indexOf(ch, 0) (见后)。</p>\n<h4 id=\"indexof-int-ch-int-fromindex\"> indexOf(int ch, int fromIndex):</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>indexOf</span><span>(</span><span><span>int</span></span> ch<span>,</span> <span><span>int</span></span> fromIndex<span>)</span> <span>{</span>\n        final <span><span>int</span></span> max <span>=</span> <span>value</span><span>.</span>length<span>;</span>\n        <span>if</span> <span>(</span>fromIndex <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            fromIndex <span>=</span> <span>0</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>fromIndex <span>>=</span> max<span>)</span> <span>{</span>\n            <span>// Note: fromIndex might be near -1>>>1.</span>\n            <span>return</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span>\n\n        <span>if</span> <span>(</span>ch <span>&lt;</span> Character<span>.</span>MIN_SUPPLEMENTARY_CODE_POINT<span>)</span> <span>{</span>\n            <span>// handle most cases here (ch is a BMP code point or a</span>\n            <span>// negative value (invalid code point))</span>\n            final <span><span>char</span><span>[</span><span>]</span></span> <span>value</span> <span>=</span> <span>this</span><span>.</span><span>value</span><span>;</span>\n            <span>for</span> <span>(</span><span><span>int</span></span> i <span>=</span> fromIndex<span>;</span> i <span>&lt;</span> max<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span><span>value</span><span>[</span>i<span>]</span> <span>==</span> ch<span>)</span> <span>{</span>\n                    <span>return</span> i<span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>return</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>return</span> <span>indexOfSupplementary</span><span>(</span>ch<span>,</span> fromIndex<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>获取指定字符在字符串中指定位置后第一次出现的索引位置。逻辑是：先对开始索引位置fromIndex进行检查，如果小于0则取0，如果大于数组长度则待查找的结果不存在，返回-1.如果fromIndex合法，再判断待查找的字符是否是在两个字节以内。ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT 这个条件非常重要，是分界BmpCode的界限,Character.MIN_SUPPLEMENTARY_CODE_POINT这个数代表十进制中62355，刚好是2个字节。如果在两个字节内则遍历字符数组找到即返回所引。待查找字符超过两个字节，则使用indexOfSupplementary(int ch, int fromIndex)方法进行查找。该方法是拆分字符的高低位进行比较,int类型在java中占4个字节，如果不是BmpCode代码(2字节以内)点是ValidCodePoint(2字节到四字节)，代码点是有高两位和低两位，这种类型的int转化为字符时分开来处理，作为两个字符。源码如下。</p>\n<div><pre><code>    <span>private</span> <span><span>int</span></span> <span>indexOfSupplementary</span><span>(</span><span><span>int</span></span> ch<span>,</span> <span><span>int</span></span> fromIndex<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>Character<span>.</span><span>isValidCodePoint</span><span>(</span>ch<span>)</span><span>)</span> <span>{</span>\n            final <span><span>char</span><span>[</span><span>]</span></span> <span>value</span> <span>=</span> <span>this</span><span>.</span><span>value</span><span>;</span>\n            final <span><span>char</span></span> hi <span>=</span> Character<span>.</span><span>highSurrogate</span><span>(</span>ch<span>)</span><span>;</span>\n            final <span><span>char</span></span> lo <span>=</span> Character<span>.</span><span>lowSurrogate</span><span>(</span>ch<span>)</span><span>;</span>\n            final <span><span>int</span></span> max <span>=</span> <span>value</span><span>.</span>length <span>-</span> <span>1</span><span>;</span>\n            <span>for</span> <span>(</span><span><span>int</span></span> i <span>=</span> fromIndex<span>;</span> i <span>&lt;</span> max<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span><span>value</span><span>[</span>i<span>]</span> <span>==</span> hi <span>&amp;&amp;</span> <span>value</span><span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>==</span> lo<span>)</span> <span>{</span>\n                    <span>return</span> i<span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>-</span><span>1</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id=\"lastindexof\"> lastIndexOf:</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>lastIndexOf</span><span>(</span><span><span>int</span></span> ch<span>)</span> <span>{</span>\n        <span>return</span> <span>lastIndexOf</span><span>(</span>ch<span>,</span> <span>value</span><span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span><span>int</span></span> <span>lastIndexOf</span><span>(</span><span><span>int</span></span> ch<span>,</span> <span><span>int</span></span> fromIndex<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>ch <span>&lt;</span> Character<span>.</span>MIN_SUPPLEMENTARY_CODE_POINT<span>)</span> <span>{</span>\n            <span>// handle most cases here (ch is a BMP code point or a</span>\n            <span>// negative value (invalid code point))</span>\n            final <span><span>char</span><span>[</span><span>]</span></span> <span>value</span> <span>=</span> <span>this</span><span>.</span><span>value</span><span>;</span>\n            <span><span>int</span></span> i <span>=</span> Math<span>.</span><span>min</span><span>(</span>fromIndex<span>,</span> <span>value</span><span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span><span>value</span><span>[</span>i<span>]</span> <span>==</span> ch<span>)</span> <span>{</span>\n                    <span>return</span> i<span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>return</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>return</span> <span>lastIndexOfSupplementary</span><span>(</span>ch<span>,</span> fromIndex<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>从后住前查找指定字符在字符串中第一次出现的位置。原理同indexOf方法类似，这里就不赘述了。</p>\n<h4 id=\"\"> </h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>indexOf</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>\n        <span>return</span> <span>indexOf</span><span>(</span>str<span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span><span>int</span></span> <span>indexOf</span><span>(</span><span>String</span> str<span>,</span> <span><span>int</span></span> fromIndex<span>)</span> <span>{</span>\n        <span>return</span> <span>indexOf</span><span>(</span><span>value</span><span>,</span> <span>0</span><span>,</span> <span>value</span><span>.</span>length<span>,</span>\n                str<span>.</span><span>value</span><span>,</span> <span>0</span><span>,</span> str<span>.</span><span>value</span><span>.</span>length<span>,</span> fromIndex<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>查找指定字符串在原字符串中第一次出现的索引位置。具体实现是调用了indexOf(char[] source, int sourceOffset, int sourceCount,\nchar[] target, int targetOffset, int targetCount,int fromIndex)方法。实现如下。</p>\n<div><pre><code>    <span>static</span> <span>int</span> <span>indexOf</span><span>(</span><span>char</span><span>[</span><span>]</span> source<span>,</span> <span>int</span> sourceOffset<span>,</span> <span>int</span> sourceCount<span>,</span>\n            <span>char</span><span>[</span><span>]</span> target<span>,</span> <span>int</span> targetOffset<span>,</span> <span>int</span> targetCount<span>,</span>\n            <span>int</span> fromIndex<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>fromIndex <span>>=</span> sourceCount<span>)</span> <span>{</span>\n            <span>return</span> <span>(</span>targetCount <span>==</span> <span>0</span> <span>?</span> sourceCount <span>:</span> <span>-</span><span>1</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>fromIndex <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            fromIndex <span>=</span> <span>0</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>targetCount <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            <span>return</span> fromIndex<span>;</span>\n        <span>}</span>\n        <span>char</span> first <span>=</span> target<span>[</span>targetOffset<span>]</span><span>;</span>\n        <span>int</span> max <span>=</span> sourceOffset <span>+</span> <span>(</span>sourceCount <span>-</span> targetCount<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> sourceOffset <span>+</span> fromIndex<span>;</span> i <span>&lt;=</span> max<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>/* Look for first character. */</span>\n            <span>if</span> <span>(</span>source<span>[</span>i<span>]</span> <span>!=</span> first<span>)</span> <span>{</span>\n                <span>while</span> <span>(</span><span>++</span>i <span>&lt;=</span> max <span>&amp;&amp;</span> source<span>[</span>i<span>]</span> <span>!=</span> first<span>)</span><span>;</span>\n            <span>}</span>\n            <span>/* Found first character, now look at the rest of v2 */</span>\n            <span>if</span> <span>(</span>i <span>&lt;=</span> max<span>)</span> <span>{</span>\n                <span>int</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span>\n                <span>int</span> end <span>=</span> j <span>+</span> targetCount <span>-</span> <span>1</span><span>;</span>\n                <span>for</span> <span>(</span><span>int</span> k <span>=</span> targetOffset <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> end <span>&amp;&amp;</span> source<span>[</span>j<span>]</span>\n                        <span>==</span> target<span>[</span>k<span>]</span><span>;</span> j<span>++</span><span>,</span> k<span>++</span><span>)</span><span>;</span>\n                <span>if</span> <span>(</span>j <span>==</span> end<span>)</span> <span>{</span>\n                    <span>/* Found whole string. */</span>\n                    <span>return</span> i <span>-</span> sourceOffset<span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>-</span><span>1</span><span>;</span>\n    <span>}</span>            \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>该方法是保护的，只能在包内调用。逻辑是(假设是从第0个位置开始找，从其它位置开始逻辑类似)：\n1.遍历当前字符串，找到当前字符串中和参数str字符串第一个字符相同的字符的位置记为i。\n2.然后逐一比较接下来的每个字符是否相等，如果相等则返回，不等进行3\n3.从原字符串第i个位置后找与str第一个字符相等的位置，再比较接下来的每个字符是否相等。\n如此循环直到找到，或原字符串遍历完成结束方法。</p>\n<h4 id=\"lastindexof-string-str\"> lastIndexOf(String str)：</h4>\n<div><pre><code>    <span>public</span> <span><span>int</span></span> <span>lastIndexOf</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>\n        <span>return</span> <span>lastIndexOf</span><span>(</span>str<span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>从后往前查找字符串str在原字符串中第一次出现的索引位置。该系列方法同indexOf(String str)系列方法逻辑类似。只不过查找顺序是从后往前。</p>\n<h4 id=\"substring-int-beginindex\"> substring(int beginIndex)：</h4>\n<div><pre><code>    <span>public</span> <span>String</span> <span>substring</span><span>(</span><span><span>int</span></span> beginIndex<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>beginIndex <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>beginIndex<span>)</span><span>;</span>\n        <span>}</span>\n        <span><span>int</span></span> subLen <span>=</span> <span>value</span><span>.</span>length <span>-</span> beginIndex<span>;</span>\n        <span>if</span> <span>(</span>subLen <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>subLen<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>(</span>beginIndex <span>==</span> <span>0</span><span>)</span> <span>?</span> <span>this</span> <span>:</span> <span>new</span> <span>String</span><span>(</span><span>value</span><span>,</span> beginIndex<span>,</span> subLen<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>截取字符串的子串。截取从指定位置beginIndex开始(包含这个位置)，到字符串结束之间的字符串内容。如果beginIndex=0则返回原串，否则创建一个新的字符串返回。</p>\n<h4 id=\"substring-int-beginindex-int-endindex\"> substring(int beginIndex, int endIndex):</h4>\n<div><pre><code>    <span>public</span> <span>String</span> <span>substring</span><span>(</span><span><span>int</span></span> beginIndex<span>,</span> <span><span>int</span></span> endIndex<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>beginIndex <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>beginIndex<span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>endIndex <span>></span> <span>value</span><span>.</span>length<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>endIndex<span>)</span><span>;</span>\n        <span>}</span>\n        <span><span>int</span></span> subLen <span>=</span> endIndex <span>-</span> beginIndex<span>;</span>\n        <span>if</span> <span>(</span>subLen <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>subLen<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>(</span><span>(</span>beginIndex <span>==</span> <span>0</span><span>)</span> <span>&amp;&amp;</span> <span>(</span>endIndex <span>==</span> <span>value</span><span>.</span>length<span>)</span><span>)</span> <span>?</span> <span>this</span>\n                <span>:</span> <span>new</span> <span>String</span><span>(</span><span>value</span><span>,</span> beginIndex<span>,</span> subLen<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>截取原字符串的子串，同上个方法类似，上一个方法的结束位置是原串的结尾，这个方法是指定结束位置endIndex(不包含这个位置)。需要注意的是这个方法是包含头不包含尾。</p>\n<h4 id=\"subsequence\"> subSequence:</h4>\n<div><pre><code>    <span>public</span> CharSequence <span>subSequence</span><span>(</span><span>int</span> beginIndex<span>,</span> <span>int</span> endIndex<span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span><span>substring</span><span>(</span>beginIndex<span>,</span> endIndex<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>截取指定区间内的字符序列。调用了substring方法，因为String本身就是一个CharSequence，所以这里可以直接返回。</p>\n<h4 id=\"concat\"> concat:</h4>\n<div><pre><code>    <span>public</span> <span>String</span> <span>concat</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>\n        <span><span>int</span></span> otherLen <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>otherLen <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            <span>return</span> <span>this</span><span>;</span>\n        <span>}</span>\n        <span><span>int</span></span> len <span>=</span> <span>value</span><span>.</span>length<span>;</span>\n        <span>char</span> buf<span>[</span><span>]</span> <span>=</span> Arrays<span>.</span><span>copyOf</span><span>(</span><span>value</span><span>,</span> len <span>+</span> otherLen<span>)</span><span>;</span>\n        str<span>.</span><span>getChars</span><span>(</span>buf<span>,</span> len<span>)</span><span>;</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>buf<span>,</span> <span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>连接两个字符串。先创建了一个新的字符数组复制了两个字符串中的内容。然后通过String(char[] value, boolean share)创建结果字符串。注意这里用的是直接复制引用的方式而不是复制数组中字符的内容来创建字符串，这可以提高效率，前面写字符串的构造方法时也提到过。创建的新的字符串，对原来的两个字符串的内容没有影响。</p>\n<h4 id=\"replace-char-oldchar-char-newchar\"> replace(char oldChar, char newChar):</h4>\n<div><pre><code>    <span>public</span> <span>String</span> <span>replace</span><span>(</span><span><span>char</span></span> oldChar<span>,</span> <span><span>char</span></span> newChar<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>oldChar <span>!=</span> newChar<span>)</span> <span>{</span>\n            <span><span>int</span></span> len <span>=</span> <span>value</span><span>.</span>length<span>;</span>\n            <span><span>int</span></span> i <span>=</span> <span>-</span><span>1</span><span>;</span>\n            <span><span>char</span><span>[</span><span>]</span></span> val <span>=</span> <span>value</span><span>;</span> <span>/* avoid getfield opcode */</span>\n\n            <span>while</span> <span>(</span><span>++</span>i <span>&lt;</span> len<span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>val<span>[</span>i<span>]</span> <span>==</span> oldChar<span>)</span> <span>{</span>\n                    <span>break</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>if</span> <span>(</span>i <span>&lt;</span> len<span>)</span> <span>{</span>\n                <span>char</span> buf<span>[</span><span>]</span> <span>=</span> <span>new</span> <span><span>char</span></span><span>[</span>len<span>]</span><span>;</span>\n                <span>for</span> <span>(</span><span><span>int</span></span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                    buf<span>[</span>j<span>]</span> <span>=</span> val<span>[</span>j<span>]</span><span>;</span>\n                <span>}</span>\n                <span>while</span> <span>(</span>i <span>&lt;</span> len<span>)</span> <span>{</span>\n                    <span><span>char</span></span> c <span>=</span> val<span>[</span>i<span>]</span><span>;</span>\n                    buf<span>[</span>i<span>]</span> <span>=</span> <span>(</span>c <span>==</span> oldChar<span>)</span> <span>?</span> newChar <span>:</span> c<span>;</span>\n                    i<span>++</span><span>;</span>\n                <span>}</span>\n                <span>return</span> <span>new</span> <span>String</span><span>(</span>buf<span>,</span> <span>true</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>this</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>将字符串中所有的旧字符oldChar，替换为新的字符newChar。逻辑是：先找到字符串中第一次出现oldChar字符的位置i。将之前的字符数组复制给新数组buf，然后从i后将字符数组中的内容复制给buf，只不过如果字符为oldCha则替换为newChar.然后再通过buf创建新的字符串返回。</p>\n<h4 id=\"matches\"> matches:</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>matches</span><span>(</span><span>String</span> regex<span>)</span> <span>{</span>\n        <span>return</span> <span>Pattern</span><span>.</span><span>matches</span><span>(</span>regex<span>,</span> <span>this</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>查找字符串是否包含指定正则规则的字符串。关于正则在java也是一个很有用知识点，有兴趣的同学可以查一下。</p>\n<h4 id=\"contains\"> contains:</h4>\n<div><pre><code>    <span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>CharSequence</span> s<span>)</span> <span>{</span>\n        <span>return</span> <span>indexOf</span><span>(</span>s<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span> <span>></span> <span>-</span><span>1</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>判断字符串中是否包含指定的字符序列。实际是调用indexOf方法，查找序列在字符串中的位置来判断的，如果不包含则查找的索引为-1.</p>\n<h4 id=\"replacefirst\"> replaceFirst：</h4>\n<div><pre><code>    public <span>String</span> <span>replaceFirst</span><span>(</span><span>String</span> regex<span>,</span> <span>String</span> replacement<span>)</span> <span>{</span>\n        <span>return</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span>regex<span>)</span><span>.</span><span>matcher</span><span>(</span><span>this</span><span>)</span><span>.</span><span>replaceFirst</span><span>(</span>replacement<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>替换第一个正则匹配项。需要注意一点，如果需要替换的内容中包含反斜杠\\需要用<img src=\"https://math.jianshu.com/math?formula=代替。这一点从注释中可以看出来。Note that backslashes (\\) and dollar signs ()\" alt=\"代替。这一点从注释中可以看出来。Note that backslashes (\\) and dollar signs (\" /> in the replacement</p>\n<h4 id=\"replaceall\"> replaceAll</h4>\n<div><pre><code>    public <span>String</span> <span>replaceAll</span><span>(</span><span>String</span> regex<span>,</span> <span>String</span> replacement<span>)</span> <span>{</span>\n        <span>return</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span>regex<span>)</span><span>.</span><span>matcher</span><span>(</span><span>this</span><span>)</span><span>.</span><span>replaceAll</span><span>(</span>replacement<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>替换所有的正则匹配项。同理新替换的内容中包含反斜杠\\需要用$代替。</p>\n<h4 id=\"split-string-regex-int-limit\"> split(String regex, int limit) :</h4>\n<div><pre><code>    <span>public</span> String<span>[</span><span>]</span> <span>split</span><span>(</span>String regex<span>,</span> <span>int</span> limit<span>)</span> <span>{</span>\n        <span>char</span> ch <span>=</span> <span>0</span><span>;</span>\n        <span>if</span> <span>(</span><span>(</span><span>(</span>regex<span>.</span>value<span>.</span>length <span>==</span> <span>1</span> <span>&amp;&amp;</span> <span>//判断参数长度是否为1</span>\n             <span>\".$|()[{^?*+\\\\\"</span><span>.</span><span>indexOf</span><span>(</span>ch <span>=</span> regex<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>)</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>||</span> <span>//判断参数不在特殊符号\".$|()[{^?*+\\\\\"中 </span>\n             <span>(</span>regex<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>2</span> <span>&amp;&amp;</span> <span>//判断参数长度是否为2</span>\n              regex<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>==</span> <span>'\\\\'</span> <span>&amp;&amp;</span>  \\\\第一位为转义符<span>\"\\\\\"</span>\n              <span>(</span><span>(</span><span>(</span>ch <span>=</span> regex<span>.</span><span>charAt</span><span>(</span><span>1</span><span>)</span><span>)</span><span>-</span><span>'0'</span><span>)</span><span>|</span><span>(</span><span>'9'</span><span>-</span>ch<span>)</span><span>)</span> <span>&lt;</span> <span>0</span> <span>&amp;&amp;</span> <span>//第二位不是0-9之间 '0'转换为int为48 '9'转换为int为57 </span>\n              <span>(</span><span>(</span>ch<span>-</span><span>'a'</span><span>)</span><span>|</span><span>(</span><span>'z'</span><span>-</span>ch<span>)</span><span>)</span> <span>&lt;</span> <span>0</span> <span>&amp;&amp;</span> <span>//判断不在 a-z之间</span>\n              <span>(</span><span>(</span>ch<span>-</span><span>'A'</span><span>)</span><span>|</span><span>(</span><span>'Z'</span><span>-</span>ch<span>)</span><span>)</span> <span>&lt;</span> <span>0</span><span>)</span><span>)</span> <span>&amp;&amp;</span> <span>//判断不在A-Z之间</span>\n            <span>(</span>ch <span>&lt;</span> Character<span>.</span>MIN_HIGH_SURROGATE <span>||</span> \n             ch <span>></span> Character<span>.</span>MAX_LOW_SURROGATE<span>)</span><span>)</span>  <span>//判断分隔符不在特殊符号中</span>\n        <span>{</span>\n            <span>int</span> off <span>=</span> <span>0</span><span>;</span><span>//当前索引</span>\n            <span>int</span> next <span>=</span> <span>0</span><span>;</span><span>//下一个分割符出现的索引</span>\n            boolean limited <span>=</span> limit <span>></span> <span>0</span><span>;</span><span>//只分割前limit份还是全部分割,limit=0代表全部分割</span>\n            ArrayList<span>&lt;</span>String<span>></span> list <span>=</span> <span>new</span> <span><span>ArrayList</span><span><span>&lt;</span><span>></span></span></span><span>(</span><span>)</span><span>;</span><span>//创建一个集合，用于存放切割好的子串</span>\n            <span>while</span> <span>(</span><span>(</span>next <span>=</span> <span>indexOf</span><span>(</span>ch<span>,</span> off<span>)</span><span>)</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span><span>//判断是否包含下个分隔符，如果有则进入循环</span>\n                <span>if</span> <span>(</span><span>!</span>limited <span>||</span> list<span>.</span><span>size</span><span>(</span><span>)</span> <span>&lt;</span> limit <span>-</span> <span>1</span><span>)</span> <span>{</span><span>//判断是全部分割或当前分割次数小于总分割次数</span>\n                    list<span>.</span><span>add</span><span>(</span><span>substring</span><span>(</span>off<span>,</span> next<span>)</span><span>)</span><span>;</span><span>//切割当前索引到下一个分隔符之间的字符串并添加到list中</span>\n                    off <span>=</span> next <span>+</span> <span>1</span><span>;</span> <span>//继续切割下一下子串</span>\n                <span>}</span> <span>else</span> <span>{</span>    <span>// last one</span>\n                    <span>//assert (list.size() == limit - 1);</span>\n                    list<span>.</span><span>add</span><span>(</span><span>substring</span><span>(</span>off<span>,</span> value<span>.</span>length<span>)</span><span>)</span><span>;</span><span>//切割当前索引到字符串结尾的子字符串并添加到list</span>\n                    off <span>=</span> value<span>.</span>length<span>;</span><span>//将当前索引置为字符串长度</span>\n                    <span>break</span><span>;</span><span>//结束循环</span>\n                <span>}</span>\n            <span>}</span>\n            <span>// If no match was found, return this</span>\n            <span>if</span> <span>(</span>off <span>==</span> <span>0</span><span>)</span> <span>//如果找不到分隔符则返回只有本字符串的数组</span>\n                <span>return</span> <span>new</span> String<span>[</span><span>]</span><span>{</span><span>this</span><span>}</span><span>;</span>\n\n            <span>// Add remaining segment</span>\n            <span>if</span> <span>(</span><span>!</span>limited <span>||</span> list<span>.</span><span>size</span><span>(</span><span>)</span> <span>&lt;</span> limit<span>)</span><span>//如果是全部分割，或者没有达到分割数，则追加最后一项</span>\n                list<span>.</span><span>add</span><span>(</span><span>substring</span><span>(</span>off<span>,</span> value<span>.</span>length<span>)</span><span>)</span><span>;</span>\n\n            <span>// Construct result</span>\n            <span>int</span> resultSize <span>=</span> list<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>limit <span>==</span> <span>0</span><span>)</span> <span>{</span><span>//移除多余集合项</span>\n                <span>while</span> <span>(</span>resultSize <span>></span> <span>0</span> <span>&amp;&amp;</span> list<span>.</span><span>get</span><span>(</span>resultSize <span>-</span> <span>1</span><span>)</span><span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                    resultSize<span>--</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            String<span>[</span><span>]</span> result <span>=</span> <span>new</span> String<span>[</span>resultSize<span>]</span><span>;</span><span>//创建对应长度数组，因为返回结果为字符串数组</span>\n            <span>return</span> list<span>.</span><span>subList</span><span>(</span><span>0</span><span>,</span> resultSize<span>)</span><span>.</span><span>toArray</span><span>(</span>result<span>)</span><span>;</span><span>//集合转数组并返回</span>\n        <span>}</span>\n        <span>return</span> Pattern<span>.</span><span>compile</span><span>(</span>regex<span>)</span><span>.</span><span>split</span><span>(</span><span>this</span><span>,</span> limit<span>)</span><span>;</span><span>//其它情况用正则的切割规则去切割</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p>根据指定规则切割原字符串。如 &quot;abc,def,ghi&quot;.split(&quot;,&quot;)则返回包含&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;三个字符串元素的字符串数组。源码分析直接写在源码中。</p>\n<h4 id=\"split\"> split:</h4>\n<div><pre><code>    <span>public</span> <span>String</span><span>[</span><span>]</span> <span>split</span><span>(</span><span>String</span> regex<span>)</span> <span>{</span> \n        <span>return</span> <span>split</span><span>(</span>regex<span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>根据指定规则切割字符串，切割全部子串。</p>\n<h4 id=\"join\"> join:</h4>\n<div><pre><code>    <span>public</span> <span>static</span> String <span>join</span><span>(</span><span>CharSequence</span> delimiter<span>,</span> CharSequence<span>..</span><span>.</span> elements<span>)</span> <span>{</span>\n        Objects<span>.</span><span>requireNonNull</span><span>(</span>delimiter<span>)</span><span>;</span>\n        Objects<span>.</span><span>requireNonNull</span><span>(</span>elements<span>)</span><span>;</span>\n        <span>// Number of elements not likely worth Arrays.stream overhead.</span>\n        <span>StringJoiner</span> joiner <span>=</span> <span>new</span> <span>StringJoiner</span><span>(</span>delimiter<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>CharSequence</span> cs<span>:</span> elements<span>)</span> <span>{</span>\n            joiner<span>.</span><span>add</span><span>(</span>cs<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> joiner<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> String <span>join</span><span>(</span><span>CharSequence</span> delimiter<span>,</span>\n            <span>Iterable<span>&lt;</span><span>?</span> extends CharSequence<span>></span></span> elements<span>)</span> <span>{</span>\n        Objects<span>.</span><span>requireNonNull</span><span>(</span>delimiter<span>)</span><span>;</span>\n        Objects<span>.</span><span>requireNonNull</span><span>(</span>elements<span>)</span><span>;</span>\n        <span>StringJoiner</span> joiner <span>=</span> <span>new</span> <span>StringJoiner</span><span>(</span>delimiter<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>CharSequence</span> cs<span>:</span> elements<span>)</span> <span>{</span>\n            joiner<span>.</span><span>add</span><span>(</span>cs<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> joiner<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>join方法是jdk1.8之后新加的方法，作用是将字符序列数组，或是字符序列集合通过分割符delimiter连接成一个字符串。提供这两个实现原理差不多，第一个方法使用的可变参数，第二个方法使用的可迭代参数，这样设计主要是为了让方法更好用，参数可以是一个数组也可以是一个集合。再来看下原理。\n通过遍历数组和集合将数组元素或集合元素添加到StringBuilder，添加前会先加入一个分割符delimiter,然后将StringBuilder中的内容返回，具体如下：</p>\n<div><pre><code>    <span>//1.StringJoiner的add方法,使用了方法调用链的方式，返回对象本身，可重复使用add方法。</span>\n    <span>public</span> StringJoiner <span>add</span><span>(</span><span>CharSequence</span> newElement<span>)</span> <span>{</span>\n        <span>prepareBuilder</span><span>(</span><span>)</span><span>.</span><span>append</span><span>(</span>newElement<span>)</span><span>;</span><span>//调用prepareBuilder()包含之前添加的元素和新加入一个分割符，然后再append添加新的元素</span>\n        <span>return</span> <span>this</span><span>;</span>\n    <span>}</span>\n    <span>//2.StringJoiner的prepareBuilder方法,内部维护了一个StringBuilder</span>\n    <span>private</span> <span>StringBuilder</span> <span>prepareBuilder</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>value</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>value</span><span>.</span><span>append</span><span>(</span>delimiter<span>)</span><span>;</span><span>//每次调用这个方法时会,往StringBuilder中添加分割符delimiter</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>value</span> <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>.</span><span>append</span><span>(</span>prefix<span>)</span><span>;</span><span>//第一次调用时创建StringBuilder对象</span>\n        <span>}</span>\n        <span>return</span> <span>value</span><span>;</span><span>//返回StringBuilder对象，以便下次调用的时候操作的是同一个StringBuilder</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id=\"大小写转换函数\"> 大小写转换函数:</h4>\n<div><pre><code>    <span>public</span> String <span>toLowerCase</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>toLowerCase</span><span>(</span>Locale<span>.</span><span>getDefault</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> String <span>toUpperCase</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>toUpperCase</span><span>(</span>Locale<span>.</span><span>getDefault</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>从名字可以看出这两个函数是对字符串进行大小写转换的，需要注意的是只是针对英文字母[a-z][A-Z]转换有效，其它字符转换无效。</p>\n<h4 id=\"trim\"> trim:</h4>\n<div><pre><code>    <span>public</span> <span>String</span> <span>trim</span><span>(</span><span>)</span> <span>{</span>\n        <span><span>int</span></span> len <span>=</span> <span>value</span><span>.</span>length<span>;</span>\n        <span><span>int</span></span> st <span>=</span> <span>0</span><span>;</span>\n        <span><span>char</span><span>[</span><span>]</span></span> val <span>=</span> <span>value</span><span>;</span>    <span>/* avoid getfield opcode */</span>\n\n        <span>while</span> <span>(</span><span>(</span>st <span>&lt;</span> len<span>)</span> <span>&amp;&amp;</span> <span>(</span>val<span>[</span>st<span>]</span> <span>&lt;=</span> <span>' '</span><span>)</span><span>)</span> <span>{</span>\n            st<span>++</span><span>;</span>\n        <span>}</span>\n        <span>while</span> <span>(</span><span>(</span>st <span>&lt;</span> len<span>)</span> <span>&amp;&amp;</span> <span>(</span>val<span>[</span>len <span>-</span> <span>1</span><span>]</span> <span>&lt;=</span> <span>' '</span><span>)</span><span>)</span> <span>{</span>\n            len<span>--</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>(</span><span>(</span>st <span>></span> <span>0</span><span>)</span> <span>||</span> <span>(</span>len <span>&lt;</span> <span>value</span><span>.</span>length<span>)</span><span>)</span> <span>?</span> <span>substring</span><span>(</span>st<span>,</span> len<span>)</span> <span>:</span> <span>this</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>去掉字符串两端的空白字符，空白字符包括，空格、tab、回车符。逻辑：\n1.从左到右循环字符数组，若字符为空字符，则继续循环，直到第一个不为空的字符记录其位置st。\n2.从右到左循环字符数组，若字符为空字符，则继续循环，直到第一个不为空的字符记录其位置len。\n3.截取字符串中从st到len位置的子串。</p>\n<h4 id=\"tostring\"> toString:</h4>\n<div><pre><code>    <span>public</span> String <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>返回字符串对象的字符串形式，实际上就是返回他本身。</p>\n<h4 id=\"tochararray\"> toCharArray:</h4>\n<div><pre><code>    <span>public</span> <span><span>char</span><span>[</span><span>]</span></span> <span>toCharArray</span><span>(</span><span>)</span> <span>{</span>\n        <span>// Cannot use Arrays.copyOf because of class initialization order issues</span>\n        <span>char</span> result<span>[</span><span>]</span> <span>=</span> <span>new</span> <span><span>char</span></span><span>[</span><span>value</span><span>.</span>length<span>]</span><span>;</span>\n        System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> <span>0</span><span>,</span> result<span>,</span> <span>0</span><span>,</span> <span>value</span><span>.</span>length<span>)</span><span>;</span>\n        <span>return</span> result<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>将字符串转换为字符数组返回。将字符串中维护的字符数组复制一份返回。这里有两点需要注意的地方：\n1.这里不能直接返回内部字符数组value，如果直接返回 value，返回的数组（假设为chArray）与value指向同一个地址，一旦你修改了 chArray数组的内容，value所指向的内容也随之改变，这样破坏了String的不变性。\n2.源码中有一行注释：Cannot use Arrays.copyOf because of class initialization order issues（由于类初始化顺序问题，无法使用ARARY.COSTOFF），这里我猜测是这样的，字符串比Arrays先初始化完成，但是在JDK中存在其它对象使用了toCharArray方法，而这个对象比String对象初始化晚，但比Arrays对象初始化早，导致使用时Arrays未初始化完成从而报错。故这里有了这个注释，而使用 System.arraycopy则不会存在这样的问题，因为这个方法是本地方法。</p>\n<h4 id=\"format\"> format</h4>\n<div><pre><code>    <span>public</span> <span>static</span> String <span>format</span><span>(</span><span>String format<span>,</span> Object<span>...</span> args</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>Formatter</span><span>(</span><span>)</span><span>.</span><span>format</span><span>(</span>format<span>,</span> args<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> String <span>format</span><span>(</span><span>Locale l<span>,</span> String format<span>,</span> Object<span>...</span> args</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>Formatter</span><span>(</span>l<span>)</span><span>.</span><span>format</span><span>(</span>format<span>,</span> args<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>用于创建格式化的字符串以及连接多个字符串对象。熟悉C语言的同学应该记得C语言的sprintf()方法，两者有类似之处。这里给出了两种重载形式，第一种使用本地语言环境，第二种使用指定的语言环境。\n如：String.format(&quot;Hi,%s:%s.%s&quot;, &quot;z3&quot;,&quot;l4&quot;,&quot;w5&quot;);返回Hi:z3,l4,w5</p>\n<h4 id=\"valueof系列\"> valueOf系列：</h4>\n<div><pre><code>    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>Object</span> obj<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>obj <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>\"null\"</span> <span>:</span> obj<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>char</span> data<span>[</span><span>]</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>data<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>char</span> data<span>[</span><span>]</span><span>,</span> <span>int</span> offset<span>,</span> <span>int</span> count<span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>data<span>,</span> offset<span>,</span> count<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>copyValueOf</span><span>(</span><span>char</span> data<span>[</span><span>]</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>data<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>boolean</span> b<span>)</span> <span>{</span>\n        <span>return</span> b <span>?</span> <span>\"true\"</span> <span>:</span> <span>\"false\"</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>char</span> c<span>)</span> <span>{</span>\n        <span>char</span> data<span>[</span><span>]</span> <span>=</span> <span>{</span>c<span>}</span><span>;</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>data<span>,</span> <span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>Integer</span><span>.</span><span>toString</span><span>(</span>i<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>long</span> l<span>)</span> <span>{</span>\n        <span>return</span> <span>Long</span><span>.</span><span>toString</span><span>(</span>l<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>float</span> f<span>)</span> <span>{</span>\n        <span>return</span> <span>Float</span><span>.</span><span>toString</span><span>(</span>f<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>valueOf</span><span>(</span><span>double</span> d<span>)</span> <span>{</span>\n        <span>return</span> <span>Double</span><span>.</span><span>toString</span><span>(</span>d<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>valueOf系列，将传入的参数，转换成各自对应的字符串对象。需要注意两点：\n1.对于对象如果是null则返回字符串&quot;null&quot;.\n2.对于boolean类型真返回&quot;true&quot;,假返回&quot;false&quot;</p>\n<h4 id=\"intern\"> intern：</h4>\n<div><pre><code>    <span>public</span> <span>native</span> <span>String</span> <span>intern</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>最后String还有一个intern方法，这个方法是本地方法，无方法体。\njdk1.7之前intern方法执行后如果在常量池找不到对应的字符串，则会将字符串拷贝到常量池，然后返回常量池中的引用。\njdk1.7之后intern方法执行后如果在常量池找不到对应的字符串，则会在常量池中生成一个对原字符串的引用。\n原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。\n实际上在常量池中有一个对象StringTable，可以看作是一个HashSet。使用StringTable来维护所有存活的字符串的一个对象。\n使用String的intern方法可以节省内存。在某些情况下可以使用 intern() 方法，它能够使内存中的不同字符串都只有一个实例对象。\n看下面的例子：</p>\n<div><pre><code><span>public</span> <span>void</span> <span>testIntern</span><span>(</span><span>)</span> <span>{</span>\n    String str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"hello\"</span><span>)</span> <span>+</span> <span>new</span> <span>String</span><span>(</span><span>\"world\"</span><span>)</span><span>;</span>\n    str2<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span><span>// 使用intern方法后str2与str1指向同一个对象，否则它们指向两个不同的对象。这样就能达到节省内存的效果。</span>\n    String str1 <span>=</span> <span>\"helloworld\"</span><span>;</span>\n    System<span>.</span>out<span>.</span><span>println</span><span>(</span>str2 <span>==</span> str1<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"_3-stringbuffer类\"> 3.StringBuffer类</h2>\n<p>StringBuffer和String的区别?\n前者长度和内容可变，后者不可变。\n如果使用前者做字符串的拼接，不会浪费太多的资源。</p>\n<p>StringBuffer的构造方法：</p>\n<div><pre><code><span>//无参构造方法</span>\n<span>public</span> <span>StringBuffer</span><span>(</span><span>)</span>\n<span>//指定容量的字符串缓冲区对象</span>\n<span>public</span> <span>StringBuffer</span><span>(</span><span>int</span> capacity<span>)</span>\n<span>//指定字符串内容的字符串缓冲区对象</span>\n<span>public</span> <span>StringBuffer</span><span>(</span><span>String</span> str<span>)</span>\n<span>//默认容量为16</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>添加功能：</p>\n<div><pre><code><span>//追加</span>\n<span>public</span> <span>StringBuffer</span> <span>append</span><span>(</span><span>String</span> str<span>)</span>\n<span>//指定位置插入字符串</span>\n<span>public</span> <span>StringBuffer</span> <span>insert</span><span>(</span><span>int</span> offset<span>,</span><span>String</span> str<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>删除功能：</p>\n<div><pre><code><span>//删除指定位置的字符，并返回本身</span>\n<span>public</span> <span>StringBuffer</span> <span>deleteCharAt</span><span>(</span><span>int</span> index<span>)</span>\n<span>//删除从指定位置开始指定位置结束的内容，并返回本身</span>\n<span>public</span> <span>StringBuffer</span> <span>delete</span><span>(</span><span>int</span> start<span>,</span><span>int</span> end<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>替换功能：</p>\n<div><pre><code><span>//从start开始到end用str替换</span>\n<span>public</span> <span>StringBuffer</span> <span>replace</span><span>(</span><span>int</span> start<span>,</span><span>int</span> end<span>,</span><span>String</span> str<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>反转功能：</p>\n<div><pre><code><span>public</span> <span>StringBuffer</span> <span>reverse</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>截取功能:</p>\n<div><pre><code><span>// 注意返回值类型不再是StringBuffer本身了</span>\n<span>public</span> <span>String</span> <span>substring</span><span>(</span><span>int</span> start<span>)</span>\n<span>public</span> <span>String</span> <span>substring</span><span>(</span><span>int</span> start<span>,</span><span>int</span> end<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>String -转化为-StringBuffer</p>\n<div><pre><code><span>String</span> s <span>=</span> <span>\"hello\"</span><span>;</span>\n<span>// 注意：不能把字符串的值直接赋值给StringBuffer</span>\n<span>// StringBuffer sb = \"hello\";</span>\n<span>// StringBuffer sb = s;</span>\n<span>// 方式1:通过构造方法</span>\n<span>StringBuffer</span> sb <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span>s<span>)</span><span>;</span>\n<span>// 方式2：通过append()方法</span>\n<span>StringBuffer</span> sb2 <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>\nsb2<span>.</span><span>append</span><span>(</span>s<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>StringBuffer -转化为- String</p>\n<div><pre><code><span>StringBuffer</span> buffer <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>\"java\"</span><span>)</span><span>;</span>\n<span>// String(StringBuffer buffer)</span>\n<span>// 方式1:通过构造方法</span>\n<span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span>buffer<span>)</span><span>;</span>\n<span>// 方式2：通过toString()方法</span>\n<span>String</span> str2 <span>=</span> buffer<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>1：String,StringBuffer,StringBuilder的区别?\n　A:String是内容不可变的，而StringBuffer,StringBuilder都是内容可变的。\n　B:StringBuffer是同步的，数据安全,效率低;StringBuilder是不同步的,数据不安全,效率高</p>\n<p>2：StringBuffer和数组的区别?\n　　 二者都可以看出是一个容器，装其他的数据。\n　　 但是呢,StringBuffer的数据最终是一个字符串数据。\n　　 而数组可以放置多种数据，但必须是同一种数据类型的。</p>\n<p>3：形式参数：\n基本类型：形式参数的改变不影响实际参数\n引用类型：形式参数的改变直接影响实际参数\n*注意：\nString作为参数传递，效果和基本类型作为参数传递是一样的。</p>\n<h2 id=\"_4-abstractstringbuffer类\"> 4.AbstractStringBuffer类</h2>\n<p>前一篇查看了String类的源码，发现String类中有不少地方使用了StringBuffer和StringBuilder类，而这两个类都是继承自AbstractStringBuilder类，里面的很多实现都是直接使用父类的，所以就看一下AbstractStringBuilder类的源码。</p>\n<h3 id=\"类的申明\"> 类的申明：</h3>\n<div><pre><code><span>abstract</span> <span>class</span> <span>AbstractStringBuilder</span> <span>implements</span> <span>Appendable</span><span>,</span> <span>CharSequence</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>1.默认访问控制修饰符，说明只能在包内使用，即只能在JDK内部使用，可能有人会问我创建一个java.lang包然后里面的类就可以使用AbstractStringBuilder类了，想法不错，但jkd不允许，会报SecurityException : Prohibited package name: java.lang。故这个类只是给StringBuffer和StringBuilder类使用的。\n2.类名用abstract修饰说明是一个抽象类，只能被继承，不能直接创建对象。查了里面的方法你会发现它就一个抽象方法，toString方法。\n3.实现了Appendable接口，Appendable能够被追加 char 序列和值的对象。如果某个类的实例打算接收来自 Formatter 的格式化输出，那么该类必须实现 Appendable 接口。\n4.实现了Charsequence接口，代表该类，或其子类是一个字符序列。</p>\n<h3 id=\"成员变量-2\"> 成员变量：</h3>\n<div><pre><code><span><span>char</span><span>[</span><span>]</span></span> <span>value</span><span>;</span>\n<span><span>int</span></span> count<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>value用于承装字符序列，count数组中实际存储字符的数量。这里的value同String类中的value不同，String类中的value是final的不可被修改，这里的value是动态的，并且可提供给外部直接操作。</p>\n<h3 id=\"构造函数\"> 构造函数：</h3>\n<div><pre><code><span>AbstractStringBuilder</span><span>(</span><span>)</span> <span>{</span>\n<span>}</span>\n<span>AbstractStringBuilder</span><span>(</span><span><span>int</span></span> capacity<span>)</span> <span>{</span>\n    <span>value</span> <span>=</span> <span>new</span> <span><span>char</span></span><span>[</span>capacity<span>]</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>AbstractStringBuilder提供两个构造函数，一个是无参构造函数。一个是传一个capacity(代表数组容量)的构造，这个构造函数用于指定类中value数组的初始大小，数组大小后面还可动态改变。</p>\n<h3 id=\"其它方法-2\"> 其它方法：</h3>\n<h4 id=\"length-2\"> length:</h4>\n<div><pre><code><span>public</span> <span>int</span> <span>length</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> count<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>返回已经存储字符序列的实际长度，即count的值。</p>\n<h4 id=\"capacity\"> capacity:</h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>capacity</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>value</span><span>.</span>length<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>返回当前value可以存储的字符容量，即在下一次重新申请内存之前能存储字符序列的长度。新添加元素的时候，可能会对数组进行扩容。</p>\n<h4 id=\"ensurecapacity\"> ensureCapacity：</h4>\n<div><pre><code><span>public</span> <span>void</span> <span>ensureCapacity</span><span>(</span><span>int</span> minimumCapacity<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>minimumCapacity <span>></span> <span>0</span><span>)</span>\n        <span>ensureCapacityInternal</span><span>(</span>minimumCapacity<span>)</span><span>;</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>该方法是用来确保容量至少等于指定的最小值,是该类的核心也是其两个实现类StringBuffer和StringBuilder的核心。通过这种方式来实现数组的动态扩容。下面来看下其具体逻辑。\n1.判断入参minimumCapacity是否有效，即是否大于0，大于0执行ensureCapacityInternal方法，小于等于0则忽略。</p>\n<div><pre><code><span>private</span> <span><span>void</span></span> <span>ensureCapacityInternal</span><span>(</span><span><span>int</span></span> minimumCapacity<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>minimumCapacity <span>-</span> <span>value</span><span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>\n        <span>value</span> <span>=</span> Arrays<span>.</span><span>copyOf</span><span>(</span><span>value</span><span>,</span>\n                              <span>newCapacity</span><span>(</span>minimumCapacity<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>2.判断入参容量值是否比原容量大，如果大于原容量，执行扩容操作,实际上就是创建一个新容量的数组，然后再将原数组中的内容拷贝到新数组中，如果小于或等于原容量则忽略。</p>\n<div><pre><code><span>private</span> <span>static</span> final <span><span>int</span></span> MAX_ARRAY_SIZE <span>=</span> Integer<span>.</span>MAX_VALUE <span>-</span> <span>8</span><span>;</span>    \n<span>private</span> <span><span>int</span></span> <span>newCapacity</span><span>(</span><span><span>int</span></span> minCapacity<span>)</span> <span>{</span>\n    <span>// overflow-conscious code</span>\n    <span><span>int</span></span> newCapacity <span>=</span> <span>(</span><span>value</span><span>.</span>length <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>+</span> <span>2</span><span>;</span>\n    <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n        newCapacity <span>=</span> minCapacity<span>;</span>\n    <span>}</span>\n    <span>return</span> <span>(</span>newCapacity <span>&lt;=</span> <span>0</span> <span>||</span> MAX_ARRAY_SIZE <span>-</span> newCapacity <span>&lt;</span> <span>0</span><span>)</span>\n        <span>?</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span>\n        <span>:</span> newCapacity<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>3.计算新数组的容量大小，新容量取原容量的2倍加2和入参minCapacity中较大者。然后再进行一些范围校验。新容量必需在int所支持的范围内，之所以有&lt;=0判断是因为，在执行 (value.length &lt;&lt; 1) + 2操作后，可能会出现int溢出的情况。如果溢出或是大于所支持的最大容量(MAX_ARRAY_SIZE为int所支持的最大值减8)，则进行hugeCapacity计算，否则取newCapacity</p>\n<div><pre><code><span>private</span> <span>int</span> <span>hugeCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>Integer<span>.</span>MAX_VALUE <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>{</span> <span>// overflow</span>\n        <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>(</span>minCapacity <span>></span> MAX_ARRAY_SIZE<span>)</span>\n        <span>?</span> minCapacity <span>:</span> MAX_ARRAY_SIZE<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>4.这一步先进行范围检查，必须在int所支持的最大范围内。然后在minCapacity与MAX_ARRAY_SIZE之间取较大者，此方法取的范围是Integer.MAX_VALUE - 8到Integer.MAX_VALUE之间的范围。\n5.总结：\n1.通过value = Arrays.copyOf(value,newCapacity(minimumCapacity));进行扩容\n2.新容量取 minCapacity，原容量乘以2再加上2中较大的，但不能大于int所支持的最大范围。\n3.在实际环境中在容量远没达到MAX_ARRAY_SIZE的时候就报OutOfMemoryError异常了，其实就是在复制的时候创建了数组char[] copy = new char[newLength];这里支持不了那么大的内存消耗，可以通过 -Xms256M -Xmx768M设置最大内存。</p>\n<h4 id=\"trimtosize\"> trimToSize:</h4>\n<div><pre><code><span>public</span> <span><span>void</span></span> <span>trimToSize</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>count <span>&lt;</span> <span>value</span><span>.</span>length<span>)</span> <span>{</span>\n        <span>value</span> <span>=</span> Arrays<span>.</span><span>copyOf</span><span>(</span><span>value</span><span>,</span> count<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>减少字符序列的使用空间，比如申请了100字符长度的空间，但是现在只用了60个，那剩下的40个无用的空间放在那里占内存，可以调用此方法释放掉未用到的内存。原理很简单，只申请一个count大小的数组把原数组中的内容复制到新数组中，原来的数组由于没有被任何引用所指向，之后会被gc回收。</p>\n<h4 id=\"setlength\"> setLength:</h4>\n<div><pre><code><span>public</span> <span><span>void</span></span> <span>setLength</span><span>(</span><span><span>int</span></span> newLength<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>newLength <span>&lt;</span> <span>0</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>newLength<span>)</span><span>;</span>\n    <span>ensureCapacityInternal</span><span>(</span>newLength<span>)</span><span>;</span>\n\n    <span>if</span> <span>(</span>count <span>&lt;</span> newLength<span>)</span> <span>{</span>\n        Arrays<span>.</span><span>fill</span><span>(</span><span>value</span><span>,</span> count<span>,</span> newLength<span>,</span> <span>'\\0'</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    count <span>=</span> newLength<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>用空字符填充未使用的空间。首先对数组进行扩容，然后将剩余未使用的空间全部填充为'0'字符。</p>\n<h4 id=\"charat-2\"> charAt:</h4>\n<div><pre><code><span>public</span> <span><span>char</span></span> <span>charAt</span><span>(</span><span><span>int</span></span> index<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>(</span>index <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>index <span>>=</span> count<span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n    <span>return</span> <span>value</span><span>[</span>index<span>]</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>获取字符序列中指定位置的字符，范围为0到count，超出范围抛StringIndexOutOfBoundsException异常。</p>\n<h4 id=\"codepointat-2\"> codePointAt:</h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>codePointAt</span><span>(</span><span><span>int</span></span> index<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>(</span>index <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>index <span>>=</span> count<span>)</span><span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> Character<span>.</span><span>codePointAtImpl</span><span>(</span><span>value</span><span>,</span> index<span>,</span> count<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>获取字符序列中指定位置的字符，所对应的代码点，即ascii码。</p>\n<h4 id=\"codepointbefore-2\"> codePointBefore:</h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>codePointBefore</span><span>(</span><span><span>int</span></span> index<span>)</span> <span>{</span>\n    <span><span>int</span></span> i <span>=</span> index <span>-</span> <span>1</span><span>;</span>\n    <span>if</span> <span>(</span><span>(</span>i <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>i <span>>=</span> count<span>)</span><span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> Character<span>.</span><span>codePointBeforeImpl</span><span>(</span><span>value</span><span>,</span> index<span>,</span> <span>0</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>获取字符序列中指定位置的前一个位置的字符，所对应的代码点。</p>\n<h4 id=\"codepointcount-2\"> codePointCount:</h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>codePointCount</span><span>(</span><span><span>int</span></span> beginIndex<span>,</span> <span><span>int</span></span> endIndex<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>beginIndex <span>&lt;</span> <span>0</span> <span>||</span> endIndex <span>></span> count <span>||</span> beginIndex <span>></span> endIndex<span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> Character<span>.</span><span>codePointCountImpl</span><span>(</span><span>value</span><span>,</span> beginIndex<span>,</span> endIndex<span>-</span>beginIndex<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>获取字符串代码点个数，是实际上的字符个数。不清楚代码点可查看<a href=\"https://www.jianshu.com/p/c3a94294056a\" target=\"_blank\" rel=\"noopener noreferrer\">java中代码点与代码单元的区别</a>。</p>\n<h4 id=\"-2\"> </h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>offsetByCodePoints</span><span>(</span><span><span>int</span></span> index<span>,</span> <span><span>int</span></span> codePointOffset<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>index <span>&lt;</span> <span>0</span> <span>||</span> index <span>></span> <span>value</span><span>.</span>length<span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> Character<span>.</span><span>offsetByCodePointsImpl</span><span>(</span><span>value</span><span>,</span> <span>0</span><span>,</span> <span>value</span><span>.</span>length<span>,</span>\n                                            index<span>,</span> codePointOffset<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>返回此字符序列中从给定的index处偏移codePointOffset个代码点的索引。不清楚代码点的可以查看<a href=\"https://www.jianshu.com/p/c3a94294056a\" target=\"_blank\" rel=\"noopener noreferrer\">java中代码点与代码单元的区别</a>。</p>\n<h4 id=\"getchars\"> getChars:</h4>\n<div><pre><code><span>public</span> <span><span>void</span></span> <span>getChars</span><span>(</span><span><span>int</span></span> srcBegin<span>,</span> <span><span>int</span></span> srcEnd<span>,</span> <span><span>char</span><span>[</span><span>]</span></span> dst<span>,</span> <span><span>int</span></span> dstBegin<span>)</span>\n<span>{</span>\n    <span>if</span> <span>(</span>srcBegin <span>&lt;</span> <span>0</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>srcBegin<span>)</span><span>;</span>\n    <span>if</span> <span>(</span><span>(</span>srcEnd <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>srcEnd <span>></span> count<span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>srcEnd<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>srcBegin <span>></span> srcEnd<span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span><span>\"srcBegin > srcEnd\"</span><span>)</span><span>;</span>\n    System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> srcBegin<span>,</span> dst<span>,</span> dstBegin<span>,</span> srcEnd <span>-</span> srcBegin<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>将字符序列中指定区间srcBegin到srcEnd内的字符拷贝到dst字符数组中从dstBegin开始往后的位置中。</p>\n<h4 id=\"setcharat\"> setCharAt:</h4>\n<div><pre><code><span>public</span> <span><span>void</span></span> <span>setCharAt</span><span>(</span><span><span>int</span></span> index<span>,</span> <span><span>char</span></span> ch<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>(</span>index <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>index <span>>=</span> count<span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n    <span>value</span><span>[</span>index<span>]</span> <span>=</span> ch<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>设置字符序列中指定索引index位置的字符为ch。</p>\n<h4 id=\"append系列\"> append系列：</h4>\n<div><pre><code><span>public</span> <span>AbstractStringBuilder</span> <span>append</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>str <span>==</span> <span>null</span><span>)</span>\n        <span>return</span> <span>appendNull</span><span>(</span><span>)</span><span>;</span>\n    <span><span>int</span></span> len <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n    <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> len<span>)</span><span>;</span>\n    str<span>.</span><span>getChars</span><span>(</span><span>0</span><span>,</span> len<span>,</span> <span>value</span><span>,</span> count<span>)</span><span>;</span>\n    count <span>+=</span> len<span>;</span>\n    <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>AbstractStringBuilder类中有一系列append方法，作用是在原字符序列后添加给定的对象或元素所对应的字符序列。这里挑一个代表讲解，其它方法原理类似。\n1.首先判断所传参数是否为null，如果为null则调用appendNull方法，实际上就是在原字符序列后加上&quot;null&quot;序列。\n2如果不为null则进行扩容操作，最小值为count+len，这一步可能增加容量也可能不增加，当count+len小于或等于capacity就不用进行扩容。\n3.然后再将参数的字符串序列添加到value中。\n4.最后返回this,注意这里返回的是this，也就意味者，可以在一条语句中多次调用append方法，即大家所知的方法调用链。原理简单，但思想值得借鉴。asb.append(&quot;hello&quot;).append(&quot;world&quot;);</p>\n<h4 id=\"appendcodepoint\"> appendCodePoint:</h4>\n<div><pre><code><span>public</span> <span>AbstractStringBuilder</span> <span>appendCodePoint</span><span>(</span><span><span>int</span></span> codePoint<span>)</span> <span>{</span>\n    final <span><span>int</span></span> count <span>=</span> <span>this</span><span>.</span>count<span>;</span>\n\n    <span>if</span> <span>(</span>Character<span>.</span><span>isBmpCodePoint</span><span>(</span>codePoint<span>)</span><span>)</span> <span>{</span>\n        <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>;</span>\n        <span>value</span><span>[</span>count<span>]</span> <span>=</span> <span>(</span><span>char</span><span>)</span> codePoint<span>;</span>\n        <span>this</span><span>.</span>count <span>=</span> count <span>+</span> <span>1</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>Character<span>.</span><span>isValidCodePoint</span><span>(</span>codePoint<span>)</span><span>)</span> <span>{</span>\n        <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> <span>2</span><span>)</span><span>;</span>\n        Character<span>.</span><span>toSurrogates</span><span>(</span>codePoint<span>,</span> <span>value</span><span>,</span> count<span>)</span><span>;</span>\n        <span>this</span><span>.</span>count <span>=</span> count <span>+</span> <span>2</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>添加代码点，将入参转换为对应的代码点后，添加到原字符序列结尾。不清楚代码点的可以查看<a href=\"https://www.jianshu.com/p/c3a94294056a\" target=\"_blank\" rel=\"noopener noreferrer\">java中代码点与代码单元的区别</a>。</p>\n<h4 id=\"delete\"> delete:</h4>\n<div><pre><code><span>public</span> <span>AbstractStringBuilder</span> <span>delete</span><span>(</span><span><span>int</span></span> start<span>,</span> <span><span>int</span></span> end<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>start <span>&lt;</span> <span>0</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>start<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>end <span>></span> count<span>)</span>\n        end <span>=</span> count<span>;</span>\n    <span>if</span> <span>(</span>start <span>></span> end<span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span><span>)</span><span>;</span>\n    <span><span>int</span></span> len <span>=</span> end <span>-</span> start<span>;</span>\n    <span>if</span> <span>(</span>len <span>></span> <span>0</span><span>)</span> <span>{</span>\n        System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> start<span>+</span>len<span>,</span> <span>value</span><span>,</span> start<span>,</span> count<span>-</span>end<span>)</span><span>;</span>\n        count <span>-=</span> len<span>;</span>\n    <span>}</span>\n    <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>删除字符序列指定区间的内容。这个操作不改变原序列的容量。</p>\n<h4 id=\"deletecharat\"> deleteCharAt:</h4>\n<div><pre><code><span>public</span> <span>AbstractStringBuilder</span> <span>deleteCharAt</span><span>(</span><span><span>int</span></span> index<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>(</span>index <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>index <span>>=</span> count<span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>\n    System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> index<span>+</span><span>1</span><span>,</span> <span>value</span><span>,</span> index<span>,</span> count<span>-</span>index<span>-</span><span>1</span><span>)</span><span>;</span>\n    count<span>--</span><span>;</span>\n    <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>删除字符序列中指定索引index位置的字符。</p>\n<h4 id=\"replace\"> replace:</h4>\n<div><pre><code><span>public</span> <span>AbstractStringBuilder</span> <span>replace</span><span>(</span><span><span>int</span></span> start<span>,</span> <span><span>int</span></span> end<span>,</span> <span>String</span> str<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>start <span>&lt;</span> <span>0</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>start<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>start <span>></span> count<span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span><span>\"start > length()\"</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>start <span>></span> end<span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span><span>\"start > end\"</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>end <span>></span> count<span>)</span>\n        end <span>=</span> count<span>;</span>\n    <span><span>int</span></span> len <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n    <span><span>int</span></span> newCount <span>=</span> count <span>+</span> len <span>-</span> <span>(</span>end <span>-</span> start<span>)</span><span>;</span>\n    <span>ensureCapacityInternal</span><span>(</span>newCount<span>)</span><span>;</span>\n    System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> end<span>,</span> <span>value</span><span>,</span> start <span>+</span> len<span>,</span> count <span>-</span> end<span>)</span><span>;</span>\n    str<span>.</span><span>getChars</span><span>(</span><span>value</span><span>,</span> start<span>)</span><span>;</span>\n    count <span>=</span> newCount<span>;</span>\n    <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>将原字符序列指定区间start到end区间内的内容替换为str,替换过程中序列长度会改变，所以需要进行扩容和改就count的操作。</p>\n<h4 id=\"substring\"> substring:</h4>\n<div><pre><code><span>public</span> <span>String</span> <span>substring</span><span>(</span><span><span>int</span></span> start<span>)</span> <span>{</span>\n    <span>return</span> <span>substring</span><span>(</span>start<span>,</span> count<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>String</span> <span>substring</span><span>(</span><span><span>int</span></span> start<span>,</span> <span><span>int</span></span> end<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>start <span>&lt;</span> <span>0</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>start<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>end <span>></span> count<span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>end<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>start <span>></span> end<span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>end <span>-</span> start<span>)</span><span>;</span>\n    <span>return</span> <span>new</span> <span>String</span><span>(</span><span>value</span><span>,</span> start<span>,</span> end <span>-</span> start<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>切割原字符序列指定区间start到end内的内容，返回字符串形式。</p>\n<h4 id=\"insert系列\"> insert系列:</h4>\n<div><pre><code><span>public</span> <span>AbstractStringBuilder</span> <span>insert</span><span>(</span><span><span>int</span></span> offset<span>,</span> <span>String</span> str<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>(</span>offset <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span>offset <span>></span> <span>length</span><span>(</span><span>)</span><span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>StringIndexOutOfBoundsException</span><span>(</span>offset<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>str <span>==</span> <span>null</span><span>)</span>\n        str <span>=</span> <span>\"null\"</span><span>;</span>\n    <span><span>int</span></span> len <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n    <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> len<span>)</span><span>;</span>\n    System<span>.</span><span>arraycopy</span><span>(</span><span>value</span><span>,</span> offset<span>,</span> <span>value</span><span>,</span> offset <span>+</span> len<span>,</span> count <span>-</span> offset<span>)</span><span>;</span>\n    str<span>.</span><span>getChars</span><span>(</span><span>value</span><span>,</span> offset<span>)</span><span>;</span>\n    count <span>+=</span> len<span>;</span>\n    <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>insert系列作用是将给定定对象所对应的字符串插入到原序列的指定位置。insert系列同append系列类似，只不过append是在原序列末尾添加元素，insert是在指定位置插入元素。这里也选一个代表进行讲解。\n假设原字符序列为&quot;hello&quot;现调用insert(int 1, “aa&quot;);\n1.对待插入的位置offset进行检查，必须在容量内\n2.如果传入对象为null则插入&quot;null&quot;字符串\n3.对value数组进行扩容\n4.通过System.arraycopy对数组进行复制\narraycopy(Object src,int srcPos,Object dest,int destPos,int length);\nsrc:源数组； ['h','e','l','l','o','o']\nsrcPos:源数组要复制的起始位置；1\ndest:目的数组； ['h','e','l','l','o','w']\ndestPos:目的数组放置的起始位置； 1+2=3\nlength:复制的长度。 6-1=5\n则执行完这句后value中的内容为['h','e','l','e','l','l','o','o']\n可以看到是将位置1到结尾的内容后移了两个长度，因为需要插入的字符串&quot;bb&quot;的长度为2\n5.将str的内容复制到value中\nstr.getChars(value, offset);//将str的内容复制到value中从offset 1位置开始复制\n复制完成后['h','b','b','e','l','l','o','o'],即我们最终想要达到的效果&quot;hbbellow&quot;</p>\n<h4 id=\"indexof\"> indexOf:</h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>indexOf</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>\n    <span>return</span> <span>indexOf</span><span>(</span>str<span>,</span> <span>0</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span><span>int</span></span> <span>indexOf</span><span>(</span><span>String</span> str<span>,</span> <span><span>int</span></span> fromIndex<span>)</span> <span>{</span>\n    <span>return</span> String<span>.</span><span>indexOf</span><span>(</span><span>value</span><span>,</span> <span>0</span><span>,</span> count<span>,</span> str<span>,</span> fromIndex<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>查询给定字符串在原字符序列中第一次出现的位置。调用的其实是String类的indexOf方法，具体可查看<a href=\"https://www.jianshu.com/p/b3e9deacd155\" target=\"_blank\" rel=\"noopener noreferrer\">一起学JDK源码 -- String类</a></p>\n<h4 id=\"reverse\"> reverse:</h4>\n<div><pre><code><span>public</span> <span>AbstractStringBuilder</span> <span>reverse</span><span>(</span><span>)</span> <span>{</span>\n    <span>boolean</span> hasSurrogates <span>=</span> <span>false</span><span>;</span>\n    <span><span>int</span></span> n <span>=</span> count <span>-</span> <span>1</span><span>;</span>\n    <span>for</span> <span>(</span><span><span>int</span></span> j <span>=</span> <span>(</span>n<span>-</span><span>1</span><span>)</span> <span>>></span> <span>1</span><span>;</span> j <span>>=</span> <span>0</span><span>;</span> j<span>--</span><span>)</span> <span>{</span>\n        <span><span>int</span></span> k <span>=</span> n <span>-</span> j<span>;</span>\n        <span><span>char</span></span> cj <span>=</span> <span>value</span><span>[</span>j<span>]</span><span>;</span>\n        <span><span>char</span></span> ck <span>=</span> <span>value</span><span>[</span>k<span>]</span><span>;</span>\n        <span>value</span><span>[</span>j<span>]</span> <span>=</span> ck<span>;</span>\n        <span>value</span><span>[</span>k<span>]</span> <span>=</span> cj<span>;</span>\n        <span>if</span> <span>(</span>Character<span>.</span><span>isSurrogate</span><span>(</span>cj<span>)</span> <span>||</span>\n            Character<span>.</span><span>isSurrogate</span><span>(</span>ck<span>)</span><span>)</span> <span>{</span>\n            hasSurrogates <span>=</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>if</span> <span>(</span>hasSurrogates<span>)</span> <span>{</span>\n        <span>reverseAllValidSurrogatePairs</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>该方法用于将字符序列反转，如&quot;hellow&quot;执行reverse后变成&quot;wolleh&quot;。\n1.hasSurrogates用于判断字符序列中是否包含surrogates pair\n2.将字符反转,count为数组长度，因为是从0开始的所以这里需要减1。具体转换是第一个字符与最后一个字符对调，第二个字符与倒数第二个字符对调，依次类推\n3.实际上上述操作只需要循环(n-1) /2 + 1次[判断条件j&gt;=0所以要+1次,源码中&gt;&gt;1就是除以2]就可以了，如数组长度为9则需要循环 (9-1-1)/2 +1 = 4次,9个字符对调次，第5个位置的字符不用换，如果长度为10需要循环(10-1-1)/2 +1 = 5次\n4.剩下的工作就是两个位置的元素互换。\n5.如果序列中包含surrogates pair 则执行reverseAllValidSurrogatePairs方法</p>\n<h4 id=\"reverseallvalidsurrogatepairs\"> reverseAllValidSurrogatePairs:</h4>\n<div><pre><code><span>private</span> <span><span>void</span></span> <span>reverseAllValidSurrogatePairs</span><span>(</span><span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span><span>int</span></span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> count <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span><span>char</span></span> c2 <span>=</span> <span>value</span><span>[</span>i<span>]</span><span>;</span>\n        <span>if</span> <span>(</span>Character<span>.</span><span>isLowSurrogate</span><span>(</span>c2<span>)</span><span>)</span> <span>{</span>\n            <span><span>char</span></span> c1 <span>=</span> <span>value</span><span>[</span>i <span>+</span> <span>1</span><span>]</span><span>;</span>\n            <span>if</span> <span>(</span>Character<span>.</span><span>isHighSurrogate</span><span>(</span>c1<span>)</span><span>)</span> <span>{</span>\n                <span>value</span><span>[</span>i<span>++</span><span>]</span> <span>=</span> c1<span>;</span>\n                <span>value</span><span>[</span>i<span>]</span> <span>=</span> c2<span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>Surrogate Pair是UTF-16中用于扩展字符而使用的编码方式，是一种采用四个字节(两个UTF-16编码)来表示一个字符。\nchar在java中是16位的，刚好是一个UTF-16编码。而字符串中可能含有Surrogate Pair,但他们是一个单一完整的字符，只不过是用两个char来表示而已，因此在反转字符串的过程中Surrogate Pairs 是不应该被反转的。而reverseAllValidSurrogatePairs方法就是对Surrogate Pair进行处理。</p>\n<h4 id=\"tostring-2\"> toString:</h4>\n<div><pre><code><span>public</span> <span>abstract</span> <span>String</span> <span>toString</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>这是这个抽象类中唯一的一个抽象方法，需要子类去实现。</p>\n<h2 id=\"_5-number类\"> 5.Number类</h2>\n<p>java是强类型语言，它提供了八种基本数据类型，  其中有六种数字类型，分别是byte、short、int、long、float、double。看源码我们自然看不到这些类型的源码，我们要看的是这些类型的包装类的源码。今天我们就看看这些类型的包装类的共同的祖先Number类的源码。</p>\n<p>包装类：java是一个面向对象的语言，但java的基本数据类型却不是面向对象的，这在实际的使用中会有诸多不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表。这八个和基本类型对应的类统称为包装类。</p>\n<h4 id=\"number抽象类中的方法\"> Number抽象类中的方法:</h4>\n<div><pre><code><span>public</span> <span>abstract</span> <span><span>int</span></span> <span>intValue</span><span>(</span><span>)</span><span>;</span>\n\n<span>public</span> <span>abstract</span> <span><span>long</span></span> <span>longValue</span><span>(</span><span>)</span><span>;</span>\n\n<span>public</span> <span>abstract</span> <span><span>float</span></span> <span>floatValue</span><span>(</span><span>)</span><span>;</span>\n\n<span>public</span> <span>abstract</span> <span><span>double</span></span> <span>doubleValue</span><span>(</span><span>)</span><span>;</span>\n\n<span>public</span> <span><span>byte</span></span> <span>byteValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>byte</span><span>)</span><span>intValue</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span><span>short</span></span> <span>shortValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>short</span><span>)</span><span>intValue</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>可以看到这些方法都是xxxValue，目的就是将数据转换为相对应的类型，如intValue就是将数据转换为int类型，byteValue就是将数据转换为byte类型，这点从返回值我们也可以看出来</p>\n<h4 id=\"思考\"> 思考：</h4>\n<p>1.byte、short、int、long、float、double都是数字类型，java为什么要搞出这么多的数字类型出来。\n2.Number是这些类型的父类，既然他们的范围不一样，那么转换时会不会出问题\n答1：因为它们的长度各不相同，使用它们是系统开销也不相同。它们有不同的特点，适用于不同的地方。我们可以根据不同的需要，而选择类型。\n答2：转换时当然会出问题，比如int类型的129你将它转换为byte时就会越界，得到的结果是-127。其它的大类型转换为小类型的时候也会有同样的问题，所以使用的时候要格外小心。</p>\n<h2 id=\"_6-byte类\"> 6.Byte类</h2>\n<p>byte即字节的意思，java中的基本类型之一、也是java中长度最小的基本数字类型，通常在读取文件时需要用字节数组来保存文件内容。byte数组也常被用作缓冲器，接收文件内容。不管是读还是写文件都会用到。接下来就让我们看看byte类型的包装类Byte类的实现。</p>\n<h4 id=\"基础知识-2\"> 基础知识：</h4>\n<p>1.java的基本数据类型byte、short、int、long、float、double、char所占的字节长度分别为1、2、4、8、4、8、2。至于boolean所占的长度众说纷纭，有人说boolean只有真和假，只用一位存储就够了。实际上存储空间的基本计量单位是字节，不是位。所以boolean至少占一个字节。JVM规范中，boolean变量作为int处理，也就是4字节；boolean数组当做byte数组处理。\n2.java中字节容量的关系:\n1TB=1024GB      TB是千千兆\n1GB=1024MB      GB是千兆\n1MB=1024KB      MB是兆\n1KB=1024Byte    KB是千字节\n1Byte = 8bit        一个字节是8位\n3.byte与bit的关系:\n我们上面所说的字节也就是byte,是计算机文件大小的基本单位，而bit是Binary digit（二进制数位）的缩写,意为“位”或“比特”，是计算机运算的基础，计算机存储数据都是0和1组成的，每个0或1也就是占这里的1位，即一个bit.\n4.源码、反码、补码:\n在计算机内，定点数有3种表示法：原码、反码和补码\n原码：就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。\n反码：表示法规定：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。\n补码：表示法规定：正数的补码与其原码相同；负数的补码是在其反码的末位加1。\nJAVA中用补码表示二进制数.\n5.位运算\njava中的位运算包括&quot;或&quot;(|)、&quot;与&quot;(&amp;)、&quot;非&quot;(~)、&quot;异或&quot;(^)\n| : 两个操作数的位中，有一个为1，结果才为1，否则结果为0\n&amp; ：两个操作数的位中，全为1，结果才为1，否则结果为0\n~ : 如果位为0，结果是1，如果位为1，结果是0\n^ : 两个操作数的位中，相同则结果为0，不同则结果为1\n上述操作数的位表示的是把目标数据转换为二进制后的每一位，举个栗子：7 &amp; 10\n7转换为二进制后:                        0    1   1   1\n&amp;\n10转换为二进制后：                   1    0   1   0\n上下按&amp;的规则计算结果为          0   0    1   0\n即7&amp;10 = 2 ，其它的位运算操作类似</p>\n<h4 id=\"byte类\"> Byte类:</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Byte</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Byte</span><span>></span></span> <span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到Byte类继承了Number类，而又不是抽象类，自然要重写Number类中的xxxValue方法。另外Byte类实现了Comparable接口，Comparable是一个接口，该接口定义类的自然顺序,实现该接口的类就可以按这种方式排序，一般情况下如果某类对象自身具有比较的特性就可以实现该接口，比如这里的Byte代表的是一种数，而数本身就具有比较的特性，就可以实现该接口。</p>\n<h4 id=\"边界值\"> 边界值:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>byte</span>   MIN_VALUE <span>=</span> <span>-</span><span>128</span><span>;</span>\n<span>public</span> <span>static</span> <span>final</span> <span>byte</span>   MAX_VALUE <span>=</span> <span>127</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>诶，为什么最大值是127，最小值是-128.在基础知识中介绍了，java中用补码表示二进制。byte为1个字节，即8位。最高位是符号位。最大值是01111111，因正数的补码是其本身，即最大值的补码是01111111，最大值的原码也是01111111，所以，此正数为01111111即用十进制表示形式为127。最小值是10000000，由于是补码需要转换成原码，因此先减去1即01111111，然后取反10000000，这就是原码，原码就是10000000，这就是最小值的绝对值，即2^7=128，那么，最小值就是-128</p>\n<p>TYPE:</p>\n<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>Class</span><span><span>&lt;</span><span>Byte</span><span>></span></span>     TYPE <span>=</span> <span>(</span><span>Class</span><span><span>&lt;</span><span>Byte</span><span>></span></span><span>)</span> <span>Class</span><span>.</span><span>getPrimitiveClass</span><span>(</span><span>\"byte\"</span><span>)</span><span>;</span>\n其中<span>Class</span><span>.</span>getPrimitiveClass的源码为<span>:</span>\n<span>static</span> <span>native</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getPrimitiveClass</span><span>(</span><span>String</span> name<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个TYPE表示的是基本类型 byte 的 Class 实例，即byte.class</p>\n<h4 id=\"tostring-byte-b\"> toString(byte b):</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>toString</span><span>(</span><span><span>byte</span></span> b<span>)</span> <span>{</span>\n    <span>return</span> Integer<span>.</span><span>toString</span><span>(</span><span>(</span><span>int</span><span>)</span>b<span>,</span> <span>10</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意这里的toString可不是重写的Object类中的toString方法，Object中的toString方法是没有参数的，方法重写必须和父类中的方法一模一样。这里是将byte数据转换为对应的字符串形式，它调用了Integer.toString(int i, int radix)方法,这个方法等我们看<a href=\"https://www.jianshu.com/p/e07d126ac1d0\" target=\"_blank\" rel=\"noopener noreferrer\">Integer类的源码</a>时再讲解。</p>\n<h4 id=\"bytecache\"> ByteCache：</h4>\n<div><pre><code><span>private</span> <span>static</span> <span>class</span> <span>ByteCache</span> <span>{</span>\n        <span>private</span> <span>ByteCache</span><span>(</span><span>)</span><span>{</span><span>}</span>\n\n        <span>static</span> <span>final</span> <span>Byte</span> cache<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>Byte</span><span>[</span><span>-</span><span>(</span><span>-</span><span>128</span><span>)</span> <span>+</span> <span>127</span> <span>+</span> <span>1</span><span>]</span><span>;</span>\n\n        <span>static</span> <span>{</span>\n            <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cache<span>.</span>length<span>;</span> i<span>++</span><span>)</span>\n                cache<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Byte</span><span>(</span><span>(</span><span>byte</span><span>)</span><span>(</span>i <span>-</span> <span>128</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这是Byte的一个内部类，而且是私有的，只能在本类中调用。可以看到在这个类的内部定义了一个Byte类型的数组，数组的长度刚好是Byte类中最小值到最大值之间的长度(负数128个，正数127个加上0共256个)。在静态代码块中创建了这256个对象放到cache数组中，之前也介绍了静态代码块在类一加载的时候就会执行。这里是将byte类型所有的可能值(对于byte来说其实它的可能值就是从-128到127，一共256个)缓存起来，只能创建256个Byte对象就可以表示所有可能的byte。而且这些都是静态且final的，避免重复的实例化和回收。</p>\n<h4 id=\"valueof-byte-b\"> valueOf(byte b):</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>Byte</span> <span>valueOf</span><span>(</span><span>byte</span> b<span>)</span> <span>{</span>\n        <span>final</span> <span>int</span> offset <span>=</span> <span>128</span><span>;</span>\n        <span>return</span> <span>ByteCache</span><span>.</span>cache<span>[</span><span>(</span><span>int</span><span>)</span>b <span>+</span> offset<span>]</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这里的valueOf其实就是从上述缓存数组中取得对应的byte对象。因为数组下标是从0开始的不包含负数，所以这里会加上一个offset来取得数组对应位置的元素值</p>\n<h4 id=\"parsebyte-string-s-int-radix\"> parseByte(String s, int radix):</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>byte</span> <span>parseByte</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> radix<span>)</span>\n        <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>int</span> i <span>=</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>s<span>,</span> radix<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>&lt;</span> MIN_VALUE <span>||</span> i <span>></span> MAX_VALUE<span>)</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span>\n                <span>\"Value out of range. Value:\\\"\"</span> <span>+</span> s <span>+</span> <span>\"\\\" Radix:\"</span> <span>+</span> radix<span>)</span><span>;</span>\n        <span>return</span> <span>(</span><span>byte</span><span>)</span>i<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这个方法从方法名也可以看出来其作用，就是将一个字符串为byte，首先它调用了 Integer.parseInt(s, radix)将目标字符串转换为int值(对于这个方法我们看<a href=\"https://www.jianshu.com/p/e07d126ac1d0\" target=\"_blank\" rel=\"noopener noreferrer\">Integer类的源码</a>时再讲)，然后判断转换后的值是否在byte类型的数值范围内，如果是就返回，否就抛出一个异常。其中s就是要转换的目标字符串，radix就是目标字符串的进制表示法，常用的有2进制、8进制、10进制和16进制。</p>\n<h4 id=\"parsebyte-string-s\"> parseByte(String s)：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>byte</span> <span>parseByte</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>parseByte</span><span>(</span>s<span>,</span> <span>10</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>将10进制表示的字符串转换为byte数字。这个方法实际上是调用了上面的方法parseByte(String s, int radix)，只不过固定的转换的进制为10进制。</p>\n<p>valueOf(String s, int radix)和 valueOf(String s) ：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>Byte</span> <span>valueOf</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> radix<span>)</span>\n        <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>valueOf</span><span>(</span><span>parseByte</span><span>(</span>s<span>,</span> radix<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>static</span> <span>Byte</span> <span>valueOf</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>valueOf</span><span>(</span>s<span>,</span> <span>10</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>获取指定进制字符串，转换为byte后对应的Byte对象。在上面我们看了valueOf(byte b),获取byte数对应的Byte对应，这里无非是将传入的参数换成了字符串，在内部先将字符串转换为byte数然后再从缓存数组中获取对应的Byte对象。将字符串转换为byte数字和从缓存数组中取Byte对象在上面已经讲过了，这里就不再赘述了。</p>\n<h4 id=\"decode-string-nm\"> decode(String nm):</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>Byte</span> <span>decode</span><span>(</span><span>String</span> nm<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>int</span> i <span>=</span> <span>Integer</span><span>.</span><span>decode</span><span>(</span>nm<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>&lt;</span> MIN_VALUE <span>||</span> i <span>></span> MAX_VALUE<span>)</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span>\n                    <span>\"Value \"</span> <span>+</span> i <span>+</span> <span>\" out of range from input \"</span> <span>+</span> nm<span>)</span><span>;</span>\n        <span>return</span> <span>valueOf</span><span>(</span><span>(</span><span>byte</span><span>)</span>i<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>将其它进制表示法，表示的字符串数据转换为10进制表示的byte数据,然后返回对应的Byte对象。其中常用的&quot;其它&quot;进制表示法有16进制表示法(数字前加0x或#）、8进制表示法(在数字前面加0)、2进制表示法(用0和1表示数字)。具体怎么转换的要看Integer.decode(nm)的源码(对于这个方法我们看<a href=\"https://www.jianshu.com/p/e07d126ac1d0\" target=\"_blank\" rel=\"noopener noreferrer\">Integer类的源码</a>时再讲)。最后判断下转换后的数据是否在byte类型的数值范围内，然后调用valueOf(byte b)方法从缓存中获取Byte对象.</p>\n<h4 id=\"数据存放位置\"> 数据存放位置:</h4>\n<div><pre><code><span>private</span> final <span><span>byte</span></span> <span>value</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>既然Byte为byte类型的包装类，每个byte对应一个Byte对象那byte对应的值存放在什么位置呢，就存在于这里的value属性中。</p>\n<h4 id=\"构造器\"> 构造器:</h4>\n<div><pre><code><span>public</span> <span>Byte</span><span>(</span><span><span>byte</span></span> <span>value</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> <span>value</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>Byte</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> NumberFormatException <span>{</span>\n        <span>this</span><span>.</span><span>value</span> <span>=</span> <span>parseByte</span><span>(</span>s<span>,</span> <span>10</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>java中的构造器是用于创建对象和初始化对象中的属性用的。Byte类中提供了两个构造器，一个是通过传byte数据来构造对象，一个是通过传字符串数据来创建对象，可以看到最终都是将传入的数据赋值给了value，也就是上面讲的byte数据的存放位置。</p>\n<h4 id=\"取值\"> 取值：</h4>\n<div><pre><code><span>public</span> <span><span>byte</span></span> <span>byteValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>value</span><span>;</span>\n<span>}</span>\n<span>public</span> <span><span>short</span></span> <span>shortValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>short</span><span>)</span><span>value</span><span>;</span>\n<span>}</span>\n<span>public</span> <span><span>int</span></span> <span>intValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>int</span><span>)</span><span>value</span><span>;</span>\n<span>}</span>\n<span>public</span> <span><span>long</span></span> <span>longValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>long</span><span>)</span><span>value</span><span>;</span>\n<span>}</span>\n<span>public</span> <span><span>float</span></span> <span>floatValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>float</span><span>)</span><span>value</span><span>;</span>\n<span>}</span>\n<span>public</span> <span><span>double</span></span> <span>doubleValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>double</span><span>)</span><span>value</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>这里的xxxValue也就是重写了父类Number类中的xxxValue方法，可以看到这些方法用的都是java的强制类型转换机制，由于这些转换中byte的长度最小，所以不用考虑数据溢出的问题。</p>\n<h4 id=\"hashcode-2\"> hashCode:</h4>\n<div><pre><code>@Override\n<span>public</span> <span><span>int</span></span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> Byte<span>.</span><span>hashCode</span><span>(</span><span>value</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>static</span> <span><span>int</span></span> <span>hashCode</span><span>(</span><span><span>byte</span></span> <span>value</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>int</span><span>)</span><span>value</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这里是重写Object的hashCode方法，可以看到返回的就是Byte对象表示的数值。至于hashCode方法是什么意思在看<a href=\"https://www.jianshu.com/p/08c8890af5a0\" target=\"_blank\" rel=\"noopener noreferrer\">Object类</a>的源码时已经讲到了，如果忘记了可以再回去看一下。</p>\n<p>equals:</p>\n<div><pre><code><span>public</span> boolean <span>equals</span><span>(</span>Object obj<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>obj instanceof Byte<span>)</span> <span>{</span>\n            <span>return</span> value <span>==</span> <span>(</span><span>(</span>Byte<span>)</span>obj<span>)</span><span>.</span><span>byteValue</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>比较两个Byte对象是否是同一个对象，分为两步：第一步判断传入的对象是否是Byte类型，java中用instanceof判断对象是否是某个类型的对象。第二步判断两个对应的value值是否相等。如果这两个条件都满足那么这两个对象就是同一个对象。</p>\n<h4 id=\"compareto-2\"> compareTo</h4>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>compareTo</span><span>(</span><span>Byte</span> anotherByte<span>)</span> <span>{</span>\n    <span>return</span> <span>compare</span><span>(</span><span>this</span><span>.</span><span>value</span><span>,</span> anotherByte<span>.</span><span>value</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个方法是实现了Comparable接口中的抽象方法，该方法的作用在文章开始的时候已经讲解了。可以看到在方法内部调用了compare方法,这个方法的源码如下:</p>\n<div><pre><code><span>public</span> <span>static</span> <span><span>int</span></span> <span>compare</span><span>(</span><span><span>byte</span></span> x<span>,</span> <span><span>byte</span></span> y<span>)</span> <span>{</span>\n        <span>return</span> x <span>-</span> y<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到返回的是两个byte数据的差值，需要注意的一点是在compareTo的比较机制中如果返回值大于0表示前一个数据比后一个数据大，返回值等于 0表示两个数据相等，返回值小于0表示第一个数据小于第二个数据</p>\n<h4 id=\"tounsignedint-byte-x\"> toUnsignedInt(byte x)</h4>\n<div><pre><code><span>public</span> <span>static</span> <span><span>int</span></span> <span>toUnsignedInt</span><span>(</span><span><span>byte</span></span> x<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>(</span><span>int</span><span>)</span> x<span>)</span> <span>&amp;</span> <span>0xff</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个方法是jdk1.8之后新加的，作用是将byte数据转换为无符号的int数据。方法的实现很简单就是将目标值和0xff这个数做&amp;的运算。&amp;运算如果有不清楚的可以看下本章的基础知识。</p>\n<h4 id=\"tounsignedlong\"> toUnsignedLong</h4>\n<div><pre><code><span>public</span> <span>static</span> <span><span>long</span></span> <span>toUnsignedLong</span><span>(</span><span><span>byte</span></span> x<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>(</span><span>long</span><span>)</span> x<span>)</span> <span>&amp;</span> <span>0xffL</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个方法同toUnsignedInt类似只不过把数据强转为long类型后进行运算。注意同一个byte类型的数据转换成int和long后所表示的二进制的数据的位数是不相同的int为32位，long是64位。</p>\n<p>SIZE:</p>\n<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>int</span> SIZE <span>=</span> <span>8</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>SIZE用来表示于二进制补码形式的byte值的位数，值为8，静态变量且不可变。</p>\n<h4 id=\"bytes\"> BYTES:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>int</span> BYTES <span>=</span> SIZE <span>/</span> <span>Byte</span><span>.</span>SIZE<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>BYTES用来表示于二进制补码形式的byte值的字节数，值为1，静态变量且不可变。</p>\n<p>注意：\n在本类中有很多使用static和final关键字修饰的属性或方法。用static 和final共同修饰的变量表示这个量为常量，不可改变。用static修饰的方法或属性表示该属性属于类，可以使用  类名.方法名或类名.属性名直接调用。否则这些属性属于对象，需要通过创建对象后，由对象来调用。</p>\n<h2 id=\"_7-short类\"> 7.Short类</h2>\n<p>short是java基本数据类型中的一种，为短整型，占2个字节，16位。Short为short类型的包装类。</p>\n<h4 id=\"基础知识-3\"> 基础知识：</h4>\n<p>1.整型变量的分类，java中整型变量分为以下四类：\n短整型，类型关键字为short[int]占2个字节。　　\n整型，类型关键字为int占4个字节。\n长整型，类型关键字为long[int]占8个字节。　　\n无符号整型，类型关键字为unsigned[int]或unsignedshort或unsignedlong</p>\n<h4 id=\"short类源码\"> Short类源码：</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Short</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Short</span><span>></span></span> <span>{</span>\n    <span>//short类型最小值</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>short</span>   MIN_VALUE <span>=</span> <span>-</span><span>32768</span><span>;</span>\n    <span>//short类型最大值</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>short</span>   MAX_VALUE <span>=</span> <span>32767</span><span>;</span>\n    <span>//基本类型 short 的 Class 实例，即short.class</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>Class</span><span><span>&lt;</span><span>Short</span><span>></span></span>    TYPE <span>=</span> <span>(</span><span>Class</span><span><span>&lt;</span><span>Short</span><span>></span></span><span>)</span> <span>Class</span><span>.</span><span>getPrimitiveClass</span><span>(</span><span>\"short\"</span><span>)</span><span>;</span>\n    <span>//将short类型的数转换为其10进制对应的数的字符串形式</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>toString</span><span>(</span><span>short</span> s<span>)</span> <span>{</span>\n        <span>return</span> <span>Integer</span><span>.</span><span>toString</span><span>(</span><span>(</span><span>int</span><span>)</span>s<span>,</span> <span>10</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>//将short类型的数转换为其指定进制对应的数的字符串形式</span>\n    <span>public</span> <span>static</span> <span>short</span> <span>parseShort</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> radix<span>)</span>\n        <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>int</span> i <span>=</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>s<span>,</span> radix<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>&lt;</span> MIN_VALUE <span>||</span> i <span>></span> MAX_VALUE<span>)</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span>\n                <span>\"Value out of range. Value:\\\"\"</span> <span>+</span> s <span>+</span> <span>\"\\\" Radix:\"</span> <span>+</span> radix<span>)</span><span>;</span>\n        <span>return</span> <span>(</span><span>short</span><span>)</span>i<span>;</span>\n    <span>}</span>\n    <span>//将10进制的字符串数转换为对应的short类型的数字</span>\n    <span>public</span> <span>static</span> <span>short</span> <span>parseShort</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>parseShort</span><span>(</span>s<span>,</span> <span>10</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>//将指定进制的字符串数转换为对应的short类型的数字</span>\n    <span>public</span> <span>static</span> <span>Short</span> <span>valueOf</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> radix<span>)</span>\n        <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>valueOf</span><span>(</span><span>parseShort</span><span>(</span>s<span>,</span> radix<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>//获取字符串形式的数字，所对应的Short对象</span>\n    <span>public</span> <span>static</span> <span>Short</span> <span>valueOf</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>valueOf</span><span>(</span>s<span>,</span> <span>10</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>//Short对象的缓冲类</span>\n    <span>private</span> <span>static</span> <span>class</span> <span>ShortCache</span> <span>{</span>\n        <span>private</span> <span>ShortCache</span><span>(</span><span>)</span><span>{</span><span>}</span>\n        <span>//缓冲数组</span>\n        <span>static</span> <span>final</span> <span>Short</span> cache<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>Short</span><span>[</span><span>-</span><span>(</span><span>-</span><span>128</span><span>)</span> <span>+</span> <span>127</span> <span>+</span> <span>1</span><span>]</span><span>;</span>\n        <span>//创建缓冲对象，共256个</span>\n        <span>static</span> <span>{</span>\n            <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cache<span>.</span>length<span>;</span> i<span>++</span><span>)</span>\n                cache<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Short</span><span>(</span><span>(</span><span>short</span><span>)</span><span>(</span>i <span>-</span> <span>128</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>//从缓冲对象中获取对应的Short对象</span>\n    <span>//可以看到在-127到128之间是从缓存数组中取的，其它范围的是创建的新的对象</span>\n    <span>public</span> <span>static</span> <span>Short</span> <span>valueOf</span><span>(</span><span>short</span> s<span>)</span> <span>{</span>\n        <span>final</span> <span>int</span> offset <span>=</span> <span>128</span><span>;</span>\n        <span>int</span> sAsInt <span>=</span> s<span>;</span>\n        <span>if</span> <span>(</span>sAsInt <span>>=</span> <span>-</span><span>128</span> <span>&amp;&amp;</span> sAsInt <span>&lt;=</span> <span>127</span><span>)</span> <span>{</span> <span>// must cache</span>\n            <span>return</span> <span>ShortCache</span><span>.</span>cache<span>[</span>sAsInt <span>+</span> offset<span>]</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>new</span> <span>Short</span><span>(</span>s<span>)</span><span>;</span>\n    <span>}</span>\n    <span>//将其它进制表示法，表示的字符串数据转换为10进制表示的short数据,然后返回对应的Short对象</span>\n    <span>public</span> <span>static</span> <span>Short</span> <span>decode</span><span>(</span><span>String</span> nm<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>int</span> i <span>=</span> <span>Integer</span><span>.</span><span>decode</span><span>(</span>nm<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>&lt;</span> MIN_VALUE <span>||</span> i <span>></span> MAX_VALUE<span>)</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span>\n                    <span>\"Value \"</span> <span>+</span> i <span>+</span> <span>\" out of range from input \"</span> <span>+</span> nm<span>)</span><span>;</span>\n        <span>return</span> <span>valueOf</span><span>(</span><span>(</span><span>short</span><span>)</span>i<span>)</span><span>;</span>\n    <span>}</span>\n    <span>//用于存储short数值</span>\n    <span>private</span> <span>final</span> <span>short</span> value<span>;</span>\n    <span>//Short类的构造器,参数为short值</span>\n    <span>public</span> <span>Short</span><span>(</span><span>short</span> value<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>value <span>=</span> value<span>;</span>\n    <span>}</span>\n    <span>//Short类的构造器,参数为字符串</span>\n    <span>public</span> <span>Short</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>this</span><span>.</span>value <span>=</span> <span>parseShort</span><span>(</span>s<span>,</span> <span>10</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>//将short数转换为byte，由于short长度大于byte所以这里可以会出现溢出的情况</span>\n    <span>public</span> <span>byte</span> <span>byteValue</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>byte</span><span>)</span>value<span>;</span>\n    <span>}</span>\n    <span>//返回short数据</span>\n    <span>public</span> <span>short</span> <span>shortValue</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> value<span>;</span>\n    <span>}</span>\n    <span>//将short数转换为int类型</span>\n    <span>public</span> <span>int</span> <span>intValue</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>int</span><span>)</span>value<span>;</span>\n    <span>}</span>\n    <span>//将short数转换为long类型</span>\n    <span>public</span> <span>long</span> <span>longValue</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>long</span><span>)</span>value<span>;</span>\n    <span>}</span>\n    <span>//将short数转换为float类型</span>\n    <span>public</span> <span>float</span> <span>floatValue</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>float</span><span>)</span>value<span>;</span>\n    <span>}</span>\n    <span>//将short数转换为double类型</span>\n    <span>public</span> <span>double</span> <span>doubleValue</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>double</span><span>)</span>value<span>;</span>\n    <span>}</span>\n    <span>//toString方法</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>Integer</span><span>.</span><span>toString</span><span>(</span><span>(</span><span>int</span><span>)</span>value<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>Short</span><span>.</span><span>hashCode</span><span>(</span>value<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>hashCode</span><span>(</span><span>short</span> value<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>int</span><span>)</span>value<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>obj <span>instanceof</span> <span>Short</span><span>)</span> <span>{</span>\n            <span>return</span> value <span>==</span> <span>(</span><span>(</span><span>Short</span><span>)</span>obj<span>)</span><span>.</span><span>shortValue</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n    <span>//比较两个short对象的大小</span>\n    <span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>Short</span> anotherShort<span>)</span> <span>{</span>\n        <span>return</span> <span>compare</span><span>(</span><span>this</span><span>.</span>value<span>,</span> anotherShort<span>.</span>value<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>compare</span><span>(</span><span>short</span> x<span>,</span> <span>short</span> y<span>)</span> <span>{</span>\n        <span>return</span> x <span>-</span> y<span>;</span>\n    <span>}</span>\n    <span>//short类型所占的位数</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>int</span> SIZE <span>=</span> <span>16</span><span>;</span>\n    <span>//short类型所占的字节数</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>int</span> BYTES <span>=</span> SIZE <span>/</span> <span>Byte</span><span>.</span>SIZE<span>;</span>\n    <span>//short的高8位与低8位互换</span>\n    <span>public</span> <span>static</span> <span>short</span> <span>reverseBytes</span><span>(</span><span>short</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>short</span><span>)</span> <span>(</span><span>(</span><span>(</span>i <span>&amp;</span> <span>0xFF00</span><span>)</span> <span>>></span> <span>8</span><span>)</span> <span>|</span> <span>(</span>i <span>&lt;&lt;</span> <span>8</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>//将short类型的数转换为无符号的int类型</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>toUnsignedInt</span><span>(</span><span>short</span> x<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>(</span><span>int</span><span>)</span> x<span>)</span> <span>&amp;</span> <span>0xffff</span><span>;</span>\n    <span>}</span>\n    <span>//将short类型的数转换为无符号的long类型</span>\n    <span>public</span> <span>static</span> <span>long</span> <span>toUnsignedLong</span><span>(</span><span>short</span> x<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>(</span><span>long</span><span>)</span> x<span>)</span> <span>&amp;</span> <span>0</span>xffffL<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br></div></div><p>可以看到在Short类的源码中绝大部分属性或方法都跟Byte类类似，这里我就不再重复讲解了，不明白的同学可以看下<a href=\"https://www.jianshu.com/p/26bedb3ae3c4\" target=\"_blank\" rel=\"noopener noreferrer\">Byte类</a>的源码学习。</p>\n<h4 id=\"与byte类的不同\"> 与Byte类的不同:</h4>\n<p>1.缓存池：</p>\n<div><pre><code><span>private</span> <span>static</span> <span>class</span> <span>ShortCache</span> <span>{</span>\n        <span>private</span> <span>ShortCache</span><span>(</span><span>)</span><span>{</span><span>}</span>\n        <span>//缓冲数组</span>\n        <span>static</span> <span>final</span> <span>Short</span> cache<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>Short</span><span>[</span><span>-</span><span>(</span><span>-</span><span>128</span><span>)</span> <span>+</span> <span>127</span> <span>+</span> <span>1</span><span>]</span><span>;</span>\n        <span>//创建缓冲对象，共256个</span>\n        <span>static</span> <span>{</span>\n            <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cache<span>.</span>length<span>;</span> i<span>++</span><span>)</span>\n                cache<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Short</span><span>(</span><span>(</span><span>short</span><span>)</span><span>(</span>i <span>-</span> <span>128</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>可以看到Short类的缓存池中也是存放了256个对象，那为什么说这里与Byte类不同呢，原因很简单，因为short类型的范围是-32768到32767，这里只缓存了256个对象，那为什么不全部缓存下来呢，因为太多了，占用的内在空间较大，所以在使用Short类的时候，对于-128到127内的Short对象是从缓存池中取的，其它的是创建的新对象。\n2.reverseBytes方法</p>\n<div><pre><code><span>public</span> <span>static</span> <span>short</span> <span>reverseBytes</span><span>(</span><span>short</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>short</span><span>)</span> <span>(</span><span>(</span><span>(</span>i <span>&amp;</span> <span>0xFF00</span><span>)</span> <span>>></span> <span>8</span><span>)</span> <span>|</span> <span>(</span>i <span>&lt;&lt;</span> <span>8</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到在Byte类中没有这个方法，这个方法是用来将short类型的低8位与高8位互换的。解释如下:\n1.将目标数i与0xFF00(转换为2进制是 1111 1111 0000 0000)做&amp;的运算,得到的结果为i的高8位不变，低8位全变为0，然后右移8位，就得到了目标数i的高8位\n2.将i左移8位，得到的数为一个新数,这个新数的高8位为原目标数i的低8位，这个数的低8位为0，然后将i的高8位与这个新数做|运算，得到的结果就是将目标数i的高8位，与低8位互换的数。\n有兴趣的同学可以亲自先一个数运算一下，如果不清楚位运算&amp;和|可以看下<a href=\"https://www.jianshu.com/p/26bedb3ae3c4\" target=\"_blank\" rel=\"noopener noreferrer\">一起学JDK源码 -- Byte类</a>的基础知识。</p>\n<h2 id=\"_8-integer类\"> 8.Integer类</h2>\n<p>Integer类为java基本类型int的包装类，除了前面提到的Byte类，Short类中的大部分方法，Integer类中还提供了很多处理int类型的方法，接下来就让我们一起看看吧。</p>\n<h4 id=\"基础知识-4\"> 基础知识：</h4>\n<p>1.Java移位运算，移位运算也是java中位运算的一部分主要有以下三种：\n前提：\n1).移位是在将对应的数字转换为2进制后进行的，JAVA中用补码表示二进制数.\n2).移位后总长度不变，比如int类型为32位，移动后还需补齐为32位，其它也类似\n3).左边为低位，右边为高位\n左移( &lt;&lt; )：将运算符左边的对象，向左移动运算符右边指定的位数，并且在低位补零。向左移n 位，就相当于乘上2 的n 次方\n右移( &gt;&gt; )：将运算符左边的运算对象，向右移动运算符右边指定的位数。如果是正数，在高位补零，如果是负数，则在高位补1\n无符号右移( &gt;&gt;&gt; )：将运算符左边的对象向右移动运算符右边指定的位数，并且在高位补0\n注：\n1).对于正数来说，右移或无称号右移n 位，就相当于除上2 的n 次方。\n2).对于int类型(长度为32位)移位，左移(&lt;&lt;)n位，相当于移动 n % 32 位，如:  1 &lt;&lt; 33 实际上是 1 &lt;&lt; 1 也就是2，其它类型移动超过自身类型长度的也应该是类似，有兴趣的可以自行研究下。\n3).java中没有无符号左移，原因很简单，左移补的是低位，java中高位的第一位表示符号位。</p>\n<h4 id=\"前言\"> 前言：</h4>\n<p>从本文开始，对于比较简单的属性和方法，或是在之前文章中讲过的文章中将不再列出，有兴趣的同学可以看下之前的文章，或是留言笔者将根据大家的需求考虑是否后续在文章中添加。</p>\n<h4 id=\"几个数组属性\"> 几个数组属性:</h4>\n<div><pre><code><span>final</span> <span>static</span> <span>char</span><span>[</span><span>]</span> digits <span>=</span> <span>{</span>\n        <span>'0'</span> <span>,</span> <span>'1'</span> <span>,</span> <span>'2'</span> <span>,</span> <span>'3'</span> <span>,</span> <span>'4'</span> <span>,</span> <span>'5'</span> <span>,</span>\n        <span>'6'</span> <span>,</span> <span>'7'</span> <span>,</span> <span>'8'</span> <span>,</span> <span>'9'</span> <span>,</span> <span>'a'</span> <span>,</span> <span>'b'</span> <span>,</span>\n        <span>'c'</span> <span>,</span> <span>'d'</span> <span>,</span> <span>'e'</span> <span>,</span> <span>'f'</span> <span>,</span> <span>'g'</span> <span>,</span> <span>'h'</span> <span>,</span>\n        <span>'i'</span> <span>,</span> <span>'j'</span> <span>,</span> <span>'k'</span> <span>,</span> <span>'l'</span> <span>,</span> <span>'m'</span> <span>,</span> <span>'n'</span> <span>,</span>\n        <span>'o'</span> <span>,</span> <span>'p'</span> <span>,</span> <span>'q'</span> <span>,</span> <span>'r'</span> <span>,</span> <span>'s'</span> <span>,</span> <span>'t'</span> <span>,</span>\n        <span>'u'</span> <span>,</span> <span>'v'</span> <span>,</span> <span>'w'</span> <span>,</span> <span>'x'</span> <span>,</span> <span>'y'</span> <span>,</span> <span>'z'</span>\n<span>}</span><span>;</span>\n<span>final</span> <span>static</span> <span>char</span> <span>[</span><span>]</span> <span>DigitTens</span> <span>=</span> <span>{</span>\n        <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span>\n        <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span>\n        <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span>\n        <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span>\n        <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span>\n        <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span>\n        <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span>\n        <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span>\n        <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span>\n        <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span>\n    <span>}</span> <span>;</span>\n\n<span>final</span> <span>static</span> <span>char</span> <span>[</span><span>]</span> <span>DigitOnes</span> <span>=</span> <span>{</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n    <span>}</span> <span>;</span>\n<span>final</span> <span>static</span> <span>int</span> <span>[</span><span>]</span> sizeTable <span>=</span> <span>{</span> <span>9</span><span>,</span> <span>99</span><span>,</span> <span>999</span><span>,</span> <span>9999</span><span>,</span> <span>99999</span><span>,</span> <span>999999</span><span>,</span> <span>9999999</span><span>,</span>\n                                      <span>99999999</span><span>,</span> <span>999999999</span><span>,</span> <span>Integer</span><span>.</span>MAX_VALUE <span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>digits数组用于表示所有可能出现的字符，因为int支持从2进制到36进制，所以这里需要有36个字符才能表示所有不同进制的数字\nDigitTens和DigitOnes两个数组也很好理解，它们主要用于获取0到99之间某个数的十位和个位，比如36，通过DigitTens数组直接取出来十位为3，而通过DigitOnes数组取出来个位为6。\nsizeTable数组主要用在判断一个int型数字对应字符串的长度。避免了使用除法或求余等操作，以提高效率。</p>\n<p>toString(int i, int radix)：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>toString</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> radix<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>radix <span>&lt;</span> <span>Character</span><span>.</span>MIN_RADIX <span>||</span> radix <span>></span> <span>Character</span><span>.</span>MAX_RADIX<span>)</span>\n            radix <span>=</span> <span>10</span><span>;</span>\n        <span>if</span> <span>(</span>radix <span>==</span> <span>10</span><span>)</span> <span>{</span>\n            <span>return</span> <span>toString</span><span>(</span>i<span>)</span><span>;</span>\n        <span>}</span>\n        <span>char</span> buf<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>char</span><span>[</span><span>33</span><span>]</span><span>;</span>\n        <span>boolean</span> negative <span>=</span> <span>(</span>i <span>&lt;</span> <span>0</span><span>)</span><span>;</span>\n        <span>int</span> charPos <span>=</span> <span>32</span><span>;</span>\n\n        <span>if</span> <span>(</span><span>!</span>negative<span>)</span> <span>{</span>\n            i <span>=</span> <span>-</span>i<span>;</span>\n        <span>}</span>\n        <span>while</span> <span>(</span>i <span>&lt;=</span> <span>-</span>radix<span>)</span> <span>{</span>\n            buf<span>[</span>charPos<span>--</span><span>]</span> <span>=</span> digits<span>[</span><span>-</span><span>(</span>i <span>%</span> radix<span>)</span><span>]</span><span>;</span>\n            i <span>=</span> i <span>/</span> radix<span>;</span>\n        <span>}</span>\n        buf<span>[</span>charPos<span>]</span> <span>=</span> digits<span>[</span><span>-</span>i<span>]</span><span>;</span>\n        <span>if</span> <span>(</span>negative<span>)</span> <span>{</span>\n            buf<span>[</span><span>--</span>charPos<span>]</span> <span>=</span> <span>'-'</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>buf<span>,</span> charPos<span>,</span> <span>(</span><span>33</span> <span>-</span> charPos<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>该方法的作用就是将int类型的数字，转换为指定进制的数的字符串形式。\n第一步判断:int类型支持的进制数为2(Character.MIN_RADIX)到36(Character.MAX_RADIX),如果不是这个范围就按10进制来处理。\n第二步：如果是10进制，调用toString(i)(这个方法我们后面再讲)，如果不是10进制，继续往下走。\n第三步：接着它创建了一个长度为33的char类型的数组，诶，为什么这里长度为33，int类型的最大长度为32啊，看到后面你就知道了，还要给 '-'留一个位置，原来这个方法的转换并不是真正意义上的转换，都是按照正数来转换，如果是负数就在正数转换的结果上加'-'。\n第四步：创建了两个局部变量negative和charPos其中negative是个标识，用来标识目标数是正数还是负数。charPos是用来指定转换后的数存储在缓冲数组中的位置。\n第五步：转换，这里就是按照10进制的数转换为其它进制数的转换方法进行的。如果不清楚的同学可以看下另一篇文章<a href=\"http://aiceflower.farbox.com/post/javaji-zhu-hun-za/javazhong-de-jin-zhi-zhuan-huan\" target=\"_blank\" rel=\"noopener noreferrer\">Java中的进制转换</a>\n第六步：创建一个字符串对象返回。</p>\n<h4 id=\"tostring-int-i\"> toString(int i):</h4>\n<div><pre><code><span>public</span> <span>static</span> String <span>toString</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>i <span>==</span> Integer<span>.</span>MIN_VALUE<span>)</span>\n            <span>return</span> <span>\"-2147483648\"</span><span>;</span>\n        <span>int</span> size <span>=</span> <span>(</span>i <span>&lt;</span> <span>0</span><span>)</span> <span>?</span> <span>stringSize</span><span>(</span><span>-</span>i<span>)</span> <span>+</span> <span>1</span> <span>:</span> <span>stringSize</span><span>(</span>i<span>)</span><span>;</span>\n        <span>char</span><span>[</span><span>]</span> buf <span>=</span> <span>new</span> <span>char</span><span>[</span>size<span>]</span><span>;</span>\n        <span>getChars</span><span>(</span>i<span>,</span> size<span>,</span> buf<span>)</span><span>;</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>buf<span>,</span> <span>true</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这个方法用来将10进制的数转换为10进制的字符串形式。\n第一步：判断如果是int类型的最小值，就直接返回一个固定的值，无需计算。\n第二步：计算数字的长度，用到的stringSize方法,如下:</p>\n<div><pre><code><span>static</span> <span>int</span> <span>stringSize</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> <span>;</span> i<span>++</span><span>)</span>\n            <span>if</span> <span>(</span>x <span>&lt;=</span> sizeTable<span>[</span>i<span>]</span><span>)</span>\n                <span>return</span> i<span>+</span><span>1</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>可以看到它使用了sizeTable这个数组，巧妙的避免了除法和求余，以高效的求得对应字符串长度。方法实现很简单，但是思想我们可以借鉴。\n第三步：创建了一个数组，然后调用getChars方法填充数组中的内容。getChars方法实现如下:</p>\n<div><pre><code><span>static</span> <span>void</span> <span>getChars</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> index<span>,</span> <span>char</span><span>[</span><span>]</span> buf<span>)</span> <span>{</span>\n        <span>int</span> q<span>,</span> r<span>;</span>\n        <span>int</span> charPos <span>=</span> index<span>;</span>\n        <span>char</span> sign <span>=</span> <span>0</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            sign <span>=</span> <span>'-'</span><span>;</span>\n            i <span>=</span> <span>-</span>i<span>;</span>\n        <span>}</span>\n        <span>// Generate two digits per iteration</span>\n        <span>while</span> <span>(</span>i <span>>=</span> <span>65536</span><span>)</span> <span>{</span>\n            q <span>=</span> i <span>/</span> <span>100</span><span>;</span>\n        <span>// really: r = i - (q * 100);</span>\n            r <span>=</span> i <span>-</span> <span>(</span><span>(</span>q <span>&lt;&lt;</span> <span>6</span><span>)</span> <span>+</span> <span>(</span>q <span>&lt;&lt;</span> <span>5</span><span>)</span> <span>+</span> <span>(</span>q <span>&lt;&lt;</span> <span>2</span><span>)</span><span>)</span><span>;</span>\n            i <span>=</span> q<span>;</span>\n            buf <span>[</span><span>--</span>charPos<span>]</span> <span>=</span> DigitOnes<span>[</span>r<span>]</span><span>;</span>\n            buf <span>[</span><span>--</span>charPos<span>]</span> <span>=</span> DigitTens<span>[</span>r<span>]</span><span>;</span>\n        <span>}</span>\n        <span>// Fall thru to fast mode for smaller numbers</span>\n        <span>// assert(i &lt;= 65536, i);</span>\n        <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n            q <span>=</span> <span>(</span>i <span>*</span> <span>52429</span><span>)</span> <span>>></span><span>></span> <span>(</span><span>16</span><span>+</span><span>3</span><span>)</span><span>;</span>\n            r <span>=</span> i <span>-</span> <span>(</span><span>(</span>q <span>&lt;&lt;</span> <span>3</span><span>)</span> <span>+</span> <span>(</span>q <span>&lt;&lt;</span> <span>1</span><span>)</span><span>)</span><span>;</span>  <span>// r = i-(q*10) ...</span>\n            buf <span>[</span><span>--</span>charPos<span>]</span> <span>=</span> digits <span>[</span>r<span>]</span><span>;</span>\n            i <span>=</span> q<span>;</span>\n            <span>if</span> <span>(</span>i <span>==</span> <span>0</span><span>)</span> <span>break</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>sign <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n            buf <span>[</span><span>--</span>charPos<span>]</span> <span>=</span> sign<span>;</span>\n        <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>这个方法的作用就是将一个int类型的数按顺序放到char数组中。不过这里使用了很多的技巧。它把int的高位的两个字节和低位的两个字节分开处理，while (i &gt;= 65536)就是处理高位的两个字节`。每次处理两位数，使用了一个技巧((q &lt;&lt; 6) + (q &lt;&lt; 5) + (q &lt;&lt; 2)),就是 q * (2^6 +2^5 + 2^2) = q * 100。DigitTens和DigitOnes用来取十位和个位。后面就是对低位的两个数进行处理了，其本质就是求余，也用了一些技巧，(i * 52429) &gt;&gt;&gt; (16+3)其实约等于i/10，((q &lt;&lt; 3) + (q &lt;&lt; 1))其实等于q*10，最后通过digits数组获取到对应的字符。这里面使用乘法和移位运算代替除法和取余，用移位运算和加法代替乘法，可见在运算效率上加法和移位高于乘法，乘法高于除法。\n第四步：根据填充好的char数组创建字符串对象返回\n注：\n1.这个方法也就是toString(int i, int radix)方法中对于10进制的处理。可以看到对于10进制的转化，可是花了大功夫在优化上，为了避免使用除法，应用各种移位操作来进行，即使在不得不使用除法的地方也尽可能用除以100而不是除以10来减少除法次数。\n2.这里使用getChars去填充char数组，显然写这段代码的之前是一个写C语言这种面向过程的人。对于java这种面向对象的语言来说，这里我们应该用  char[] buf = getChars(i, size);这种方式，以后大家写java代码我也推荐大家使用这种方式。什么没看明白，自己去百度下面向过程和面向对象方面的知识吧。</p>\n<h4 id=\"int类型转换为其它进制的字符串形式\"> int类型转换为其它进制的字符串形式:</h4>\n<div><pre><code><span>//转换为16进制</span>\n<span>public</span> <span>static</span> String <span>toHexString</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>toUnsignedString0</span><span>(</span>i<span>,</span> <span>4</span><span>)</span><span>;</span>\n<span>}</span>\n<span>//转换为8进制</span>\n<span>public</span> <span>static</span> String <span>toOctalString</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>toUnsignedString0</span><span>(</span>i<span>,</span> <span>3</span><span>)</span><span>;</span>\n<span>}</span>\n<span>//转换为2进制</span>\n<span>public</span> <span>static</span> String <span>toBinaryString</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>toUnsignedString0</span><span>(</span>i<span>,</span> <span>1</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>可以看到这几个转换的方法都调用了同一个方法toUnsignedString0只是传的参数不同，toUnsignedString0方法如下：</p>\n<div><pre><code><span>private</span> <span>static</span> String <span>toUnsignedString0</span><span>(</span><span>int</span> val<span>,</span> <span>int</span> shift<span>)</span> <span>{</span>\n        <span>// assert shift > 0 &amp;&amp; shift &lt;=5 : \"Illegal shift value\";</span>\n        <span>int</span> mag <span>=</span> Integer<span>.</span>SIZE <span>-</span> Integer<span>.</span><span>numberOfLeadingZeros</span><span>(</span>val<span>)</span><span>;</span>\n        <span>int</span> chars <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>(</span><span>(</span>mag <span>+</span> <span>(</span>shift <span>-</span> <span>1</span><span>)</span><span>)</span> <span>/</span> shift<span>)</span><span>,</span> <span>1</span><span>)</span><span>;</span>\n        <span>char</span><span>[</span><span>]</span> buf <span>=</span> <span>new</span> <span>char</span><span>[</span>chars<span>]</span><span>;</span>\n        <span>formatUnsignedInt</span><span>(</span>val<span>,</span> shift<span>,</span> buf<span>,</span> <span>0</span><span>,</span> chars<span>)</span><span>;</span>\n        <span>// Use special constructor which takes over \"buf\".</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>buf<span>,</span> <span>true</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>第一步：获取目标值value的二进制形式有效位长度，Integer.numberOfLeadingZeros(val)这个方法是计算value的二进制高位共有多少位0，后面我们再讲这个方法。\n第二步:获取缓冲数组的大小\n第三步:调用formatUnsignedInt方法，这个方法才是核心，原因如下：</p>\n<div><pre><code><span>static</span> <span>int</span> <span>formatUnsignedInt</span><span>(</span><span>int</span> val<span>,</span> <span>int</span> shift<span>,</span> <span>char</span><span>[</span><span>]</span> buf<span>,</span> <span>int</span> offset<span>,</span> <span>int</span> len<span>)</span> <span>{</span>\n        <span>int</span> charPos <span>=</span> len<span>;</span>\n        <span>int</span> radix <span>=</span> <span>1</span> <span>&lt;&lt;</span> shift<span>;</span>\n        <span>int</span> mask <span>=</span> radix <span>-</span> <span>1</span><span>;</span>\n        <span>do</span> <span>{</span>\n            buf<span>[</span>offset <span>+</span> <span>--</span>charPos<span>]</span> <span>=</span> Integer<span>.</span>digits<span>[</span>val <span>&amp;</span> mask<span>]</span><span>;</span>\n            val <span>>></span><span>>=</span> shift<span>;</span>\n        <span>}</span> <span>while</span> <span>(</span>val <span>!=</span> <span>0</span> <span>&amp;&amp;</span> charPos <span>></span> <span>0</span><span>)</span><span>;</span>\n        <span>return</span> charPos<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这里就是<a href=\"http://aiceflower.farbox.com/post/javaji-zhu-hun-za/javazhong-de-jin-zhi-zhuan-huan\" target=\"_blank\" rel=\"noopener noreferrer\">将10进制数转换为其它进制数</a>的代码体现了,其中 1 &lt;&lt; shift相当于2^shift，radix - 1如果转换为16进制就是15如果是8进制就是7，这里是为了后面做&amp;的计算，你想一下如果转换为16进制，一个数&amp;上15(1111)，就是取得这个数字的低4位，这样4位4位的计算不就转换为这个数的16进制了吗，转换为8进制同理。后面的val&amp;mask  就相当于  val%(mask+1)也就是进制转换的过程了。\n第四步：根据buf数组，创建String对象后返回。</p>\n<h4 id=\"parseint\"> parseInt:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>parseInt</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> radix<span>)</span>\n                <span>throws</span> <span>NumberFormatException</span>\n    <span>{</span>\n        <span>if</span> <span>(</span>s <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span><span>\"null\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>radix <span>&lt;</span> <span>Character</span><span>.</span>MIN_RADIX<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span><span>\"radix \"</span> <span>+</span> radix <span>+</span>\n                                            <span>\" less than Character.MIN_RADIX\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>radix <span>></span> <span>Character</span><span>.</span>MAX_RADIX<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span><span>\"radix \"</span> <span>+</span> radix <span>+</span>\n                                            <span>\" greater than Character.MAX_RADIX\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>int</span> result <span>=</span> <span>0</span><span>;</span>\n        <span>boolean</span> negative <span>=</span> <span>false</span><span>;</span>\n        <span>int</span> i <span>=</span> <span>0</span><span>,</span> len <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> limit <span>=</span> <span>-</span><span>Integer</span><span>.</span>MAX_VALUE<span>;</span>\n        <span>int</span> multmin<span>;</span>\n        <span>int</span> digit<span>;</span>\n        <span>if</span> <span>(</span>len <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>char</span> firstChar <span>=</span> s<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>firstChar <span>&lt;</span> <span>'0'</span><span>)</span> <span>{</span> <span>// Possible leading \"+\" or \"-\"</span>\n                <span>if</span> <span>(</span>firstChar <span>==</span> <span>'-'</span><span>)</span> <span>{</span>\n                    negative <span>=</span> <span>true</span><span>;</span>\n                    limit <span>=</span> <span>Integer</span><span>.</span>MIN_VALUE<span>;</span>\n                <span>}</span> <span>else</span> <span>if</span> <span>(</span>firstChar <span>!=</span> <span>'+'</span><span>)</span>\n                    <span>throw</span> <span>NumberFormatException</span><span>.</span><span>forInputString</span><span>(</span>s<span>)</span><span>;</span>\n                <span>if</span> <span>(</span>len <span>==</span> <span>1</span><span>)</span> <span>// Cannot have lone \"+\" or \"-\"</span>\n                    <span>throw</span> <span>NumberFormatException</span><span>.</span><span>forInputString</span><span>(</span>s<span>)</span><span>;</span>\n                i<span>++</span><span>;</span>\n            <span>}</span>\n            multmin <span>=</span> limit <span>/</span> radix<span>;</span>\n            <span>while</span> <span>(</span>i <span>&lt;</span> len<span>)</span> <span>{</span>\n                digit <span>=</span> <span>Character</span><span>.</span><span>digit</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span>i<span>++</span><span>)</span><span>,</span>radix<span>)</span><span>;</span>\n                <span>if</span> <span>(</span>digit <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n                    <span>throw</span> <span>NumberFormatException</span><span>.</span><span>forInputString</span><span>(</span>s<span>)</span><span>;</span>\n                <span>}</span>\n                <span>if</span> <span>(</span>result <span>&lt;</span> multmin<span>)</span> <span>{</span>\n                    <span>throw</span> <span>NumberFormatException</span><span>.</span><span>forInputString</span><span>(</span>s<span>)</span><span>;</span>\n                <span>}</span>\n                result <span>*=</span> radix<span>;</span>\n                <span>if</span> <span>(</span>result <span>&lt;</span> limit <span>+</span> digit<span>)</span> <span>{</span>\n                    <span>throw</span> <span>NumberFormatException</span><span>.</span><span>forInputString</span><span>(</span>s<span>)</span><span>;</span>\n                <span>}</span>\n                result <span>-=</span> digit<span>;</span>\n            <span>}</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>throw</span> <span>NumberFormatException</span><span>.</span><span>forInputString</span><span>(</span>s<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> negative <span>?</span> result <span>:</span> <span>-</span>result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><p>parseInt有两个方法，作用是将指定进制的数的字符串形式转换为int类型。看上面这个就行。\n第一步：参数校验。字符串为null或是radix不在可转换的进制范围内就抛出异常。\n第二步：核心处理逻辑是字符串转换数字，<a href=\"http://aiceflower.farbox.com/post/javaji-zhu-hun-za/javazhong-de-jin-zhi-zhuan-huan\" target=\"_blank\" rel=\"noopener noreferrer\">其它进制转成十进制</a>，如521为8进制，则结果为5* 8^2 + 2<em>8^1 + 1</em>8^0.上面的转换方法也差不多是根据此方法，只是稍微转变了思路( (5 * 8+2)*8)+1结果都是一样的。规律就是从左到右遍历字符串的每个字符，然后乘以进制数，再加上下一个字符，接着再乘以进制数，再加上下个字符，不断重复，直到最后一个字符。除此之外另外一个不同就是上面的转换不使用加法来做，全都转成负数来运算，其实可以看成是等价了。因为负数Integer.MIN_VALUE变化为正数时会导致数值溢出，所以全部都用负数来运算。\n第三步：返回正确的结果如果是负数就添加负号。</p>\n<p>无符号转换:</p>\n<div><pre><code><span>public</span> <span>static</span> String <span>toUnsignedString</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> radix<span>)</span> <span>{</span>\n        <span>return</span> Long<span>.</span><span>toUnsignedString</span><span>(</span><span>toUnsignedLong</span><span>(</span>i<span>)</span><span>,</span> radix<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>static</span> <span>long</span> <span>toUnsignedLong</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>(</span><span>long</span><span>)</span> x<span>)</span> <span>&amp;</span> <span>0xffffffffL</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这两个方法就是将目标数转换为无符号表示的long或是字符串，无符号意思就是将二进制中的高位的第一位不当作符号位来看待。其中toUnsignedString使用了Long.toUnsignedString方法，一直跟踪源码可以发现实现方式与Integer中的实现方式相同，这里就不再重复了，不明白的同学可以看下Integer中的toString方法和toUnsignedString0方法。</p>\n<h4 id=\"parseunsignedint\"> parseUnsignedInt：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>parseUnsignedInt</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> radix<span>)</span>\n                <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>if</span> <span>(</span>s <span>==</span> <span>null</span><span>)</span>  <span>{</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span><span>\"null\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>int</span> len <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>len <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>char</span> firstChar <span>=</span> s<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>firstChar <span>==</span> <span>'-'</span><span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span>\n                    <span>NumberFormatException</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"Illegal leading minus sign \"</span> <span>+</span>\n                                                       <span>\"on unsigned string %s.\"</span><span>,</span> s<span>)</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>if</span> <span>(</span>len <span>&lt;=</span> <span>5</span> <span>||</span> <span>// Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits</span>\n                    <span>(</span>radix <span>==</span> <span>10</span> <span>&amp;&amp;</span> len <span>&lt;=</span> <span>9</span><span>)</span> <span>)</span> <span>{</span> <span>// Integer.MAX_VALUE in base 10 is 10 digits</span>\n                    <span>return</span> <span>parseInt</span><span>(</span>s<span>,</span> radix<span>)</span><span>;</span>\n                <span>}</span> <span>else</span> <span>{</span>\n                    <span>long</span> ell <span>=</span> <span>Long</span><span>.</span><span>parseLong</span><span>(</span>s<span>,</span> radix<span>)</span><span>;</span>\n                    <span>if</span> <span>(</span><span>(</span>ell <span>&amp;</span> <span>0</span>xffff_ffff_0000_0000L<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                        <span>return</span> <span>(</span><span>int</span><span>)</span> ell<span>;</span>\n                    <span>}</span> <span>else</span> <span>{</span>\n                        <span>throw</span> <span>new</span>\n                            <span>NumberFormatException</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>\"String value %s exceeds \"</span> <span>+</span>\n                                                                <span>\"range of unsigned int.\"</span><span>,</span> s<span>)</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>throw</span> <span>NumberFormatException</span><span>.</span><span>forInputString</span><span>(</span>s<span>)</span><span>;</span>\n        <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>将目标字符串数字转换为指定进制的无符号整型。\n第一步：获取第一个字符，判断是否为'-',如果是'-'就抛出异常。\n第二步：判断长度小于5或是小于9的10进制，使用parseInt方法长度小于5是因为int类型的最大数转换为最大进制36进制是6位。parseInt方法在上面已经讲过了。\n第三步：如果超出第二步判断的范围，就要使用long来转换了，否则可能溢出。 if ((ell &amp; 0xffff_ffff_0000_0000L) == 0) 若未超过int无符号数支持的范围，即数字高八位为0，则返回int值，否则抛出异常，数字超过int可表示的范围。</p>\n<p>IntegerCache：</p>\n<div><pre><code><span>private</span> <span>static</span> <span>class</span> <span>IntegerCache</span> <span>{</span>\n        <span>static</span> <span>final</span> <span>int</span> low <span>=</span> <span>-</span><span>128</span><span>;</span>\n        <span>static</span> <span>final</span> <span>int</span> high<span>;</span>\n        <span>static</span> <span>final</span> <span>Integer</span> cache<span>[</span><span>]</span><span>;</span>\n\n        <span>static</span> <span>{</span>\n            <span>int</span> h <span>=</span> <span>127</span><span>;</span>\n            <span>String</span> integerCacheHighPropValue <span>=</span>\n                sun<span>.</span>misc<span>.</span>VM<span>.</span><span>getSavedProperty</span><span>(</span><span>\"java.lang.Integer.IntegerCache.high\"</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>integerCacheHighPropValue <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                    <span>int</span> i <span>=</span> <span>parseInt</span><span>(</span>integerCacheHighPropValue<span>)</span><span>;</span>\n                    i <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>i<span>,</span> <span>127</span><span>)</span><span>;</span>\n                    h <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>i<span>,</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>(</span><span>-</span>low<span>)</span> <span>-</span><span>1</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span><span>(</span> <span>NumberFormatException</span> nfe<span>)</span> <span>{</span>\n                <span>}</span>\n            <span>}</span>\n            high <span>=</span> h<span>;</span>\n            cache <span>=</span> <span>new</span> <span>Integer</span><span>[</span><span>(</span>high <span>-</span> low<span>)</span> <span>+</span> <span>1</span><span>]</span><span>;</span>\n            <span>int</span> j <span>=</span> low<span>;</span>\n            <span>for</span><span>(</span><span>int</span> k <span>=</span> <span>0</span><span>;</span> k <span>&lt;</span> cache<span>.</span>length<span>;</span> k<span>++</span><span>)</span>\n                cache<span>[</span>k<span>]</span> <span>=</span> <span>new</span> <span>Integer</span><span>(</span>j<span>++</span><span>)</span><span>;</span>\n            <span>assert</span> <span>IntegerCache</span><span>.</span>high <span>>=</span> <span>127</span><span>;</span>\n        <span>}</span>\n        <span>private</span> <span>IntegerCache</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>可以看出Integer类也有如同Byte和Short类类似的缓存池机制，而不同点在于Integer的缓存池可以改变上限的大小，通过 sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);来获取上限，这个参数可以在JVM中配置。但是在设置的时候这个值是要大于或等于127小于Integer.MAX_VALUE。如果小于127以127为上限。注意。下限是-128这个是不可以改变的。</p>\n<h4 id=\"getinteger\"> getInteger:</h4>\n<div><pre><code><span>public</span> static Integer <span>getInteger</span><span>(</span>String nm<span>,</span> Integer <span>val</span><span>)</span> <span>{</span>\n        String v <span>=</span> <span>null</span><span>;</span>\n        <span>try</span> <span>{</span>\n            v <span>=</span> System<span>.</span><span>getProperty</span><span>(</span>nm<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span>IllegalArgumentException | NullPointerException e<span>)</span> <span>{</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>v <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>return</span> Integer<span>.</span><span>decode</span><span>(</span>v<span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span>NumberFormatException e<span>)</span> <span>{</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>val</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这个方法是从系统属性中查找数据然后转换为对应的Integer对象，如果系统中不存在待查找的属性，则返回null。单从方法名上看Integer.getInteger与Integer.valueOf(由于valueOf方法在之前的<a href=\"https://www.jianshu.com/p/26bedb3ae3c4\" target=\"_blank\" rel=\"noopener noreferrer\">Byte类</a>或<a href=\"https://www.jianshu.com/p/3826ccd9e867\" target=\"_blank\" rel=\"noopener noreferrer\">Short类</a>中已经讲过了，都是相似的，这里不赘述)方法功能是一样的，但实际则不然，我们在使用的时候也要小心一点。</p>\n<h4 id=\"decode\"> decode：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>Integer</span> <span>decode</span><span>(</span><span>String</span> nm<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>int</span> radix <span>=</span> <span>10</span><span>;</span>\n        <span>int</span> index <span>=</span> <span>0</span><span>;</span>\n        <span>boolean</span> negative <span>=</span> <span>false</span><span>;</span>\n        <span>Integer</span> result<span>;</span>\n        <span>if</span> <span>(</span>nm<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span><span>\"Zero length string\"</span><span>)</span><span>;</span>\n        <span>char</span> firstChar <span>=</span> nm<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>// Handle sign, if present</span>\n        <span>if</span> <span>(</span>firstChar <span>==</span> <span>'-'</span><span>)</span> <span>{</span>\n            negative <span>=</span> <span>true</span><span>;</span>\n            index<span>++</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>firstChar <span>==</span> <span>'+'</span><span>)</span>\n            index<span>++</span><span>;</span>\n        <span>// Handle radix specifier, if present</span>\n        <span>if</span> <span>(</span>nm<span>.</span><span>startsWith</span><span>(</span><span>\"0x\"</span><span>,</span> index<span>)</span> <span>||</span> nm<span>.</span><span>startsWith</span><span>(</span><span>\"0X\"</span><span>,</span> index<span>)</span><span>)</span> <span>{</span>\n            index <span>+=</span> <span>2</span><span>;</span>\n            radix <span>=</span> <span>16</span><span>;</span>\n        <span>}</span>\n        <span>else</span> <span>if</span> <span>(</span>nm<span>.</span><span>startsWith</span><span>(</span><span>\"#\"</span><span>,</span> index<span>)</span><span>)</span> <span>{</span>\n            index <span>++</span><span>;</span>\n            radix <span>=</span> <span>16</span><span>;</span>\n        <span>}</span>\n        <span>else</span> <span>if</span> <span>(</span>nm<span>.</span><span>startsWith</span><span>(</span><span>\"0\"</span><span>,</span> index<span>)</span> <span>&amp;&amp;</span> nm<span>.</span><span>length</span><span>(</span><span>)</span> <span>></span> <span>1</span> <span>+</span> index<span>)</span> <span>{</span>\n            index <span>++</span><span>;</span>\n            radix <span>=</span> <span>8</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>nm<span>.</span><span>startsWith</span><span>(</span><span>\"-\"</span><span>,</span> index<span>)</span> <span>||</span> nm<span>.</span><span>startsWith</span><span>(</span><span>\"+\"</span><span>,</span> index<span>)</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>NumberFormatException</span><span>(</span><span>\"Sign character in wrong position\"</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            result <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span>nm<span>.</span><span>substring</span><span>(</span>index<span>)</span><span>,</span> radix<span>)</span><span>;</span>\n            result <span>=</span> negative <span>?</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>-</span>result<span>.</span><span>intValue</span><span>(</span><span>)</span><span>)</span> <span>:</span> result<span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>NumberFormatException</span> e<span>)</span> <span>{</span>\n            <span>// If number is Integer.MIN_VALUE, we'll end up here. The next line</span>\n            <span>// handles this case, and causes any genuine format error to be</span>\n            <span>// rethrown.</span>\n            <span>String</span> constant <span>=</span> negative <span>?</span> <span>(</span><span>\"-\"</span> <span>+</span> nm<span>.</span><span>substring</span><span>(</span>index<span>)</span><span>)</span>\n                                       <span>:</span> nm<span>.</span><span>substring</span><span>(</span>index<span>)</span><span>;</span>\n            result <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span>constant<span>,</span> radix<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>这个方法是用来解析2进制，8进制，10进制16进制表示的字符串的。我们用数字前面加0表示8进制如056，数字前面加0x或是#，如0x1234或是#1234，表示16进制，默认数字为10进制。注意这个方法也不是太智能，如你传100这个字符串，他就不知道是10进制还是2进制，默认当10进制来转换了。又如你给定字符串 0000 0000 0000 0100 ，你想让他按2进制来解析，但实际上他按8进制来解析。所以使用的时候如果有这种有歧义的字符串，要小心一些。</p>\n<p>无符号比较：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>compareUnsigned</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span>\n        <span>return</span> <span>compare</span><span>(</span>x <span>+</span> MIN_VALUE<span>,</span> y <span>+</span> MIN_VALUE<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>static</span> <span>int</span> <span>compare</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>x <span>&lt;</span> y<span>)</span> <span>?</span> <span>-</span><span>1</span> <span>:</span> <span>(</span><span>(</span>x <span>==</span> y<span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>1</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>无符号就是二进制的最高位符号位不当作符号位来，比较，实现过程也很简单。那么这个函数用来比较两个数-1是最大的，因为-1的所有位都是1，当然最大。</p>\n<h4 id=\"divideunsigned\"> divideUnsigned:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>divideUnsigned</span><span>(</span><span>int</span> dividend<span>,</span> <span>int</span> divisor<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>int</span><span>)</span><span>(</span><span>toUnsignedLong</span><span>(</span>dividend<span>)</span> <span>/</span> <span>toUnsignedLong</span><span>(</span>divisor<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>divide意为除的意思，这个方法就是将两个数转换为无符号的数，然后再相除。</p>\n<h4 id=\"remainderunsigned\"> remainderUnsigned:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>remainderUnsigned</span><span>(</span><span>int</span> dividend<span>,</span> <span>int</span> divisor<span>)</span> <span>{</span>\n        <span>// In lieu of tricky code, for now just use long arithmetic.</span>\n        <span>return</span> <span>(</span><span>int</span><span>)</span><span>(</span><span>toUnsignedLong</span><span>(</span>dividend<span>)</span> <span>%</span> <span>toUnsignedLong</span><span>(</span>divisor<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>将两个数转换为无符号的数，然后再计算余数,可以看到源码的注释 // In lieu of tricky code, for now just use long arithmetic.意思就是因为这个情况很棘手，所以现在暂时用long型数据，具体待我们看到<a href=\"https://www.jianshu.com/p/160c2bf8f781\" target=\"_blank\" rel=\"noopener noreferrer\">Long类的源码</a>时再研究</p>\n<h4 id=\"highestonebit\"> highestOneBit:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>highestOneBit</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        i <span>|=</span> <span>(</span>i <span>>></span>  <span>1</span><span>)</span><span>;</span>\n        i <span>|=</span> <span>(</span>i <span>>></span>  <span>2</span><span>)</span><span>;</span>\n        i <span>|=</span> <span>(</span>i <span>>></span>  <span>4</span><span>)</span><span>;</span>\n        i <span>|=</span> <span>(</span>i <span>>></span>  <span>8</span><span>)</span><span>;</span>\n        i <span>|=</span> <span>(</span>i <span>>></span> <span>16</span><span>)</span><span>;</span>\n        <span>return</span> i <span>-</span> <span>(</span>i <span>>></span><span>></span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>乍一看这个方法是干什么的，不明白。按照位运算|和移位运算一步一步的跟下来，你就会发现，将目标数转换为二进制后。保留这个数的最高位1，即从右边开始数第一个1保留。然后其它位全变为0后的结果。如10 ，二进制为1010，保留最高位1，其它位全变0就是1000，结果就为8.</p>\n<p>lowestOneBit：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>lowestOneBit</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>return</span> i <span>&amp;</span> <span>-</span>i<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>同highestOneBit类似，从左边开始数第1位1保留，其它全变0后的结果。</p>\n<h4 id=\"numberofleadingzeros\"> numberOfLeadingZeros：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>numberOfLeadingZeros</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>i <span>==</span> <span>0</span><span>)</span>\n            <span>return</span> <span>32</span><span>;</span>\n        <span>int</span> n <span>=</span> <span>1</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>>></span><span>></span> <span>16</span> <span>==</span> <span>0</span><span>)</span> <span>{</span> n <span>+=</span> <span>16</span><span>;</span> i <span>&lt;&lt;=</span> <span>16</span><span>;</span> <span>}</span>\n        <span>if</span> <span>(</span>i <span>>></span><span>></span> <span>24</span> <span>==</span> <span>0</span><span>)</span> <span>{</span> n <span>+=</span>  <span>8</span><span>;</span> i <span>&lt;&lt;=</span>  <span>8</span><span>;</span> <span>}</span>\n        <span>if</span> <span>(</span>i <span>>></span><span>></span> <span>28</span> <span>==</span> <span>0</span><span>)</span> <span>{</span> n <span>+=</span>  <span>4</span><span>;</span> i <span>&lt;&lt;=</span>  <span>4</span><span>;</span> <span>}</span>\n        <span>if</span> <span>(</span>i <span>>></span><span>></span> <span>30</span> <span>==</span> <span>0</span><span>)</span> <span>{</span> n <span>+=</span>  <span>2</span><span>;</span> i <span>&lt;&lt;=</span>  <span>2</span><span>;</span> <span>}</span>\n        n <span>-=</span> i <span>>></span><span>></span> <span>31</span><span>;</span>\n        <span>return</span> n<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这个函数的作用就是，取一个int类型数的二进制左边共有多少位0.如10的二进制为1010，int共有32位，那么左边就有28个0，即numberOfLeadingZeros(10)结果为28。这个方法作用很简单，但实现这个方法用的一个思想却是很重要，值得我们一学。有兴趣的同学可以看下我的别一篇文章<a href=\"http://aiceflower.farbox.com/post/ji-zhu-si-xiang/cong-jdkyuan-ma-kan-er-fen-si-xiang\" target=\"_blank\" rel=\"noopener noreferrer\">从JDK源码看二分思想</a>。</p>\n<h4 id=\"numberoftrailingzeros\"> numberOfTrailingZeros：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>numberOfTrailingZeros</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>int</span> y<span>;</span>\n        <span>if</span> <span>(</span>i <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>32</span><span>;</span>\n        <span>int</span> n <span>=</span> <span>31</span><span>;</span>\n        y <span>=</span> i <span>&lt;&lt;</span><span>16</span><span>;</span> <span>if</span> <span>(</span>y <span>!=</span> <span>0</span><span>)</span> <span>{</span> n <span>=</span> n <span>-</span><span>16</span><span>;</span> i <span>=</span> y<span>;</span> <span>}</span>\n        y <span>=</span> i <span>&lt;&lt;</span> <span>8</span><span>;</span> <span>if</span> <span>(</span>y <span>!=</span> <span>0</span><span>)</span> <span>{</span> n <span>=</span> n <span>-</span> <span>8</span><span>;</span> i <span>=</span> y<span>;</span> <span>}</span>\n        y <span>=</span> i <span>&lt;&lt;</span> <span>4</span><span>;</span> <span>if</span> <span>(</span>y <span>!=</span> <span>0</span><span>)</span> <span>{</span> n <span>=</span> n <span>-</span> <span>4</span><span>;</span> i <span>=</span> y<span>;</span> <span>}</span>\n        y <span>=</span> i <span>&lt;&lt;</span> <span>2</span><span>;</span> <span>if</span> <span>(</span>y <span>!=</span> <span>0</span><span>)</span> <span>{</span> n <span>=</span> n <span>-</span> <span>2</span><span>;</span> i <span>=</span> y<span>;</span> <span>}</span>\n        <span>return</span> n <span>-</span> <span>(</span><span>(</span>i <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>>></span><span>></span> <span>31</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>同numberOfLeadingZeros类似，这个方法的作用就是取一个int类型的二进制右边共有多少位0。如10的二进制为1010.右边共有1个0.numberOfTrailingZeros(10)结果就为1。</p>\n<h4 id=\"bitcount\"> bitCount：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>bitCount</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        i <span>=</span> i <span>-</span> <span>(</span><span>(</span>i <span>>></span><span>></span> <span>1</span><span>)</span> <span>&amp;</span> <span>0x55555555</span><span>)</span><span>;</span>\n        i <span>=</span> <span>(</span>i <span>&amp;</span> <span>0x33333333</span><span>)</span> <span>+</span> <span>(</span><span>(</span>i <span>>></span><span>></span> <span>2</span><span>)</span> <span>&amp;</span> <span>0x33333333</span><span>)</span><span>;</span>\n        i <span>=</span> <span>(</span>i <span>+</span> <span>(</span>i <span>>></span><span>></span> <span>4</span><span>)</span><span>)</span> <span>&amp;</span> <span>0x0f0f0f0f</span><span>;</span>\n        i <span>=</span> i <span>+</span> <span>(</span>i <span>>></span><span>></span> <span>8</span><span>)</span><span>;</span>\n        i <span>=</span> i <span>+</span> <span>(</span>i <span>>></span><span>></span> <span>16</span><span>)</span><span>;</span>\n        <span>return</span> i <span>&amp;</span> <span>0x3f</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这个方法的作用是，将一个int类型的数转换为二进制后，数里面有多少个1。如10，二进制为1010，有两个1，那么bitCount(10)结果就为2。其核心思想是使用二分法，两两一组相加，之后四个四个一组相加，接着八个八个，最后就得到各位之和了。 第一行是计算每两位中的 1 的个数 , 并且用该对应的两位来存储这个个数 , 如 : 01101100  转换后为 01011000 , 即先把前者每两位分段 01 10 11 00 , 分别有 1 1 2 0 个 1, 用两位二进制数表示为 01 01 10 00, 合起来为 01011000。 第二行是计算每四位中的 1 的个数 , 并且用该对应的四位来存储这个个数 。如 : 01101100 经过第一行计算后得 01011000 , 然后把 01011000 每四位分段成 0101 1000 , 段内移位相加 : 前段 01+01 =10 , 后段 10+00=10, 分别用四位二进制数表示为 0010 0010, 合起来为 00100010 . 下面的各行以此类推 , 分别计算每 8 位 ,16 位 ,32 位中的 1 的个数 。</p>\n<p>rotateLeft:</p>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>rotateLeft</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> distance<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>i <span>&lt;&lt;</span> distance<span>)</span> <span>|</span> <span>(</span>i <span>>></span><span>></span> <span>-</span>distance<span>)</span><span>;</span>\n       \n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>(i &lt;&lt; distance) 先把尾巴那几位空出来成0，然后(i &gt;&gt;&gt; -distance)获得前面的那几位，然后按位或运算，就旋转了，即循环左移。</p>\n<h4 id=\"rotateright\"> rotateRight:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>rotateRight</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> distance<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>i <span>>></span><span>></span> distance<span>)</span> <span>|</span> <span>(</span>i <span>&lt;&lt;</span> <span>-</span>distance<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>跟前面的rotateLeft一样，先把位置空出来，然后取得对应的二进制位，按位或运算，就成了。</p>\n<h4 id=\"reverse-2\"> reverse：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>reverse</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        i <span>=</span> <span>(</span>i <span>&amp;</span> <span>0x55555555</span><span>)</span> <span>&lt;&lt;</span> <span>1</span> <span>|</span> <span>(</span>i <span>>></span><span>></span> <span>1</span><span>)</span> <span>&amp;</span> <span>0x55555555</span><span>;</span>\n        i <span>=</span> <span>(</span>i <span>&amp;</span> <span>0x33333333</span><span>)</span> <span>&lt;&lt;</span> <span>2</span> <span>|</span> <span>(</span>i <span>>></span><span>></span> <span>2</span><span>)</span> <span>&amp;</span> <span>0x33333333</span><span>;</span>\n        i <span>=</span> <span>(</span>i <span>&amp;</span> <span>0x0f0f0f0f</span><span>)</span> <span>&lt;&lt;</span> <span>4</span> <span>|</span> <span>(</span>i <span>>></span><span>></span> <span>4</span><span>)</span> <span>&amp;</span> <span>0x0f0f0f0f</span><span>;</span>\n        i <span>=</span> <span>(</span>i <span>&lt;&lt;</span> <span>24</span><span>)</span> <span>|</span> <span>(</span><span>(</span>i <span>&amp;</span> <span>0xff00</span><span>)</span> <span>&lt;&lt;</span> <span>8</span><span>)</span> <span>|</span>\n            <span>(</span><span>(</span>i <span>>></span><span>></span> <span>8</span><span>)</span> <span>&amp;</span> <span>0xff00</span><span>)</span> <span>|</span> <span>(</span>i <span>>></span><span>></span> <span>24</span><span>)</span><span>;</span>\n        <span>return</span> i<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>将目标数转换为32位二进制数据后，高位和低位对应位置数据互换。如10转换为2进制后为00000000 000000000 00000000 0001010则转换后数据为01010000 00000000 00000000 00000000怎么样很好理解吧。其实Integer中的很多操作都是转换为二进制后，再处理的，光看代码很复杂。把数据转换成二进制，然后再对照代码看就很简单了。</p>\n<h4 id=\"signum\"> signum：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>signum</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>i <span>>></span> <span>31</span><span>)</span> <span>|</span> <span>(</span><span>-</span>i <span>>></span><span>></span> <span>31</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个方法我还没研究明白是干什么用的，i &gt;&gt; 31这个如果i为正数运算后全变为0，如果是负数运算后全变为1(指的是二进制位)，(-i &gt;&gt;&gt;31) 如果i为正数，运算后为1，如果i为负数运算后为0。两个数做|运算后，如果i为正则结果为1，如果为负数结果为-1，如果是0则结果为0，估计是运来判断一个数是正数负数还是0吧。如果是这样的话直接跟0做比较不就好了，写这段代码干什么呢，搞不明白。</p>\n<p>reverseBytes:</p>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>reverseBytes</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>(</span>i <span>>></span><span>></span> <span>24</span><span>)</span>           <span>)</span> <span>|</span>\n               <span>(</span><span>(</span>i <span>>></span>   <span>8</span><span>)</span> <span>&amp;</span>   <span>0xFF00</span><span>)</span> <span>|</span>\n               <span>(</span><span>(</span>i <span>&lt;&lt;</span>   <span>8</span><span>)</span> <span>&amp;</span> <span>0xFF0000</span><span>)</span> <span>|</span>\n               <span>(</span><span>(</span>i <span>&lt;&lt;</span> <span>24</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这个方法同Byte类的reverseBytes方法有点类似。但这里是高8位与低8位互换，中间的两个8位互换之后的结果。转换成二进制后就一目了然了，我就不举例了。</p>\n<h4 id=\"其它方法-3\"> 其它方法：</h4>\n<div><pre><code><span>//求两个数之和</span>\n<span>public</span> <span>static</span> <span>int</span> <span>sum</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n   <span>return</span> a <span>+</span> b<span>;</span>\n<span>}</span>\n<span>//取两个数中较大的数</span>\n<span>public</span> <span>static</span> <span>int</span> <span>max</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n    <span>return</span> Math<span>.</span><span>max</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>\n<span>}</span>\n<span>//取两个数中较小的数</span>\n<span>public</span> <span>static</span> <span>int</span> <span>min</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n    <span>return</span> Math<span>.</span><span>min</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>这几个方法挺简单的，大家一看就明白了。</p>\n<p>注：</p>\n<ul>\n<li>Integer类中的很多方法都是操作二进制数的。光看代码可能一头雾水，转换为二进制后，再辅助代码就直观多了。</li>\n<li>这个类中涉及了很多的位运算，如果对位运算不清楚的可以看下<a href=\"https://www.jianshu.com/p/26bedb3ae3c4\" target=\"_blank\" rel=\"noopener noreferrer\">一起学JDK源码 -- Byte类</a>和本章的基础知识部分。</li>\n<li>这个类中有一些方法如signum、reverseBytes等操作二进制数的思想到是很精彩。但实际不知道有什么用。不知道是作者炫耀它的思想，还是我太菜没看出来他的意图。</li>\n</ul>\n<h2 id=\"_9-long类\"> 9.Long类</h2>\n<p>Long类为java基本类型long的包装类，其中提供了一些处理long类型的方法。但是大部分方法名称和实现都同Integer类类似，本章中不与列出，可查看<a href=\"https://www.jianshu.com/p/e07d126ac1d0\" target=\"_blank\" rel=\"noopener noreferrer\">一起学JDK源码 -- Integer</a>查看相应的解释，本章只列出Integer类中没有实现的方法。</p>\n<h4 id=\"基础知识-5\"> 基础知识</h4>\n<p>1.java默认数值类型:</p>\n<ul>\n<li>java中数值类型分为整形(short、int、long)和浮点形(单精度浮点float，双精度浮点double)</li>\n<li>对于整数来说，缺省后缀的都视为int，long类型在数字末尾加l或L，推荐使用大写L,因为小写l看起来像数字1</li>\n<li>对于浮点数来说，缺省后缀的都视为double，double类型后缀为d，float类型后缀为f。注意 double d = 3f 可以，但 float f = 3d不可以</li>\n</ul>\n<p>2.访问修饰符：\njava中的访问修饰符是用来控制类及类中的方法和属性的访问权限的。共有以下四种:</p>\n<ul>\n<li>public： 用public修饰的类、类属变量及方法，包内及包外的任何类（包括子类和普通类）均可以访问；</li>\n<li>protected： 用protected修饰的类、类属变量及方法，包内的任何类及包外那些继承了该类的子类才能访问（此处稍后解释），protected重点突出继承；</li>\n<li>default： 如果一个类、类属变量及方法没有用任何修饰符（即没有用public、protected及private中任何一种修饰），则其访问权限为default（默认访问权限）。默认访问权限的类、类属变量及方法，包内的任何类（包括继承了此类的子类）都可以访问它，而对于包外的任何类都不能访问它（包括包外继承了此类的子类）。default重点突出包；</li>\n<li>用private修饰的类、类属变量及方法，只有本类可以访问，而包内包外的任何类均不能访问它。</li>\n</ul>\n<p>3数值溢出: java中的数值溢出是指当某一类型的数据无法承装一个数时出现结果错误显示的情况。啥，这是啥，我也不明白。举个例子： byte a = (byte)127; byte b = (byte)127; byte c = (byte)a + b; 结果是254? no，byte的范围是-128到127怎么可能出现254呢。这就出现了数值溢出的情况了。254转换为二进制就是0000000011111110，而byte只有8位，取8位也就是11111110这个数转换为10进制就是-2 ，所以上述结果为-2，超出byte范围的二进制被舍去，也就是我们常说的溢出了，其它类型数值运算结果超出某一类型所表示的范围，或大类型的数据转换为小类型的数据都有可能出现数值溢出的情况。原理跟这个类似。</p>\n<h4 id=\"tounsignedbiginteger\"> toUnsignedBigInteger:</h4>\n<div><pre><code><span>private</span> <span>static</span> <span>BigInteger</span> <span>toUnsignedBigInteger</span><span>(</span><span><span>long</span></span> i<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>i <span>>=</span> <span>0L</span><span>)</span>\n            <span>return</span> BigInteger<span>.</span><span>valueOf</span><span>(</span>i<span>)</span><span>;</span>\n        <span>else</span> <span>{</span>\n            <span><span>int</span></span> upper <span>=</span> <span>(</span><span>int</span><span>)</span> <span>(</span>i <span>>></span><span>></span> <span>32</span><span>)</span><span>;</span>\n            <span><span>int</span></span> lower <span>=</span> <span>(</span><span>int</span><span>)</span> i<span>;</span>\n\n            <span>// return (upper &lt;&lt; 32) + lower</span>\n            <span>return</span> <span>(</span>BigInteger<span>.</span><span>valueOf</span><span>(</span>Integer<span>.</span><span>toUnsignedLong</span><span>(</span>upper<span>)</span><span>)</span><span>)</span><span>.</span><span>shiftLeft</span><span>(</span><span>32</span><span>)</span><span>.</span>\n                <span>add</span><span>(</span>BigInteger<span>.</span><span>valueOf</span><span>(</span>Integer<span>.</span><span>toUnsignedLong</span><span>(</span>lower<span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>这个方法的作用是将long类型的数字转换为无符号的BigInteger类型(这是一个可以承装很大类型数据的类，如一个数据超出了int的范围，甚至超出了long的范围，那么我们就可以使用BigInteger类来承装这个数据。BigInteger内部维护了int类型的数组，想象一下，一个数组最大长度为 Integer.MAX_VALUE 大约20 多亿，int最大20 多亿，20亿 * 20亿 多大的数大概都能装下吧，这里只是简单说了下BigInteger，更多关于BigInteger类，等我们看到[BigInteger类源码]的时候再讲解)。\n第一步：判断目标数i是否为0，如果为0直接调用BigInteger.valueOf(i)返回BigInteger对象\n第二步：如果不为0，将long类型的数字拆分为高32位upper和低32位lower。\n第三步：将高32位和低32位的数字使用Integer的方法转换为无符号Long类型，然后调用BigInteger的add方法(就是两个数相加，只不过这里可以相加两个超大的数而不出现溢出)把两个数加起来。</p>\n<h4 id=\"remainderunsigned-long-dividend-long-divisor\"> remainderUnsigned(long dividend, long divisor):</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>long</span> <span>remainderUnsigned</span><span>(</span><span>long</span> dividend<span>,</span> <span>long</span> divisor<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>dividend <span>></span> <span>0</span> <span>&amp;&amp;</span> divisor <span>></span> <span>0</span><span>)</span> <span>{</span> <span>// signed comparisons</span>\n            <span>return</span> dividend <span>%</span> divisor<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>if</span> <span>(</span><span>compareUnsigned</span><span>(</span>dividend<span>,</span> divisor<span>)</span> <span>&lt;</span> <span>0</span><span>)</span> <span>// Avoid explicit check for 0 divisor</span>\n                <span>return</span> dividend<span>;</span>\n            <span>else</span>\n                <span>return</span> <span>toUnsignedBigInteger</span><span>(</span>dividend<span>)</span><span>.</span>\n                    <span>remainder</span><span>(</span><span>toUnsignedBigInteger</span><span>(</span>divisor<span>)</span><span>)</span><span>.</span><span>longValue</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这个方法的作用就是将两个数转换为无符号的数然后求余数。首先对于两个正数，无有无符号之分直接求余数就可以了。然后比较两个数的大小，如果前一个数比后一个数小，余数为前一个数，道理也很简单一个小的数除以一个大的数商为0余数为这个小的数。接着如果前一个数比后一个数大。那么先将这两个数转换为无符号的BigInteger类型。然后再对这两个数进行求余数的操作。最后将结果转换为long类型返回。</p>\n<h2 id=\"_10-float类\"> 10.Float类</h2>\n<p>前面几篇文章我们看了JAVA基本数据类型整型的包装类，接下来我们看下浮点型float的包装类Float类。</p>\n<h4 id=\"基础知识-6\"> 基础知识：</h4>\n<p>1.IEEE 754：\nIEEE 754是一个标准，该标准定义了浮点数的格式还有一些特殊值，它规定了计算机中二进制与十进制浮点数转换的格式及方法。规定了四种表示浮点数值的方法，单精确度（32位）、双精确度（64位）、延伸单精确度（43位以上）与延伸双精确度（79位以上）。JAVA语言支持这里的单精确度float，与双精确度double。\n2.无穷大：\nJAVA中用Infinity表示正无穷大，任何有限正数除以0为正无穷大，正无穷的值为0x7f800000。用-Infinity表示负无穷大，任何有限负数除以0为负无穷的，负无穷的值为0xff800000。\n3.NAN：\n不是一个数(not a number ),NaN 用来表示处理计算中出现的错误情况，比如0除以0或负数平方根。</p>\n<h4 id=\"主要属性\"> 主要属性:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>float</span> POSITIVE_INFINITY <span>=</span> <span>1.0f</span> <span>/</span> <span>0.0f</span><span>;</span>\n\n<span>public</span> <span>static</span> <span>final</span> <span>float</span> NEGATIVE_INFINITY <span>=</span> <span>-</span><span>1.0f</span> <span>/</span> <span>0.0f</span><span>;</span>\n\n<span>public</span> <span>static</span> <span>final</span> <span>float</span> <span>NaN</span> <span>=</span> <span>0.0f</span> <span>/</span> <span>0.0f</span><span>;</span>\n\n<span>public</span> <span>static</span> <span>final</span> <span>float</span> MAX_VALUE <span>=</span> <span>0x1.fffffeP+127f</span><span>;</span>\n\n<span>public</span> <span>static</span> <span>final</span> <span>float</span> MIN_NORMAL <span>=</span> <span>0x1.0p-126f</span><span>;</span>\n\n<span>public</span> <span>static</span> <span>final</span> <span>float</span> MIN_VALUE <span>=</span> <span>0x0.000002P-126f</span><span>;</span>\n\n<span>public</span> <span>static</span> <span>final</span> <span>int</span> MAX_EXPONENT <span>=</span> <span>127</span><span>;</span>\n\n<span>public</span> <span>static</span> <span>final</span> <span>int</span> MIN_EXPONENT <span>=</span> <span>-</span><span>126</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>POSITIVE_INFINITY 表示正无穷大，其值为0x7f800000。\nNEGATIVE_INFINITY 表示负无穷大，其值为0xff800000。\nNaN 表示计算出错的情况，NaN 实际上是一个数，而是一族数。\nMAX_VALUE最大的浮点数值，其值为3.4028235E38，即2的127次方。\nMIN_NORMAL 用来表示最小标准值，它定义为0x1.0p-126f，这里其实就是2的-126次方的了，值为1.17549435E-38f。\nMIN_VALUE 最小的浮点数值，其值为1.4e-45f。\nMAX_EXPONENT用来表示指数的最大值，这里定为127。\nMIN_EXPONENT 用来表示指数的最小值，这里定为-126。</p>\n<h4 id=\"tostring-float-f\"> toString(float f):</h4>\n<div><pre><code><span>public</span> <span>static</span> String <span>toString</span><span>(</span><span>float</span> f<span>)</span> <span>{</span>\n        <span>return</span> FloatingDecimal<span>.</span><span>toJavaFormatString</span><span>(</span>f<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>通过FloatingDecimal类的toJavaFormatString方法转成字符串。它处理的过程是先将浮点数转成IEEE-754标准的二进制形式，并且还要判断是否是正负无穷大，是否是NaN。然后再按照IEEE-754标准从二进制转换成十进制，最后生成浮点数对应的字符串。</p>\n<h4 id=\"tohexstring-float-f\"> toHexString(float f) :</h4>\n<div><pre><code><span>public</span> <span>static</span> String <span>toHexString</span><span>(</span><span>float</span> f<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>Math<span>.</span><span>abs</span><span>(</span>f<span>)</span> <span>&lt;</span> FloatConsts<span>.</span>MIN_NORMAL\n            <span>&amp;&amp;</span>  f <span>!=</span> <span>0.0f</span> <span>)</span> <span>{</span>\n            String s <span>=</span> Double<span>.</span><span>toHexString</span><span>(</span>Math<span>.</span><span>scalb</span><span>(</span><span>(</span><span>double</span><span>)</span>f<span>,</span>\n                                                     DoubleConsts<span>.</span>MIN_EXPONENT<span>-</span>\n                                                     FloatConsts<span>.</span>MIN_EXPONENT<span>)</span><span>)</span><span>;</span>\n            <span>return</span> s<span>.</span><span>replaceFirst</span><span>(</span><span>\"p-1022$\"</span><span>,</span> <span>\"p-126\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>else</span>\n            <span>return</span> Double<span>.</span><span>toHexString</span><span>(</span>f<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>看方法名就知道是将，float转换成16进制表示的形式，这里先会判断下目标数f，如果是NaN则返回字符串&quot;NaN&quot;,如果是正无穷大，则返回Infinity。如果是负无穷大则返回-Infinity。如果f为0，则用返回&quot;0x0.0p0&quot;，-0则返回&quot;-0x0.0p0&quot;。如果f是具有标准化表示形式的float值，则使用子字符串表示有效位数和指数。有效位数用字符串&quot;0x1.&quot;表示，后跟该有效位数小数部分的小写十六进制表示形式。除非所有位数都为0，否则移除十六进制表示形式中的尾部0，在所有位数为0的情况下，可以用一个0表示，然后用&quot;p&quot;表示指数，后跟无偏指数的十进制字符串，该值与对指数值调用Integer.toString生成的值相同。如果f是具有subnormal表示形式的float值，则用字符&quot;0x0.&quot;表示有效位数，后跟该有效位数小数部分的十六进制表示形式，移除十六进制表示形式中的尾部0，然后用&quot;p-126&quot;表示指数。注意，在subnormal有效位数中，必须至少有一个非0位数。（网上摘的，我也看不大懂）</p>\n<h4 id=\"valueof\"> valueOf</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>Float</span> <span>valueOf</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>Float</span><span>(</span><span>parseFloat</span><span>(</span>s<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>static</span> <span>Float</span> <span>valueOf</span><span>(</span><span>float</span> f<span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>Float</span><span>(</span>f<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>返回对应浮点数的Float对象，可以看到在Float类中没有像Byte或是Integer类那样将常用的数存放到缓存池中。这里是直接创建对象，然后返回。</p>\n<h4 id=\"parsefloat-string-s\"> parseFloat(String s) :</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>float</span> <span>parseFloat</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>FloatingDecimal</span><span>.</span><span>parseFloat</span><span>(</span>s<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>通过调用FloatingDecimal的parseFloat方法来实现对字符串的转换.这里会先判断s是否为NaN,Infinity,-Infinity等数。如果是以0x打头则会按<a href=\"http://aiceflower.farbox.com/post/javaji-zhu-hun-za/javazhong-de-jin-zhi-zhuan-huan\" target=\"_blank\" rel=\"noopener noreferrer\">16进制转换为10进制转换</a>。判断是否包含了E字符，即是否是科学计数法，如果有则需要处理。</p>\n<h4 id=\"isnan\"> isNaN:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>boolean</span> <span>isNaN</span><span>(</span><span>float</span> v<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>v <span>!=</span> v<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>判断一个数是否是NaN，该方法逻辑很简单，直接判断一个数是否与自己相等，因为规定一个NaN与任何值都不相等，包括它自己。这部分逻辑在JVM中会做，这里直接通过比较来判断就可以了。</p>\n<h4 id=\"isinfinite\"> isInfinite</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>boolean</span> <span>isInfinite</span><span>(</span><span>float</span> v<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>v <span>==</span> POSITIVE_INFINITY<span>)</span> <span>||</span> <span>(</span>v <span>==</span> NEGATIVE_INFINITY<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>判断一个数是否为无穷数，无穷大POSITIVE_INFINITY或无穷小NEGATIVE_INFINITY。</p>\n<h4 id=\"isfinite\"> isFinite:</h4>\n<div><pre><code><span>public</span> <span>static</span> boolean <span>isFinite</span><span>(</span><span>float</span> f<span>)</span> <span>{</span>\n        <span>return</span> Math<span>.</span><span>abs</span><span>(</span>f<span>)</span> <span>&lt;=</span> FloatConsts<span>.</span>MAX_VALUE<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>判断一个数是否为有穷数。绝对值（Math.abs(f)是用来获取一个数的绝对值的）小于FloatConsts.MAX_VALUE的数则为有穷数，FloatConsts.MAX_VALUE的值为3.4028235e+38f，它其实与Float类中定义的MAX_VALUE相同。</p>\n<h4 id=\"floattorawintbits\"> floatToRawIntBits:</h4>\n<div><pre><code> <span>public</span> <span>static</span> native <span><span>int</span></span> <span>floatToRawIntBits</span><span>(</span><span><span>float</span></span> <span>value</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>floatToRawIntBits是一个本地方法，该方法主要是将一个浮点数转成IEEE 754标准的二进制形式对应的整型数。用其它语言实现。</p>\n<h4 id=\"floattointbits\"> floatToIntBits:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span><span>int</span></span> <span>floatToIntBits</span><span>(</span><span><span>float</span></span> <span>value</span><span>)</span> <span>{</span>\n    <span><span>int</span></span> result <span>=</span> <span>floatToRawIntBits</span><span>(</span><span>value</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span> <span>(</span><span>(</span>result <span>&amp;</span> FloatConsts<span>.</span>EXP_BIT_MASK<span>)</span> <span>==</span>\n          FloatConsts<span>.</span>EXP_BIT_MASK<span>)</span> <span>&amp;&amp;</span>\n         <span>(</span>result <span>&amp;</span> FloatConsts<span>.</span>SIGNIF_BIT_MASK<span>)</span> <span>!=</span> <span>0</span><span>)</span>\n        result <span>=</span> <span>0x7fc00000</span><span>;</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>该方法主要先通过调用floatToRawIntBits获取到IEEE 754标准对应的整型数，然后再分别用FloatConsts.EXP_BIT_MASK和FloatConsts.SIGNIF_BIT_MASK两个掩码去判断是否为NaN，0x7fc00000对应的即为NaN。</p>\n<h4 id=\"intbitstofloat\"> intBitsToFloat:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>native</span> <span>float</span> <span>intBitsToFloat</span><span>(</span><span>int</span> bits<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>该方法与floatToRawIntBits方法对应，intBitsToFloat同样是一个本地方法，该方法主要是将一个IEEE 754标准的二进制形式对应的整型数转成一个浮点数。用其它语言实现。</p>\n<h4 id=\"sum\"> sum:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>float</span> <span>sum</span><span>(</span><span>float</span> a<span>,</span> <span>float</span> b<span>)</span> <span>{</span>\n        <span>return</span> a <span>+</span> b<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>计算两个浮点数的和。</p>\n<h4 id=\"max\"> max:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>float</span> <span>max</span><span>(</span><span>float</span> a<span>,</span> <span>float</span> b<span>)</span> <span>{</span>\n        <span>return</span> Math<span>.</span><span>max</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>取两个浮点数中较大的一个。</p>\n<h4 id=\"min\"> min:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>float</span> <span>min</span><span>(</span><span>float</span> a<span>,</span> <span>float</span> b<span>)</span> <span>{</span>\n        <span>return</span> Math<span>.</span><span>min</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>取两个浮点数中较小的一个。</p>\n<h2 id=\"_11-double类\"> 11.Double类</h2>\n<h4 id=\"基础知识-7\"> 基础知识：</h4>\n<p>1.浮点数的表示：\n浮点数由三部分组成，符号位s、指数e和尾数f。\n对于float表示如下\n0                       00000000            00000000000000000000000\nsign(1bit)        exponent(8bit)                fraction(23bit)                                   共32bit\n对于求值我们是有一个公式对应的，某个浮点数的值为：\n(−1)^s ∗    (1.f)   ∗   2^(e−127)\n可以看到32位的最高位为符号标识符，1表示负数，0表示正数。指数部分为8位，其实可以是0到255，但是为了可正可负，这里需要减去127后才是真正的指数，而底数固定为2。剩下的23位表示尾数，但默认前面都会加上1.。所以通过上面就可以将一个浮点数表示出来了。\n我们举个例子来看，二进制的“01000001001101100000000000000000”表示的浮点数是啥？\n符号位为0，表示正数。\n指数为“10000010”，减去127后为3。\n尾数对应的值为“1.011011”。\n于是最终得到浮点数为“1011.011”，转成十进制为“11.375”。\n2.精度丢失:\n对float或double 的使用不当，可能会出现精度丢失的问题。浮点运算很少是精确的，只要是超过精度能表示的范围就会产生误差。往往产生误差不是 因为数的大小，而是因为数的精度。因此，产生的结果接近但不等于想要的结果。尤其在使用 float 和 double 作精确运 算的时候要特别小心。如:\nSystem.out.println(0.1d + 0.2d);这个输出的结果不是我们想要的0.3而是0.30000000000000004。这就是java中的精度丢失。可以使用如下方式解决：</p>\n<div><pre><code><span>BigDecimal</span> b1 <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>\"0.1\"</span><span>)</span><span>;</span>\n<span>BigDecimal</span> b2 <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>\"0.2\"</span><span>)</span><span>;</span>\nSystem<span>.</span><span>out</span><span>.</span><span>println</span><span>(</span>b1<span>.</span><span>add</span><span>(</span>b2<span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>所以大家在遇到金钱等对精度要求较高的业务时最好不要使用浮点类型的数。可以考虑使用BigDecimal。或是把单位转换成分，这样处理的数字都是整数，最后再化成小数。这样就不会出现精度丢失的问题了。</p>\n<h2 id=\"_12-boolean类\"> 12.Boolean类</h2>\n<p>boolean java基本数据类型之一，只有两个取值：true 和 false 这种类型只作为一种标志来记录 true/false ，其包装类为Boolean类，里面提供了一些处理boolean类型的方法。接下来让我们看一下Boolean类的具体实现。</p>\n<h3 id=\"基础知识-8\"> 基础知识</h3>\n<p>1.java中判断是否相等：\njava中相等的判断有两中方式，一种是使用操作符==，一种是使用对象的equals方法。\n== ：对于基本数据类型==是数值比较，且基本数据类型只能用==进行比较，对于引用数据类型==比较的是地址值。\nequals：比较两个对象是否相等。如java中有两个Person对象，对于现实中要比较这两个人是否相同，只需要比较其姓名，身份证是否相同就可以了，在java中是两个对象，自然有不同的地址，若是用==进行比较这两个Person显示不是同一个，这时就需要通过重写equals方法实现自己的比较逻辑来判断两个Person是否相等。\n2.对象的排序\njava中对象是通过Collections.sort进行排序的，有两种情况，一种是让对象本身具有比较的特性，对象需要实现Comparable接口实现其compareTo方法；一种是创建一个新的比较器类，该类要实现Comparator接口，实现其compare方法。\n3.设置与获取系统属性\n设置： 通过-Dkey=value的形式设置系统属性\n在eclipse中设置：\nRun--&gt;Run Confgurations--&gt;然后在对话框的右边选择Arguments--&gt;然后在VM arguments中输入-Dkey=value\n在命令行中设置：\njava -Dkey=value -jar Test.jar\n获取：System.getProperty(propertyName)</p>\n<h3 id=\"boolean类\"> Boolean类：</h3>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Boolean</span> <span>implements</span> <span>Serializable</span><span>,</span><span>Comparable</span><span><span>&lt;</span><span>Boolean</span><span>></span></span><span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>可以看到Boolean类是final的不能被继承，同时他实现了Comparable说明对象本身具有比较性。</p>\n<p>主要属性</p>\n<div><pre><code><span>private</span> <span>final</span> <span>boolean</span> value<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>用于保存Boolean对象的值，而且是final的，一但初始化完成，不能被修改。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>final</span> Boolean <span>TRUE</span> <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>true</span><span>)</span><span>;</span>\n<span>public</span> <span>static</span> <span>final</span> Boolean <span>FALSE</span> <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>false</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>全局的不可改变的两个Boolean对象。对于布尔值也就只有两种状态，即我们可以使用以上这两个Boolean对象表示所有的布尔值。提供这两个静态变量相当于对Boolean对象的&quot;缓存&quot;,是为了让开发者直接使用这两个变量而不是每次都创建新的Boolean对象，这样既节省内存又避免了创建一个新实例的时间开销。</p>\n<div><pre><code><span>public</span> <span>Boolean</span><span>(</span><span>boolean</span> <span>value</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span><span>value</span> <span>=</span> <span>value</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>Boolean</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n    <span>this</span><span>(</span><span>toBoolean</span><span>(</span>s<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n<span>private</span> <span>static</span> <span>boolean</span> <span>toBoolean</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>(</span>name <span>!=</span> <span>null</span><span>)</span> <span>&amp;&amp;</span> name<span>.</span><span>equalsIgnoreCase</span><span>(</span><span>\"true\"</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>两种构造方法，一种传入boolean值，一种传入一个字符串，传入字符会进行&quot;to boolean&quot;解析，即当传入的字符串忽略大小写等于&quot;true&quot;时判断为true，否则为false。\n一般我们不推荐直接用构造函数来创建Boolean对象，使用全局变量TRUE 、FALSE 或是使用Boolean.valueOf方法即可，避免生成不必要的对象。</p>\n<h3 id=\"parseboolean\"> parseBoolean:</h3>\n<div><pre><code><span>public</span> <span>static</span> <span>boolean</span> <span>parseBoolean</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n    <span>return</span> <span>toBoolean</span><span>(</span>s<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>将字符串转换为boolean值，调用了toBoolean方法。只有当传入的字符串忽略大小写为&quot;true&quot;时返回true否则返回false。</p>\n<h3 id=\"booleanvalue\"> booleanValue:</h3>\n<div><pre><code><span>public</span> <span>boolean</span> <span>booleanValue</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>value</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>返回本对象的布尔值。</p>\n<h3 id=\"valueof-2\"> valueOf:</h3>\n<div><pre><code><span>public</span> <span>static</span> Boolean <span>valueOf</span><span>(</span>boolean b<span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>b <span>?</span> <span>TRUE</span> <span>:</span> <span>FALSE</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>static</span> Boolean <span>valueOf</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n    <span>return</span> <span>toBoolean</span><span>(</span>s<span>)</span> <span>?</span> <span>TRUE</span> <span>:</span> <span>FALSE</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>valueOf方法用于返回对应的Boolean对象，这里可以看成从&quot;缓存&quot;中获取Boolean对象，因为布尔类型只有两种状态。</p>\n<h3 id=\"tostring-3\"> toString:</h3>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>toString</span><span>(</span><span>boolean</span> b<span>)</span> <span>{</span>\n    <span>return</span> b <span>?</span> <span>\"true\"</span> <span>:</span> <span>\"false\"</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>value</span> <span>?</span> <span>\"true\"</span> <span>:</span> <span>\"false\"</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果为true返回字符串&quot;true&quot;如果为false返回字符串&quot;false&quot;。</p>\n<h3 id=\"hashcode-3\"> hashCode:</h3>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>value</span> <span>?</span> <span>1231</span> <span>:</span> <span>1237</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>true返回1231，false返回1237。</p>\n<p>equals:</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object obj</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>obj <span>instanceof</span> <span>Boolean</span><span>)</span> <span>{</span>\n        <span>return</span> value <span>==</span> <span>(</span><span>(</span>Boolean<span>)</span>obj<span>)</span><span>.</span><span>booleanValue</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>先判断对象是否是Boolean类型，如果是再比较它们的值是否相等。</p>\n<h3 id=\"getboolean\"> getBoolean:</h3>\n<div><pre><code><span>public</span> <span>static</span> <span>boolean</span> <span>getBoolean</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n    <span>boolean</span> result <span>=</span> <span>false</span><span>;</span>\n    <span>try</span> <span>{</span>\n        result <span>=</span> <span>toBoolean</span><span>(</span><span>System</span><span>.</span><span>getProperty</span><span>(</span>name<span>)</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>IllegalArgumentException</span> e<span>)</span> <span>{</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>NullPointerException</span> e<span>)</span> <span>{</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>根据给定的名称查询系统中是否存在该属性，如果存在且为true则返回true，否则返回false。根据程序需要可以提前设置一些系统属性，使用System.getProperty(name)获取设置的系统属性。</p>\n<h3 id=\"compareto-3\"> compareTo:</h3>\n<div><pre><code><span>public</span> <span><span>int</span></span> <span>compareTo</span><span>(</span><span>Boolean</span> b<span>)</span> <span>{</span>\n    <span>return</span> <span>compare</span><span>(</span><span>this</span><span>.</span><span>value</span><span>,</span> b<span>.</span><span>value</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>static</span> <span><span>int</span></span> <span>compare</span><span>(</span><span>boolean</span> x<span>,</span> <span>boolean</span> y<span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>x <span>==</span> y<span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>x <span>?</span> <span>1</span> <span>:</span> <span>-</span><span>1</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>compareTo用于比较两个布尔值的大小true大于false，compareTo调用了compare方法。(x == y) ? 0 : (x ? 1 : -1)如果相等返回0，如果不等x为true则y为false返回1，否则返回-1。compareTo是实现的Comparable接口中的方法，该方法返回0表示本对象与传入的对象相等，返回正数表示本对象比传入的对象大，返回负数表示本对象比传入的对象小。</p>\n<h2 id=\"_13-system类\"> 13.System类</h2>\n<p>说起System类，对我们来说既熟悉又陌生，熟悉的是我们刚接触java时就会用到这个类，甚至每天写代码也会用到这个类(System.out.println())；陌生的是我们对这个类一知半解，它是如何实现的，为什么这样写就能在屏幕上输出东西。今天就让我们通过阅读它的源码揭开它那神秘的面纱。</p>\n<h3 id=\"基础知识-9\"> 基础知识：</h3>\n<h4 id=\"深拷贝与浅拷贝\"> 深拷贝与浅拷贝:</h4>\n<p>浅拷贝：只是简单的对对象的引用进行复制。\n深拷贝：拷贝对象的值和对象的内容。</p>\n<h3 id=\"类定义\"> 类定义：</h3>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>System</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>System类是被final修饰的，不能被继承。</p>\n<p>成员变量：</p>\n<div><pre><code><span>//标准输入流，一般接收键盘输入</span>\n<span>public</span> <span>final</span> <span>static</span> <span>InputStream</span> in <span>=</span> <span>null</span><span>;</span>\n<span>//标准输出流，向控制台输出正确信息</span>\n<span>public</span> <span>final</span> <span>static</span> <span>PrintStream</span> out <span>=</span> <span>null</span>\n<span>//标准输出流，向控制台输出错误信息</span>\n<span>public</span> <span>final</span> <span>static</span> <span>PrintStream</span> err <span>=</span> <span>null</span><span>;</span>\n<span>//安全管理器，用volatile关键字修饰，表示对象在多个线程间可见</span>\n<span>private</span> <span>static</span> <span>volatile</span> <span>SecurityManager</span> security <span>=</span> <span>null</span><span>;</span>\n<span>//JAVA控制台对象与JAVA虚拟机相联，接收控制台输入，或向控制台输出信息。只能在控制台运行代码，否则获得对象为null。</span>\n<span>private</span> <span>static</span> <span>volatile</span> <span>Console</span> cons <span>=</span> <span>null</span><span>;</span>\n<span>//用于承装系统属性，如os.name os.version等</span>\n<span>private</span> <span>static</span> <span>Properties</span> props<span>;</span>\n<span>//换行符widows返回\"\\r\\n\",UNIX系统返回\"\\n\"</span>\n<span>private</span> <span>static</span> <span>String</span> lineSeparator<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>看到这些成员变量，有些是公有的，有些是私有的。这些对象被赋值为null，而且有的被final修饰不能被重新赋值。找遍整个类也没看到在哪里初始化这些对象。但我们使用System.out.println();的时候并没有报错啊。能够使用，就说明对象在谋个时刻被创建了，那到底这些对象是什么时候被创建的呢。怀着无比好奇的心理，在类中查找，忽然我看到了如下代码。</p>\n<div><pre><code><span>static</span> <span>{</span>\n    <span>registerNatives</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>private</span> <span>static</span> <span>native</span> <span>void</span> <span>registerNatives</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>静态代码块，类被加载的时候执行，会不会这些对象是在registerNatives方法中创建的呢。再一看这个方法是本地方法。看下注释，也看不懂，但隐约能看到VM啊，initializer啊，initializeSystemClass method之类的，找了一下，发现类中有一个initializeSystemClass方法，大概能猜到，是VM会执行这个方法。</p>\n<div><pre><code><span>private</span> <span>static</span> <span><span>void</span></span> <span>initializeSystemClass</span><span>(</span><span>)</span> <span>{</span>\n    props <span>=</span> <span>new</span> <span>Properties</span><span>(</span><span>)</span><span>;</span>\n    <span>initProperties</span><span>(</span>props<span>)</span><span>;</span>  <span>// initialized by the VM</span>\n    sun<span>.</span>misc<span>.</span>VM<span>.</span><span>saveAndRemoveProperties</span><span>(</span>props<span>)</span><span>;</span>\n    lineSeparator <span>=</span> props<span>.</span><span>getProperty</span><span>(</span><span>\"line.separator\"</span><span>)</span><span>;</span>\n    sun<span>.</span>misc<span>.</span>Version<span>.</span><span>init</span><span>(</span><span>)</span><span>;</span>\n    <span>FileInputStream</span> fdIn <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span>FileDescriptor<span>.</span><span>in</span><span>)</span><span>;</span>\n    <span>FileOutputStream</span> fdOut <span>=</span> <span>new</span> <span>FileOutputStream</span><span>(</span>FileDescriptor<span>.</span><span>out</span><span>)</span><span>;</span>\n    <span>FileOutputStream</span> fdErr <span>=</span> <span>new</span> <span>FileOutputStream</span><span>(</span>FileDescriptor<span>.</span>err<span>)</span><span>;</span>\n    <span>setIn0</span><span>(</span><span>new</span> <span>BufferedInputStream</span><span>(</span>fdIn<span>)</span><span>)</span><span>;</span>\n    <span>setOut0</span><span>(</span><span>newPrintStream</span><span>(</span>fdOut<span>,</span> props<span>.</span><span>getProperty</span><span>(</span><span>\"sun.stdout.encoding\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>setErr0</span><span>(</span><span>newPrintStream</span><span>(</span>fdErr<span>,</span> props<span>.</span><span>getProperty</span><span>(</span><span>\"sun.stderr.encoding\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>loadLibrary</span><span>(</span><span>\"zip\"</span><span>)</span><span>;</span>\n    Terminator<span>.</span><span>setup</span><span>(</span><span>)</span><span>;</span>\n    sun<span>.</span>misc<span>.</span>VM<span>.</span><span>initializeOSEnvironment</span><span>(</span><span>)</span><span>;</span>\n    <span>Thread</span> current <span>=</span> Thread<span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>\n    current<span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>.</span><span>add</span><span>(</span>current<span>)</span><span>;</span>\n    <span>setJavaLangAccess</span><span>(</span><span>)</span><span>;</span>\n    sun<span>.</span>misc<span>.</span>VM<span>.</span><span>booted</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>在这个方法中可以看到刚才那些对象都是在这里被创建的。\nlineSeparator = props.getProperty(&quot;line.separator&quot;);从系统中获取换行符。\nsetIn0(new BufferedInputStream(fdIn));设置标准输入流，也就是创建in对象，追溯到源头也就是创建了FileDescriptor.in对象，这个对象用于操作标准输入流，再往深了就到了虚拟机内部实现细节了，这里就有展开了，有兴趣的同学可以自行研究。\n其它的对象像out、err创建过程同in类似。到这里我们终于明白了为什么执行System.out.println()时会向控制台输出东西了。</p>\n<h3 id=\"构造函数-2\"> 构造函数：</h3>\n<div><pre><code><span>private</span> <span>System</span><span>(</span><span>)</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>可以看到System类就一个构造函数，而且被私有化了，不允许我们创建对象。如果要使用这个类，只能使用类中的一些静态成员。这也是java中单例模式的雏形，把构造私有化，然后对外提供一个内部创建的唯一的对象，就形成单例了。</p>\n<h3 id=\"其它函数\"> 其它函数：</h3>\n<h4 id=\"setin\"> setIn:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>setIn</span><span>(</span><span>InputStream</span> in<span>)</span> <span>{</span>\n    <span>checkIO</span><span>(</span><span>)</span><span>;</span>\n    <span>setIn0</span><span>(</span>in<span>)</span><span>;</span>\n<span>}</span>\n<span>//对setIo进行安全检查</span>\n<span>private</span> <span>static</span> <span>void</span> <span>checkIO</span><span>(</span><span>)</span> <span>{</span>\n    <span>SecurityManager</span> sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        sm<span>.</span><span>checkPermission</span><span>(</span><span>new</span> <span>RuntimePermission</span><span>(</span><span>\"setIO\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>//给System.in重新赋值，内部实现。</span>\n<span>private</span> <span>static</span> <span>native</span> <span>void</span> <span>setIn0</span><span>(</span><span>InputStream</span> in<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>给System.in对象重新赋值。即当调用了些方法后，我们再使用System.in的时候接收的信息不再是从键盘录入了，而是我们指定的文件或设备。点开函数可以看到，第一个函数是进行安全检查的，第二个函数是调用的本地方法。有人疑惑System.in变量不是被final修饰了吗，为什么还可以被修改。额...这个...它调用的是本地方法，由虚拟机内部实现，他是老大能不能改变他说了算。</p>\n<h4 id=\"setout\"> setOut:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span><span>void</span></span> <span>setOut</span><span>(</span>PrintStream <span>out</span><span>)</span> <span>{</span>\n    <span>checkIO</span><span>(</span><span>)</span><span>;</span>\n    <span>setOut0</span><span>(</span><span>out</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>给System.out重新赋值，原理同setIn。比如我们想让System.out.println()把内容输出到文件，就可以调用这个方法，指定输出文件。</p>\n<h4 id=\"seterr\"> setErr:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>setErr</span><span>(</span>PrintStream err<span>)</span> <span>{</span>\n    <span>checkIO</span><span>(</span><span>)</span><span>;</span>\n    <span>setErr0</span><span>(</span>err<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>给System.err重新赋值，原理同setOut。</p>\n<h4 id=\"console\"> console:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>Console</span> <span>console</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>cons <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        <span>synchronized</span> <span>(</span><span>System</span><span>.</span><span>class</span><span>)</span> <span>{</span>\n            cons <span>=</span> <span><span>sun<span>.</span>misc<span>.</span></span>SharedSecrets</span><span>.</span><span>getJavaIOAccess</span><span>(</span><span>)</span><span>.</span><span>console</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> cons<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>返回唯一的Console对象，这个对象是跟Java虚拟机相关联的。可以看到这里使用了synchronized代码块，避免多线程调用的时候返回多个Console对象。</p>\n<h4 id=\"inheritedchannel\"> inheritedChannel:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>Channel</span> <span>inheritedChannel</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n    <span>return</span> <span>SelectorProvider</span><span>.</span><span>provider</span><span>(</span><span>)</span><span>.</span><span>inheritedChannel</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>返回从创建此 java 虚拟机的实体中继承的通道。如果有则返回，没有返回null。</p>\n<h4 id=\"securitymanager设置与获取\"> SecurityManager设置与获取：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>setSecurityManager</span><span>(</span><span>final</span> <span>SecurityManager</span> s<span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n        s<span>.</span><span>checkPackageAccess</span><span>(</span><span>\"java.lang\"</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n        <span>// no-op</span>\n    <span>}</span>\n    <span>setSecurityManager0</span><span>(</span>s<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>static</span> <span>SecurityManager</span> <span>getSecurityManager</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> security<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>设置和获取java的安全管理器，当运行未知的Java程序的时候，该程序可能有操作如删除系统文件、重启系统等，为了防止运行恶意代码对系统产生影响，需要对运行的代码的权限进行控制，这时候就要启用Java安全管理器。</p>\n<p>currentTimeMillis:</p>\n<div><pre><code><span>public</span> <span>static</span> <span>native</span> <span>long</span> <span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>获取当前系统时间的毫秒数。1秒=1000毫秒(ms);</p>\n<h4 id=\"nanotime\"> nanoTime:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>native</span> <span>long</span> <span>nanoTime</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>获取当前系统时间的纳秒数。1秒=1,000,000,000 纳秒(ns);</p>\n<h4 id=\"arraycopy\"> arraycopy:</h4>\n<div><pre><code><span>public</span> <span>static</span> native <span>void</span> <span>arraycopy</span><span>(</span>\n    Object src<span>,</span><span>//源数组</span>\n    <span>int</span>  srcPos<span>,</span> <span>//源数组要复制的起始位置</span>\n    Object dest<span>,</span> <span>//目标数组</span>\n    <span>int</span> destPos<span>,</span> <span>//目标数组的起始位置</span>\n    <span>int</span> length<span>//复制的长度</span>\n<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>复制数组，从一个明确的数组中复制数组元素到另一个数组中。System.arraycopy采用的是浅复制，使用的时候注意一下。</p>\n<h4 id=\"identityhashcode\"> identityHashCode:</h4>\n<div><pre><code>    <span>public</span> <span>static</span> <span>native</span> <span>int</span> <span>identityHashCode</span><span>(</span><span>Object</span> x<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>获取对象的hashCode,一般可通过对象的hashCode()方法获取对象的hashCode,但有些对象重写了hashCode()方法，那么想要获取对象的hashCode时就要使用本方法了。</p>\n<h4 id=\"props\"> props：</h4>\n<div><pre><code>    <span>private</span> <span>static</span> <span>Properties</span> props<span>;</span>\n    <span>private</span> <span>static</span> <span>native</span> <span>Properties</span> <span>initProperties</span><span>(</span><span>Properties</span> props<span>)</span><span>;</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>setProperties</span><span>(</span><span>Properties</span> props<span>)</span> <span>{</span>\n        <span>SecurityManager</span> sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            sm<span>.</span><span>checkPropertiesAccess</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>props <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            props <span>=</span> <span>new</span> <span>Properties</span><span>(</span><span>)</span><span>;</span>\n            <span>initProperties</span><span>(</span>props<span>)</span><span>;</span>\n        <span>}</span>\n        <span>System</span><span>.</span>props <span>=</span> props<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>Properties</span> <span>getProperties</span><span>(</span><span>)</span> <span>{</span>\n        <span>SecurityManager</span> sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            sm<span>.</span><span>checkPropertiesAccess</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>return</span> props<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>props是用于承装java的系统变量的，initProperties是初始化props对象，本地方法实现。setProperties()重新设置系统的Properties对象。getProperties()方法用于获取Properties对象。不论是设置还是获取都先会进行安全检查，看是否对系统属性有安全限制。获取Properties对象后可重新设值取值。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>setProperty</span><span>(</span><span>String</span> key<span>,</span> <span>String</span> value<span>)</span> <span>{</span>\n    <span>checkKey</span><span>(</span>key<span>)</span><span>;</span>\n    <span>SecurityManager</span> sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        sm<span>.</span><span>checkPermission</span><span>(</span><span>new</span> <span>PropertyPermission</span><span>(</span>key<span>,</span>\n                                                  <span>SecurityConstants</span><span>.</span>PROPERTY_WRITE_ACTION<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> <span>(</span><span>String</span><span>)</span> props<span>.</span><span>setProperty</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>设置系统属性到Properties对象中，如果已经存在则覆盖原有属性，并返回原有属性。该对象是全局的，在程序中到处都可以调用。</p>\n<h4 id=\"getproperty\"> getProperty:</h4>\n<div><pre><code><span>public</span> <span>static</span> String <span>getProperty</span><span>(</span><span>String key</span><span>)</span> <span>{</span>\n    <span>checkKey</span><span>(</span>key<span>)</span><span>;</span>\n    SecurityManager sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        sm<span>.</span><span>checkPropertyAccess</span><span>(</span>key<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> props<span>.</span><span>getProperty</span><span>(</span>key<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>从Properties中获取系统属性，如果有则返回，如果没有返回null。</p>\n<h4 id=\"getproperty-string-key-string-def\"> getProperty(String key, String def):</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>getProperty</span><span>(</span><span>String</span> key<span>,</span> <span>String</span> def<span>)</span> <span>{</span>\n    <span>checkKey</span><span>(</span>key<span>)</span><span>;</span>\n    <span>SecurityManager</span> sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        sm<span>.</span><span>checkPropertyAccess</span><span>(</span>key<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> props<span>.</span><span>getProperty</span><span>(</span>key<span>,</span> def<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>从Properties中获取系统属性，如果有则返回，如果没有返回默认值，第二个参数为默认值。</p>\n<h4 id=\"clearproperty\"> clearProperty:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>clearProperty</span><span>(</span><span>String</span> key<span>)</span> <span>{</span>\n    <span>checkKey</span><span>(</span>key<span>)</span><span>;</span>\n    <span>SecurityManager</span> sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        sm<span>.</span><span>checkPermission</span><span>(</span><span>new</span> <span>PropertyPermission</span><span>(</span>key<span>,</span> <span>\"write\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> <span>(</span><span>String</span><span>)</span> props<span>.</span><span>remove</span><span>(</span>key<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>用于清除系统属性，并返回原属性值。</p>\n<h4 id=\"lineseparator\"> lineSeparator:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>lineSeparator</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> lineSeparator<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>获取系统的换行符widows系统返回&quot;\\r\\n&quot;,UNIX系统返回&quot;\\n&quot;。</p>\n<h4 id=\"getenv\"> getenv:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span><span>java<span>.</span>util<span>.</span></span>Map</span><span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>></span></span> <span>getenv</span><span>(</span><span>)</span> <span>{</span>\n    <span>SecurityManager</span> sm <span>=</span> <span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        sm<span>.</span><span>checkPermission</span><span>(</span><span>new</span> <span>RuntimePermission</span><span>(</span><span>\"getenv.*\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> <span>ProcessEnvironment</span><span>.</span><span>getenv</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>获取java程序环境信息，如LOCALAPPDATA，JAVA_HOME等。返回的是一个Map对象。</p>\n<h4 id=\"exit\"> exit:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>exit</span><span>(</span><span>int</span> status<span>)</span> <span>{</span>\n    <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>exit</span><span>(</span>status<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>结束当前正在运行中的java虚拟机。参数0代表正常退出，非0代表异常退出。</p>\n<h4 id=\"gc\"> gc：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>gc</span><span>(</span><span>)</span> <span>{</span>\n    <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>gc</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>该方法用于告知虚拟机进行垃圾回收。垃圾收集器将运行以回收未使用的内存空间。注意这一步只是通知虚拟机要进行垃圾回收操作，虚拟机并不一定立即进行回收操作。</p>\n<h4 id=\"runfinalization\"> runFinalization:</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>runFinalization</span><span>(</span><span>)</span> <span>{</span>\n    <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>runFinalization</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我们知道Object对象不有一个finalize方法，当进行垃圾回收时，对象被回收前会执行finalize方法。调用runFinalization方法运行处于挂起终止状态的所有对象的终止方法。Java虚拟机已经尽最大努力去完成所有未执行的终止方法。</p>\n<h4 id=\"load\"> load:</h4>\n<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>load</span><span>(</span><span>String</span> filename<span>)</span> <span>{</span>\n        <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>load0</span><span>(</span><span>Reflection</span><span>.</span><span>getCallerClass</span><span>(</span><span>)</span><span>,</span> filename<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>用于装载指定名称filename的系统库文件。filename必需是绝对路径。</p>\n<h4 id=\"loadlibrary\"> loadLibrary：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>loadLibrary</span><span>(</span><span>String</span> libname<span>)</span> <span>{</span>\n    <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>loadLibrary0</span><span>(</span><span>Reflection</span><span>.</span><span>getCallerClass</span><span>(</span><span>)</span><span>,</span> libname<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>加载系统中的本地库，如果是Windows系统加载的是xxx.dll，如果是unix系统加载的是xxx.so，注意该方法不能包含文件的扩展名，但该文件必需在JVM属性java.library.path所指向的路径中。</p>\n<h4 id=\"maplibraryname\"> mapLibraryName：</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>native</span> <span>String</span> <span>mapLibraryName</span><span>(</span><span>String</span> libname<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>将一个库名称映射到特定于平台的、表示本机库的字符串中。有点抽象，比如你想映射mapLibraryName这个库名，映射到Windows平台就是mapLibraryName.dll映射到Unix平台就是mapLibraryName.so</p>\n",
      "image": "https://math.jianshu.com/math?formula=%E4%BB%A3%E6%9B%BF%E3%80%82%E8%BF%99%E4%B8%80%E7%82%B9%E4%BB%8E%E6%B3%A8%E9%87%8A%E4%B8%AD%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%87%BA%E6%9D%A5%E3%80%82Note%20that%20backslashes%20(%5C",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "数据库",
      "url": "http://blog.alanlee.top/blog-vuepress/database/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/",
      "content_html": "<h1 id=\"数据库\"> 数据库</h1>\n<img :src=\"$withBase=('/note_images/database.jpg')\"/>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "memcached",
      "url": "http://blog.alanlee.top/blog-vuepress/database/memcached/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/memcached/",
      "content_html": "<h1 id=\"memcached\"> memcached</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "安装memcached",
      "url": "http://blog.alanlee.top/blog-vuepress/database/memcached/%E5%AE%89%E8%A3%85memcached/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/memcached/%E5%AE%89%E8%A3%85memcached/",
      "content_html": "<h1 id=\"安装memcached\"> 安装memcached</h1>\n<p>安装</p>\n<div><pre><code>yum –y <span>install</span> memcached\n</code></pre>\n<div><span>1</span><br></div></div><p>启动</p>\n<div><pre><code>service memcached start\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "MongoDB数据库",
      "url": "http://blog.alanlee.top/blog-vuepress/database/mongodb/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/mongodb/",
      "content_html": "<h1 id=\"mongodb数据库\"> MongoDB数据库</h1>\n<img :src=\"$withBase=('/note_images/mongodb.jpg')\"/>\n<p>MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p>\n<p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "MySQL数据库",
      "url": "http://blog.alanlee.top/blog-vuepress/database/mysql/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/mysql/",
      "content_html": "<h1 id=\"mysql数据库\"> MySQL数据库</h1>\n<img :src=\"$withBase=('/note_images/mysql.jpg')\"/>\n<p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p>\n<p>MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>\n<p>MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "MySQL主从配置与Mycat读写分离",
      "url": "http://blog.alanlee.top/blog-vuepress/database/mysql/mycat/MySQL%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE%E4%B8%8EMycat%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/mysql/mycat/MySQL%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE%E4%B8%8EMycat%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/",
      "content_html": "<h1 id=\"mysql主从配置与mycat读写分离\"> MySQL主从配置与Mycat读写分离</h1>\n<h2 id=\"一、主数据库配置\"> 一、主数据库配置</h2>\n<ol>\n<li>\n<p>编辑配置文件</p>\n<p>添加如下内容</p>\n<div><pre><code>server-id=1\nbinlog-do-db=master_db1 #备份的数据库\nlog-bin=mysql-bin\nbinlog-ignore-db=mysql\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200523133136523.png\" alt=\"image-20200523133136523\" /></p>\n</li>\n<li>\n<p>重启mysql</p>\n</li>\n<li>\n<p>创建一个允许从服务器来访问的用户(主服务器)：</p>\n<div><pre><code>grant replication slave on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;123456&#39;;\n\nGRANT FILE ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;\n\nFLUSH PRIVILEGES;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>\n<p>grant replication slave on <em>.</em> to 'root'@'%' identified by '123456';</p>\n<p>说明：</p>\n<ul>\n<li>\n<p>root：Slave使用的账号</p>\n</li>\n<li>\n<p>IDENTIFIED BY 123456：Slave使用的密码</p>\n</li>\n<li>\n<p>%：Slave数据库IP</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>查看配置的信息</p>\n<div><pre><code>show master status \\G;\n</code></pre>\n<div><span>1</span><br></div></div><p>如图：</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200522155203831.png\" alt=\"image-20200522155203831\" /></p>\n<blockquote>\n<p>记住 File和Position的值，后面会用到</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"二、从数据库配置\"> 二、从数据库配置</h2>\n<ol>\n<li>编辑配置文件my.cnf，在[mysqld]下面添加这段内容</li>\n</ol>\n<div><pre><code>log-bin=mysql-bin\nserver-id=2\n# 忽略日志的db\nbinlog-ignore-db=information_schema\nbinlog-ignore-db=cluster\nbinlog-ignore-db=mysql\n# 需要备份的db\nreplicate-do-db=master_db1\n# 忽略备份的db\nreplicate-ignore-db=mysql\nlog-slave-updates\nslave-skip-errors=all\nslave-net-timeout=60\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ol start=\"2\">\n<li>关联Master信息</li>\n</ol>\n<div><pre><code>stop slave;\n\nCHANGE MASTER TO MASTER_HOST=&#39;192.168.1.20&#39;,MASTER_USER=&#39;root&#39;,MASTER_PASSWORD=&#39;123456&#39;,MASTER_PORT=3306,MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;,MASTER_CONNECT_RETRY=60,MASTER_LOG_POS=154;\n\nstart slave;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>\n<p>这里的MASTER_LOG_POS=154的154就是配置主服务器的时候说要记住的那个，</p>\n<p>MASTER_LOG_FILE的值就是之前的Position的值</p>\n</blockquote>\n<ol start=\"3\">\n<li>查看状态</li>\n</ol>\n<div><pre><code>show slave status \\G;\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200522170042277.png\" alt=\"image-20200522170042277\" /></p>\n<blockquote>\n<p>只有Slave_IO_Running与Slave_SQL_Running都为Yes才配置成功。</p>\n</blockquote>\n<h2 id=\"三、主从复制测试\"> 三、主从复制测试</h2>\n<ol>\n<li>在从服务器中创建数据库master_db1</li>\n</ol>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200523131328951.png\" alt=\"image-20200523131328951\" /></p>\n<ol start=\"2\">\n<li>在主MySQL服务器创建test表，测试结果是从MySQL的服务器会自动复制主MySQL服务器的test表。</li>\n<li>添加500w条数据进行测试，可以使用jdbc插入，也可以使用dataFactory。（可以先手动插入一条数据查看效果）<img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200603111431707.png\" alt=\"image-20200603111431707\" /></li>\n</ol>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200603111537557.png\" alt=\"image-20200603111537557\" /></p>\n<h2 id=\"四、启用mycat读写分离\"> 四、启用Mycat读写分离</h2>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>主机名</th>\n<th>IP和端口</th>\n<th>操作</th>\n<th>引擎</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>主MySQL服务器</td>\n<td>master</td>\n<td>192.168.1.20:3306</td>\n<td>写</td>\n<td>InnoDB</td>\n</tr>\n<tr>\n<td>从MySQL服务器</td>\n<td>node-1</td>\n<td>192.168.1.21:3306</td>\n<td>读</td>\n<td>MyISAM</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>\n<p>修改从数据库的表</p>\n<p>将表的引擎改为<code>MyISAM</code></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200523135553033.png\" alt=\"image-20200523135553033\" /></p>\n</li>\n<li>\n<p>配置mycat读写分离</p>\n</li>\n</ol>\n<p>编辑schema.xml文件</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\"?></span>\n<span><span>&lt;!</span><span>DOCTYPE</span> <span>mycat:schema</span> <span>SYSTEM</span> <span>\"schema.dtd\"</span><span>></span></span>\n<span><span><span>&lt;</span><span>mycat:</span>schema</span> <span><span>xmlns:</span>mycat</span><span><span>=</span><span>\"</span>http://org.opencloudb/<span>\"</span></span><span>></span></span>\n\n\t<span><span><span>&lt;</span>schema</span> <span>name</span><span><span>=</span><span>\"</span>zdxh<span>\"</span></span> <span>checkSQLschema</span><span><span>=</span><span>\"</span>false<span>\"</span></span> <span>sqlMaxLimit</span><span><span>=</span><span>\"</span>100<span>\"</span></span><span>></span></span>\n\n\t\t<span>&lt;!-- 测试读写分离 --></span>\n\t\t<span><span><span>&lt;</span>table</span> <span>name</span><span><span>=</span><span>\"</span>test<span>\"</span></span> <span>primaryKey</span><span><span>=</span><span>\"</span>ID<span>\"</span></span> <span>dataNode</span><span><span>=</span><span>\"</span>dn4<span>\"</span></span> <span>/></span></span>\n\t<span><span><span>&lt;/</span>schema</span><span>></span></span>\n\n\n\t<span>&lt;!-- 测试读写分离 --></span>\n\t<span><span><span>&lt;</span>dataNode</span> <span>name</span><span><span>=</span><span>\"</span>dn4<span>\"</span></span> <span>dataHost</span><span><span>=</span><span>\"</span>local-master-rw<span>\"</span></span> <span>database</span><span><span>=</span><span>\"</span>master_db1<span>\"</span></span> <span>/></span></span>\n\n\t\n\t<span>&lt;!-- 测试读写分离 --></span>\n\t<span><span><span>&lt;</span>dataHost</span> <span>name</span><span><span>=</span><span>\"</span>local-master-rw<span>\"</span></span> <span>maxCon</span><span><span>=</span><span>\"</span>1000<span>\"</span></span> <span>minCon</span><span><span>=</span><span>\"</span>10<span>\"</span></span> <span>balance</span><span><span>=</span><span>\"</span>1<span>\"</span></span>\n\t\t<span>writeType</span><span><span>=</span><span>\"</span>0<span>\"</span></span> <span>dbType</span><span><span>=</span><span>\"</span>mysql<span>\"</span></span> <span>dbDriver</span><span><span>=</span><span>\"</span>native<span>\"</span></span> <span>switchType</span><span><span>=</span><span>\"</span>1<span>\"</span></span>  <span>slaveThreshold</span><span><span>=</span><span>\"</span>100<span>\"</span></span><span>></span></span>\n\t\t<span><span><span>&lt;</span>heartbeat</span><span>></span></span>select user()<span><span><span>&lt;/</span>heartbeat</span><span>></span></span>\n\t\t<span>&lt;!-- 写入配置--></span>\n\t\t<span><span><span>&lt;</span>writeHost</span> <span>host</span><span><span>=</span><span>\"</span>hostM4<span>\"</span></span> <span>url</span><span><span>=</span><span>\"</span>192.168.1.20:3306<span>\"</span></span> \n                   <span>user</span><span><span>=</span><span>\"</span>root<span>\"</span></span> <span>password</span><span><span>=</span><span>\"</span>123456<span>\"</span></span><span>></span></span>\n\t\t\t<span>&lt;!-- 添加只读库配置--></span>\n            <span><span><span>&lt;</span>readHost</span> <span>host</span><span><span>=</span><span>\"</span>hostS1<span>\"</span></span> <span>url</span><span><span>=</span><span>\"</span>192.168.1.21:3306<span>\"</span></span> \n                      <span>user</span><span><span>=</span><span>\"</span>root<span>\"</span></span> <span>password</span><span><span>=</span><span>\"</span>123456<span>\"</span></span> <span>/></span></span>\n\t\t<span><span><span>&lt;/</span>writeHost</span><span>></span></span>\n\t<span><span><span>&lt;/</span>dataHost</span><span>></span></span>\n\n<span><span><span>&lt;/</span><span>mycat:</span>schema</span><span>></span></span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200523145846248.png\" alt=\"image-20200523145846248\" /></p>\n<h2 id=\"五、mycat读写分离测试\"> 五、Mycat读写分离测试</h2>\n<p>测试分为启用读写分离测试和不启用读写分离的情况赖测试</p>\n<h3 id=\"启用读写分离的查询\"> 启用读写分离的查询</h3>\n<p>配置schema.xml</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200603092525583.png\" alt=\"image-20200603092525583\" /></p>\n<p>在mycat中查询</p>\n<p><strong>count关键字查询</strong></p>\n<div><pre><code>select count(id) from test;\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200603093857376.png\" alt=\"image-20200603093857376\" /></p>\n<p><strong>like关键字查询</strong></p>\n<div><pre><code>select * from test where name like &#39;%alanlee%&#39;;\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200603094541570.png\" alt=\"image-20200603094541570\" /></p>\n<p><strong>=查询</strong></p>\n<div><pre><code>select * from test where name = &#39;alanlee&#39;;\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200603094709481.png\" alt=\"image-20200603094709481\" /></p>\n<p><strong>insert</strong></p>\n<div><pre><code>insert into test(name) values(&#39;libuguan&#39;);\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200603095335013.png\" alt=\"image-20200603095335013\" /></p>\n<p><strong>update</strong></p>\n<div><pre><code>update test set name = &#39;libuguan-007&#39; where name = &#39;libuguan&#39;;\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200603095728778.png\" alt=\"image-20200603095728778\" /></p>\n<p><strong>delete</strong></p>\n<div><pre><code>delete from test where name = &#39;libuguan-007&#39;;\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200603100214050.png\" alt=\"image-20200603100214050\" /></p>\n<h3 id=\"不启用读写分离的查询\"> 不启用读写分离的查询</h3>\n<p>配置schema.xml</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200529152232726.png\" alt=\"image-20200529152232726\" /></p>\n<p>在mycat中查询</p>\n<p><strong>count关键字查询</strong></p>\n<div><pre><code>select count(*) from test;\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200529151832264.png\" alt=\"image-20200529151832264\" /></p>\n<p><strong>like关键字查询</strong></p>\n<div><pre><code>select * from test where name like &#39;%alanlee%&#39;;\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200529153145449.png\" alt=\"image-20200529153145449\" /></p>\n<p><strong>=查询</strong></p>\n<div><pre><code>select * from test where name = &#39;alanlee&#39;;\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200529153440308.png\" alt=\"image-20200529153440308\" /></p>\n<p><strong>insert</strong></p>\n<div><pre><code>insert into test(name) values(&#39;libuguan-01&#39;);\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200603104934708.png\" alt=\"image-20200603104934708\" /></p>\n<p><strong>update</strong></p>\n<div><pre><code>update test set name = &#39;libuguan-02&#39; where name = &#39;libuguan-01&#39;;\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200603105102926.png\" alt=\"image-20200603105102926\" /></p>\n<p><strong>delete</strong></p>\n<div><pre><code>delete from test where name = &#39;libuguan-02&#39;;\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200603105351203.png\" alt=\"image-20200603105351203\" /></p>\n<h3 id=\"统计\"> 统计</h3>\n<table>\n<thead>\n<tr>\n<th>Sql语句</th>\n<th>启用读写分离机制（读库使用MyISAM）</th>\n<th>取消读写分离机制(读使用的是Innodb)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>count</td>\n<td>0.00秒</td>\n<td>1.68秒</td>\n</tr>\n<tr>\n<td>like</td>\n<td>2.36秒</td>\n<td>3.01秒</td>\n</tr>\n<tr>\n<td>=</td>\n<td>0.92秒</td>\n<td>1.30秒</td>\n</tr>\n<tr>\n<td>insert</td>\n<td>0.11秒</td>\n<td>0.05秒</td>\n</tr>\n<tr>\n<td>update</td>\n<td>3.27秒</td>\n<td>3.02秒</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>2.93秒</td>\n<td>3.31秒</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200603110848207.png\" alt=\"image-20200603110848207\" /></p>\n<h3 id=\"总结\"> 总结</h3>\n<p>**启用mycat读写分离，查询操作的速度比不启用读写分离快很多。**原因是查询时使用的是MyISAM引擎。而插入、更新、删除的操作基本上没有变化，因为执行这3个操作时都是使用的InnoDB引擎。</p>\n<h2 id=\"六、遇到的问题\"> 六、遇到的问题</h2>\n<h3 id=\"问题1\"> 问题1</h3>\n<p>[ERROR] unknown variable 'master-host=192.168.1.20'</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200522162243354.png\" alt=\"image-20200522162243354\" /></p>\n<h4 id=\"原因\"> 原因</h4>\n<p>MySQL5.6和之后的版本没有master-host参数了</p>\n<h4 id=\"解决\"> 解决</h4>\n<p>解决方案：</p>\n<ol>\n<li>在my.cnf文件的[mysqld]下面添加以下配置</li>\n</ol>\n<div><pre><code>log-bin=mysql-bin\nserver-id=2\n# 忽略日志的db\nbinlog-ignore-db=information_schema\nbinlog-ignore-db=cluster\nbinlog-ignore-db=mysql\n# 需要备份的db\nreplicate-do-db=master_db\n# 忽略备份的db\nreplicate-ignore-db=mysql\nlog-slave-updates\nslave-skip-errors=all\nslave-net-timeout=60\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200522165424009.png\" alt=\"image-20200522165424009\" /></p>\n<ol start=\"2\">\n<li>\n<p>重启mysql</p>\n</li>\n<li>\n<p>命令行输入</p>\n</li>\n</ol>\n<div><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.1.20&#39;,MASTER_USER=&#39;root&#39;,MASTER_PASSWORD=&#39;123456&#39;,MASTER_PORT=3306,MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;,MASTER_CONNECT_RETRY=60,MASTER_LOG_POS=154;\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>需根据自己的机子修改参数值</p>\n<ul>\n<li>MASTER_HOST</li>\n<li>MASTER_LOG_FILE</li>\n<li>MASTER_LOG_POS</li>\n</ul>\n</blockquote>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200522164835461.png\" alt=\"image-20200522164835461\" /></p>\n<h3 id=\"问题2\"> 问题2</h3>\n<p>配置好了主从服务器之后，主服务器创建表后，从服务器不会复制</p>\n<h3 id=\"原因-2\"> 原因</h3>\n<p>没有赋予Slave机器有File权限，没有刷新权限。</p>\n<h3 id=\"解决-2\"> 解决</h3>\n<p>在主MySQL服务器中命令行执行</p>\n<div><pre><code># 赋予Slave机器有File权限\nGRANT FILE ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;\n# 刷新权限\nFLUSH PRIVILEGES;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>重启主MySQL服务器</p>\n<blockquote>\n<p>还要检查其他的配置是否准确，例如MASTER_HOST，MASTER_LOG_FILE，MASTER_LOG_POS的参数值等等。</p>\n</blockquote>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200523133136523.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "计算机网络知识点总结",
      "url": "http://blog.alanlee.top/blog-vuepress/common/network/%E6%95%B4%E5%90%88/",
      "id": "http://blog.alanlee.top/blog-vuepress/common/network/%E6%95%B4%E5%90%88/",
      "content_html": "<h1 id=\"计算机网络知识点总结\"> 计算机网络知识点总结</h1>\n<h2 id=\"一、计算机概述\"> 一、计算机概述</h2>\n<h3 id=\"_1-基本术语\"> （1）基本术语</h3>\n<h4 id=\"结点-node\"> 结点 （node）：</h4>\n<div><pre><code>网络中的结点可以是计算机，集线器，交换机或路由器等。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"链路-link\"> 链路（link ）：</h4>\n<div><pre><code>从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"主机-host\"> 主机（host）：</h4>\n<div><pre><code>连接在因特网上的计算机.\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"isp-internet-service-provider\"> ISP（Internet Service Provider）：</h4>\n<div><pre><code>因特网服务提供者（提供商）.\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"ixp-internet-exchange-point\"> IXP（Internet eXchange Point）：</h4>\n<div><pre><code>互联网交换点IXP的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。.\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"rfc-request-for-comments\"> RFC(Request For Comments)</h4>\n<div><pre><code>意思是“请求评议”，包含了关于Internet几乎所有的重要的文字资料。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"广域网wan-wide-area-network\"> 广域网WAN（Wide Area Network）</h4>\n<div><pre><code>任务是通过长距离运送主机发送的数据\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"城域网man-metropolitan-area-network\"> 城域网MAN（Metropolitan Area Network）</h4>\n<div><pre><code>用来将多个局域网进行互连\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"局域网lan-local-area-network\"> 局域网LAN（Local Area Network）</h4>\n<div><pre><code> 学校或企业大多拥有多个互连的局域网\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"个人区域网pan-personal-area-network\"> 个人区域网PAN（Personal Area Network）</h4>\n<div><pre><code>在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络  \n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"端系统-end-system\"> 端系统（end system）：</h4>\n<div><pre><code>处在因特网边缘的部分即是连接在因特网上的所有的主机.\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"分组-packet\"> 分组（packet ）：</h4>\n<div><pre><code>因特网中传送的数据单元。由首部header和数据段组成。分组又称为包，首部可称为包头。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"存储转发-store-and-forward\"> 存储转发（store and forward ）:</h4>\n<div><pre><code>路由器收到一个分组，先存储下来，再检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"带宽-bandwidth\"> 带宽（bandwidth）：</h4>\n<div><pre><code>在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为b/s。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"吞吐量-throughput\"> 吞吐量（throughput ）：</h4>\n<div><pre><code>表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-重要知识点总结\"> （2）重要知识点总结</h3>\n<p>1，计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</p>\n<p>2，小写字母i开头的internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。</p>\n<p>大写字母I开头的Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用TCP/IP协议作为通信规则，其前身为ARPANET。Internet的推荐译名为因特网，现在一般流行称为互联网。</p>\n<p>3，路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</p>\n<p>4，互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。</p>\n<p>5，计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S方式）和对等连接方式（P2P方式）。</p>\n<p>6，客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</p>\n<p>7，按照作用范围的不同，计算机网络分为广域网WAN，城域网MAN，局域网LAN，个人区域网PAN。</p>\n<p>8，计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</p>\n<p>9，网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</p>\n<p>10，五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是TCP和UDP协议，网络层最重要的协议是IP协议。</p>\n<h2 id=\"二、物理层\"> 二、物理层</h2>\n<h3 id=\"_1-基本术语-2\"> （1）基本术语</h3>\n<h4 id=\"数据-data\"> 数据（data）：</h4>\n<div><pre><code>运送消息的实体。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"信号-signal\"> 信号（signal）：</h4>\n<div><pre><code>数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"码元-code\"> 码元（ code）：</h4>\n<div><pre><code>在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"单工-simplex\"> 单工（simplex ）：</h4>\n<div><pre><code>只能有一个方向的通信而没有反方向的交互。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"半双工-half-duplex\"> 半双工（half duplex ）：</h4>\n<div><pre><code>通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"全双工-full-duplex\"> 全双工（full duplex）：</h4>\n<div><pre><code>通信的双方可以同时发送和接收信息。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"奈氏准则\"> 奈氏准则：</h4>\n<div><pre><code>在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"基带信号-baseband-signal\"> 基带信号（baseband signal）：</h4>\n<div><pre><code>来自信源的信号。指没有经过调制的数字信号或模拟信号。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"带通-频带-信号-bandpass-signal\"> 带通（频带）信号（bandpass signal）：</h4>\n<div><pre><code>把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"调制-modulation\"> 调制（modulation ）：</h4>\n<div><pre><code>对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"信噪比-signal-to-noise-ratio\"> 信噪比（signal-to-noise ratio ）：</h4>\n<div><pre><code>指信号的平均功率和噪声的平均功率之比，记为S/N。信噪比（dB）=10*log10（S/N）\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"信道复用-channel-multiplexing\"> 信道复用（channel multiplexing ）：</h4>\n<div><pre><code>指多个用户共享同一个信道。（并不一定是同时）\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"比特率-bit-rate\"> 比特率（bit rate ）：</h4>\n<div><pre><code>单位时间（每秒）内传送的比特数。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"波特率-baud-rate\"> 波特率（baud rate）：</h4>\n<div><pre><code>单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"复用-multiplexing\"> 复用（multiplexing）：</h4>\n<div><pre><code>共享信道的方法\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"adsl-asymmetric-digital-subscriber-line\"> ADSL（Asymmetric Digital Subscriber Line ）：</h4>\n<div><pre><code>非对称数字用户线。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"光纤同轴混合网-hfc网\"> 光纤同轴混合网（HFC网）:</h4>\n<div><pre><code>在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-重要知识点总结-2\"> （2）重要知识点总结</h3>\n<p>1，物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</p>\n<p>2，一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</p>\n<p>3，通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电器或电磁的表现。</p>\n<p>4，根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</p>\n<p>5，根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</p>\n<p>6，来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</p>\n<p>7，要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</p>\n<p>8，传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</p>\n<p>9，为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络EPON和吉比特无源光网络GPON。</p>\n<h3 id=\"_3-最重要的知识点\"> （3）最重要的知识点</h3>\n<h4 id=\"_1物理层的任务\"> <strong>①物理层的任务</strong></h4>\n<p>透明地传送比特流。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能能的各种可能事件的出现顺序）。</p>\n<h4 id=\"拓展\"> 拓展：</h4>\n<p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</p>\n<h4 id=\"_2几种常用的信道复用技术\"> <strong>②几种常用的信道复用技术</strong></h4>\n<p><a href=\"https://camo.githubusercontent.com/47e7f195826449a3a89d7ba4988e803e76eaaf11/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376637613137306563363631313f773d3132343726683d34323526663d706e6726733d3336373436\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/47e7f195826449a3a89d7ba4988e803e76eaaf11/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376637613137306563363631313f773d3132343726683d34323526663d706e6726733d3336373436\" alt=\"这里写图片描述\" /></a></p>\n<h4 id=\"_3几种常用的宽带接入技术-主要是adsl和fttx\"> ③几种常用的宽带接入技术，主要是ADSL和FTTx</h4>\n<p>用户到互联网的宽带接入方法有非对称数字用户线ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ASDL的快速版本是甚高速数字用户线VDSL。），光纤同轴混合网HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和FTTx（即光纤到······）。</p>\n<h2 id=\"三、数据链路层\"> 三、数据链路层</h2>\n<h3 id=\"_1-基本术语-3\"> （1）基本术语</h3>\n<h4 id=\"链路-link-2\"> 链路（link）：</h4>\n<div><pre><code>一个结点到相邻结点的一段物理链路\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"数据链路-data-link\"> 数据链路（data link）：</h4>\n<div><pre><code>把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"循环冗余检验crc-cyclic-redundancy-check\"> 循环冗余检验CRC（Cyclic Redundancy Check）：</h4>\n<div><pre><code>为了保证数据传输的可靠性，CRC是数据链路层广泛使用的一种检错技术\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"帧-frame\"> 帧（frame）：</h4>\n<div><pre><code>一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"mtu-maximum-transfer-uint\"> MTU（Maximum Transfer Uint ）：</h4>\n<div><pre><code>最大传送单元。帧的数据部分的的长度上限。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"误码率ber-bit-error-rate\"> 误码率BER（Bit Error Rate ）：</h4>\n<div><pre><code>在一段时间内，传输错误的比特占所传输比特总数的比率。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"ppp-point-to-point-protocol\"> PPP（Point-to-Point Protocol ）：</h4>\n<div><pre><code>点对点协议。即用户计算机和ISP进行通信时所使用的数据链路层协议。以下是PPP帧的示意图:\n</code></pre>\n<div><span>1</span><br></div></div><p><a href=\"https://camo.githubusercontent.com/9416dd31ba2008abf8b4dfc125ed2c16260fe8cd/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376638323931633662303332633f773d36323426683d33353926663d6a70656726733d3434323731\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/9416dd31ba2008abf8b4dfc125ed2c16260fe8cd/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376638323931633662303332633f773d36323426683d33353926663d6a70656726733d3434323731\" alt=\"PPP\" /></a></p>\n<h4 id=\"mac地址-media-access-control或者medium-access-control\"> MAC地址（Media Access Control或者Medium Access Control）：</h4>\n<div><pre><code>意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。\n在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。\n因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址  。\n地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处”\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"网桥-bridge\"> 网桥（bridge）：</h4>\n<div><pre><code> 一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"交换机-switch\"> 交换机（switch ）：</h4>\n<div><pre><code>广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-重要知识点总结-3\"> （2）重要知识点总结</h3>\n<p>1，链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p>\n<p>2，数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</p>\n<p>3，数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></p>\n<p>4，<strong>循环冗余检验CRC</strong>是一种检错方法，而帧检验序列FCS是添加在数据后面的冗余码</p>\n<p>5，<strong>点对点协议PPP</strong>是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</p>\n<p>6，PPPoE是为宽带上网的主机使用的链路层协议</p>\n<p>7，局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</p>\n<p>8，共向媒体通信资源的方法有二：一是静态划分信道(各种复用技术)，而是动态媒体接入控制，又称为多点接入（随即接入或受控接入）</p>\n<p>9，计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的ROM中</strong>。</p>\n<p>10，以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</p>\n<p>11，以太网采用的协议是具有冲突检测的<strong>载波监听多点接入CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道</p>\n<p>12，以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</p>\n<p>13，使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</p>\n<h3 id=\"_3-最重要的知识点-2\"> （3）最重要的知识点</h3>\n<h4 id=\"_1-数据链路层的点对点信道和广播信道的特点-以及这两种信道所使用的协议-ppp协议以及csma-cd协议-的特点\"> ① 数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP协议以及CSMA/CD协议）的特点</h4>\n<h4 id=\"_2-数据链路层的三个基本问题-封装成帧-透明传输-差错检测\"> ② 数据链路层的三个基本问题：<strong>封装成帧</strong>，<strong>透明传输</strong>，<strong>差错检测</strong></h4>\n<h4 id=\"_3-以太网的mac层硬件地址\"> ③ 以太网的MAC层硬件地址</h4>\n<h4 id=\"_4-适配器-转发器-集线器-网桥-以太网交换机的作用以及适用场合\"> ④ 适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合</h4>\n<h2 id=\"四、网络层\"> 四、网络层</h2>\n<h3 id=\"_1-基本术语-4\"> （1）基本术语</h3>\n<h4 id=\"虚电路-virtual-circuit\"> 虚电路（Virtual Circuit）：</h4>\n<div><pre><code>在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"ip-internet-protocol\"> IP（Internet Protocol ）：</h4>\n<div><pre><code>网际协议 IP 是 TCP/IP体系中两个最主要的协议之一，是TCP/IP体系结构网际层的核心。配套的有ARP，RARP，ICMP，IGMP。\n</code></pre>\n<div><span>1</span><br></div></div><p><a href=\"https://camo.githubusercontent.com/96fd61e40c5c60eb8ef986a5876d9a4a5237f119/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376639326639383433363238363f773d34353326683d33333126663d6a70656726733d3237353335\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/96fd61e40c5c60eb8ef986a5876d9a4a5237f119/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376639326639383433363238363f773d34353326683d33333126663d6a70656726733d3237353335\" alt=\"这里写图片描述\" /></a></p>\n<h4 id=\"arp-address-resolution-protocol\"> ARP（Address Resolution Protocol）：</h4>\n<div><pre><code>地址解析协议\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"icmp-internet-control-message-protocol\"> ICMP（Internet Control Message Protocol ）：</h4>\n<div><pre><code>网际控制报文协议  （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。）\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"子网掩码-subnet-mask\"> 子网掩码（subnet mask ）：</h4>\n<div><pre><code>它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"cidr-classless-inter-domain-routing\"> CIDR（ Classless Inter-Domain Routing ）：</h4>\n<div><pre><code>无分类域间路由选择  （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"默认路由-default-route\"> 默认路由（default route）：</h4>\n<div><pre><code>当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"路由选择算法-virtual-circuit\"> 路由选择算法（Virtual Circuit）：</h4>\n<div><pre><code>路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-重要知识点总结-4\"> （2）重要知识点总结</h3>\n<p>1，TCP/IP协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</p>\n<p>2，在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</p>\n<p>3，分类的IP地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明IP地址的类别。IP地址是一种分等级的地址结构。IP地址管理机构分配IP地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的IP地址</p>\n<p>4，IP数据报分为首部和数据两部分。首部的前一部分是固定长度，共20字节，是所有IP数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP首部中的生存时间给出了IP数据报在互联网中所能经过的最大路由器数。可防止IP数据报在互联网中无限制的兜圈子。</p>\n<p>5，地址解析协议ARP把IP地址解析为硬件地址。ARP的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去广播方式发送ARP请求分组</p>\n<p>6，无分类域间路由选择CIDR是解决目前IP地址紧缺的一个好办法。CIDR记法把IP地址后面加上斜线“/”，然后写上前缀所所占的位数。前缀（或网络前缀用来指明网络），前缀后面的部分是后缀，用来指明主机。CIDR把前缀都相同的连续的IP地址组成一个“CIDR地址块”，IP地址分配都以CIDR地址块为单位。</p>\n<p>7， 网际控制报文协议是IP层的协议.ICMP报文作为IP数据报的数据，加上首部后组成IP数据报发送出去。使用ICMP数据报并不是为了实现可靠传输。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文的种类有两种 ICMP差错报告报文和ICMP询问报文。</p>\n<p>8，要解决IP地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本IP协议-IPv6。IPv6所带来的变化有①更大的地址空间（采用128位地址）②灵活的首部格式③改进的选项④支持即插即用⑤支持资源的预分配⑥IPv6的首部改为8字节对齐。另外IP数据报的目的地址可以是以下三种基本类型地址之一：单播，多播和任播</p>\n<p>9，虚拟专用网络VPN利用公用的互联网作为本机构专用网之间的通信载体。VPN内使用互联网的专用地址。一个VPN至少要有一个路由器具有合法的全球IP地址，这样才能和本系统的另一个VPN通过互联网进行通信。所有通过互联网传送的数据都需要加密</p>\n<p>10， MPLS的特点是：①支持面向连接的服务质量②支持流量工程，平衡网络负载③有效的支持虚拟专用网VPN。MPLS在入口节点给每一个IP数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</p>\n<h3 id=\"_3-最重要知识点\"> （3）最重要知识点</h3>\n<h4 id=\"_1-虚拟互联网络的概念\"> ① 虚拟互联网络的概念</h4>\n<h4 id=\"_2-ip地址和物理地址的关系\"> ② IP地址和物理地址的关系</h4>\n<h4 id=\"_3-传统的分类的ip地址-包括子网掩码-和无分类域间路由选择cidr\"> ③ 传统的分类的IP地址（包括子网掩码）和无分类域间路由选择CIDR</h4>\n<h4 id=\"_4-路由选择协议的工作原理\"> ④ 路由选择协议的工作原理</h4>\n<h2 id=\"五、运输层\"> 五、运输层</h2>\n<h3 id=\"_1-基本术语-5\"> （1）基本术语</h3>\n<h4 id=\"进程-process\"> 进程（process）：</h4>\n<div><pre><code>指计算机中正在运行的程序实体\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"应用进程互相通信\"> 应用进程互相通信：</h4>\n<div><pre><code>一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"传输层的复用与分用\"> 传输层的复用与分用：</h4>\n<div><pre><code>复用指发送方不同的进程都可以通过统一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。 \n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"tcp-transmission-control-protocol\"> TCP（Transmission Control Protocol）：</h4>\n<div><pre><code>传输控制协议\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"udp-user-datagram-protocol\"> UDP（User Datagram Protocol）：</h4>\n<div><pre><code>用户数据报协议\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"端口-port-link\"> 端口（port）（link）：</h4>\n<div><pre><code>端口的目的是为了确认对方机器是那个进程在于自己进行交互，比如MSN和QQ的端口不同，如果没有端口就可能出现QQ进程和MSN交互错误。端口又称协议端口号。 \n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"停止等待协议-link\"> 停止等待协议（link）：</h4>\n<div><pre><code>指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"流量控制-link\"> 流量控制（link）：</h4>\n<div><pre><code>就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"拥塞控制-link\"> 拥塞控制（link）：</h4>\n<div><pre><code>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-重要知识点总结-5\"> （2）重要知识点总结</h3>\n<p>1，运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</p>\n<p>2，网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</p>\n<p>3，运输层的两个重要协议是用户数据报协议UDP和传输控制协议TCP。按照OSI的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元TPDU（Transport Protocol Data Unit）。但在TCP/IP体系中，则根据所使用的协议是TCP或UDP，分别称之为TCP报文段或UDP用户数据报。</p>\n<p>4，UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式。 TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的传输服务，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</p>\n<p>5，硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP和TCP的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到IP层交上来的运输层报文时，就能够 根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方IP地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</p>\n<p>6，运输层用一个16位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由TCP和UDP来完成。</p>\n<p>7，运输层的端口号分为服务器端使用的端口号（0<s>1023指派给熟知端口，1024</s>49151是登记端口号）和客户端暂时使用的端口号（49152~65535）</p>\n<p>8，UDP的主要特点是①无连接②尽最大努力交付③面向报文④无拥塞控制⑤支持一对一，一对多，多对一和多对多的交互通信⑥首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</p>\n<p>9，TCP的主要特点是①面向连接②每一条TCP连接只能是一对一的③提供可靠交付④提供全双工通信⑤面向字节流</p>\n<p>10，TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP地址：端口号）来表示。每一条TCP连接唯一被通信两端的两个端点所确定。</p>\n<p>11，停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>\n<p>12，为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</p>\n<p>13，停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续ARQ协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>\n<p>14，TCP报文段的前20个字节是固定的，后面有4n字节是根据需要增加的选项。因此，TCP首部的最小长度是20字节。</p>\n<p>15，TCP使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>\n<p>16，在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>\n<p>17，为了进行拥塞控制，TCP发送方要维持一个拥塞窗口cwnd的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>\n<p>18，TCP的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理AQM），以减少网络拥塞的发生。</p>\n<p>19，运输连接的三个阶段，即：连接建立，数据传送和连接释放。</p>\n<p>20，主动发起TCP连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</p>\n<p>21，TCP的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了TCP连接</p>\n<h3 id=\"_3-最重要的知识点-3\"> （3）最重要的知识点</h3>\n<h4 id=\"_1-端口和套接字的意义\"> ① 端口和套接字的意义</h4>\n<h4 id=\"_2-无连接udp的特点\"> ② 无连接UDP的特点</h4>\n<h4 id=\"_3-面向连接tcp的特点\"> ③ 面向连接TCP的特点</h4>\n<h4 id=\"_4-在不可靠的网络上实现可靠传输的工作原理-停止等待协议和arq协议\"> ④ 在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议</h4>\n<h4 id=\"_1-tcp的滑动窗口-流量控制-拥塞控制和连接管理\"> ① TCP的滑动窗口，流量控制，拥塞控制和连接管理</h4>\n<h2 id=\"六、应用层\"> 六、应用层</h2>\n<h3 id=\"_1-基本术语-6\"> （1）基本术语</h3>\n<h4 id=\"域名系统-dns\"> 域名系统（DNS）：</h4>\n<div><pre><code>DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。\n通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。在RFC文档中RFC 2181对DNS有规范说明，RFC 2136对DNS的动态更新进行说明，RFC 2308对DNS查询的反向缓存进行说明。\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"文件传输协议-ftp\"> 文件传输协议（FTP）：</h4>\n<div><pre><code> FTP 是File TransferProtocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。\n 基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：&quot;下载&quot;（Download）和&quot;上传&quot;（Upload）。\n &quot;下载&quot;文件就是从远程主机拷贝文件至自己的计算机上；&quot;上传&quot;文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"简单文件传输协议-tftp\"> 简单文件传输协议（TFTP）：</h4>\n<div><pre><code>TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"远程终端协议-telenet\"> 远程终端协议（TELENET）：</h4>\n<div><pre><code>Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。\n在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。\n可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"万维网-www\"> 万维网（WWW）：</h4>\n<div><pre><code>WWW是环球信息网的缩写，（亦作“Web”、“WWW”、“&#39;W3&#39;”，英文全称为“World Wide Web”），中文名字为“万维网”，&quot;环球网&quot;等，常简称为Web。分为Web客户端和Web服务器程序。\nWWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。\n万维网联盟（英语：World Wide Web Consortium，简称W3C），又称W3C理事会。1994年10月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。\n万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"万维网的大致工作工程\"> 万维网的大致工作工程：</h4>\n<p><a href=\"https://camo.githubusercontent.com/25cd12cef72f4f0d410f94f4fb7d28c431fd07c8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376666393661393630383761663f773d38333926683d36313026663d6a70656726733d3836373033\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/25cd12cef72f4f0d410f94f4fb7d28c431fd07c8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376666393661393630383761663f773d38333926683d36313026663d6a70656726733d3836373033\" alt=\"万维网的大致工作工程\" /></a></p>\n<h4 id=\"统一资源定位符-url\"> 统一资源定位符（URL）：</h4>\n<div><pre><code>统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 \n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"超文本传输协议-http\"> 超文本传输协议（HTTP）：</h4>\n<div><pre><code>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。\n设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"代理服务器-proxy-server\"> 代理服务器（Proxy Server）：</h4>\n<div><pre><code> 代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。\n 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按URL的地址再次去互联网访问该资源。\n 代理服务器可在客户端或服务器工作，也可以在中间系统工作。 \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"http请求头\"> http请求头：</h4>\n<div><pre><code>http请求头，HTTP客户程序（例如浏览器），向服务器发送请求的时候必须指明请求类型（一般是GET或者POST）。如有必要，客户程序还可以选择发送其他的请求头。\n- Accept：浏览器可接受的MIME类型。\n- Accept-Charset：浏览器可接受的字符集。\n- Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。\n- Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。\n- Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。\n- Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。\n- Content-Length：表示请求消息正文的长度。\n- Cookie：这是最重要的请求头信息之一\n- From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。\n- Host：初始URL中的主机和端口。\n- If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。\n- Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。\n- Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。\n- User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id=\"简单邮件传输协议-smtp\"> 简单邮件传输协议(SMTP)：</h4>\n<div><pre><code> SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。\n SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。\n 通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"搜索引擎\"> 搜索引擎：</h4>\n<div><pre><code> 搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。\n 搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"全文索引\"> 全文索引：</h4>\n<div><pre><code> 全文索引技术是目前搜索引擎的关键技术。\n试想在1M大小的文件中搜索一个词，可能需要几秒，在100M的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。\n所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"目录索引\"> 目录索引：</h4>\n<div><pre><code>目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"垂直搜索引擎\"> 垂直搜索引擎：</h4>\n<div><pre><code>垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。\n垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。\n其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_2-重要知识点总结-6\"> （2）重要知识点总结</h3>\n<p>1，文件传输协议（FTP）使用TCP可靠的运输服务。FTP使用客户服务器方式。一个FTP服务器进程可以同时为多个用户提供服务。在进进行文件传输时，FTP的客户和服务器之间要先建立两个并行的TCP连接:控制连接和数据连接。实际用于传输文件的是数据连接。</p>\n<p>2，万维网客户程序与服务器之间进行交互使用的协议是超文本传输协议HTTP。HTTP使用TCP连接进行可靠传输。但HTTP本身是无连接、无状态的。HTTP/1.1协议使用了持续连接（分为非流水线方式和流水线方式）</p>\n<p>3，电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</p>\n<p>4，一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如SMTP，和邮件读取协议，如POP3和IMAP）。用户代理和邮件服务器都要运行这些协议。</p>\n<h3 id=\"_3-最重要知识点总结\"> （3）最重要知识点总结</h3>\n<h4 id=\"_1-域名系统-从域名解析出ip地址\"> ① 域名系统-从域名解析出IP地址</h4>\n<h4 id=\"_2-访问一个网站大致的过程\"> ② 访问一个网站大致的过程</h4>\n<h4 id=\"_3-系统调用和应用编程接口概念\"> ③ 系统调用和应用编程接口概念</h4>\n<h1 id=\"计算机网络面试知识点总结\"> 计算机网络面试知识点总结</h1>\n<h2 id=\"一、osi与tcp-ip各层的结构与功能-都有哪些协议\"> 一、OSI与TCP/IP各层的结构与功能,都有哪些协议?</h2>\n<p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p>\n<p><img src=\"https://camo.githubusercontent.com/5bf7c14046570425f50bca412a3cf3710514ccff/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542412539342545352542312538322545342542442539332545372542332542422545372542422539332545362539452538342e706e67\" alt=\"\" /></p>\n<p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p>\n<h3 id=\"_1-1-应用层\"> 1.1 应用层</h3>\n<p>**应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。*<em>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如*<em>域名系统DNS</em></em>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p>\n<p><strong>域名系统</strong></p>\n<blockquote>\n<p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href=\"http://www.ibm.xn--comoracle-xj3h/\" target=\"_blank\" rel=\"noopener noreferrer\">www.ibm.com、Oracle</a> 公司的域名是 <a href=\"http://www.oracle.xn--comcisco-hm3g8360a63fhh376bwz2c1gzc/\" target=\"_blank\" rel=\"noopener noreferrer\">www.oracle.com、Cisco公司的域名是</a> <a href=\"http://www.cisco.com/\" target=\"_blank\" rel=\"noopener noreferrer\">www.cisco.com</a> 等。</p>\n</blockquote>\n<p><strong>HTTP协议</strong></p>\n<blockquote>\n<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p>\n</blockquote>\n<h3 id=\"_1-2-运输层\"> 1.2 运输层</h3>\n<p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>\n<p><strong>运输层主要使用以下两种协议:</strong></p>\n<ol>\n<li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）--提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li>\n<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）--提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li>\n</ol>\n<p><strong>TCP 与 UDP 的对比见问题三。</strong></p>\n<h3 id=\"_1-3-网络层\"> 1.3 网络层</h3>\n<p><strong>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p>\n<p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>\n<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p>\n<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p>\n<h3 id=\"_1-4-数据链路层\"> 1.4 数据链路层</h3>\n<p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>\n<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>\n<h3 id=\"_1-5-物理层\"> 1.5 物理层</h3>\n<p>在物理层上所传送的数据单位是比特。 <strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>\n<p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p>\n<h3 id=\"_1-6-总结一下\"> 1.6 总结一下</h3>\n<p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下（图片来源于网络）。</p>\n<p><a href=\"https://camo.githubusercontent.com/62a81cdf1d9840226e1a49625e5821f17e655cfd/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542382538332545352542312538322545342542442539332545372542332542422545372542422539332545362539452538342545352539422542452e706e67\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/62a81cdf1d9840226e1a49625e5821f17e655cfd/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542382538332545352542312538322545342542442539332545372542332542422545372542422539332545362539452538342545352539422542452e706e67\" alt=\"七层体系结构图\" /></a></p>\n<h2 id=\"二、tcp-三次握手和四次挥手-面试常客\"> 二、TCP 三次握手和四次挥手(面试常客)</h2>\n<p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>\n<h3 id=\"_2-1-tcp-三次握手漫画图解\"> 2.1 TCP 三次握手漫画图解</h3>\n<p>如下图所示，下面的两个机器人通过3次握手确定了对方能正确接收和发送消息(图片来源：《图解HTTP》)。 <a href=\"https://camo.githubusercontent.com/ce8b8f1b3c8d2fbe9e5798ceeef0f67e4725fe3a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542382538392545362541432541312545362538462541312545362538392538422e706e67\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/ce8b8f1b3c8d2fbe9e5798ceeef0f67e4725fe3a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542382538392545362541432541312545362538462541312545362538392538422e706e67\" alt=\"TCP三次握手\" /></a></p>\n<p><strong>简单示意图：</strong> <a href=\"https://camo.githubusercontent.com/f6dfce1f05e95f94dbcc4b0bee8c4e3acbfb9f30/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254534254238253839254536254143254131254536253846254131254536253839253842322e706e67\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/f6dfce1f05e95f94dbcc4b0bee8c4e3acbfb9f30/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254534254238253839254536254143254131254536253846254131254536253839253842322e706e67\" alt=\"TCP三次握手\" /></a></p>\n<ul>\n<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>\n<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>\n<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>\n</ul>\n<h3 id=\"_2-2-为什么要三次握手\"> 2.2 为什么要三次握手</h3>\n<p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>\n<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>\n<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>\n<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>\n<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>\n<h3 id=\"_2-3-第2次握手传回了ack-为什么还要传回syn\"> 2.3 第2次握手传回了ACK，为什么还要传回SYN？</h3>\n<p>接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。”</p>\n<blockquote>\n<p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>\n</blockquote>\n<h3 id=\"_2-5-为什么要四次挥手\"> 2.5 为什么要四次挥手</h3>\n<p><a href=\"https://camo.githubusercontent.com/66e3447783e22d736f7db9c7d121e8eba54f07c0/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f5443502545352539422539422545362541432541312545362538432541352545362538392538422e706e67\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/66e3447783e22d736f7db9c7d121e8eba54f07c0/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f5443502545352539422539422545362541432541312545362538432541352545362538392538422e706e67\" alt=\"TCP四次挥手\" /></a></p>\n<p>断开一个 TCP 连接则需要“四次挥手”：</p>\n<ul>\n<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>\n<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li>\n<li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>\n<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li>\n</ul>\n<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>\n<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>\n<p>上面讲的比较概括，推荐一篇讲的比较细致的文章：https://blog.csdn.net/qzcsu/article/details/72861891</p>\n<h2 id=\"三、tcp-udp-协议的区别\"> 三、TCP,UDP 协议的区别</h2>\n<p><a href=\"https://camo.githubusercontent.com/582cf0bd58f1b7859ff7696d0345200d133bee88/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f7463702d76732d7564702e6a7067\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/582cf0bd58f1b7859ff7696d0345200d133bee88/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f7463702d76732d7564702e6a7067\" alt=\"TCP、UDP协议的区别\" /></a></p>\n<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>\n<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>\n<h2 id=\"四-tcp-协议如何保证可靠传输\"> 四 TCP 协议如何保证可靠传输</h2>\n<ol>\n<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>\n<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>\n<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>\n<li>TCP 的接收端会丢弃重复的数据。</li>\n<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>\n<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>\n<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>\n<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>\n</ol>\n<h3 id=\"_4-1-arq协议\"> 4.1 ARQ协议</h3>\n<p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p>\n<h4 id=\"停止等待arq协议\"> 停止等待ARQ协议</h4>\n<ul>\n<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li>\n<li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li>\n</ul>\n<p><strong>优点：</strong> 简单</p>\n<p><strong>缺点：</strong> 信道利用率低，等待时间长</p>\n<p><strong>1) 无差错情况:</strong></p>\n<p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>\n<p><strong>2) 出现差错情况（超时重传）:</strong></p>\n<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>\n<p><strong>3) 确认丢失和确认迟到</strong></p>\n<ul>\n<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>\n<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li>\n</ul>\n<h4 id=\"连续arq协议\"> 连续ARQ协议</h4>\n<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>\n<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>\n<p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>\n<h3 id=\"_4-2-滑动窗口和流量控制\"> 4.2 滑动窗口和流量控制</h3>\n<p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>\n<h3 id=\"_4-3-拥塞控制\"> 4.3 拥塞控制</h3>\n<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>\n<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>\n<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>\n<ul>\n<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>\n<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li>\n<li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>\n</ul>\n<h2 id=\"五、在浏览器中输入url地址-显示主页的过程-面试常客\"> 五、在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)</h2>\n<p>百度好像最喜欢问这个问题。</p>\n<blockquote>\n<p>打开一个网页，整个过程会使用哪些协议？</p>\n</blockquote>\n<p>图解（图片来源：《图解HTTP》）：</p>\n<p><a href=\"https://camo.githubusercontent.com/07ae8275dfa810865986f72535ca7e242857038a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f75726ce8be93e585a5e588b0e5b195e7a4bae587bae69da5e79a84e8bf87e7a88b2e6a7067\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/07ae8275dfa810865986f72535ca7e242857038a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f75726ce8be93e585a5e588b0e5b195e7a4bae587bae69da5e79a84e8bf87e7a88b2e6a7067\" alt=\"img\" /></a></p>\n<blockquote>\n<p>上图有一个错误，请注意，是OSPF不是OPSF。 OSPF（Open Shortest Path Fitst，ospf）开放最短路径优先协议,是由Internet工程任务组开发的路由选择协议</p>\n</blockquote>\n<p>总体来说分为以下几个过程:</p>\n<ol>\n<li>DNS解析</li>\n<li>TCP连接</li>\n<li>发送HTTP请求</li>\n<li>服务器处理请求并返回HTTP报文</li>\n<li>浏览器解析渲染页面</li>\n<li>连接结束</li>\n</ol>\n<p>具体可以参考下面这篇文章：</p>\n<ul>\n<li>https://segmentfault.com/a/1190000006879700</li>\n</ul>\n<h2 id=\"六、状态码\"> 六、状态码</h2>\n<p><a href=\"https://camo.githubusercontent.com/08ea24912a75db4a06bfd17995ce464ee4b4af48/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545372538412542362545362538302538312545372541302538312e706e67\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/08ea24912a75db4a06bfd17995ce464ee4b4af48/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545372538412542362545362538302538312545372541302538312e706e67\" alt=\"状态码\" /></a></p>\n<h2 id=\"七、各种协议与http协议之间的关系\"> 七、各种协议与HTTP协议之间的关系</h2>\n<p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p>\n<p>图片来源：《图解HTTP》</p>\n<p><a href=\"https://camo.githubusercontent.com/d70c1d9edab4a7e4d8320e123e2935ef0375e8f5/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254535253930253834254537254137253844254535253844253846254538254145254145254534254238253845485454502545352538442538462545382541452541452545342542392538422545392539372542342545372539412538342545352538352542332545372542332542422e706e67\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/d70c1d9edab4a7e4d8320e123e2935ef0375e8f5/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254535253930253834254537254137253844254535253844253846254538254145254145254534254238253845485454502545352538442538462545382541452541452545342542392538422545392539372542342545372539412538342545352538352542332545372542332542422e706e67\" alt=\"各种协议与HTTP协议之间的关系\" /></a></p>\n<h2 id=\"八、http长连接-短连接\"> 八、HTTP长连接,短连接</h2>\n<p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>\n<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>\n<div><pre><code>Connection:keep-alive\n</code></pre>\n<div><span>1</span><br></div></div><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>\n<p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p>\n<p>—— <a href=\"https://www.cnblogs.com/gotodsp/p/6366163.html\" target=\"_blank\" rel=\"noopener noreferrer\">《HTTP长连接、短连接究竟是什么？》</a></p>\n<h2 id=\"九、http是不保存状态的协议-如何保存用户状态\"> 九、HTTP是不保存状态的协议,如何保存用户状态?</h2>\n<p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>\n<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>\n<p><strong>Cookie 被禁用怎么办?</strong></p>\n<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>\n<p><a href=\"https://camo.githubusercontent.com/bb933f4dcc039d22ffb579335038fb0e000c7051/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f485454502545362539382541462545362539372541302545372538412542362545362538302538312545372539412538342e706e67\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://camo.githubusercontent.com/bb933f4dcc039d22ffb579335038fb0e000c7051/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f485454502545362539382541462545362539372541302545372538412542362545362538302538312545372539412538342e706e67\" alt=\"HTTP是无状态协议\" /></a></p>\n<h2 id=\"十、cookie的作用是什么-和session有什么区别\"> 十、Cookie的作用是什么?和Session有什么区别？</h2>\n<p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>\n<p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>\n<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>\n<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>\n<h2 id=\"十一、http-1-0和http-1-1的主要区别是什么\"> 十一、HTTP 1.0和HTTP 1.1的主要区别是什么?</h2>\n<blockquote>\n<p>这部分回答引用这篇文章 https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A? 的一些内容。</p>\n</blockquote>\n<p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>\n<ol>\n<li><strong>长连接</strong> : <strong>在HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 <strong>HTTP/1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>\n<li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>\n<li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>\n<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>\n</ol>\n<h2 id=\"十二、uri和url的区别是什么\"> 十二、URI和URL的区别是什么?</h2>\n<ul>\n<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>\n<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>\n</ul>\n<p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>\n<h2 id=\"十三、http-和-https-的区别\"> 十三、HTTP 和 HTTPS 的区别？</h2>\n<ol>\n<li>\n<p><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p>\n</li>\n<li>\n<p>安全性和资源消耗：</p>\n<p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p>\n<ul>\n<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>\n<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"建议\"> 建议</h2>\n<p>非常推荐大家看一下 《图解HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p>\n",
      "image": "https://camo.githubusercontent.com/47e7f195826449a3a89d7ba4988e803e76eaaf11/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f312f313632376637613137306563363631313f773d3132343726683d34323526663d706e6726733d3336373436",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "MySQL大表优化方案",
      "url": "http://blog.alanlee.top/blog-vuepress/database/mysql/MySQL%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/mysql/MySQL%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/",
      "content_html": "<h1 id=\"mysql大表优化方案\"> MySQL大表优化方案</h1>\n<blockquote>\n<p>原文：<a href=\"https://segmentfault.com/a/1190000006158186\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL大表优化方案</a></p>\n<p>地址：https://segmentfault.com/a/1190000006158186</p>\n</blockquote>\n<p>当MySQL单表记录数过大时，增删改查性能都会急剧下降，可以参考以下步骤来优化：</p>\n<h3 id=\"单表优化\"> 单表优化</h3>\n<p>除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在<code>千万级</code>以下，字符串为主的表在<code>五百万</code>以下是没有太大问题的。而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量：</p>\n<h4 id=\"字段\"> 字段</h4>\n<ul>\n<li>尽量使用<code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUM_INT</code>作为整数类型而非<code>INT</code>，如果非负则加上<code>UNSIGNED</code></li>\n<li><code>VARCHAR</code>的长度只分配真正需要的空间</li>\n<li>使用枚举或整数代替字符串类型</li>\n<li>尽量使用<code>TIMESTAMP</code>而非<code>DATETIME</code>，</li>\n<li>单表不要有太多字段，建议在20以内</li>\n<li>避免使用NULL字段，很难查询优化且占用额外索引空间</li>\n<li>用整型来存IP</li>\n</ul>\n<h4 id=\"索引\"> 索引</h4>\n<ul>\n<li>索引并不是越多越好，要根据查询有针对性的创建，考虑在<code>WHERE</code>和<code>ORDER BY</code>命令上涉及的列建立索引，可根据<code>EXPLAIN</code>来查看是否用了索引还是全表扫描</li>\n<li>应尽量避免在<code>WHERE</code>子句中对字段进行<code>NULL</code>值判断，否则将导致引擎放弃使用索引而进行全表扫描</li>\n<li>值分布很稀少的字段不适合建索引，例如&quot;性别&quot;这种只有两三个值的字段</li>\n<li>字符字段只建前缀索引</li>\n<li>字符字段最好不要做主键</li>\n<li>不用外键，由程序保证约束</li>\n<li>尽量不用<code>UNIQUE</code>，由程序保证约束</li>\n<li>使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引</li>\n</ul>\n<h4 id=\"查询sql\"> 查询SQL</h4>\n<ul>\n<li>可通过开启慢查询日志来找出较慢的SQL</li>\n<li>不做列运算：<code>SELECT id WHERE age + 1 = 10</code>，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边</li>\n<li>sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库</li>\n<li>不用<code>SELECT *</code></li>\n<li><code>OR</code>改写成<code>IN</code>：<code>OR</code>的效率是n级别，<code>IN</code>的效率是log(n)级别，in的个数建议控制在200以内</li>\n<li>不用函数和触发器，在应用程序实现</li>\n<li>避免<code>%xxx</code>式查询</li>\n<li>少用<code>JOIN</code></li>\n<li>使用同类型进行比较，比如用<code>'123'</code>和<code>'123'</code>比，<code>123</code>和<code>123</code>比</li>\n<li>尽量避免在<code>WHERE</code>子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</li>\n<li>对于连续数值，使用<code>BETWEEN</code>不用<code>IN</code>：<code>SELECT id FROM t WHERE num BETWEEN 1 AND 5</code></li>\n<li>列表数据不要拿全表，要使用<code>LIMIT</code>来分页，每页数量也不要太大</li>\n</ul>\n<h4 id=\"引擎\"> 引擎</h4>\n<p>目前广泛使用的是MyISAM和InnoDB两种引擎：</p>\n<h5 id=\"myisam\"> MyISAM</h5>\n<p>MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：</p>\n<ul>\n<li>不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁</li>\n<li>不支持事务</li>\n<li>不支持外键</li>\n<li>不支持崩溃后的安全恢复</li>\n<li>在表有读取查询的同时，支持往表中插入新纪录</li>\n<li>支持<code>BLOB</code>和<code>TEXT</code>的前500个字符索引，支持全文索引</li>\n<li>支持延迟更新索引，极大提升写入性能</li>\n<li>对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用</li>\n</ul>\n<h5 id=\"innodb\"> InnoDB</h5>\n<p>InnoDB在MySQL 5.5后成为默认索引，它的特点是：</p>\n<ul>\n<li>支持行锁，采用MVCC来支持高并发</li>\n<li>支持事务</li>\n<li>支持外键</li>\n<li>支持崩溃后的安全恢复</li>\n<li>不支持全文索引</li>\n</ul>\n<p>总体来讲，MyISAM适合<code>SELECT</code>密集型的表，而InnoDB适合<code>INSERT</code>和<code>UPDATE</code>密集型的表</p>\n<h4 id=\"系统调优参数\"> 系统调优参数</h4>\n<p>可以使用下面几个工具来做基准测试：</p>\n<ul>\n<li><a href=\"https://github.com/akopytov/sysbench\" target=\"_blank\" rel=\"noopener noreferrer\">sysbench</a>：一个模块化，跨平台以及多线程的性能测试工具</li>\n<li><a href=\"https://github.com/tmcallaghan/iibench-mysql\" target=\"_blank\" rel=\"noopener noreferrer\">iibench-mysql</a>：基于 Java 的 MySQL/Percona/MariaDB 索引进行插入性能测试工具</li>\n<li><a href=\"https://github.com/Percona-Lab/tpcc-mysql\" target=\"_blank\" rel=\"noopener noreferrer\">tpcc-mysql</a>：Percona开发的TPC-C测试工具</li>\n</ul>\n<p>具体的调优参数内容较多，具体可参考官方文档，这里介绍一些比较重要的参数：</p>\n<ul>\n<li>back_log：back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySql的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。可以从默认的50升至500</li>\n<li>wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时</li>\n<li>max_user_connection: 最大连接数，默认为0无上限，最好设一个合理上限</li>\n<li>thread_concurrency：并发线程数，设为CPU核数的两倍</li>\n<li>skip_name_resolve：禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问</li>\n<li>key_buffer_size：索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。对于内存4G左右，可设为256M或384M，通过查询<code>show status like 'key_read%'</code>，保证<code>key_reads / key_read_requests</code>在0.1%以下最好</li>\n<li>innodb_buffer_pool_size：缓存数据块和索引块，对InnoDB表性能影响最大。通过查询<code>show status like 'Innodb_buffer_pool_read%'</code>，保证<code>(Innodb_buffer_pool_read_requests – Innodb_buffer_pool_reads) / Innodb_buffer_pool_read_requests</code>越高越好</li>\n<li>innodb_additional_mem_pool_size：InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL会记录Warning信息到数据库的错误日志中，这时就需要该调整这个参数大小</li>\n<li>innodb_log_buffer_size：InnoDB存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MB</li>\n<li>query_cache_size：缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。当某个表的数据有任何任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用Query Cache可能会得不偿失。根据命中率<code>(Qcache_hits/(Qcache_hits+Qcache_inserts)*100))</code>进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大.\n可以通过命令<code>show status like 'Qcache_%'</code>查看目前系统Query catch使用大小</li>\n<li>read_buffer_size：MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能</li>\n<li>sort_buffer_size：MySql执行排序使用的缓冲大小。如果想要增加<code>ORDER BY</code>的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小</li>\n<li>read_rnd_buffer_size：MySql的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。</li>\n<li>record_buffer：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值</li>\n<li>thread_cache_size：保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的</li>\n<li>table_cache：类似于thread_cache_size，但用来缓存表文件，对InnoDB效果不大，主要用于MyISAM</li>\n</ul>\n<h4 id=\"升级硬件\"> 升级硬件</h4>\n<p>Scale up，这个不多说了，根据MySQL是CPU密集型还是I/O密集型，通过提升CPU和内存、使用SSD，都能显著提升MySQL性能</p>\n<h3 id=\"读写分离\"> 读写分离</h3>\n<p>也是目前常用的优化，从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离</p>\n<h3 id=\"缓存\"> 缓存</h3>\n<p>缓存可以发生在这些层次：</p>\n<ul>\n<li>MySQL内部：在系统调优参数介绍了相关设置</li>\n<li>数据访问层：比如MyBatis针对SQL语句做缓存，而Hibernate可以精确到单个记录，这里缓存的对象主要是持久化对象<code>Persistence Object</code></li>\n<li>应用服务层：这里可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对象是数据传输对象<code>Data Transfer Object</code></li>\n<li>Web层：针对web页面做缓存</li>\n<li>浏览器客户端：用户端的缓存</li>\n</ul>\n<p>可以根据实际情况在一个层次或多个层次结合加入缓存。这里重点介绍下服务层的缓存实现，目前主要有两种方式：</p>\n<ul>\n<li>直写式（Write Through）：在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是当前大多数应用缓存框架如Spring Cache的工作方式。这种实现非常简单，同步好，但效率一般。</li>\n<li>回写式（Write Back）：当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。这种实现比较复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率非常高。</li>\n</ul>\n<h3 id=\"表分区\"> 表分区</h3>\n<p>MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码</p>\n<p>对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000006767126/view\" alt=\"Alt text\" /></p>\n<p>用户的SQL语句是需要针对分区表做优化，SQL条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过<code>EXPLAIN PARTITIONS</code>来查看某条SQL语句会落在那些分区上，从而进行SQL优化，如下图5条记录落在两个分区上：</p>\n<div><pre><code>mysql&gt; explain partitions select count(1) from user_partition where id in (1,2,3,4,5);\n+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+\n| id | select_type | table          | partitions | type  | possible_keys | key     | key_len | ref  | rows | Extra                    |\n+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+\n|  1 | SIMPLE      | user_partition | p1,p4      | range | PRIMARY       | PRIMARY | 8       | NULL |    5 | Using where; Using index |\n+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+\n1 row in set (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>分区的好处是：</p>\n<ul>\n<li>可以让单表存储更多的数据</li>\n<li>分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作</li>\n<li>部分查询能够从查询条件确定只落在少数分区上，速度会很快</li>\n<li>分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备</li>\n<li>可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争</li>\n<li>可以备份和恢复单个分区</li>\n</ul>\n<p>分区的限制和缺点：</p>\n<ul>\n<li>一个表最多只能有1024个分区</li>\n<li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li>\n<li>分区表无法使用外键约束</li>\n<li>NULL值会使分区过滤无效</li>\n<li>所有分区必须使用相同的存储引擎</li>\n</ul>\n<p>分区的类型：</p>\n<ul>\n<li>RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区</li>\n<li>LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择</li>\n<li>HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式</li>\n<li>KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值</li>\n</ul>\n<p>分区适合的场景有：</p>\n<ul>\n<li>最适合的场景数据的时间序列性比较强，则可以按时间来分区，如下所示：</li>\n</ul>\n<div><pre><code>CREATE TABLE members (\n    firstname VARCHAR(25) NOT NULL,\n    lastname VARCHAR(25) NOT NULL,\n    username VARCHAR(16) NOT NULL,\n    email VARCHAR(35),\n    joined DATE NOT NULL\n)\nPARTITION BY RANGE( YEAR(joined) ) (\n    PARTITION p0 VALUES LESS THAN (1960),\n    PARTITION p1 VALUES LESS THAN (1970),\n    PARTITION p2 VALUES LESS THAN (1980),\n    PARTITION p3 VALUES LESS THAN (1990),\n    PARTITION p4 VALUES LESS THAN MAXVALUE\n);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>查询时加上时间范围条件效率会非常高，同时对于不需要的历史数据能很容的批量删除。</p>\n<ul>\n<li>如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将热点数据单独放在一个分区，让这个分区的数据能够有机会都缓存在内存中，查询时只访问一个很小的分区表，能够有效使用索引和缓存</li>\n</ul>\n<p>另外MySQL有一种早期的简单的分区实现 - 合并表（merge table），限制较多且缺乏优化，不建议使用，应该用新的分区机制来替代</p>\n<h3 id=\"垂直拆分\"> 垂直拆分</h3>\n<p>垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联</p>\n<p>比如原始的用户表是：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000006158196\" alt=\"Alt text\" /></p>\n<p>垂直拆分后是：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000006158199\" alt=\"Alt text\" /></p>\n<p>垂直拆分的优点是：</p>\n<ul>\n<li>可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I/O次数(每次查询时读取的Block 就少)</li>\n<li>可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起</li>\n<li>数据维护简单</li>\n</ul>\n<p>缺点是：</p>\n<ul>\n<li>主键出现冗余，需要管理冗余列</li>\n<li>会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力</li>\n<li>依然存在单表数据量过大的问题（需要水平拆分）</li>\n<li>事务处理复杂</li>\n</ul>\n<h3 id=\"水平拆分\"> 水平拆分</h3>\n<h4 id=\"概述\"> 概述</h4>\n<p>水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。前面的表分区本质上也是一种特殊的库内分表</p>\n<p>库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻MySQL服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的IO、CPU、网络，这个就要通过分库来解决</p>\n<p>前面垂直拆分的用户表如果进行水平拆分，结果是：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000006158207\" alt=\"Alt text\" /></p>\n<p>实际情况中往往会是垂直拆分和水平拆分的结合，即将<code>Users_A_M</code>和<code>Users_N_Z</code>再拆成<code>Users</code>和<code>UserExtras</code>，这样一共四张表</p>\n<p>水平拆分的优点是:</p>\n<ul>\n<li>不存在单库大数据和高并发的性能瓶颈</li>\n<li>应用端改造较少</li>\n<li>提高了系统的稳定性和负载能力</li>\n</ul>\n<p>缺点是：</p>\n<ul>\n<li>分片事务一致性难以解决</li>\n<li>跨节点Join性能差，逻辑复杂</li>\n<li>数据多次扩展难度跟维护量极大</li>\n</ul>\n<h4 id=\"分片原则\"> 分片原则</h4>\n<ul>\n<li>能不分就不分，参考单表优化</li>\n<li>分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询SQL跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量</li>\n<li>分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性Hash分片，这几种分片都有利于扩容</li>\n<li>尽量不要在一个事务中的SQL跨越多个分片，分布式事务一直是个不好处理的问题</li>\n<li>查询条件尽量优化，尽量避免Select * 的方式，大量数据结果集下，会消耗大量带宽和CPU资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引。</li>\n<li>通过数据冗余和表分区赖降低跨库Join的可能</li>\n</ul>\n<p>这里特别强调一下分片规则的选择问题，如果某个表的数据有明显的时间特征，比如订单、交易记录等，则他们通常比较合适用时间范围分片，因为具有时效性的数据，我们往往关注其近期的数据，查询条件中往往带有时间字段进行过滤，比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。</p>\n<p>总体上来说，分片的选择是取决于最频繁的查询SQL的条件，因为不带任何Where语句的查询SQL，会遍历所有的分片，性能相对最差，因此这种SQL越多，对系统的影响越大，所以我们要尽量避免这种SQL的产生。</p>\n<h4 id=\"解决方案\"> 解决方案</h4>\n<p>由于水平拆分牵涉的逻辑比较复杂，当前也有了不少比较成熟的解决方案。这些方案分为两大类：客户端架构和代理架构。</p>\n<h5 id=\"客户端架构\"> 客户端架构</h5>\n<p>通过修改数据访问层，如JDBC、Data Source、MyBatis，通过配置来管理多个数据源，直连数据库，并在模块内完成数据的分片整合，一般以Jar包的方式呈现</p>\n<p>这是一个客户端架构的例子：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000006158210\" alt=\"Alt text\" /></p>\n<p>可以看到分片的实现是和应用服务器在一起的，通过修改Spring JDBC层来实现</p>\n<p>客户端架构的优点是：</p>\n<ul>\n<li>应用直连数据库，降低外围系统依赖所带来的宕机风险</li>\n<li>集成成本低，无需额外运维的组件</li>\n</ul>\n<p>缺点是：</p>\n<ul>\n<li>限于只能在数据库访问层上做文章，扩展性一般，对于比较复杂的系统可能会力不从心</li>\n<li>将分片逻辑的压力放在应用服务器上，造成额外风险</li>\n</ul>\n<h5 id=\"代理架构\"> 代理架构</h5>\n<p>通过独立的中间件来统一管理所有数据源和数据分片整合，后端数据库集群对前端应用程序透明，需要独立部署和运维代理组件</p>\n<p>这是一个代理架构的例子：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000006767127\" alt=\"Alt text\" /></p>\n<p>代理组件为了分流和防止单点，一般以集群形式存在，同时可能需要Zookeeper之类的服务组件来管理</p>\n<p>代理架构的优点是：</p>\n<ul>\n<li>能够处理非常复杂的需求，不受数据库访问层原来实现的限制，扩展性强</li>\n<li>对于应用服务器透明且没有增加任何额外负载</li>\n</ul>\n<p>缺点是：</p>\n<ul>\n<li>需部署和运维独立的代理中间件，成本高</li>\n<li>应用需经过代理来连接数据库，网络上多了一跳，性能有损失且有额外风险</li>\n</ul>\n<h5 id=\"各方案比较\"> 各方案比较</h5>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>出品方</th>\n<th>架构模型</th>\n<th>支持数据库</th>\n<th>分库</th>\n<th>分表</th>\n<th>读写分离</th>\n<th>外部依赖</th>\n<th>是否开源</th>\n<th>实现语言</th>\n<th>支持语言</th>\n<th>最后更新</th>\n<th>Github星数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://www.mysql.com/products/enterprise/fabric.html\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL Fabric</a></td>\n<td>MySQL官方</td>\n<td>代理架构</td>\n<td>MySQL</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>是</td>\n<td>python</td>\n<td>无限制</td>\n<td>4个月前</td>\n<td>35</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/alibaba/cobar\" target=\"_blank\" rel=\"noopener noreferrer\">Cobar</a></td>\n<td>阿里巴巴</td>\n<td>代理架构</td>\n<td>MySQL</td>\n<td>有</td>\n<td>无</td>\n<td>无</td>\n<td>无</td>\n<td>是</td>\n<td>Java</td>\n<td>无限制</td>\n<td>两年前</td>\n<td>1287</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/alibaba/cobarclient\" target=\"_blank\" rel=\"noopener noreferrer\">Cobar Client</a></td>\n<td>阿里巴巴</td>\n<td>客户端架构</td>\n<td>MySQL</td>\n<td>有</td>\n<td>无</td>\n<td>无</td>\n<td>无</td>\n<td>是</td>\n<td>Java</td>\n<td>Java</td>\n<td>三年前</td>\n<td>344</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/alibaba/tb_tddl\" target=\"_blank\" rel=\"noopener noreferrer\">TDDL</a></td>\n<td>淘宝</td>\n<td>客户端架构</td>\n<td>无限制</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>Diamond</td>\n<td>只开源部分</td>\n<td>Java</td>\n<td>Java</td>\n<td>未知</td>\n<td>519</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/Qihoo360/Atlas\" target=\"_blank\" rel=\"noopener noreferrer\">Atlas</a></td>\n<td>奇虎360</td>\n<td>代理架构</td>\n<td>MySQL</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>是</td>\n<td>C</td>\n<td>无限制</td>\n<td>10个月前</td>\n<td>1941</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/brucexx/heisenberg\" target=\"_blank\" rel=\"noopener noreferrer\">Heisenberg</a></td>\n<td>百度熊照</td>\n<td>代理架构</td>\n<td>MySQL</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>是</td>\n<td>Java</td>\n<td>无限制</td>\n<td>2个月前</td>\n<td>197</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/jojoin/TribeDB\" target=\"_blank\" rel=\"noopener noreferrer\">TribeDB</a></td>\n<td>个人</td>\n<td>代理架构</td>\n<td>MySQL</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>是</td>\n<td>NodeJS</td>\n<td>无限制</td>\n<td>3个月前</td>\n<td>126</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/dangdangdotcom/sharding-jdbc\" target=\"_blank\" rel=\"noopener noreferrer\">ShardingJDBC</a></td>\n<td>当当</td>\n<td>客户端架构</td>\n<td>MySQL</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>是</td>\n<td>Java</td>\n<td>Java</td>\n<td>当天</td>\n<td>1144</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/gaoxianglong/shark\" target=\"_blank\" rel=\"noopener noreferrer\">Shark</a></td>\n<td>个人</td>\n<td>客户端架构</td>\n<td>MySQL</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>无</td>\n<td>是</td>\n<td>Java</td>\n<td>Java</td>\n<td>两天前</td>\n<td>84</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/flike/kingshard\" target=\"_blank\" rel=\"noopener noreferrer\">KingShard</a></td>\n<td>个人</td>\n<td>代理架构</td>\n<td>MySQL</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>是</td>\n<td>Golang</td>\n<td>无限制</td>\n<td>两天前</td>\n<td>1836</td>\n</tr>\n<tr>\n<td><a href=\"http://www.onexsoft.com/?page_id=3383\" target=\"_blank\" rel=\"noopener noreferrer\">OneProxy</a></td>\n<td>平民软件</td>\n<td>代理架构</td>\n<td>MySQL</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>否</td>\n<td>未知</td>\n<td>无限制</td>\n<td>未知</td>\n<td>未知</td>\n</tr>\n<tr>\n<td><a href=\"http://mycat.io/\" target=\"_blank\" rel=\"noopener noreferrer\">MyCat</a></td>\n<td>社区</td>\n<td>代理架构</td>\n<td>MySQL</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>是</td>\n<td>Java</td>\n<td>无限制</td>\n<td>两天前</td>\n<td>1270</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/youtube/vitess\" target=\"_blank\" rel=\"noopener noreferrer\">Vitess</a></td>\n<td>Youtube</td>\n<td>代理架构</td>\n<td>MySQL</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>是</td>\n<td>Golang</td>\n<td>无限制</td>\n<td>当天</td>\n<td>3636</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/siddontang/mixer\" target=\"_blank\" rel=\"noopener noreferrer\">Mixer</a></td>\n<td>个人</td>\n<td>代理架构</td>\n<td>MySQL</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>无</td>\n<td>是</td>\n<td>Golang</td>\n<td>无限制</td>\n<td>9个月前</td>\n<td>472</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/tumblr/jetpants\" target=\"_blank\" rel=\"noopener noreferrer\">JetPants</a></td>\n<td>Tumblr</td>\n<td>客户端架构</td>\n<td>MySQL</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>无</td>\n<td>是</td>\n<td>Ruby</td>\n<td>Ruby</td>\n<td>10个月前</td>\n<td>957</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/hibernate/hibernate-shards\" target=\"_blank\" rel=\"noopener noreferrer\">HibernateShard</a></td>\n<td>Hibernate</td>\n<td>客户端架构</td>\n<td>无限制</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>无</td>\n<td>是</td>\n<td>Java</td>\n<td>Java</td>\n<td>4年前</td>\n<td>57</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/makersoft/mybatis-shards\" target=\"_blank\" rel=\"noopener noreferrer\">MybatisShard</a></td>\n<td>MakerSoft</td>\n<td>客户端架构</td>\n<td>无限制</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>无</td>\n<td>是</td>\n<td>Java</td>\n<td>Java</td>\n<td>11个月前</td>\n<td>119</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/twitter/gizzard\" target=\"_blank\" rel=\"noopener noreferrer\">Gizzard</a></td>\n<td>Twitter</td>\n<td>代理架构</td>\n<td>无限制</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>无</td>\n<td>是</td>\n<td>Java</td>\n<td>无限制</td>\n<td>3年前</td>\n<td>2087</td>\n</tr>\n</tbody>\n</table>\n<p>如此多的方案，如何进行选择？可以按以下思路来考虑：</p>\n<ol>\n<li>确定是使用代理架构还是客户端架构。中小型规模或是比较简单的场景倾向于选择客户端架构，复杂场景或大规模系统倾向选择代理架构</li>\n<li>具体功能是否满足，比如需要跨节点<code>ORDER BY</code>，那么支持该功能的优先考虑</li>\n<li>不考虑一年内没有更新的产品，说明开发停滞，甚至无人维护和技术支持</li>\n<li>最好按大公司-&gt;社区-&gt;小公司-&gt;个人这样的出品方顺序来选择</li>\n<li>选择口碑较好的，比如github星数、使用者数量质量和使用者反馈</li>\n<li>开源的优先，往往项目有特殊需求可能需要改动源代码</li>\n</ol>\n<p>按照上述思路，推荐以下选择：</p>\n<ul>\n<li>客户端架构：ShardingJDBC</li>\n<li>代理架构：MyCat或者Atlas</li>\n</ul>\n<h3 id=\"兼容mysql且可水平扩展的数据库\"> 兼容MySQL且可水平扩展的数据库</h3>\n<p>目前也有一些开源数据库兼容MySQL协议，如：</p>\n<ul>\n<li><a href=\"https://github.com/pingcap/tidb\" target=\"_blank\" rel=\"noopener noreferrer\">TiDB</a></li>\n<li><a href=\"http://www.cubrid.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Cubrid</a></li>\n</ul>\n<p>但其工业品质和MySQL尚有差距，且需要较大的运维投入，如果想将原始的MySQL迁移到可水平扩展的新数据库中，可以考虑一些云数据库：</p>\n<ul>\n<li><a href=\"https://cn.aliyun.com/product/petadata/?spm=5176.7960203.237031.38.cAzx5r\" target=\"_blank\" rel=\"noopener noreferrer\">阿里云PetaData</a></li>\n<li><a href=\"https://cn.aliyun.com/product/oceanbase?spm=5176.7960203.237031.40.cAzx5r\" target=\"_blank\" rel=\"noopener noreferrer\">阿里云OceanBase</a></li>\n<li><a href=\"https://www.qcloud.com/product/dcdb_for_tdsql.html\" target=\"_blank\" rel=\"noopener noreferrer\">腾讯云DCDB</a></li>\n</ul>\n<h3 id=\"nosql\"> NoSQL</h3>\n<p>在MySQL上做Sharding是一种戴着镣铐的跳舞，事实上很多大表本身对MySQL这种RDBMS的需求并不大，并不要求ACID，可以考虑将这些表迁移到NoSQL，彻底解决水平扩展问题，例如：</p>\n<ul>\n<li>日志类、监控类、统计类数据</li>\n<li>非结构化或弱结构化数据</li>\n<li>对事务要求不强，且无太多关联操作的数据</li>\n</ul>\n",
      "image": "https://segmentfault.com/img/remote/1460000006767126/view",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Mycat的安装与简单使用",
      "url": "http://blog.alanlee.top/blog-vuepress/database/mysql/mycat/Mycat%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/mysql/mycat/Mycat%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/",
      "content_html": "<h1 id=\"mycat的安装与简单使用\"> Mycat的安装与简单使用</h1>\n<h2 id=\"一、准备资源\"> 一、准备资源</h2>\n<table>\n<thead>\n<tr>\n<th>IP</th>\n<th>主机名</th>\n<th>数据库名</th>\n<th>安装软件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>192.168.1.20</td>\n<td>master</td>\n<td>master_db1</td>\n<td>mycat,mysql</td>\n</tr>\n<tr>\n<td>192.168.1.21</td>\n<td>node1</td>\n<td>node1_db2</td>\n<td>mysql</td>\n</tr>\n<tr>\n<td>192.168.1.22</td>\n<td>node2</td>\n<td>node2_db3</td>\n<td>mysql</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二、安装mysql\"> 二、安装MySQL</h2>\n<p>安装mysql的方式有很多，这里我使用docker来安装mysql。</p>\n<p>3台机子上都执行同样的操作</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515152615593.png\" alt=\"image-20200515152615593\" /></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515155644635.png\" alt=\"image-20200515155644635\" /></p>\n<h2 id=\"三、连接数据库\"> 三、连接数据库</h2>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515155756557.png\" alt=\"image-20200515155756557\" /></p>\n<h3 id=\"创建数据库\"> 创建数据库</h3>\n<p>local-master创建db1</p>\n<div><pre><code>create database db1<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>local-node-1创建db2</p>\n<div><pre><code>create database db2<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>local-node-2创建db3</p>\n<div><pre><code>create database db3<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"四、安装mycat\"> 四、安装Mycat</h2>\n<p>去官网下载mycat，链接http://www.mycat.org.cn/</p>\n<ol>\n<li>上传Mycat到服务器</li>\n</ol>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515160405920.png\" alt=\"image-20200515160405920\" /></p>\n<ol start=\"2\">\n<li>解压</li>\n</ol>\n<div><pre><code><span>tar</span> -zxvf Mycat-server-1.4-release-20151019230038-linux.tar.gz\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515160529560.png\" alt=\"image-20200515160529560\" /></p>\n<ol start=\"3\">\n<li>创建组</li>\n</ol>\n<div><pre><code>groupadd mycat\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"4\">\n<li>创建一个新的用户，并加入group</li>\n</ol>\n<div><pre><code><span>useradd</span> -g mycat mycat\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"5\">\n<li>给新用户设置密码</li>\n</ol>\n<div><pre><code><span>passwd</span> mycat\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515161040956.png\" alt=\"image-20200515161040956\" /></p>\n<ol start=\"6\">\n<li>进入conf</li>\n</ol>\n<p>修改server.xml</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515161416760.png\" alt=\"image-20200515161416760\" /></p>\n<blockquote>\n<p>完整的server.xml</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n\n<span><span>&lt;!</span><span>DOCTYPE</span> <span>mycat:server</span> <span>SYSTEM</span> <span>\"server.dtd\"</span><span>></span></span>\n<span><span><span>&lt;</span><span>mycat:</span>server</span> <span><span>xmlns:</span>mycat</span><span><span>=</span><span>\"</span>http://org.opencloudb/<span>\"</span></span><span>></span></span>\n\t<span><span><span>&lt;</span>system</span><span>></span></span>\n\t<span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>defaultSqlParser<span>\"</span></span><span>></span></span>druidparser<span><span><span>&lt;/</span>property</span><span>></span></span>\n\t<span><span><span>&lt;/</span>system</span><span>></span></span>\n\t<span><span><span>&lt;</span>user</span> <span>name</span><span><span>=</span><span>\"</span>root<span>\"</span></span><span>></span></span>\n\t\t<span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>password<span>\"</span></span><span>></span></span>123456<span><span><span>&lt;/</span>property</span><span>></span></span>\n\t\t<span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>schemas<span>\"</span></span><span>></span></span>zdxh<span><span><span>&lt;/</span>property</span><span>></span></span>\n\t<span><span><span>&lt;/</span>user</span><span>></span></span>\n<span><span><span>&lt;/</span><span>mycat:</span>server</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></blockquote>\n<p>修改schema.xml</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515161739168.png\" alt=\"image-20200515161739168\" /></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200516105219957.png\" alt=\"image-20200516105219957\" /></p>\n<blockquote>\n<p>完整的schema.xml</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\"?></span>\n<span><span>&lt;!</span><span>DOCTYPE</span> <span>mycat:schema</span> <span>SYSTEM</span> <span>\"schema.dtd\"</span><span>></span></span>\n<span><span><span>&lt;</span><span>mycat:</span>schema</span> <span><span>xmlns:</span>mycat</span><span><span>=</span><span>\"</span>http://org.opencloudb/<span>\"</span></span><span>></span></span>\n\n\t<span><span><span>&lt;</span>schema</span> <span>name</span><span><span>=</span><span>\"</span>zdxh<span>\"</span></span> <span>checkSQLschema</span><span><span>=</span><span>\"</span>false<span>\"</span></span> <span>sqlMaxLimit</span><span><span>=</span><span>\"</span>100<span>\"</span></span><span>></span></span>\n\t\t<span><span><span>&lt;</span>table</span> <span>name</span><span><span>=</span><span>\"</span>employee<span>\"</span></span> <span>primaryKey</span><span><span>=</span><span>\"</span>ID<span>\"</span></span> <span>dataNode</span><span><span>=</span><span>\"</span>dn1,dn2,dn3<span>\"</span></span>\n\t\t\t<span>rule</span><span><span>=</span><span>\"</span>sharding-by-intfile<span>\"</span></span> <span>/></span></span>\n\t<span><span><span>&lt;/</span>schema</span><span>></span></span>\n\n\t<span><span><span>&lt;</span>dataNode</span> <span>name</span><span><span>=</span><span>\"</span>dn1<span>\"</span></span> <span>dataHost</span><span><span>=</span><span>\"</span>local-master<span>\"</span></span> <span>database</span><span><span>=</span><span>\"</span>master_db1<span>\"</span></span> <span>/></span></span>\n\t<span><span><span>&lt;</span>dataNode</span> <span>name</span><span><span>=</span><span>\"</span>dn2<span>\"</span></span> <span>dataHost</span><span><span>=</span><span>\"</span>local-node-1<span>\"</span></span> <span>database</span><span><span>=</span><span>\"</span>node1_db2<span>\"</span></span> <span>/></span></span>\n\t<span><span><span>&lt;</span>dataNode</span> <span>name</span><span><span>=</span><span>\"</span>dn3<span>\"</span></span> <span>dataHost</span><span><span>=</span><span>\"</span>local-node-2<span>\"</span></span> <span>database</span><span><span>=</span><span>\"</span>node2_db3<span>\"</span></span> <span>/></span></span>\n\n\t<span><span><span>&lt;</span>dataHost</span> <span>name</span><span><span>=</span><span>\"</span>local-master<span>\"</span></span> <span>maxCon</span><span><span>=</span><span>\"</span>1000<span>\"</span></span> <span>minCon</span><span><span>=</span><span>\"</span>10<span>\"</span></span> <span>balance</span><span><span>=</span><span>\"</span>0<span>\"</span></span>\n\t\t<span>writeType</span><span><span>=</span><span>\"</span>0<span>\"</span></span> <span>dbType</span><span><span>=</span><span>\"</span>mysql<span>\"</span></span> <span>dbDriver</span><span><span>=</span><span>\"</span>native<span>\"</span></span> <span>switchType</span><span><span>=</span><span>\"</span>1<span>\"</span></span>  <span>slaveThreshold</span><span><span>=</span><span>\"</span>100<span>\"</span></span><span>></span></span>\n\t\t<span><span><span>&lt;</span>heartbeat</span><span>></span></span>select user()<span><span><span>&lt;/</span>heartbeat</span><span>></span></span>\n\t\t<span><span><span>&lt;</span>writeHost</span> <span>host</span><span><span>=</span><span>\"</span>hostM1<span>\"</span></span> <span>url</span><span><span>=</span><span>\"</span>192.168.1.20:3306<span>\"</span></span> <span>user</span><span><span>=</span><span>\"</span>root<span>\"</span></span> <span>password</span><span><span>=</span><span>\"</span>123456<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>writeHost</span><span>></span></span>\n\t<span><span><span>&lt;/</span>dataHost</span><span>></span></span>\n\t\n\t<span><span><span>&lt;</span>dataHost</span> <span>name</span><span><span>=</span><span>\"</span>local-node-1<span>\"</span></span> <span>maxCon</span><span><span>=</span><span>\"</span>1000<span>\"</span></span> <span>minCon</span><span><span>=</span><span>\"</span>10<span>\"</span></span> <span>balance</span><span><span>=</span><span>\"</span>0<span>\"</span></span>\n\t\t<span>writeType</span><span><span>=</span><span>\"</span>0<span>\"</span></span> <span>dbType</span><span><span>=</span><span>\"</span>mysql<span>\"</span></span> <span>dbDriver</span><span><span>=</span><span>\"</span>native<span>\"</span></span> <span>switchType</span><span><span>=</span><span>\"</span>1<span>\"</span></span>  <span>slaveThreshold</span><span><span>=</span><span>\"</span>100<span>\"</span></span><span>></span></span>\n\t\t<span><span><span>&lt;</span>heartbeat</span><span>></span></span>select user()<span><span><span>&lt;/</span>heartbeat</span><span>></span></span>\n\t\t<span><span><span>&lt;</span>writeHost</span> <span>host</span><span><span>=</span><span>\"</span>hostM2<span>\"</span></span> <span>url</span><span><span>=</span><span>\"</span>192.168.1.21:3306<span>\"</span></span> <span>user</span><span><span>=</span><span>\"</span>root<span>\"</span></span> <span>password</span><span><span>=</span><span>\"</span>123456<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>writeHost</span><span>></span></span>\n\t<span><span><span>&lt;/</span>dataHost</span><span>></span></span>\n\t\n\t<span><span><span>&lt;</span>dataHost</span> <span>name</span><span><span>=</span><span>\"</span>local-node-2<span>\"</span></span> <span>maxCon</span><span><span>=</span><span>\"</span>1000<span>\"</span></span> <span>minCon</span><span><span>=</span><span>\"</span>10<span>\"</span></span> <span>balance</span><span><span>=</span><span>\"</span>0<span>\"</span></span>\n\t\t<span>writeType</span><span><span>=</span><span>\"</span>0<span>\"</span></span> <span>dbType</span><span><span>=</span><span>\"</span>mysql<span>\"</span></span> <span>dbDriver</span><span><span>=</span><span>\"</span>native<span>\"</span></span> <span>switchType</span><span><span>=</span><span>\"</span>1<span>\"</span></span>  <span>slaveThreshold</span><span><span>=</span><span>\"</span>100<span>\"</span></span><span>></span></span>\n\t\t<span><span><span>&lt;</span>heartbeat</span><span>></span></span>select user()<span><span><span>&lt;/</span>heartbeat</span><span>></span></span>\n\t\t<span><span><span>&lt;</span>writeHost</span> <span>host</span><span><span>=</span><span>\"</span>hostM3<span>\"</span></span> <span>url</span><span><span>=</span><span>\"</span>192.168.1.22:3306<span>\"</span></span> <span>user</span><span><span>=</span><span>\"</span>root<span>\"</span></span> <span>password</span><span><span>=</span><span>\"</span>123456<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>writeHost</span><span>></span></span>\n\t<span><span><span>&lt;/</span>dataHost</span><span>></span></span>\n\n<span><span><span>&lt;/</span><span>mycat:</span>schema</span><span>></span></span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div></blockquote>\n<p>修改partition-hash-int.txt</p>\n<div><pre><code>10000=0\n10010=1\n10020=2\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start=\"7\">\n<li>启动mycat</li>\n</ol>\n<div><pre><code><span>cd</span> bin\n./mycat start\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>启动成功</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515170634394.png\" alt=\"image-20200515170634394\" /></p>\n<h2 id=\"五、测试与使用\"> 五、测试与使用</h2>\n<ol>\n<li>navicat连接mycat</li>\n</ol>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515170923072.png\" alt=\"image-20200515170923072\" /></p>\n<blockquote>\n<p>这里显示连接成功，但是打不开数据库，后面会提到解决方案，先往后面的步骤继续做</p>\n</blockquote>\n<ol start=\"2\">\n<li>创建表</li>\n</ol>\n<div><pre><code>use zdxh;\ncreate table employee (id int not null primary key,name varchar(100),sharding_id int not null);\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515175655400.png\" alt=\"image-20200515175655400\" /></p>\n<ol start=\"3\">\n<li>往mycat中插入数据</li>\n</ol>\n<div><pre><code>INSERT INTO EMPLOYEE(ID,NAME,SHARDING_ID) VALUES(1, &#39;I am db1&#39;,10000);\nINSERT INTO EMPLOYEE(ID,NAME,SHARDING_ID) VALUES(2, &#39;I am db2&#39;,10010);\nINSERT INTO EMPLOYEE(ID,NAME,SHARDING_ID) VALUES(3, &#39;I am db3&#39;,10020);\nINSERT INTO EMPLOYEE(ID,NAME,SHARDING_ID) VALUES(4, &#39;I am db1&#39;,10000);\nINSERT INTO EMPLOYEE(ID,NAME,SHARDING_ID) VALUES(5, &#39;I am db2&#39;,10010);\nINSERT INTO EMPLOYEE(ID,NAME,SHARDING_ID) VALUES(6, &#39;I am db3&#39;,10020);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>效果</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515203852730.png\" alt=\"image-20200515203852730\" /></p>\n<p>在mycat中插入的6条数据被分散地插入到3个数据库中</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515204045044.png\" alt=\"image-20200515204045044\" /></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515204109907.png\" alt=\"image-20200515204109907\" /></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515204124375.png\" alt=\"image-20200515204124375\" /></p>\n<h2 id=\"六、遇到的问题\"> 六、遇到的问题</h2>\n<h3 id=\"问题1\"> 问题1</h3>\n<p>org.opencloudb.config.util.ConfigException: schema zdxh refered by user root is not exist!</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515163739559.png\" alt=\"image-20200515163739559\" /></p>\n<h4 id=\"原因\"> 原因</h4>\n<p>schema.xml文件下的schema标签的name属性值忘了改成zdxh</p>\n<h4 id=\"解决\"> 解决</h4>\n<p>schema.xml文件下的schema标签的name属性值改成zdxh</p>\n<h3 id=\"问题2\"> 问题2</h3>\n<p>navicat连接mycat，显示连接成功，却打不开mycat，提示database not selected的问题</p>\n<img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515171718851.png\" alt=\"image-20200515171718851\" style=\"zoom: 50%;\" />\n<h4 id=\"原因-2\"> 原因</h4>\n<p>navicat版本的问题</p>\n<h4 id=\"解决-2\"> 解决</h4>\n<p>方案1：</p>\n<p>如果采用工具连接，1.4,1.3目前部分工具无法连接，会提示database not selected，建议采用高版本，navicat测试。1.5已经修复了部分工具连接。</p>\n<p>方案2：使用mysql客户端连接</p>\n<div><pre><code>mysql -uroot -p123456 -P8066 -h192.168.1.20\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515173743637.png\" alt=\"image-20200515173743637\" /></p>\n<p>方案3：使用sqlyog连接工具连接</p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200515152615593.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "为什么不建议使用外键",
      "url": "http://blog.alanlee.top/blog-vuepress/database/mysql/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%A4%96%E9%94%AE/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/mysql/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%A4%96%E9%94%AE/",
      "content_html": "<h1 id=\"为什么不建议使用外键\"> 为什么不建议使用外键</h1>\n<h2 id=\"外键和级联\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E5%88%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5?id=%E5%A4%96%E9%94%AE%E5%92%8C%E7%BA%A7%E8%81%94\" target=\"_blank\" rel=\"noopener noreferrer\">外键和级联</a></h2>\n<p>对于外键和级联，阿里巴巴开发手册这样说到：</p>\n<blockquote>\n<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>\n<p>说明:以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群;级联更新是强阻塞，存在数据库更新风暴的风 险;外键影响数据库的插入速度</p>\n</blockquote>\n<p>为什么不要用外键呢？大部分人可能会这样回答：</p>\n<blockquote>\n<ol>\n<li><strong>增加了复杂性：</strong> a.每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦,测试数据极为不方便;b.外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li>\n<li><strong>增加了额外工作</strong>： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li>\n<li>外键还会因为需要请求对其他表内部加锁而容易出现死锁情况；</li>\n<li><strong>对分不分表不友好</strong> ：因为分库分表下外键是无法生效的。</li>\n<li>......</li>\n</ol>\n</blockquote>\n<p>我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：</p>\n<ol>\n<li>保证了数据库数据的一致性和完整性；</li>\n<li>级联操作方便，减轻了程序代码量；</li>\n<li>......</li>\n</ol>\n<p>所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分不分表，并发量不是很高的情况还是可以考虑使用外键的。</p>\n<p>我个人是不太喜欢外键约束，比较喜欢在应用层去进行相关操作。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Explain关键字详解",
      "url": "http://blog.alanlee.top/blog-vuepress/database/mysql/explain%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/mysql/explain%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/",
      "content_html": "<h1 id=\"explain关键字详解\"> Explain关键字详解</h1>\n<blockquote>\n<p>原文：<a href=\"https://segmentfault.com/a/1190000021458117\" target=\"_blank\" rel=\"noopener noreferrer\">一张图彻底搞懂MySQL的 explain</a></p>\n<p>地址：https://segmentfault.com/a/1190000021458117?utm_source=tag-newest#item-1</p>\n</blockquote>\n<blockquote>\n<p>explain关键字可以模拟MySQL优化器执行SQL语句，可以很好的分析SQL语句或表结构的性能瓶颈。</p>\n</blockquote>\n<h2 id=\"explain的用途\"> explain的用途</h2>\n<div><pre><code>1. 表的读取顺序如何\n2. 数据读取操作有哪些操作类型\n3. 哪些索引可以使用\n4. 哪些索引被实际使用\n5. 表之间是如何引用\n6. 每张表有多少行被优化器查询\n......\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"explain的执行效果\"> explain的执行效果</h2>\n<div><pre><code>mysql&gt; explain select * from subject where id = 1 \\G\n******************************************************\n           id: 1\n  select_type: SIMPLE\n        table: subject\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 4\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n******************************************************\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"explain包含的字段\"> explain包含的字段</h2>\n<div><pre><code>1. id //select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序\n2. select_type //查询类型\n3. table //正在访问哪个表\n4. partitions //匹配的分区\n5. type //访问的类型\n6. possible_keys //显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到\n7. key //实际使用到的索引，如果为NULL，则没有使用索引\n8. key_len //表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度\n9. ref //显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值\n10. rows //根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数\n11. filtered //查询的表行占表的百分比\n12. Extra //包含不适合在其它列中显示但十分重要的额外信息\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"图片版\"> 图片版</h2>\n<p><img src=\"https://segmentfault.com/img/remote/1460000021458122/view\" alt=\"一张图搞定explain\" /></p>\n<h2 id=\"文字版\"> 文字版</h2>\n<h3 id=\"id字段\"> id字段</h3>\n<h5 id=\"_1-id相同\"> 1. id相同</h5>\n<div><pre><code>执行顺序从上至下\n例子：\nexplain select subject.* from subject,student_score,teacher where subject.id = student_id and subject.teacher_id = teacher.id;\n读取顺序：subject &gt; teacher &gt; student_score\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458124\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_2-id不同\"> 2. id不同</h5>\n<div><pre><code>如果是子查询，id的序号会递增，id的值越大优先级越高，越先被执行\n例子：\nexplain select score.* from student_score as score where subject_id = (select id from subject where teacher_id = (select id from teacher where id = 2));\n读取顺序：teacher &gt; subject &gt; student_score\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458120\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_3-id相同又不同\"> 3. id相同又不同</h5>\n<div><pre><code>id如果相同，可以认为是一组，从上往下顺序执行\n在所有组中，id值越大，优先级越高，越先执行\n例子：\nexplain select subject.* from subject left join teacher on subject.teacher_id = teacher.id\n -&gt; union \n -&gt; select subject.* from subject right join teacher on subject.teacher_id = teacher.id;\n 读取顺序：2.teacher &gt; 2.subject &gt; 1.subject &gt; 1.teacher\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458126\" alt=\"一张图搞定 explain\" /></p>\n<h3 id=\"select-type字段\"> select_type字段</h3>\n<h5 id=\"_1-simple\"> 1. SIMPLE</h5>\n<div><pre><code>简单查询，不包含子查询或Union查询\n例子：\nexplain select subject.* from subject,student_score,teacher where subject.id = student_id and subject.teacher_id = teacher.id;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458121\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_2-primary\"> 2. PRIMARY</h5>\n<div><pre><code>查询中若包含任何复杂的子部分，最外层查询则被标记为主查询\n例子：\nexplain select score.* from student_score as score where subject_id = (select id from subject where teacher_id = (select id from teacher where id = 2));\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458125\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_3-subquery\"> 3. SUBQUERY</h5>\n<div><pre><code>在select或where中包含子查询\n例子：\nexplain select score.* from student_score as score where subject_id = (select id from subject where teacher_id = (select id from teacher where id = 2));\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458123\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_4-derived\"> 4. DERIVED</h5>\n<div><pre><code>在FROM列表中包含的子查询被标记为DERIVED（衍生），MySQL\n会递归执行这些子查询，把结果放在临时表中\n备注：\nMySQL5.7+ 进行优化了，增加了derived_merge（派生合并），默认开启，可加快查询效率\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h5 id=\"_5-union\"> 5. UNION</h5>\n<div><pre><code>若第二个select出现在uion之后，则被标记为UNION\n例子：\nexplain select subject.* from subject left join teacher on subject.teacher_id = teacher.id\n -&gt; union \n -&gt; select subject.* from subject right join teacher on subject.teacher_id = teacher.id;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458127\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_6-union-result\"> 6. UNION RESULT</h5>\n<div><pre><code>从UNION表获取结果的select\n例子：\nexplain select subject.* from subject left join teacher on subject.teacher_id = teacher.id\n -&gt; union \n -&gt; select subject.* from subject right join teacher on subject.teacher_id = teacher.id;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458128\" alt=\"一张图搞定 explain\" /></p>\n<h3 id=\"type字段\"> type字段</h3>\n<div><pre><code>NULL&gt;system&gt;const&gt;eq_ref&gt;ref&gt;fulltext&gt;ref_or_null&gt;index_merge&gt;unique_subquery&gt;index_subquery&gt;range&gt;index&gt;ALL //最好到最差\n备注：掌握以下10种常见的即可\nNULL&gt;system&gt;const&gt;eq_ref&gt;ref&gt;ref_or_null&gt;index_merge&gt;range&gt;index&gt;ALL\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h5 id=\"_1-null\"> 1. NULL</h5>\n<div><pre><code>MySQL能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引\n例子：\nexplain select min(id) from subject;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458137\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_2-system\"> 2. system</h5>\n<div><pre><code>表只有一行记录（等于系统表），这是const类型的特列，平时不大会出现，可以忽略\n</code></pre>\n<div><span>1</span><br></div></div><h5 id=\"_3-const\"> 3. const</h5>\n<div><pre><code>表示通过索引一次就找到了，const用于比较primary key或uique索引，因为只匹配一行数据，所以很快，如主键置于where列表中，MySQL就能将该查询转换为一个常量\n例子：\nexplain select * from teacher where teacher_no = &#39;T2010001&#39;;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458138\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_4-eq-ref\"> 4. eq_ref</h5>\n<div><pre><code>唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描\n例子：\nexplain select subject.* from subject left join teacher on subject.teacher_id = teacher.id;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458134\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_5-ref\"> 5. ref</h5>\n<div><pre><code>非唯一性索引扫描，返回匹配某个单独值的所有行\n本质上也是一种索引访问，返回所有匹配某个单独值的行\n然而可能会找到多个符合条件的行，应该属于查找和扫描的混合体\n例子：\nexplain select subject.* from subject,student_score,teacher where subject.id = student_id and subject.teacher_id = teacher.id;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458135\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_6-ref-or-null\"> 6. ref_or_null</h5>\n<div><pre><code>类似ref，但是可以搜索值为NULL的行\n例子：\nexplain select * from teacher where name = &#39;wangsi&#39; or name is null;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458130\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_7-index-merge\"> 7. index_merge</h5>\n<div><pre><code>表示使用了索引合并的优化方法\n例子：\nexplain select * from teacher where id = 1 or teacher_no = &#39;T2010001&#39; .\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458129\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_8-range\"> 8. range</h5>\n<div><pre><code>只检索给定范围的行，使用一个索引来选择行，key列显示使用了哪个索引\n一般就是在你的where语句中出现between、&lt;&gt;、in等的查询。\n例子：\nexplain select * from subject where id between 1 and 3;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458132\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_9-index\"> 9. index</h5>\n<div><pre><code>Full index Scan，Index与All区别：index只遍历索引树，通常比All快\n因为索引文件通常比数据文件小，也就是虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘读的。\n例子：\nexplain select id from subject;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458131\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_10-all\"> 10. ALL</h5>\n<div><pre><code>Full Table Scan，将遍历全表以找到匹配行\n例子：\nexplain select * from subject;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458133\" alt=\"一张图搞定 explain\" /></p>\n<h3 id=\"table字段\"> table字段</h3>\n<div><pre><code>数据来自哪张表\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"possible-keys字段\"> possible_keys字段</h3>\n<div><pre><code>显示可能应用在这张表中的索引，一个或多个\n查询涉及到的字段若存在索引，则该索引将被列出，但不一定被实际使用\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"key字段\"> key字段</h3>\n<div><pre><code> 实际使用到的索引，如果为NULL，则没有使用索引\n查询中若使用了覆盖索引（查询的列刚好是索引），则该索引仅出现在key列表\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"key-len字段\"> key_len字段</h3>\n<div><pre><code> 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度\n在不损失精确度的情况下，长度越短越好\nkey_len显示的值为索引字段最大的可能长度，并非实际使用长度\n即key_len是根据定义计算而得，不是通过表内检索出的\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"ref字段\"> ref字段</h3>\n<div><pre><code>显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"rows字段\"> rows字段</h3>\n<div><pre><code>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"partitions字段\"> partitions字段</h3>\n<div><pre><code>匹配的分区\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"filtered字段\"> filtered字段</h3>\n<div><pre><code>查询的表行占表的百分比\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"extra字段\"> Extra字段</h3>\n<div><pre><code>包含不适合在其它列中显示但十分重要的额外信息\n</code></pre>\n<div><span>1</span><br></div></div><h5 id=\"_1-using-filesort\"> 1. Using filesort</h5>\n<div><pre><code>说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取\nMySQL中无法利用索引完成的排序操作称为“文件排序”\n例子：\nexplain select * from subject order by name;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458136\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_2-using-temporary\"> 2. Using temporary</h5>\n<div><pre><code>使用了临时表保存中间结果，MySQL在对结果排序时使用临时表，常见于排序order by 和分组查询group by\n例子：\nexplain select subject.* from subject left join teacher on subject.teacher_id = teacher.id\n -&gt; union \n -&gt; select subject.* from subject right join teacher on subject.teacher_id = teacher.id;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458141\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_3-using-index\"> 3. Using index</h5>\n<div><pre><code>表示相应的select操作中使用了覆盖索引（Covering Index）,避免访问了表的数据行，效率不错！\n如果同时出现using where，表明索引被用来执行索引键值的查找\n如果没有同时出现using where，表明索引用来读取数据而非执行查找动作\n例子：\nexplain select subject.* from subject,student_score,teacher where subject.id = student_id and subject.teacher_id = teacher.id;\n备注：\n覆盖索引：select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，即查询列要被所建的索引覆盖\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458145\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_4-using-where\"> 4. Using where</h5>\n<div><pre><code>使用了where条件\n例子：\nexplain select subject.* from subject,student_score,teacher where subject.id = student_id and subject.teacher_id = teacher.id;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458139\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_5-using-join-buffer\"> 5. Using join buffer</h5>\n<div><pre><code>使用了连接缓存\n例子：\nexplain select student.*,teacher.*,subject.* from student,teacher,subject;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458140\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_6-impossible-where\"> 6. impossible where</h5>\n<div><pre><code>where子句的值总是false，不能用来获取任何元组\n例子：\nexplain select * from teacher where name = &#39;wangsi&#39; and name = &#39;lisi&#39;;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458144\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_7-distinct\"> 7. distinct</h5>\n<div><pre><code>一旦mysql找到了与行相联合匹配的行，就不再搜索了\n例子：\nexplain select distinct teacher.name from teacher left join subject on teacher.id = subject.teacher_id;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458143\" alt=\"一张图搞定 explain\" /></p>\n<h5 id=\"_8-select-tables-optimized-away\"> 8. Select tables optimized away</h5>\n<div><pre><code>SELECT操作已经优化到不能再优化了（MySQL根本没有遍历表或索引就返回数据了）\n例子：\nexplain select min(id) from subject;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://segmentfault.com/img/remote/1460000021458142\" alt=\"一张图搞定 explain\" /></p>\n<h3 id=\"使用的数据表\"> 使用的数据表</h3>\n<div><pre><code>create table subject(\n -&gt; id int(10) auto_increment,\n -&gt; name varchar(20),\n -&gt; teacher_id int(10),\n -&gt; primary key (id),\n -&gt; index idx_teacher_id (teacher_id));//学科表\n \ncreate table teacher(\n -&gt; id int(10) auto_increment,\n -&gt; name varchar(20),\n -&gt; teacher_no varchar(20),\n -&gt; primary key (id),\n -&gt; unique index unx_teacher_no (teacher_no(20)));//教师表\n \n create table student(\n -&gt; id int(10) auto_increment,\n -&gt; name varchar(20),\n -&gt; student_no varchar(20),\n -&gt; primary key (id),\n -&gt; unique index unx_student_no (student_no(20)));//学生表\n \n create table student_score(\n -&gt; id int(10) auto_increment,\n -&gt; student_id int(10),\n -&gt; subject_id int(10),\n -&gt; score int(10),\n -&gt; primary key (id),\n -&gt; index idx_student_id (student_id),\n -&gt; index idx_subject_id (subject_id));//学生成绩表\n \n alter table teacher add index idx_name(name(20));//教师表增加名字普通索引\n \n 数据填充：\n insert into student(name,student_no) values (&#39;zhangsan&#39;,&#39;20200001&#39;),(&#39;lisi&#39;,&#39;20200002&#39;),(&#39;yan&#39;,&#39;20200003&#39;),(&#39;dede&#39;,&#39;20200004&#39;);\n \n insert into teacher(name,teacher_no) values(&#39;wangsi&#39;,&#39;T2010001&#39;),(&#39;sunsi&#39;,&#39;T2010002&#39;),(&#39;jiangsi&#39;,&#39;T2010003&#39;),(&#39;zhousi&#39;,&#39;T2010004&#39;);\n \n insert into subject(name,teacher_id) values(&#39;math&#39;,1),(&#39;Chinese&#39;,2),(&#39;English&#39;,3),(&#39;history&#39;,4);\n \ninsert into student_score(student_id,subject_id,score) values(1,1,90),(1,2,60),(1,3,80),(1,4,100),(2,4,60),(2,3,50),(2,2,80),(2,1,90),(3,1,90),(3,4,100),(4,1,40),(4,2,80),(4,3,80),(4,5,100);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div>",
      "image": "https://segmentfault.com/img/remote/1460000021458122/view",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "一条SQL语句执行得很慢的原因有哪些",
      "url": "http://blog.alanlee.top/blog-vuepress/database/mysql/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%97%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/mysql/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%97%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B/",
      "content_html": "<h1 id=\"一条sql语句执行得很慢的原因有哪些\"> 一条SQL语句执行得很慢的原因有哪些</h1>\n<p>说实话，这个问题可以涉及到 MySQL 的很多核心知识，可以扯出一大堆，就像要考你计算机网络的知识时，问你“输入URL回车之后，究竟发生了什么”一样，看看你能说出多少了。</p>\n<p>之前腾讯面试的实话，也问到这个问题了，不过答的很不好，之前没去想过相关原因，导致一时之间扯不出来。所以今天，我带大家来详细扯一下有哪些原因，相信你看完之后一定会有所收获，不然你打我。</p>\n<h3 id=\"一、开始装逼-分类讨论\"> 一、开始装逼：分类讨论</h3>\n<p>一条 SQL 语句执行的很慢，那是每次执行都很慢呢？还是大多数情况下是正常的，偶尔出现很慢呢？所以我觉得，我们还得分以下两种情况来讨论。</p>\n<p><strong>1、大多数情况是正常的，只是偶尔会出现很慢的情况。</strong></p>\n<p><strong>2、在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。</strong></p>\n<p>针对这两种情况，我们来分析下可能是哪些原因导致的。</p>\n<h2 id=\"二、针对偶尔很慢的情况\"> 二、针对偶尔很慢的情况</h2>\n<p>一条 SQL 大多数情况正常，偶尔才能出现很慢的情况，针对这种情况，我觉得这条SQL语句的书写本身是没什么问题的，而是其他原因导致的，那会是什么原因呢？</p>\n<h3 id=\"_1、数据库在刷新脏页-flush-我也无奈啊\"> 1、数据库在刷新脏页（flush）我也无奈啊</h3>\n<p>当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在<strong>内存</strong>中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到<strong>磁盘</strong>中去，而是把这些更新的记录写入到 redo log 日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到<strong>磁盘</strong>中去。</p>\n<blockquote>\n<p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p>\n</blockquote>\n<p><strong>刷脏页有下面4种场景（后两种不用太关注“性能”问题）：</strong></p>\n<ul>\n<li>**redolog写满了：**redo log 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，<strong>就会导致我们平时正常的SQL语句突然执行的很慢</strong>，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的SQL语句执行的很慢了。</li>\n<li>**内存不够用了：**如果一次查询较多的数据，恰好碰到所查数据页不在内存中时，需要申请内存，而此时恰好内存不足的时候就需要淘汰一部分内存数据页，如果是干净页，就直接释放，如果恰好是脏页就需要刷脏页。</li>\n<li>**MySQL 认为系统“空闲”的时候：**这时系统没什么压力。</li>\n<li>**MySQL 正常关闭的时候：**这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li>\n</ul>\n<h3 id=\"_2、拿不到锁我能怎么办\"> 2、拿不到锁我能怎么办</h3>\n<p>这个就比较容易想到了，我们要执行的这条语句，刚好这条语句涉及到的<strong>表</strong>，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者，表没有加锁，但要使用到的某个一行被加锁了，这个时候，我也没办法啊。</p>\n<p>如果要判断是否真的在等待锁，我们可以用 <strong>show processlist</strong>这个命令来查看当前的状态哦，这里我要提醒一下，有些命令最好记录一下，反正，我被问了好几个命令，都不知道怎么写，呵呵。</p>\n<p>下来我们来访分析下第二种情况，我觉得第二种情况的分析才是最重要的</p>\n<h2 id=\"三、针对一直都这么慢的情况\"> 三、针对一直都这么慢的情况</h2>\n<p>如果在数据量一样大的情况下，这条 SQL 语句每次都执行的这么慢，那就就要好好考虑下你的 SQL 书写了，下面我们来分析下哪些原因会导致我们的 SQL 语句执行的很不理想。</p>\n<p>我们先来假设我们有一个表，表里有下面两个字段,分别是主键 id，和两个普通字段 c 和 d。</p>\n<div><pre><code>mysql&gt; CREATE TABLE `t` (\n  `id` int(11) NOT NULL,\n  `c` int(11) DEFAULT NULL,\n  `d` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_1、扎心了-没用到索引\"> 1、扎心了，没用到索引</h3>\n<p>没有用上索引，我觉得这个原因是很多人都能想到的，例如你要查询这条语句</p>\n<div><pre><code>select * from t where 100 &lt;c and c &lt; 100000;\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>（1）、字段没有索引</strong></p>\n<p>刚好你的 c 字段上没有索引，那么抱歉，只能走全表扫描了，你就体验不会索引带来的乐趣了，所以，这回导致这条查询语句很慢。</p>\n<p><strong>（2）、字段有索引，但却没有用索引</strong></p>\n<p>好吧，这个时候你给 c 这个字段加上了索引，然后又查询了一条语句</p>\n<div><pre><code>select * from t where c - 1 = 1000;\n</code></pre>\n<div><span>1</span><br></div></div><p>我想问大家一个问题，这样子在查询的时候会用索引查询吗？</p>\n<p>答是不会，如果我们在字段的左边做了运算，那么很抱歉，在查询的时候，就不会用上索引了，所以呢，大家要注意这种<strong>字段上有索引，但由于自己的疏忽，导致系统没有使用索引</strong>的情况了。</p>\n<p>正确的查询应该如下</p>\n<div><pre><code>select * from t where c = 1000 + 1;\n</code></pre>\n<div><span>1</span><br></div></div><p>有人可能会说，右边有运算就能用上索引？难道数据库就不会自动帮我们优化一下，自动把 c - 1=1000 自动转换为 c = 1000+1。</p>\n<p>不好意思，确实不会帮你，所以，你要注意了。</p>\n<p><strong>（3）、函数操作导致没有用上索引</strong></p>\n<p>如果我们在查询的时候，对字段进行了函数操作，也是会导致没有用上索引的，例如</p>\n<div><pre><code>select * from t where pow(c,2) = 1000;\n</code></pre>\n<div><span>1</span><br></div></div><p>这里我只是做一个例子，假设函数 pow 是求 c 的 n 次方，实际上可能并没有 pow(c,2)这个函数。其实这个和上面在左边做运算也是很类似的。</p>\n<p>所以呢，一条语句执行都很慢的时候，可能是该语句没有用上索引了，不过具体是啥原因导致没有用上索引的呢，你就要会分析了，我上面列举的三个原因，应该是出现的比较多的吧。</p>\n<h3 id=\"_2、呵呵-数据库自己选错索引了\"> 2、呵呵，数据库自己选错索引了</h3>\n<p>我们在进行查询操作的时候，例如</p>\n<div><pre><code>select * from t where 100 &lt; c and c &lt; 100000;\n</code></pre>\n<div><span>1</span><br></div></div><p>我们知道，主键索引和非主键索引是有区别的，主键索引存放的值是<strong>整行字段的数据</strong>，而非主键索引上存放的值不是整行字段的数据，而且存放<strong>主键字段的值</strong>。不大懂的可以看这篇文章： <a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484848&amp;idx=1&amp;sn=77a0e6e82944ec385f5df17e91ce3bf2&amp;chksm=cea24a7bf9d5c36d4b289cccb017292f9f36da9f3c887fd2b93ecd6af021fcf30121ba09799f&amp;token=1082669959&amp;lang=zh_CN&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">【思维导图-索引篇】搞定数据库索引就是这么简单</a> 里面有说到主键索引和非主键索引的区别</p>\n<p>也就是说，我们如果走 c 这个字段的索引的话，最后会查询到对应主键的值，然后，再根据主键的值走主键索引，查询到整行数据返回。</p>\n<p>好吧扯了这么多，其实我就是想告诉你，就算你在 c 字段上有索引，系统也并不一定会走 c 这个字段上的索引，而是有可能会直接扫描扫描全表，找出所有符合 100 &lt; c and c &lt; 100000 的数据。</p>\n<p><strong>为什么会这样呢？</strong></p>\n<p>其实是这样的，系统在执行这条语句的时候，会进行预测：究竟是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？显然，扫描行数越少当然越好了，因为扫描行数越少，意味着I/O操作的次数越少。</p>\n<p>如果是扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，也就是说，需要走两次索引。而且，我们也不知道符合 100 c &lt; and c &lt; 10000 这个条件的数据有多少行，万一这个表是全部数据都符合呢？这个时候意味着，走 c 索引不仅扫描的行数是 n，同时还得每行数据走两次索引。</p>\n<p><strong>所以呢，系统是有可能走全表扫描而不走索引的。那系统是怎么判断呢？</strong></p>\n<p>判断来源于系统的预测，也就是说，如果要走 c 字段索引的话，系统会预测走 c 字段索引大概需要扫描多少行。如果预测到要扫描的行数很多，它可能就不走索引而直接扫描全表了。</p>\n<p>那么问题来了，**系统是怎么预测判断的呢？**这里我给你讲下系统是怎么判断的吧，虽然这个时候我已经写到脖子有点酸了。</p>\n<p>系统是通过<strong>索引的区分度</strong>来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。我们也把区分度称之为<strong>基数</strong>，即区分度越高，基数越大。所以呢，基数越大，意味着符合 100 &lt; c and c &lt; 10000 这个条件的行数越少。</p>\n<p>所以呢，一个索引的基数越大，意味着走索引查询越有优势。</p>\n<p><strong>那么问题来了，怎么知道这个索引的基数呢？</strong></p>\n<p>系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过<strong>采样</strong>的方式，来预测索引的基数的。</p>\n<p><strong>扯了这么多，重点的来了</strong>，居然是采样，那就有可能出现<strong>失误</strong>的情况，也就是说，c 这个索引的基数实际上是很大的，但是采样的时候，却很不幸，把这个索引的基数预测成很小。例如你采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。<strong>然后就呵呵，系统就不走 c 索引了，直接走全部扫描了</strong>。</p>\n<p>所以呢，说了这么多，得出结论：<strong>由于统计的失误，导致系统没有走索引，而是走了全表扫描</strong>，而这，也是导致我们 SQL 语句执行的很慢的原因。</p>\n<blockquote>\n<p>这里我声明一下，系统判断是否走索引，扫描行数的预测其实只是原因之一，这条查询语句是否需要使用使用临时表、是否需要排序等也是会影响系统的选择的。</p>\n</blockquote>\n<p>不过呢，我们有时候也可以通过强制走索引的方式来查询，例如</p>\n<div><pre><code>select * from t force index(a) where c &lt; 100 and c &lt; 100000;\n</code></pre>\n<div><span>1</span><br></div></div><p>我们也可以通过</p>\n<div><pre><code>show index from t;\n</code></pre>\n<div><span>1</span><br></div></div><p>来查询索引的基数和实际是否符合，如果和实际很不符合的话，我们可以重新来统计索引的基数，可以用这条命令</p>\n<div><pre><code>analyze table t;\n</code></pre>\n<div><span>1</span><br></div></div><p>来重新统计分析。</p>\n<p><strong>既然会预测错索引的基数，这也意味着，当我们的查询语句有多个索引的时候，系统有可能也会选错索引哦</strong>，这也可能是 SQL 执行的很慢的一个原因。</p>\n<p>好吧，就先扯这么多了，你到时候能扯出这么多，我觉得已经很棒了，下面做一个总结。</p>\n<p><strong>四、总结</strong></p>\n<p>以上是我的总结与理解，最后一个部分，我怕很多人不大懂<strong>数据库居然会选错索引</strong>，所以我详细解释了一下，下面我对以上做一个总结。</p>\n<p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p>\n<p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p>\n<p>(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。</p>\n<p>(2)、执行的时候，遇到锁，如表锁、行锁。</p>\n<p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p>\n<p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p>\n<p>(2)、数据库选错了索引。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Oracle数据库",
      "url": "http://blog.alanlee.top/blog-vuepress/database/oracle/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/oracle/",
      "content_html": "<h1 id=\"oracle数据库\"> Oracle数据库</h1>\n<img :src=\"$withBase=('/note_images/oracle.jpg')\"/>\n<p>Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。它是在数据库领域一直处于领先地位的产品。可以说Oracle数据库系统是目前世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小、微机环境。它是一种高效率、可靠性好的、适应高吞吐量的数据库方案。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "IO多路复用",
      "url": "http://blog.alanlee.top/blog-vuepress/database/redis/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/redis/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/",
      "content_html": "<h1 id=\"io多路复用\"> IO多路复用</h1>\n<p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p>\n<p><img src=\"https://pic3.zhimg.com/50/9155e2307879cd7ce515e7a997b9d532_hd.jpg\" alt=\"img\" /><img src=\"https://pic3.zhimg.com/80/9155e2307879cd7ce515e7a997b9d532_1440w.jpg\" alt=\"img\" /></p>\n<p>这样在处理1000个连接时，只需要1个线程监控就绪状态，对就绪的每个连接开一个线程处理就可以了，这样需要的线程数大大减少，减少了内存开销和上下文切换的CPU开销。</p>\n<p>使用select函数的方式如下图所示：</p>\n<p><img src=\"https://pic4.zhimg.com/50/bf52854bd1dc678de998b77aebaa2311_hd.jpg\" alt=\"img\" /><img src=\"https://pic4.zhimg.com/80/bf52854bd1dc678de998b77aebaa2311_1440w.jpg\" alt=\"img\" /></p>\n",
      "image": "https://pic3.zhimg.com/50/9155e2307879cd7ce515e7a997b9d532_hd.jpg",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Redis",
      "url": "http://blog.alanlee.top/blog-vuepress/database/redis/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/redis/",
      "content_html": "<h1 id=\"redis\"> Redis</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "一条SQL语句在MySQL中如何执行的",
      "url": "http://blog.alanlee.top/blog-vuepress/database/mysql/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E5%9C%A8MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/mysql/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E5%9C%A8MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/",
      "content_html": "<h1 id=\"一条sql语句在mysql中如何执行的\"> 一条SQL语句在MySQL中如何执行的</h1>\n<p>本篇文章会分析一个 sql 语句在 MySQL 中的执行流程，包括 sql 的查询在 MySQL 内部会怎么流转，sql 语句的更新是怎么完成的。</p>\n<p>在分析之前我会先带着你看看 MySQL 的基础架构，知道了 MySQL 由那些组件组成以及这些组件的作用是什么，可以帮助我们理解和解决这些问题。</p>\n<h2 id=\"一-mysql-基础架构分析\"> 一 MySQL 基础架构分析</h2>\n<h3 id=\"_1-1-mysql-基本架构概览\"> 1.1 MySQL 基本架构概览</h3>\n<p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。</p>\n<p>先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。</p>\n<p>•<strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。•<strong>查询缓存:</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。•<strong>分析器:</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。•<strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。•<strong>执行器:</strong> 执行语句，然后从存储引擎返回数据。</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/640\" alt=\"null\" /></p>\n<p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p>\n<p>•<strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。•<strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></p>\n<h3 id=\"_1-2-server-层基本组件介绍\"> 1.2 Server 层基本组件介绍</h3>\n<h3 id=\"_1-连接器\"> 1) 连接器</h3>\n<p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。</p>\n<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。</p>\n<h3 id=\"_2-查询缓存-mysql-8-0-版本后移除\"> 2) 查询缓存(MySQL 8.0 版本后移除)</h3>\n<p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>\n<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>\n<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>\n<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>\n<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>\n<h3 id=\"_3-分析器\"> 3) 分析器</h3>\n<p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>\n<p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>\n<p><strong>第二步，语法分析</strong>，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p>\n<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>\n<h3 id=\"_4-优化器\"> 4) 优化器</h3>\n<p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>\n<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>\n<h3 id=\"_5-执行器\"> 5) 执行器</h3>\n<p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>\n<h2 id=\"二-语句分析\"> 二 语句分析</h2>\n<h3 id=\"_2-1-查询语句\"> 2.1 查询语句</h3>\n<p>说了以上这么多，那么究竟一条 sql 语句是如何执行的呢？其实我们的 sql 可以分为两种，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：</p>\n<ul>\n<li></li>\n</ul>\n<div><pre><code>select * from tb_student  A where A.age=&#39;18&#39; and A.name=&#39; 张三 &#39;;\n</code></pre>\n<div><span>1</span><br></div></div><p>结合上面的说明，我们分析下这个语句的执行流程：</p>\n<ul>\n<li>\n<p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p>\n</li>\n<li>\n<p>通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student,需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p>\n</li>\n<li>\n<p>接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：</p>\n</li>\n<li></li>\n<li></li>\n</ul>\n<div><pre><code>  a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。  b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。\n</code></pre>\n<div><span>1</span><br></div></div><p>​    那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>\n<ul>\n<li></li>\n</ul>\n<div><pre><code>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。\n</code></pre>\n</div><h3 id=\"_2-2-更新语句\"> 2.2 更新语句</h3>\n<p>以上就是一条查询 sql 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？sql 语句如下：</p>\n<ul>\n<li></li>\n</ul>\n<div><pre><code>update tb_student A set A.age=&#39;19&#39; where A.name=&#39; 张三 &#39;;\n</code></pre>\n<div><span>1</span><br></div></div><p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块式 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>\n<ul>\n<li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。•然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。•执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。•更新完成。</li>\n</ul>\n<p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p>\n<p>这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p>\n<p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>\n<ul>\n<li>\n<p><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</p>\n</li>\n<li>\n<p><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</p>\n</li>\n</ul>\n<p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p>\n<ul>\n<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。•如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li>\n</ul>\n<p>这样就解决了数据一致性的问题。</p>\n<h2 id=\"三-总结\"> 三 总结</h2>\n<ul>\n<li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。</li>\n<li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li>\n<li>SQL 等执行过程分为两类，一类对于查询等过程如下：权限校验---》查询缓存---》分析器---》优化器---》权限校验---》执行器---》引擎</li>\n<li>对于更新等语句执行流程如下：分析器----》权限校验----》执行器---》引擎---redo log prepare---》binlog---》redo log commit</li>\n</ul>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/640",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "一千行MySQL命令",
      "url": "http://blog.alanlee.top/blog-vuepress/database/mysql/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4/",
      "id": "http://blog.alanlee.top/blog-vuepress/database/mysql/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4/",
      "content_html": "<h1 id=\"一千行mysql命令\"> 一千行MySQL命令</h1>\n<blockquote>\n<p>原文：一千行MySQL命令</p>\n<p>地址：https://snailclimb.gitee.io/javaguide/#/docs/database/一千行MySQL命令</p>\n</blockquote>\n<h3 id=\"基本操作\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\" target=\"_blank\" rel=\"noopener noreferrer\">基本操作</a></h3>\n<div><pre><code>/* Windows服务 */\n-- 启动MySQL\n    net start mysql\n-- 创建Windows服务\n    sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)\n/* 连接与断开服务器 */\nmysql -h 地址 -P 端口 -u 用户名 -p 密码\nSHOW PROCESSLIST -- 显示哪些线程正在运行\nSHOW VARIABLES -- 显示系统变量信息Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"数据库操作\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C\" target=\"_blank\" rel=\"noopener noreferrer\">数据库操作</a></h3>\n<div><pre><code>/* 数据库操作 */ ------------------\n-- 查看当前数据库\n    SELECT DATABASE();\n-- 显示当前时间、用户名、数据库版本\n    SELECT now(), user(), version();\n-- 创建库\n    CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项\n    数据库选项：\n        CHARACTER SET charset_name\n        COLLATE collation_name\n-- 查看已有库\n    SHOW DATABASES[ LIKE &#39;PATTERN&#39;]\n-- 查看当前库信息\n    SHOW CREATE DATABASE 数据库名\n-- 修改库的选项信息\n    ALTER DATABASE 库名 选项信息\n-- 删除库\n    DROP DATABASE[ IF EXISTS] 数据库名\n        同时删除该数据库相关的目录及其目录内容Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id=\"表的操作\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C\" target=\"_blank\" rel=\"noopener noreferrer\">表的操作</a></h3>\n<div><pre><code>-- 创建表\n    CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]\n        每个字段必须有数据类型\n        最后一个字段后不能有逗号\n        TEMPORARY 临时表，会话结束时表自动消失\n        对于字段的定义：\n            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#39;string&#39;]\n-- 表选项\n    -- 字符集\n        CHARSET = charset_name\n        如果表没有设定，则使用数据库字符集\n    -- 存储引擎\n        ENGINE = engine_name\n        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同\n        常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive\n        不同的引擎在保存表的结构和数据时采用不同的方式\n        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引\n        InnoDB表文件含义：.frm表定义，表空间数据和日志文件\n        SHOW ENGINES -- 显示存储引擎的状态信息\n        SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息\n    -- 自增起始数\n        AUTO_INCREMENT = 行数\n    -- 数据文件目录\n        DATA DIRECTORY = &#39;目录&#39;\n    -- 索引文件目录\n        INDEX DIRECTORY = &#39;目录&#39;\n    -- 表注释\n        COMMENT = &#39;string&#39;\n    -- 分区选项\n        PARTITION BY ... (详细见手册)\n-- 查看所有表\n    SHOW TABLES[ LIKE &#39;pattern&#39;]\n    SHOW TABLES FROM  库名\n-- 查看表结构\n    SHOW CREATE TABLE 表名 （信息更详细）\n    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &#39;PATTERN&#39;]\n    SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;]\n-- 修改表\n    -- 修改表本身的选项\n        ALTER TABLE 表名 表的选项\n        eg: ALTER TABLE 表名 ENGINE=MYISAM;\n    -- 对表进行重命名\n        RENAME TABLE 原表名 TO 新表名\n        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）\n        -- RENAME可以交换两个表名\n    -- 修改表的字段机构（13.1.2. ALTER TABLE语法）\n        ALTER TABLE 表名 操作名\n        -- 操作名\n            ADD[ COLUMN] 字段定义       -- 增加字段\n                AFTER 字段名          -- 表示增加在该字段名后面\n                FIRST               -- 表示增加在第一个\n            ADD PRIMARY KEY(字段名)   -- 创建主键\n            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引\n            ADD INDEX [索引名] (字段名) -- 创建普通索引\n            DROP[ COLUMN] 字段名      -- 删除字段\n            MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)\n            CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改\n            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)\n            DROP INDEX 索引名 -- 删除索引\n            DROP FOREIGN KEY 外键    -- 删除外键\n-- 删除表\n    DROP TABLE[ IF EXISTS] 表名 ...\n-- 清空表数据\n    TRUNCATE [TABLE] 表名\n-- 复制表结构\n    CREATE TABLE 表名 LIKE 要复制的表名\n-- 复制表结构和数据\n    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名\n-- 检查表是否有错误\n    CHECK TABLE tbl_name [, tbl_name] ... [option] ...\n-- 优化表\n    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...\n-- 修复表\n    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]\n-- 分析表\n    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div><h3 id=\"数据操作\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C\" target=\"_blank\" rel=\"noopener noreferrer\">数据操作</a></h3>\n<div><pre><code>/* 数据操作 */ ------------------\n-- 增\n    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]\n        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。\n        -- 可同时插入多条数据记录！\n        REPLACE 与 INSERT 完全一样，可互换。\n    INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]\n-- 查\n    SELECT 字段列表 FROM 表名[ 其他子句]\n        -- 可来自多个表的多个字段\n        -- 其他子句可以不使用\n        -- 字段列表可以用*代替，表示所有字段\n-- 删\n    DELETE FROM 表名[ 删除条件子句]\n        没有条件子句，则会删除全部\n-- 改\n    UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"字符集编码\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BC%96%E7%A0%81\" target=\"_blank\" rel=\"noopener noreferrer\">字符集编码</a></h3>\n<div><pre><code>/* 字符集编码 */ ------------------\n-- MySQL、数据库、表、字段均可设置编码\n-- 数据编码与客户端编码不需一致\nSHOW VARIABLES LIKE &#39;character_set_%&#39;   -- 查看所有字符集编码项\n    character_set_client        客户端向服务器发送数据时使用的编码\n    character_set_results       服务器端将结果返回给客户端所使用的编码\n    character_set_connection    连接层编码\nSET 变量名 = 变量值\n    SET character_set_client = gbk;\n    SET character_set_results = gbk;\n    SET character_set_connection = gbk;\nSET NAMES GBK;  -- 相当于完成以上三个设置\n-- 校对集\n    校对集用以排序\n    SHOW CHARACTER SET [LIKE &#39;pattern&#39;]/SHOW CHARSET [LIKE &#39;pattern&#39;]   查看所有字符集\n    SHOW COLLATION [LIKE &#39;pattern&#39;]     查看所有校对集\n    CHARSET 字符集编码     设置字符集编码\n    COLLATE 校对集编码     设置校对集编码Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"数据类型-列类型\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%97%E7%B1%BB%E5%9E%8B\" target=\"_blank\" rel=\"noopener noreferrer\">数据类型(列类型)</a></h3>\n<div><pre><code>/* 数据类型（列类型） */ ------------------\n1. 数值类型\n-- a. 整型 ----------\n    类型         字节     范围（有符号位）\n    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255\n    smallint    2字节    -32768 ~ 32767\n    mediumint   3字节    -8388608 ~ 8388607\n    int         4字节\n    bigint      8字节\n    int(M)  M表示总位数\n    - 默认存在符号位，unsigned 属性修改\n    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改\n        例：int(5)   插入一个数&#39;123&#39;，补填后为&#39;00123&#39;\n    - 在满足要求的情况下，越小越好。\n    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。\n-- b. 浮点型 ----------\n    类型             字节     范围\n    float(单精度)     4字节\n    double(双精度)    8字节\n    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。\n        不同于整型，前后均会补填0.\n    定义浮点型时，需指定总位数和小数位数。\n        float(M, D)     double(M, D)\n        M表示总位数，D表示小数位数。\n        M和D的大小会决定浮点数的范围。不同于整型的固定范围。\n        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。\n        支持科学计数法表示。\n        浮点数表示近似值。\n-- c. 定点数 ----------\n    decimal -- 可变长度\n    decimal(M, D)   M也表示总位数，D表示小数位数。\n    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。\n    将浮点数转换为字符串来保存，每9位数字保存为4个字节。\n2. 字符串类型\n-- a. char, varchar ----------\n    char    定长字符串，速度快，但浪费空间\n    varchar 变长字符串，速度慢，但节省空间\n    M表示能存储的最大长度，此长度是字符数，非字节数。\n    不同的编码，所占用的空间不同。\n    char,最多255个字符，与编码无关。\n    varchar,最多65535字符，与编码有关。\n    一条有效记录最大不能超过65535个字节。\n        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符\n    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。\n    varchar 的最大有效长度由最大行大小和使用的字符集确定。\n    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是65535-1-2=65532字节。\n    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3\n-- b. blob, text ----------\n    blob 二进制字符串（字节字符串）\n        tinyblob, blob, mediumblob, longblob\n    text 非二进制字符串（字符字符串）\n        tinytext, text, mediumtext, longtext\n    text 在定义时，不需要定义长度，也不会计算总长度。\n    text 类型在定义时，不可给default值\n-- c. binary, varbinary ----------\n    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。\n    char, varchar, text 对应 binary, varbinary, blob.\n3. 日期时间类型\n    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。\n    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59\n    date        3字节    日期         1000-01-01 到 9999-12-31\n    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07\n    time        3字节    时间         -838:59:59 到 838:59:59\n    year        1字节    年份         1901 - 2155\ndatetime    YYYY-MM-DD hh:mm:ss\ntimestamp   YY-MM-DD hh:mm:ss\n            YYYYMMDDhhmmss\n            YYMMDDhhmmss\n            YYYYMMDDhhmmss\n            YYMMDDhhmmss\ndate        YYYY-MM-DD\n            YY-MM-DD\n            YYYYMMDD\n            YYMMDD\n            YYYYMMDD\n            YYMMDD\ntime        hh:mm:ss\n            hhmmss\n            hhmmss\nyear        YYYY\n            YY\n            YYYY\n            YY\n4. 枚举和集合\n-- 枚举(enum) ----------\nenum(val1, val2, val3...)\n    在已知的值中进行单选。最大数量为65535.\n    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。\n    表现为字符串类型，存储却是整型。\n    NULL值的索引是NULL。\n    空字符串错误值的索引值是0。\n-- 集合（set） ----------\nset(val1, val2, val3...)\n    create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) );\n    insert into tab values (&#39;男, 女&#39;);\n    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。\n    当创建表时，SET成员值的尾部空格将自动被删除。Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br></div></div><h3 id=\"列属性-列约束\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E5%88%97%E5%B1%9E%E6%80%A7%E5%88%97%E7%BA%A6%E6%9D%9F\" target=\"_blank\" rel=\"noopener noreferrer\">列属性(列约束)</a></h3>\n<div><pre><code>/* 列属性（列约束） */ ------------------\n1. PRIMARY 主键\n    - 能唯一标识记录的字段，可以作为主键。\n    - 一个表只能有一个主键。\n    - 主键具有唯一性。\n    - 声明字段时，用 primary key 标识。\n        也可以在字段列表之后声明\n            例：create table tab ( id int, stu varchar(10), primary key (id));\n    - 主键字段的值不能为null。\n    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。\n        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));\n2. UNIQUE 唯一索引（唯一约束）\n    使得某字段的值也不能重复。\n3. NULL 约束\n    null不是数据类型，是列的一个属性。\n    表示当前列是否可以为null，表示什么都没有。\n    null, 允许为空。默认。\n    not null, 不允许为空。\n    insert into tab values (null, &#39;val&#39;);\n        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null\n4. DEFAULT 默认值属性\n    当前字段的默认值。\n    insert into tab values (default, &#39;val&#39;);    -- 此时表示强制使用默认值。\n    create table tab ( add_time timestamp default current_timestamp );\n        -- 表示将当前时间的时间戳设为默认值。\n        current_date, current_time\n5. AUTO_INCREMENT 自动增长约束\n    自动增长必须为索引（主键或unique）\n    只能存在一个字段为自动增长。\n    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;\n6. COMMENT 注释\n    例：create table tab ( id int ) comment &#39;注释内容&#39;;\n7. FOREIGN KEY 外键约束\n    用于限制主表与从表数据完整性。\n    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);\n        -- 将表t1的t1_id外键关联到表t2的id字段。\n        -- 每个外键都有一个名字，可以通过 constraint 指定\n    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。\n    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。\n    MySQL中，可以对InnoDB引擎使用外键约束：\n    语法：\n    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]\n    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。\n    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。\n    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：\n    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。\n    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。\n    3. restrict，拒绝父表删除和更新。\n    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。\nCopy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h3 id=\"建表规范\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E5%BB%BA%E8%A1%A8%E8%A7%84%E8%8C%83\" target=\"_blank\" rel=\"noopener noreferrer\">建表规范</a></h3>\n<div><pre><code>/* 建表规范 */ ------------------\n    -- Normal Format, NF\n        - 每个表保存一个实体信息\n        - 每个具有一个ID字段作为主键\n        - ID主键 + 原子表\n    -- 1NF, 第一范式\n        字段不能再分，就满足第一范式。\n    -- 2NF, 第二范式\n        满足第一范式的前提下，不能出现部分依赖。\n        消除复合主键就可以避免部分依赖。增加单列关键字。\n    -- 3NF, 第三范式\n        满足第二范式的前提下，不能出现传递依赖。\n        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。\n        将一个实体信息的数据放在一个表内实现。Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"select\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=select\" target=\"_blank\" rel=\"noopener noreferrer\">SELECT</a></h3>\n<div><pre><code>/* SELECT */ ------------------\nSELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT\na. select_expr\n    -- 可以用 * 表示所有字段。\n        select * from tb;\n    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）\n        select stu, 29+25, now() from tb;\n    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。\n        - 使用 as 关键字，也可省略 as.\n        select stu+10 as add10 from tb;\nb. FROM 子句\n    用于标识查询来源。\n    -- 可以为表起别名。使用as关键字。\n        SELECT * FROM tb1 AS tt, tb2 AS bb;\n    -- from子句后，可以同时出现多个表。\n        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。\n        SELECT * FROM tb1, tb2;\n    -- 向优化符提示如何选择索引\n        USE INDEX、IGNORE INDEX、FORCE INDEX\n        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;\n        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;\nc. WHERE 子句\n    -- 从from获得的数据源中进行筛选。\n    -- 整型1表示真，0表示假。\n    -- 表达式由运算符和运算数组成。\n        -- 运算数：变量（字段）、值、函数返回值\n        -- 运算符：\n            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,\n            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor\n            is/is not 加上ture/false/unknown，检验某个值的真假\n            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较\nd. GROUP BY 子句, 分组子句\n    GROUP BY 字段/别名 [排序方式]\n    分组后会进行排序。升序：ASC，降序：DESC\n    以下[合计函数]需配合 GROUP BY 使用：\n    count 返回不同的非NULL值数目  count(*)、count(字段)\n    sum 求和\n    max 求最大值\n    min 求最小值\n    avg 求平均值\n    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。\ne. HAVING 子句，条件子句\n    与 where 功能、用法相同，执行时机不同。\n    where 在开始时执行检测数据，对原数据进行过滤。\n    having 对筛选出的结果再次进行过滤。\n    having 字段必须是查询出来的，where 字段必须是数据表存在的。\n    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。\n    where 不可以使用合计函数。一般需用合计函数才会用 having\n    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。\nf. ORDER BY 子句，排序子句\n    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...\n    升序：ASC，降序：DESC\n    支持多个字段的排序。\ng. LIMIT 子句，限制结果数量子句\n    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。\n    limit 起始位置, 获取条数\n    省略第一个参数，表示从索引0开始。limit 获取条数\nh. DISTINCT, ALL 选项\n    distinct 去除重复记录\n    默认为 all, 全部记录Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><h3 id=\"union\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=union\" target=\"_blank\" rel=\"noopener noreferrer\">UNION</a></h3>\n<div><pre><code>/* UNION */ ------------------\n    将多个select查询的结果组合成一个结果集合。\n    SELECT ... UNION [ALL|DISTINCT] SELECT ...\n    默认 DISTINCT 方式，即所有返回的行都是唯一的\n    建议，对每个SELECT查询加上小括号包裹。\n    ORDER BY 排序时，需加上 LIMIT 进行结合。\n    需要各select查询的字段数量一样。\n    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"子查询\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E5%AD%90%E6%9F%A5%E8%AF%A2\" target=\"_blank\" rel=\"noopener noreferrer\">子查询</a></h3>\n<div><pre><code>/* 子查询 */ ------------------\n    - 子查询需用括号包裹。\n-- from型\n    from后要求是一个表，必须给子查询结果取个别名。\n    - 简化每个查询内的条件。\n    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。\n    - 子查询返回一个表，表型子查询。\n    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;\n-- where型\n    - 子查询返回一个值，标量子查询。\n    - 不需要给子查询取别名。\n    - where子查询内的表，不能直接用以更新。\n    select * from tb where money = (select max(money) from tb);\n    -- 列子查询\n        如果子查询结果返回的是一列。\n        使用 in 或 not in 完成查询\n        exists 和 not exists 条件\n            如果子查询返回数据，则返回1或0。常用于判断条件。\n            select column1 from t1 where exists (select * from t2);\n    -- 行子查询\n        查询条件是一个行。\n        select * from t1 where (id, gender) in (select id, gender from t2);\n        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)\n        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。\n    -- 特殊运算符\n    != all()    相当于 not in\n    = some()    相当于 in。any 是 some 的别名\n    != some()   不等同于 not in，不等于其中某一个。\n    all, some 可以配合其他运算符一起使用。Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"连接查询-join\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2join\" target=\"_blank\" rel=\"noopener noreferrer\">连接查询(join)</a></h3>\n<div><pre><code>/* 连接查询(join) */ ------------------\n    将多个表的字段进行连接，可以指定连接条件。\n-- 内连接(inner join)\n    - 默认就是内连接，可省略inner。\n    - 只有数据存在时才能发送连接。即连接结果不能出现空行。\n    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）\n    也可用where表示连接条件。\n    还有 using, 但需字段名相同。 using(字段名)\n    -- 交叉连接 cross join\n        即，没有条件的内连接。\n        select * from tb1 cross join tb2;\n-- 外连接(outer join)\n    - 如果数据不存在，也会出现在连接结果中。\n    -- 左外连接 left join\n        如果数据不存在，左表记录会出现，而右表为null填充\n    -- 右外连接 right join\n        如果数据不存在，右表记录会出现，而左表为null填充\n-- 自然连接(natural join)\n    自动判断连接条件完成连接。\n    相当于省略了using，会自动查找相同字段名。\n    natural join\n    natural left join\n    natural right join\nselect info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id=\"truncate\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=truncate\" target=\"_blank\" rel=\"noopener noreferrer\">TRUNCATE</a></h3>\n<div><pre><code>/* TRUNCATE */ ------------------\nTRUNCATE [TABLE] tbl_name\n清空数据\n删除重建表\n区别：\n1，truncate 是删除表再创建，delete 是逐条删除\n2，truncate 重置auto_increment的值。而delete不会\n3，truncate 不知道删除了几条，而delete知道。\n4，当被用于带分区的表时，truncate 会保留分区Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"备份与还原\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F\" target=\"_blank\" rel=\"noopener noreferrer\">备份与还原</a></h3>\n<div><pre><code>/* 备份与还原 */ ------------------\n备份，将数据的结构与表内数据保存起来。\n利用 mysqldump 指令完成。\n-- 导出\nmysqldump [options] db_name [tables]\nmysqldump [options] ---database DB1 [DB2 DB3...]\nmysqldump [options] --all--database\n1. 导出一张表\n　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)\n2. 导出多张表\n　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)\n3. 导出所有表\n　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)\n4. 导出一个库\n　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)\n可以-w携带WHERE条件\n-- 导入\n1. 在登录mysql的情况下：\n　　source  备份文件\n2. 在不登录的情况下\n　　mysql -u用户名 -p密码 库名 &lt; 备份文件Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"视图\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E8%A7%86%E5%9B%BE\" target=\"_blank\" rel=\"noopener noreferrer\">视图</a></h3>\n<div><pre><code>什么是视图：\n    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。\n    视图具有表结构文件，但不存在数据文件。\n    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。\n    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。\n-- 创建视图\nCREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement\n    - 视图名必须唯一，同时不能与表重名。\n    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。\n    - 可以指定视图执行的算法，通过ALGORITHM指定。\n    - column_list如果存在，则数目必须等于SELECT语句检索的列数\n-- 查看结构\n    SHOW CREATE VIEW view_name\n-- 删除视图\n    - 删除视图后，数据依然存在。\n    - 可同时删除多个视图。\n    DROP VIEW [IF EXISTS] view_name ...\n-- 修改视图结构\n    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。\n    ALTER VIEW view_name [(column_list)] AS select_statement\n-- 视图作用\n    1. 简化业务逻辑\n    2. 对客户端隐藏真实的表结构\n-- 视图算法(ALGORITHM)\n    MERGE       合并\n        将视图的查询语句，与外部查询需要先合并再执行！\n    TEMPTABLE   临时表\n        将视图执行完毕后，形成临时表，再做外层查询！\n    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"事务-transaction\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E4%BA%8B%E5%8A%A1transaction\" target=\"_blank\" rel=\"noopener noreferrer\">事务(transaction)</a></h3>\n<div><pre><code>事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。\n    - 支持连续SQL的集体成功或集体撤销。\n    - 事务是数据库在数据完整性方面的一个功能。\n    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。\n    - InnoDB被称为事务安全型引擎。\n-- 事务开启\n    START TRANSACTION; 或者 BEGIN;\n    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。\n-- 事务提交\n    COMMIT;\n-- 事务回滚\n    ROLLBACK;\n    如果部分操作发生问题，映射到事务开启前。\n-- 事务的特性\n    1. 原子性（Atomicity）\n        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。\n    2. 一致性（Consistency）\n        事务前后数据的完整性必须保持一致。\n        - 事务开始和结束时，外部数据一致\n        - 在整个事务过程中，操作是连续的\n    3. 隔离性（Isolation）\n        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。\n    4. 持久性（Durability）\n        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。\n-- 事务的实现\n    1. 要求是事务支持的表类型\n    2. 执行一组相关的操作前开启事务\n    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。\n-- 事务的原理\n    利用InnoDB的自动提交(autocommit)特性完成。\n    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。\n    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。\n-- 注意\n    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。\n    2. 事务不能被嵌套\n-- 保存点\n    SAVEPOINT 保存点名称 -- 设置一个事务保存点\n    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点\n    RELEASE SAVEPOINT 保存点名称 -- 删除保存点\n-- InnoDB自动提交特性设置\n    SET autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。\n    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。\n    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，\n        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)\n        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)\nCopy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h3 id=\"锁表\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E9%94%81%E8%A1%A8\" target=\"_blank\" rel=\"noopener noreferrer\">锁表</a></h3>\n<div><pre><code>/* 锁表 */\n表锁定只用于防止其它客户端进行不正当地读取和写入\nMyISAM 支持表锁，InnoDB 支持行锁\n-- 锁定\n    LOCK TABLES tbl_name [AS alias]\n-- 解锁\n    UNLOCK TABLESCopy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"触发器\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E8%A7%A6%E5%8F%91%E5%99%A8\" target=\"_blank\" rel=\"noopener noreferrer\">触发器</a></h3>\n<div><pre><code>/* 触发器 */ ------------------\n    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象\n    监听：记录的增加、修改、删除。\n-- 创建触发器\nCREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt\n    参数：\n    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。\n    trigger_event指明了激活触发程序的语句的类型\n        INSERT：将新行插入表时激活触发程序\n        UPDATE：更改某一行时激活触发程序\n        DELETE：从表中删除某一行时激活触发程序\n    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。\n    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构\n-- 删除\nDROP TRIGGER [schema_name.]trigger_name\n可以使用old和new代替旧的和新的数据\n    更新操作，更新前是old，更新后是new.\n    删除操作，只有old.\n    增加操作，只有new.\n-- 注意\n    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。\n-- 字符连接函数\nconcat(str1,str2,...])\nconcat_ws(separator,str1,str2,...)\n-- 分支语句\nif 条件 then\n    执行语句\nelseif 条件 then\n    执行语句\nelse\n    执行语句\nend if;\n-- 修改最外层语句结束符\ndelimiter 自定义结束符号\n    SQL语句\n自定义结束符号\ndelimiter ;     -- 修改回原来的分号\n-- 语句块包裹\nbegin\n    语句块\nend\n-- 特殊的执行\n1. 只要添加记录，就会触发程序。\n2. Insert into on duplicate key update 语法会触发：\n    如果没有重复记录，会触发 before insert, after insert;\n    如果有重复记录并更新，会触发 before insert, before update, after update;\n    如果有重复记录但是没有发生更新，则触发 before insert, before update\n3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insertCopy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><h3 id=\"sql编程\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=sql%E7%BC%96%E7%A8%8B\" target=\"_blank\" rel=\"noopener noreferrer\">SQL编程</a></h3>\n<div><pre><code>/* SQL编程 */ ------------------\n--// 局部变量 ----------\n-- 变量声明\n    declare var_name[,...] type [default value]\n    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。\n-- 赋值\n    使用 set 和 select into 语句为变量赋值。\n    - 注意：在函数内是可以使用全局变量（用户自定义的变量）\n--// 全局变量 ----------\n-- 定义、赋值\nset 语句可以定义并为变量赋值。\nset @var = value;\n也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。\n还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。\nselect @var:=20;\nselect @v1:=id, @v2=name from t1 limit 1;\nselect * from tbl_name where @var:=30;\nselect into 可以将表中查询获得的数据赋给变量。\n    -| select max(height) into @max_height from tb;\n-- 自定义变量名\n为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。\n@var=10;\n    - 变量被定义后，在整个会话周期都有效（登录到退出）\n--// 控制结构 ----------\n-- if语句\nif search_condition then\n    statement_list   \n[elseif search_condition then\n    statement_list]\n...\n[else\n    statement_list]\nend if;\n-- case语句\nCASE value WHEN [compare-value] THEN result\n[WHEN [compare-value] THEN result ...]\n[ELSE result]\nEND\n-- while循环\n[begin_label:] while search_condition do\n    statement_list\nend while [end_label];\n- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。\n    -- 退出循环\n        退出整个循环 leave\n        退出当前循环 iterate\n        通过退出的标签决定退出哪个循环\n--// 内置函数 ----------\n-- 数值函数\nabs(x)          -- 绝对值 abs(-10.9) = 10\nformat(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46\nceil(x)         -- 向上取整 ceil(10.1) = 11\nfloor(x)        -- 向下取整 floor (10.1) = 10\nround(x)        -- 四舍五入去整\nmod(m, n)       -- m%n m mod n 求余 10%3=1\npi()            -- 获得圆周率\npow(m, n)       -- m^n\nsqrt(x)         -- 算术平方根\nrand()          -- 随机数\ntruncate(x, d)  -- 截取d位小数\n-- 时间日期函数\nnow(), current_timestamp();     -- 当前日期时间\ncurrent_date();                 -- 当前日期\ncurrent_time();                 -- 当前时间\ndate(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取日期部分\ntime(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取时间部分\ndate_format(&#39;yyyy-mm-dd hh:ii:ss&#39;, &#39;%d %y %a %d %m %b %j&#39;); -- 格式化时间\nunix_timestamp();               -- 获得unix时间戳\nfrom_unixtime();                -- 从时间戳获得时间\n-- 字符串函数\nlength(string)          -- string长度，字节\nchar_length(string)     -- string的字符个数\nsubstring(str, position [,length])      -- 从str的position开始,取length个字符\nreplace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str\ninstr(string ,substring)    -- 返回substring首次在string中出现的位置\nconcat(string [,...])   -- 连接字串\ncharset(str)            -- 返回字串字符集\nlcase(string)           -- 转换成小写\nleft(string, length)    -- 从string2中的左边起取length个字符\nload_file(file_name)    -- 从文件读取内容\nlocate(substring, string [,start_position]) -- 同instr,但可指定开始位置\nlpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length\nltrim(string)           -- 去除前端空格\nrepeat(string, count)   -- 重复count次\nrpad(string, length, pad)   --在str后用pad补充,直到长度为length\nrtrim(string)           -- 去除后端空格\nstrcmp(string1 ,string2)    -- 逐字符比较两字串大小\n-- 流程函数\ncase when [condition] then result [when [condition] then result ...] [else result] end   多分支\nif(expr1,expr2,expr3)  双分支。\n-- 聚合函数\ncount()\nsum();\nmax();\nmin();\navg();\ngroup_concat()\n-- 其他常用函数\nmd5();\ndefault();\n--// 存储函数，自定义函数 ----------\n-- 新建\n    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型\n        函数体\n    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。\n    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。\n    - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。\n    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。\n    - 多条语句应该使用 begin...end 语句块包含。\n    - 一定要有 return 返回值语句。\n-- 删除\n    DROP FUNCTION [IF EXISTS] function_name;\n-- 查看\n    SHOW FUNCTION STATUS LIKE &#39;partten&#39;\n    SHOW CREATE FUNCTION function_name;\n-- 修改\n    ALTER FUNCTION function_name 函数选项\n--// 存储过程，自定义功能 ----------\n-- 定义\n存储存储过程 是一段代码（过程），存储在数据库中的sql组成。\n一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。\n而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。\n-- 创建\nCREATE PROCEDURE sp_name (参数列表)\n    过程体\n参数列表：不同于函数的参数列表，需要指明参数类型\nIN，表示输入型\nOUT，表示输出型\nINOUT，表示混合型\n注意，没有返回值。Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br></div></div><h3 id=\"存储过程\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B\" target=\"_blank\" rel=\"noopener noreferrer\">存储过程</a></h3>\n<div><pre><code>/* 存储过程 */ ------------------\n存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。\n调用：CALL 过程名\n-- 注意\n- 没有返回值。\n- 只能单独调用，不可夹杂在其他语句中\n-- 参数\nIN|OUT|INOUT 参数名 数据类型\nIN      输入：在调用过程中，将数据输入到过程体内部的参数\nOUT     输出：在调用过程中，将过程体处理完的结果返回到客户端\nINOUT   输入输出：既可输入，也可输出\n-- 语法\nCREATE PROCEDURE 过程名 (参数列表)\nBEGIN\n    过程体\nENDCopy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"用户和权限管理\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86\" target=\"_blank\" rel=\"noopener noreferrer\">用户和权限管理</a></h3>\n<div><pre><code>/* 用户和权限管理 */ ------------------\n-- root密码重置\n1. 停止MySQL服务\n2.  [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp;\n    [Windows] mysqld --skip-grant-tables\n3. use mysql;\n4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;;\n5. FLUSH PRIVILEGES;\n用户信息表：mysql.user\n-- 刷新权限\nFLUSH PRIVILEGES;\n-- 增加用户\nCREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)\n    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。\n    - 只能创建用户，不能赋予权限。\n    - 用户名，注意引号：如 &#39;user_name&#39;@&#39;192.168.1.1&#39;\n    - 密码也需引号，纯数字密码也要加引号\n    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD\n-- 重命名用户\nRENAME USER old_user TO new_user\n-- 设置密码\nSET PASSWORD = PASSWORD(&#39;密码&#39;)  -- 为当前用户设置密码\nSET PASSWORD FOR 用户名 = PASSWORD(&#39;密码&#39;) -- 为指定用户设置密码\n-- 删除用户\nDROP USER 用户名\n-- 分配权限/添加用户\nGRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#39;password&#39;]\n    - all privileges 表示所有权限\n    - *.* 表示所有库的所有表\n    - 库名.表名 表示某库下面的某表\n    GRANT ALL PRIVILEGES ON `pms`.* TO &#39;pms&#39;@&#39;%&#39; IDENTIFIED BY &#39;pms0817&#39;;\n-- 查看权限\nSHOW GRANTS FOR 用户名\n    -- 查看当前用户权限\n    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();\n-- 撤消权限\nREVOKE 权限列表 ON 表名 FROM 用户名\nREVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限\n-- 权限层级\n-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。\n全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user\n    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。\n数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host\n    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。\n表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv\n    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。\n列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv\n    当使用REVOKE时，您必须指定与被授权列相同的列。\n-- 权限列表\nALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限\nALTER   -- 允许使用ALTER TABLE\nALTER ROUTINE   -- 更改或取消已存储的子程序\nCREATE  -- 允许使用CREATE TABLE\nCREATE ROUTINE  -- 创建已存储的子程序\nCREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE\nCREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。\nCREATE VIEW     -- 允许使用CREATE VIEW\nDELETE  -- 允许使用DELETE\nDROP    -- 允许使用DROP TABLE\nEXECUTE     -- 允许用户运行已存储的子程序\nFILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE\nINDEX   -- 允许使用CREATE INDEX和DROP INDEX\nINSERT  -- 允许使用INSERT\nLOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES\nPROCESS     -- 允许使用SHOW FULL PROCESSLIST\nREFERENCES  -- 未被实施\nRELOAD  -- 允许使用FLUSH\nREPLICATION CLIENT  -- 允许用户询问从属服务器或主服务器的地址\nREPLICATION SLAVE   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）\nSELECT  -- 允许使用SELECT\nSHOW DATABASES  -- 显示所有数据库\nSHOW VIEW   -- 允许使用SHOW CREATE VIEW\nSHUTDOWN    -- 允许使用mysqladmin shutdown\nSUPER   -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。\nUPDATE  -- 允许使用UPDATE\nUSAGE   -- “无权限”的同义词\nGRANT OPTION    -- 允许授予权限Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br></div></div><h3 id=\"表维护\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E8%A1%A8%E7%BB%B4%E6%8A%A4\" target=\"_blank\" rel=\"noopener noreferrer\">表维护</a></h3>\n<div><pre><code>/* 表维护 */\n-- 分析和存储表的关键字分布\nANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...\n-- 检查一个或多个表是否有错误\nCHECK TABLE tbl_name [, tbl_name] ... [option] ...\noption = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}\n-- 整理数据文件的碎片\nOPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...Copy to clipboardErrorCopied\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"杂项\"> <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4?id=%E6%9D%82%E9%A1%B9\" target=\"_blank\" rel=\"noopener noreferrer\">杂项</a></h3>\n<div><pre><code>/* 杂项 */ ------------------\n1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！\n2. 每个库目录存在一个保存当前数据库的选项文件db.opt。\n3. 注释：\n    单行注释 # 注释内容\n    多行注释 /* 注释内容 */\n    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)\n4. 模式通配符：\n    _   任意单个字符\n    %   任意多个字符，甚至包括零字符\n    单引号需要进行转义 \\&#39;\n5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\\G&quot;, &quot;\\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。\n6. SQL对大小写不敏感\n7. 清除已有语句：\\c\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "工具",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/",
      "content_html": "<h1 id=\"工具\"> 工具</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "CentOS安装Docker",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/docker/CentOS%E5%AE%89%E8%A3%85docker/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/docker/CentOS%E5%AE%89%E8%A3%85docker/",
      "content_html": "<h1 id=\"centos安装docker\"> CentOS安装Docker</h1>\n<ol>\n<li>安装要求</li>\n</ol>\n<p>docker官方说Linux内核至少3.8以上，建议3.10以上</p>\n<ol start=\"2\">\n<li>查看Linux版本</li>\n</ol>\n<div><pre><code><span>uname</span> -a\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"3\">\n<li>更新yum版本</li>\n</ol>\n<div><pre><code>yum update -y\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"4\">\n<li>安装需要的软件包\nyum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</li>\n</ol>\n<div><pre><code>yum <span>install</span> -y yum-utils device-mapper-persistent-data lvm2\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"5\">\n<li>设置yum源\n选择阿里云的仓库</li>\n</ol>\n<p>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo（阿里仓库）</p>\n<div><pre><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"6\">\n<li>查看docker版本</li>\n</ol>\n<div><pre><code>yum list docker-ce --showduplicates <span>|</span> <span>sort</span> -r\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"7\">\n<li>选择docker版本安装\n我选的是docker-ce-18.03.1.ce</li>\n</ol>\n<div><pre><code>yum <span>install</span> docker-ce-版本号 -y\nyum <span>install</span> docker-ce-18.03.1.ce -y\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ol start=\"8\">\n<li>配置镜像加速器</li>\n</ol>\n<div><pre><code><span>sudo</span> <span>mkdir</span> -p /etc/docker\n<span>sudo</span> <span>tee</span> /etc/docker/daemon.json <span>&lt;&lt;-</span><span>'EOF'\n{\n  \"registry-mirrors\": [\"https://h3exari1.mirror.aliyuncs.com\"]\n}\nEOF</span>\n<span>sudo</span> systemctl daemon-reload\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ol start=\"8\">\n<li>启动Docker</li>\n</ol>\n<div><pre><code>systemctl start docker\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"9\">\n<li>查看docker版本</li>\n</ol>\n<div><pre><code>docker version\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"10\">\n<li>运行hello-docker测试</li>\n</ol>\n<div><pre><code>docker run hello-world\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2020-02-20T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Docker安装Redis",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/docker/Docker%E5%AE%89%E8%A3%85Redis/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/docker/Docker%E5%AE%89%E8%A3%85Redis/",
      "content_html": "<h1 id=\"docker安装redis\"> Docker安装Redis</h1>\n<h2 id=\"安装单机版redis\"> 安装单机版redis</h2>\n<div><pre><code>vim docker-compose.yml\n</code></pre>\n<div><span>1</span><br></div></div><p>docker-compose.yml</p>\n<div><pre><code><span>version</span><span>:</span> <span>'3.1'</span>\n<span>services</span><span>:</span>\n  <span>redis</span><span>:</span>\n    <span>image</span><span>:</span> redis<span>:</span>5.0.8\n    <span>container_name</span><span>:</span> redis\n    <span>restart</span><span>:</span> always\n    <span>command</span><span>:</span> redis<span>-</span>server <span>-</span><span>-</span>requirepass 123456\n    <span>ports</span><span>:</span>\n      <span>-</span> 6379<span>:</span><span>6379</span>\n    <span>volumes</span><span>:</span>\n      <span>-</span> ./data<span>:</span>/data\n      <span>-</span> ./conf<span>:</span>/conf\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Docker使用网络",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/docker/Docker%E7%BD%91%E7%BB%9C/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/docker/Docker%E7%BD%91%E7%BB%9C/",
      "content_html": "<h1 id=\"docker使用网络\"> Docker使用网络</h1>\n<p><strong>创建网络</strong></p>\n<div><pre><code>docker network create 网络名\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p><strong>示例</strong></p>\n<div><pre><code>docker network create elastic\n</code></pre>\n<div><span>1</span><br></div></div></blockquote>\n<p><strong>docker-compose.yml中加入同一个网络</strong></p>\n<p>在服务名节点下添加</p>\n<div><pre><code><span>networks</span><span>:</span>\n  <span>-</span> <span>\"网络名\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>在最外层添加</p>\n<div><pre><code><span>networks</span><span>:</span>\n  <span>网络名</span><span>:</span>\n    <span>external</span><span>:</span> <span>true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>\n<p><strong>完整示例</strong></p>\n<div><pre><code><span>version</span><span>:</span> <span>'2.2'</span>\n<span>services</span><span>:</span>\n  <span>es01</span><span>:</span>\n    <span>image</span><span>:</span> docker.elastic.co/elasticsearch/elasticsearch<span>:</span>7.6.1\n    <span>container_name</span><span>:</span> es01\n    <span>environment</span><span>:</span>\n      <span>-</span> node.name=es01\n      <span>-</span> discovery.type=single<span>-</span>node\n      <span>-</span> bootstrap.memory_lock=true\n      <span>-</span> <span>\"ES_JAVA_OPTS=-Xms512m -Xmx512m\"</span>\n    <span>ulimits</span><span>:</span>\n      <span>memlock</span><span>:</span>\n        <span>soft</span><span>:</span> <span>-1</span>\n        <span>hard</span><span>:</span> <span>-1</span>\n    <span>volumes</span><span>:</span>\n      <span>-</span> data01<span>:</span>/usr/share/elasticsearch/data\n    <span>ports</span><span>:</span>\n      <span>-</span> 9200<span>:</span><span>9200</span>\n    <span>networks</span><span>:</span>\n      <span>-</span> elastic\n\n<span>volumes</span><span>:</span>\n  <span>data01</span><span>:</span>\n    <span>driver</span><span>:</span> local\n\n\n<span>networks</span><span>:</span>\n  <span>elastic</span><span>:</span>\n    <span>external</span><span>:</span> <span>true</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div></blockquote>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Docker安装RabbitMQ",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/docker/Docker%E5%AE%89%E8%A3%85RabbitMQ/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/docker/Docker%E5%AE%89%E8%A3%85RabbitMQ/",
      "content_html": "<h1 id=\"docker安装rabbitmq\"> Docker安装RabbitMQ</h1>\n<p><strong>创建文件夹</strong></p>\n<div><pre><code><span>mkdir</span> /usr/local/docker/rabbitmq <span>&amp;&amp;</span> <span>cd</span> /usr/local/docker/rabbitmq\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>创建存放数据的文件夹</strong></p>\n<div><pre><code><span>mkdir</span> data\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>创建docker-compose.yml</strong></p>\n<div><pre><code><span>vim</span> docker-compose.yml\n</code></pre>\n<div><span>1</span><br></div></div><p>内容如下：</p>\n<div><pre><code><span>version</span><span>:</span> <span>'3.1'</span>\n<span>services</span><span>:</span>\n  <span>rabbitmq</span><span>:</span>\n    <span>restart</span><span>:</span> always\n    <span>image</span><span>:</span> rabbitmq<span>:</span>management\n    <span>container_name</span><span>:</span> rabbitmq\n    <span>ports</span><span>:</span>\n      <span>-</span> 5672<span>:</span><span>5672</span>\n      <span>-</span> 15672<span>:</span><span>15672</span>\n    <span>environment</span><span>:</span>\n      <span>TZ</span><span>:</span> Asia/Shanghai\n      <span>RABBITMQ_DEFAULT_USER</span><span>:</span> rabbit\n      <span>RABBITMQ_DEFAULT_PASS</span><span>:</span> <span>123456</span>\n    <span>volumes</span><span>:</span>\n      <span>-</span> ./data<span>:</span>/var/lib/rabbitmq\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>启动</strong></p>\n<div><pre><code>docker-compose up -d\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>浏览器访问</strong></p>\n<p>ip:15672</p>\n<p>帐号：rabbit</p>\n<p>密码：123456</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Docker下安装MySQL，普通安装方式和docker-compose方式安装",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/docker/Docker%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/docker/Docker%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/",
      "content_html": "<h1 id=\"docker下安装mysql-普通安装方式和docker-compose方式安装\"> Docker下安装MySQL，普通安装方式和docker-compose方式安装</h1>\n<h2 id=\"方式一\"> 方式一</h2>\n<ol>\n<li>搜索MySQL镜像</li>\n</ol>\n<div><pre><code>docker search mysql\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"2\">\n<li>拉取镜像</li>\n</ol>\n<div><pre><code>docker pull mysql:5.7\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"3\">\n<li>运行</li>\n</ol>\n<div><pre><code>docker run -d -p <span>3306</span>:3306 mysql:5.7\n</code></pre>\n<div><span>1</span><br></div></div><p>上面这种方式简单，但是没有对mysql做配置，虽然也可以在命令后面加参数，但是写起来比较麻烦。推荐下面的dcoker-compose.yml方式（需安装docker-compose）。</p>\n<h2 id=\"方式二\"> 方式二</h2>\n<ol>\n<li>创建目录</li>\n</ol>\n<div><pre><code><span>mkdir</span> /usr/local/mysql\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"2\">\n<li>进入mysql目录</li>\n</ol>\n<div><pre><code><span>cd</span> /usr/local/mysql\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"3\">\n<li>在mysql目录下创建docker-compose.yml文件，内容如下</li>\n</ol>\n<div><pre><code><span>version</span><span>:</span> <span>'3.1'</span>\n<span>services</span><span>:</span>\n  <span>mysql</span><span>:</span>\n    <span>image</span><span>:</span> mysql<span>:</span><span>5.7</span>\n    <span>container_name</span><span>:</span> mysql57\n    <span>ports</span><span>:</span> \n     <span>-</span> <span>\"3306:3306\"</span>\n    <span>environment</span><span>:</span>\n      <span>MYSQL_ROOT_PASSWORD</span><span>:</span> <span>\"123456\"</span>\n      <span>MYSQL_USER</span><span>:</span> <span>'root'</span>\n      <span>MYSQL_PASS</span><span>:</span> <span>'123456'</span>\n    <span>volumes</span><span>:</span> \n     <span>-</span> ./data<span>:</span>/var/lib/mysql\n     <span>-</span> ./conf/my.cnf<span>:</span>/etc/my.cnf\n    <span>restart</span><span>:</span> always\n    <span>network_mode</span><span>:</span> <span>\"bridge\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>其中\n<code>network_mode</code>:为容器的网络模式。\n<code>MYSQL_ROOT_PASSWORD</code>:为数据库的密码，也就是root用户的密。\n<code>MYSQL_USER</code>和<code>MYSQL_PASS</code>:代表用户名和密码。\n<code>image</code>:为你拉取镜像的地址和版本，当然也可以换成自己的镜像仓库，这里使用官方的。\n<code>volumes</code>:里面的参数为映射本地和docker容器里面的文件夹和目录。\n<code>ports</code>:为映射端口。</p>\n<ol start=\"4\">\n<li>创建存放数据的文件夹data</li>\n</ol>\n<div><pre><code><span>mkdir</span> /usr/local/mysql/data\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"5\">\n<li>创建存放配置的的文件夹conf</li>\n</ol>\n<div><pre><code><span>mkdir</span> /usr/local/mysql/conf\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"6\">\n<li>创建配置文件</li>\n</ol>\n<div><pre><code><span>cd</span> /usr/local/mysql/conf\n<span>vi</span> my.cnf\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>内容如下：</p>\n<div><pre><code><span>[</span>mysqld<span>]</span>\n<span>user</span><span>=</span>mysql\ndefault-storage-engine<span>=</span>INNODB\ncharacter-set-server<span>=</span>utf8\n<span>[</span>client<span>]</span>\ndefault-character-set<span>=</span>utf8\n<span>[</span>mysql<span>]</span>\ndefault-character-set<span>=</span>utf8\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ol start=\"7\">\n<li>启动</li>\n</ol>\n<div><pre><code>docker-compose up -d\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"8\">\n<li>\n<p>navicat测试连接</p>\n</li>\n<li>\n<p>如果需要停掉mysql</p>\n</li>\n</ol>\n<div><pre><code>docker-compose down\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2020-02-20T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Docker笔记",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/docker/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/docker/",
      "content_html": "<h1 id=\"docker笔记\"> Docker笔记</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "镜像加速",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/docker/Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/docker/Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/",
      "content_html": "<h1 id=\"镜像加速\"> 镜像加速</h1>\n<p>设置 docker 镜像</p>\n<p>执行以下命令使用 docker 国内镜像，提高 docker 镜像下载速度和稳定性</p>\n<div><pre><code><span>curl</span> -sSL https://get.daocloud.io/daotools/set_mirror.sh <span>|</span> <span>sh</span> -s http://f1361db2.m.daocloud.io\n</code></pre>\n<div><span>1</span><br></div></div><p>重启docker</p>\n<div><pre><code>systemctl restart docker\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "docker-compose.yml模板",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/docker/docker-compose.yml/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/docker/docker-compose.yml/",
      "content_html": "<h1 id=\"docker-compose-yml模板\"> docker-compose.yml模板</h1>\n<div><pre><code><span>version</span><span>:</span> <span>'3.1'</span>\n<span>services</span><span>:</span>\n  <span>panda-config</span><span>:</span>\n    <span>image</span><span>:</span> registry.cn<span>-</span>shenzhen.aliyuncs.com/alanlee_java/docker<span>-</span>demo<span>:</span>1.0.0\n    <span>container_name</span><span>:</span> panda<span>-</span>config\n    <span>ports</span><span>:</span>\n     <span>-</span> 8888<span>:</span><span>8888</span>\n    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>",
      "date_published": "2020-02-20T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "docker-compose安装nginx",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/docker/docker-compose%E5%AE%89%E8%A3%85nginx/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/docker/docker-compose%E5%AE%89%E8%A3%85nginx/",
      "content_html": "<h1 id=\"docker-compose安装nginx\"> docker-compose安装nginx</h1>\n<p>docker-compose.yml</p>\n<div><pre><code><span>version</span><span>:</span> <span>'3.1'</span>\n<span>services</span><span>:</span>\n  <span>nginx</span><span>:</span>\n    <span>image</span><span>:</span> nginx\n    <span>restart</span><span>:</span> always\n    <span>container_name</span><span>:</span> nginx\n    <span>environment</span><span>:</span>\n      <span>-</span> TZ=Asia/Shanghai\n    <span>ports</span><span>:</span>\n      <span>-</span> <span>80:80</span>\n      <span>-</span> 443<span>:</span><span>443</span>\n    <span>volumes</span><span>:</span>\n      <span>-</span> ./nginx.conf<span>:</span>/etc/nginx/nginx.conf\n      <span>-</span> ./log<span>:</span>/var/log/nginx\n      <span>-</span> ./html<span>:</span>/html\n      <span>-</span> /etc/letsencrypt<span>:</span>/etc/letsencrypt\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>nginx.conf</p>\n<div><pre><code>user  nginx;\n#nginx 进程数，建议按照cpu 数目来指定，一般为它的倍数。\nworker_processes  2;\n\nerror_log  /var/log/nginx/error.log warn;\npid        /var/run/nginx.pid;\n\nevents {\n\t#单个后台worker process进程的最大并发链接数  \n    worker_connections  1024;\n}\n\nhttp {\n\t#设定mime类型,类型由mime.type文件定义\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    #设定日志格式\n    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n\n    access_log  /var/log/nginx/access.log  main;\n\n    #开启gzip压缩\n    gzip  on;\n    gzip_disable &quot;MSIE [1-6].&quot;;\n\n    #设定请求缓冲\n    client_header_buffer_size    128k;\n    large_client_header_buffers  4 128k;\n\t\n\t#sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，\n\t#对于普通应用，必须设为 on,\n    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，\n    #以平衡磁盘与网络I/O处理速度，降低系统的uptime.\n    sendfile on;\n\t\n\t#用于设置客户端连接保持活动的超时时间，在超过这个时间之后服务器会关闭该链接。\n    #keepalive_timeout  0;\n    keepalive_timeout  120; \n\t\n\t#允许客户端请求的最大单文件字节数\n\tclient_max_body_size 50m;\n\t\n\t#服务器名字的hash表大小\n\tserver_names_hash_bucket_size 128;\n\t#header中自定义变量时支持下划线\n\tunderscores_in_headers on; \n\t\n\t#down 表示当前的server暂时不参与负载\n\t#weight 加权轮询权重,默认为1。weight越大，负载的权重就越大。\n\t#backup 备用服务器, 当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。\n\t#max_fails 允许请求失败的次数默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误\n\t#fail_timeout max_fails次失败后，暂停的时间。\n\t#apiServer不能用下划线,否则访问不到\n\t#upstream apiServer {\n    #  server 172.17.0.1:18081 weight=10;\n    #  server 172.17.0.1:28081 weight=10;\n    #}\n\n\n\tserver{\n\t\tlisten 81;\n\t\t# server_name www.xxxx.com;\n\t\tlocation / {\n\t\t\troot /html/uuid-react-frontend;\n\t\t\tindex index.html index.htm;\n\t\t}\n\t}\n\t\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br></div></div><div><pre><code><span><span>#</span> 检查配置文件</span>\ndocker exec -it nginx service nginx check-reload\n<span><span>#</span> 重新加载配置文件</span>\ndocker exec -it nginx service nginx reload\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Docker常用命令",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
      "content_html": "<h1 id=\"docker常用命令\"> Docker常用命令</h1>\n<p>docker命令</p>\n<p>构建镜像</p>\n<div><pre><code>docker build -t panda:1.1.1 .\n</code></pre>\n<div><span>1</span><br></div></div><p>运行容器</p>\n<p>查看运行中的容器</p>\n<div><pre><code>docker ps\n</code></pre>\n<div><span>1</span><br></div></div><p>查看所有容器</p>\n<div><pre><code>docker ps -a\n</code></pre>\n<div><span>1</span><br></div></div><p>停止运行中的容器</p>\n<div><pre><code>docker stop 容器id\n</code></pre>\n<div><span>1</span><br></div></div><p>删除容器</p>\n<div><pre><code>docker rm 容器id\n</code></pre>\n<div><span>1</span><br></div></div><p>查看镜像</p>\n<div><pre><code>docker images\n</code></pre>\n<div><span>1</span><br></div></div><p>删除镜像</p>\n<div><pre><code>docker rmi 镜像id\n</code></pre>\n<div><span>1</span><br></div></div><p>运行镜像到容器\ndocker run -d -p 对外访问的端口号:你开发的应用的运行端口号 镜像名:版本号\n例如：</p>\n<div><pre><code>docker run -d -p 8083:8083 panda:1.1.1\n</code></pre>\n<div><span>1</span><br></div></div><p>-d表示后台运行\n-p表示端口映射</p>\n",
      "date_published": "2020-02-20T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "解决Docker容器应用中mvn: command not found的问题",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/docker/%E8%A7%A3%E5%86%B3Docker%E5%AE%B9%E5%99%A8%E5%BA%94%E7%94%A8%E4%B8%ADmvn%20command%20not%20found%E7%9A%84%E9%97%AE%E9%A2%98/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/docker/%E8%A7%A3%E5%86%B3Docker%E5%AE%B9%E5%99%A8%E5%BA%94%E7%94%A8%E4%B8%ADmvn%20command%20not%20found%E7%9A%84%E9%97%AE%E9%A2%98/",
      "content_html": "<h1 id=\"解决docker容器应用中mvn-command-not-found的问题\"> 解决Docker容器应用中mvn: command not found的问题</h1>\n<h2 id=\"问题\"> 问题</h2>\n<p>我在搞jenkins时使用shell脚本执行mvn命令，提示mvn: command not found。因为我的jenkins是在docker中安装的，所以没有mvn环境</p>\n<h2 id=\"原因\"> 原因</h2>\n<p>在docker中安装的jenkins，没有maven，虽然可以通过挂载宿主机目录来提供maven，但是容器内的环境变量却不会知道设置，因此需要我们手动设置环境变量。</p>\n<h2 id=\"解决\"> 解决</h2>\n<ol>\n<li>运行容器的时候将宿主机的java和maven目录挂载进去</li>\n</ol>\n<div><pre><code>docker run \n-d -p <span>8080</span>:8080 <span>\\</span>\n-v /usr/lib/jvm/java-1.8-openjdk:/usr/lib/jvm/java-1.8-openjdk <span>\\</span>\n-v /usr/local/maven/maven3:/usr/local/maven/maven3 <span>\\</span>\n容器id\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>-v</code> 是将宿主机的目录挂载到容器内</p>\n<p><code>:</code>冒号前面的是宿主机目录，冒号后面的是容器应用的目录</p>\n<ol start=\"2\">\n<li>运行容器成功后，进入容器</li>\n</ol>\n<div><pre><code>docker <span>exec</span> -it 容器id /bin/bash\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"3\">\n<li>设置容器应用的环境变量</li>\n</ol>\n<div><pre><code><span>vi</span> /etc/profile\n</code></pre>\n<div><span>1</span><br></div></div><p>在文件最后面添加如下内容</p>\n<div><pre><code><span># java环境变量</span>\n<span>export</span> <span>JAVA_HOME</span><span>=</span>/usr/lib/jvm/java-1.8-openjdk\n<span>export</span> <span>JRE_HOME</span><span>=</span><span>$JAVA_HOME</span>/jre\n<span>export</span> <span><span>PATH</span></span><span>=</span><span>$JAVA_HOME</span>/bin:<span>$PATH</span>\n<span>export</span> <span>CLASSPATH</span><span>=</span>./:JAVA_HOME/lib:<span>$JRE_HOME</span>/lib\n\n\n<span># maven环境变量</span>\n<span>export</span> <span>M2_HOME</span><span>=</span>/usr/local/maven/maven3\n<span>export</span> <span><span>PATH</span></span><span>=</span><span>$PATH</span><span>:</span><span>$JAVA_HOME</span>/bin:<span>$M2_HOME</span>/bin\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ol start=\"4\">\n<li>更新profile</li>\n</ol>\n<div><pre><code><span>source</span> /etc/profile\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"5\">\n<li>验证是否设置成功</li>\n</ol>\n<div><pre><code>mvn -v\n</code></pre>\n<div><span>1</span><br></div></div><p>出现上面的内容则表明成功</p>\n",
      "date_published": "2020-02-20T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "安装Elastic Search",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/elstaicsearch/01-%E5%AE%89%E8%A3%85Elastic%20Search/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/elstaicsearch/01-%E5%AE%89%E8%A3%85Elastic%20Search/",
      "content_html": "<h1 id=\"安装elastic-search\"> 安装Elastic Search</h1>\n<h2 id=\"windows下安装\"> Windows下安装</h2>\n<p><a href=\"https://www.elastic.co/downloads/elasticsearch\" target=\"_blank\" rel=\"noopener noreferrer\">官网</a>最新版本 Elasticsearch （7.6.1）</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200315110946-410556.png\" alt=\"img\" /></p>\n<blockquote>\n<p>顺带一提：在下载之前你应该确保你的 Java 版本保持在 1.8 及以上（就 1.8 吧..），这是 Elasticsearch 的硬性要求，可以自行打开命令行输入 <code>java -version</code> 来查看 Java 的版本</p>\n</blockquote>\n<p>下载完成后，可以看到是一个压缩包，我们直接解压在 D 盘上，然后打开 <code>bin</code> 目录下的 elasticsearch.bat 文件</p>\n<p>浏览器访问</p>\n<p>http://localhost:9200/</p>\n<p>返回如下json数据表示成功</p>\n<h2 id=\"安装kibana\"> 安装Kibana</h2>\n<p>这是一个官方推出的把 Elasticsearch 数据可视化的工具，官网在这里：<a href=\"https://www.elastic.co/cn/products/kibana\" target=\"_blank\" rel=\"noopener noreferrer\">【传送门】</a>，不过我们现在暂时还用不到那些数据分析的东西，不过里面有一个 Dev Tools 的工具可以方便的和 Elasticsearch 服务进行交互，去官网下载了最新版本的 Kibana（7.6.1）</p>\n<p>下载后解压，执行bin目录的kibana.bat</p>\n<p>运行</p>\n<p>出现超时错误</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200315111842-200901.png\" alt=\"image-20200315111837446\" /></p>\n<p>解决</p>\n<p>修改kibana\\config目录下的kibana.yml文件</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200315112845-376308.png\" alt=\"image-20200315112844231\" /></p>\n<p>改成如下图</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200315112912-103026.png\" alt=\"image-20200315112912595\" /></p>\n<p>重新运行</p>\n<p>出现如下图表示成功</p>\n<p>浏览器访问http://localhost:5601/app/kibana#/home</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200315113032-241900.png\" alt=\"image-20200315113028103\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200315113227-779083.png\" alt=\"image-20200315113151512\" /></p>\n<p>找到左边侧栏的扳手图标，点击进入dev tools</p>\n<p>点击 【Get to work】，然后在控制台输入 <code>GET /_cat/health?v</code> 查看服务器状态，可以在右侧返回的结果中看到 <code>green</code> 即表示服务器状态目前是健康的：</p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200315110946-410556.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Docker安装Elastic Search",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/elstaicsearch/03-Docker%E5%AE%89%E8%A3%85Elastic%20Search/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/elstaicsearch/03-Docker%E5%AE%89%E8%A3%85Elastic%20Search/",
      "content_html": "<h1 id=\"docker安装elastic-search\"> Docker安装Elastic Search</h1>\n<h2 id=\"单节点集群\"> 单节点集群</h2>\n<h3 id=\"普通方式安装\"> 普通方式安装</h3>\n<h4 id=\"拉取镜像\"> 拉取镜像</h4>\n<div><pre><code>docker pull docker.elastic.co/elasticsearch/elasticsearch:7.6.1\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"运行\"> 运行</h4>\n<div><pre><code>docker run -p <span>9200</span>:9200 -p <span>9300</span>:9300 -e <span>\"discovery.type=single-node\"</span> docker.elastic.co/elasticsearch/elasticsearch:7.6.1\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"docker-compose-yml方式\"> Docker-compose.yml方式</h3>\n<p>docker-compose.yml</p>\n<div><pre><code><span>version</span><span>:</span> <span>'2.2'</span>\n<span>services</span><span>:</span>\n  <span>es01</span><span>:</span>\n    <span>image</span><span>:</span> docker.elastic.co/elasticsearch/elasticsearch<span>:</span>6.2.2\n    <span>container_name</span><span>:</span> es01\n    <span>environment</span><span>:</span>\n      <span>-</span> node.name=es01\n\t  <span>-</span> discovery.type=single<span>-</span>node\n      <span>-</span> bootstrap.memory_lock=true\n      <span>-</span> <span>\"ES_JAVA_OPTS=-Xms64m -Xmx64m\"</span>\n    <span>ulimits</span><span>:</span>\n      <span>memlock</span><span>:</span>\n        <span>soft</span><span>:</span> <span>-1</span>\n        <span>hard</span><span>:</span> <span>-1</span>\n    <span>volumes</span><span>:</span>\n      <span>-</span> data01<span>:</span>/usr/share/elasticsearch/data\n    <span>ports</span><span>:</span>\n      <span>-</span> 9200<span>:</span><span>9200</span>\n    <span>networks</span><span>:</span>\n      <span>-</span> elastic\n\n<span>volumes</span><span>:</span>\n  <span>data01</span><span>:</span>\n    <span>driver</span><span>:</span> local\n\n\n<span>networks</span><span>:</span>\n  <span>elastic</span><span>:</span>\n    <span>driver</span><span>:</span> bridge\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>启动</p>\n<div><pre><code>docker-compose up -d\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"docker安装kibana\"> Docker安装kibana</h2>\n<p>docker-compose.yml</p>\n<div><pre><code><span>version</span><span>:</span> <span>'2.2'</span>\n<span>services</span><span>:</span>\n  <span>kibana</span><span>:</span>\n    <span>image</span><span>:</span> docker.elastic.co/kibana/kibana<span>:</span>7.6.1\n    <span>container_name</span><span>:</span> kibana\n    <span>environment</span><span>:</span>\n      <span>-</span> ELASTICSEARCH_HOSTS=http<span>:</span>//es01<span>:</span><span>9200</span>\n      <span># 需要将Kibana配置文件中的小写转换成大写，然后这个才能用于变量，才能被设置</span>\n到\n      <span>-</span> I18N_LOCALE=zh<span>-</span>CN\n      <span>-</span> xpack.monitoring.ui.container.elasticsearch.enabled=false\n    <span>ports</span><span>:</span>\n      <span>-</span> 5601<span>:</span><span>5601</span>\n    <span>networks</span><span>:</span>\n      <span>-</span> elastic\n\n<span>networks</span><span>:</span>\n  <span>elastic</span><span>:</span>\n    <span>driver</span><span>:</span> bridge\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>创建config目录</p>\n<div><pre><code><span>mkdir</span> config\n</code></pre>\n<div><span>1</span><br></div></div><p>进入config目录</p>\n<div><pre><code><span>cd</span> config\n</code></pre>\n<div><span>1</span><br></div></div><p>创建配置文件kibana.yml</p>\n<div><pre><code><span>vim</span> kibana.yml\n</code></pre>\n<div><span>1</span><br></div></div><p>粘贴如下内容</p>\n<div><pre><code><span>#</span>\n<span># ** THIS IS AN AUTO-GENERATED FILE **</span>\n<span>#</span>\n\n<span># Default Kibana configuration for docker target</span>\n<span>server.name</span><span>:</span> kibana\n<span>server.host</span><span>:</span> <span>\"0\"</span>\n<span>elasticsearch.hosts</span><span>:</span> <span>[</span> <span>\"http://elasticsearch:9200\"</span> <span>]</span>\n<span>xpack.monitoring.ui.container.elasticsearch.enabled</span><span>:</span> <span>true</span>\n\n<span>elasticsearch.requestTimeout</span><span>:</span> <span>120000</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "安装docker-compose（国内高速镜像）",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/docker/%E5%AE%89%E8%A3%85docker-compose%EF%BC%88%E5%9B%BD%E5%86%85%E9%AB%98%E9%80%9F%E9%95%9C%E5%83%8F%EF%BC%89/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/docker/%E5%AE%89%E8%A3%85docker-compose%EF%BC%88%E5%9B%BD%E5%86%85%E9%AB%98%E9%80%9F%E9%95%9C%E5%83%8F%EF%BC%89/",
      "content_html": "<h1 id=\"安装docker-compose-国内高速镜像\"> 安装docker-compose（国内高速镜像）</h1>\n<p>gihub上下载docker-compose太慢了，下载不动，只能换成国内镜像（daocloud.io）来下载。</p>\n<p><strong>下载</strong></p>\n<div><pre><code><span>curl</span> -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-<span><span>`</span><span>uname</span> -s<span>`</span></span>-<span><span>`</span><span>uname</span> -m<span>`</span></span> <span>></span> /usr/local/bin/docker-compose\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>修改权限</strong></p>\n<div><pre><code><span>chmod</span> +x /usr/local/bin/docker-compose\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>查看是否安装成功</strong></p>\n<div><pre><code>docker-compose -version\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>卸载docker-compose</strong></p>\n<div><pre><code><span># whereis docker-compose</span>\n<span># /usr/bin/docker-compose</span>\n<span># rm /usr/bin/docker-compose</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>",
      "date_published": "2020-02-20T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "快速入门",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/elstaicsearch/02-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/elstaicsearch/02-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/",
      "content_html": "<h1 id=\"快速入门\"> 快速入门</h1>\n<h2 id=\"一、基础概念-快速入门\"> 一、基础概念-快速入门</h2>\n<h3 id=\"节点-node、集群-cluster-和分片-shards\"> 节点 Node、集群 Cluster 和分片 Shards</h3>\n<p>ElasticSearch 是分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个实例。单个实例称为一个节点（node），一组节点构成一个集群（cluster）。分片是底层的工作单元，文档保存在分片内，分片又被分配到集群内的各个节点里，每个分片仅保存全部数据的一部分。</p>\n<h3 id=\"索引-index、类型-type-和文档-document\"> 索引 Index、类型 Type 和文档 Document</h3>\n<p>对比我们比较熟悉的 MySQL 数据库：</p>\n<blockquote>\n<p>index → db\ntype → table\ndocument → row</p>\n</blockquote>\n<p>如果我们要访问一个文档元数据应该包括囊括 <code>index/type/id</code> 这三种类型，很好理解。</p>\n<h2 id=\"二、使用-restful-api-与-elasticsearch-进行交互\"> 二、使用 RESTful API 与 Elasticsearch 进行交互</h2>\n<p>所有其他语言可以使用 RESTful API 通过端口 <em>9200</em> 和 Elasticsearch 进行通信，你可以用你最喜爱的 web 客户端访问 Elasticsearch 。一个 Elasticsearch 请求和任何 HTTP 请求一样由若干相同的部件组成：</p>\n<blockquote>\n<div><pre><code>curl -X &#39;://:/?&#39; -d &#39;&#39;\n</code></pre>\n<div><span>1</span><br></div></div></blockquote>\n<p>被 <code>&lt; &gt;</code> 标记的部件：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>部件名</strong></th>\n<th style=\"text-align:left\"><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>VERB</code></td>\n<td style=\"text-align:left\">适当的 HTTP 方法 或 谓词 : <code>GET</code>、 <code>POST</code>、 <code>PUT</code>、 <code>HEAD</code> 或者 <code>DELETE</code>。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>PROTOCOL</code></td>\n<td style=\"text-align:left\"><code>http</code> 或者 <code>https</code>（如果你在 Elasticsearch 前面有一个 <code>https</code> 代理）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>HOST</code></td>\n<td style=\"text-align:left\">Elasticsearch 集群中任意节点的主机名，或者用 <code>localhost</code> 代表本地机器上的节点。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>PORT</code></td>\n<td style=\"text-align:left\">运行 Elasticsearch HTTP 服务的端口号，默认是 <code>9200</code> 。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>PATH</code></td>\n<td style=\"text-align:left\">API 的终端路径（例如 <code>_count</code> 将返回集群中文档数量）。Path 可能包含多个组件，例如：<code>_cluster/stats</code> 和 <code>_nodes/stats/jvm</code> 。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>QUERY_STRING</code></td>\n<td style=\"text-align:left\">任意可选的查询字符串参数 (例如 <code>?pretty</code> 将格式化地输出 JSON 返回值，使其更容易阅读)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>BODY</code></td>\n<td style=\"text-align:left\">一个 JSON 格式的请求体 (如果请求需要的话)</td>\n</tr>\n</tbody>\n</table>\n<p>就比如计算集群中文档的数量，我们可以用这个:</p>\n<div><pre><code><span>curl</span> -XGET <span>'http://localhost:9200/_count?pretty'</span> -d <span>'\n{\n    \"query\": {\n        \"match_all\": {}\n    }\n}\n'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>不过对于安装了 Kibana 的我们，可以直接在 Kibana 的控制台输出以下语句，也是同样的效果：</p>\n<div><pre><code>GET /_count?pretty\n<span>{</span>\n    <span>\"query\"</span><span>:</span> <span>{</span>\n        <span>\"match_all\"</span><span>:</span> <span>{</span><span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"文档管理-crud\"> 文档管理（CRUD）</h3>\n<p>如果对于 RESTful 不太熟悉的童鞋请右转：<a href=\"https://www.jianshu.com/p/91600da4df95\" target=\"_blank\" rel=\"noopener noreferrer\">【传送门】</a></p>\n<p><strong>增加：</strong></p>\n<div><pre><code>POST /db/user/1\n<span>{</span>\n  <span>\"username\"</span><span>:</span> <span>\"wmyskxz1\"</span>,\n  <span>\"password\"</span><span>:</span> <span>\"123456\"</span>,\n  <span>\"age\"</span><span>:</span> <span>\"22\"</span>\n<span>}</span>\nPOST /db/user/2\n<span>{</span>\n  <span>\"username\"</span><span>:</span> <span>\"wmyskxz2\"</span>,\n  <span>\"password\"</span><span>:</span> <span>\"123456\"</span>,\n  <span>\"age\"</span><span>:</span> <span>\"22\"</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>这一段代码稍微解释一下，这其实就往索引为 <code>db</code> 类型为 <code>user</code> 的数据库中插入一条 <code>id</code> 为 1 的一条数据，这条数据其实就相当于一个拥有 <code>username/password/age</code> 三个属性的一个实体，就是 JSON 数据</p>\n<p>执行命令后，Elasticsearch 返回如下数据：</p>\n<div><pre><code><span># POST /db/user/1</span>\n<span>{</span>\n  <span>\"_index\"</span><span>:</span> <span>\"db\"</span>,\n  <span>\"_type\"</span><span>:</span> <span>\"user\"</span>,\n  <span>\"_id\"</span><span>:</span> <span>\"1\"</span>,\n  <span>\"_version\"</span><span>:</span> <span>1</span>,\n  <span>\"result\"</span><span>:</span> <span>\"created\"</span>,\n  <span>\"_shards\"</span><span>:</span> <span>{</span>\n    <span>\"total\"</span><span>:</span> <span>2</span>,\n    <span>\"successful\"</span><span>:</span> <span>1</span>,\n    <span>\"failed\"</span><span>:</span> <span>0</span>\n  <span>}</span>,\n  <span>\"_seq_no\"</span><span>:</span> <span>2</span>,\n  <span>\"_primary_term\"</span><span>:</span> <span>1</span>\n<span>}</span>\n\n<span># POST /db/user/2</span>\n<span>{</span>\n  <span>\"_index\"</span><span>:</span> <span>\"db\"</span>,\n  <span>\"_type\"</span><span>:</span> <span>\"user\"</span>,\n  <span>\"_id\"</span><span>:</span> <span>\"2\"</span>,\n  <span>\"_version\"</span><span>:</span> <span>1</span>,\n  <span>\"result\"</span><span>:</span> <span>\"created\"</span>,\n  <span>\"_shards\"</span><span>:</span> <span>{</span>\n    <span>\"total\"</span><span>:</span> <span>2</span>,\n    <span>\"successful\"</span><span>:</span> <span>1</span>,\n    <span>\"failed\"</span><span>:</span> <span>0</span>\n  <span>}</span>,\n  <span>\"_seq_no\"</span><span>:</span> <span>1</span>,\n  <span>\"_primary_term\"</span><span>:</span> <span>1</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p><code>version</code> 是版本号的意思，当我们执行操作会自动加 1</p>\n<blockquote>\n<p><strong>使用postman测试</strong></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200315102059-818795.png\" alt=\"image-20200315102056011\" /></p>\n<p>返回的数据</p>\n</blockquote>\n<p><strong>删除：</strong></p>\n<div><pre><code>DELETE /db/user/1\n</code></pre>\n<div><span>1</span><br></div></div><p>Elasticsearch 返回数据如下：</p>\n<div><pre><code><span>{</span>\n  <span>\"_index\"</span><span>:</span> <span>\"db\"</span>,\n  <span>\"_type\"</span><span>:</span> <span>\"user\"</span>,\n  <span>\"_id\"</span><span>:</span> <span>\"1\"</span>,\n  <span>\"_version\"</span><span>:</span> <span>2</span>,\n  <span>\"result\"</span><span>:</span> <span>\"deleted\"</span>,\n  <span>\"_shards\"</span><span>:</span> <span>{</span>\n    <span>\"total\"</span><span>:</span> <span>2</span>,\n    <span>\"successful\"</span><span>:</span> <span>1</span>,\n    <span>\"failed\"</span><span>:</span> <span>0</span>\n  <span>}</span>,\n  <span>\"_seq_no\"</span><span>:</span> <span>1</span>,\n  <span>\"_primary_term\"</span><span>:</span> <span>1</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这里就可以看到 <code>version</code> 变成了 2</p>\n<p><strong>修改：</strong></p>\n<div><pre><code>PUT /db/user/2\n{\n  &quot;username&quot;: &quot;wmyskxz3&quot;,\n  &quot;password&quot;: &quot;123456&quot;,\n  &quot;age&quot;: &quot;22&quot;\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>Elasticsearch 返回数据如下：sh</p>\n<div><pre><code><span>{</span>\n  <span>\"_index\"</span><span>:</span> <span>\"db\"</span>,\n  <span>\"_type\"</span><span>:</span> <span>\"user\"</span>,\n  <span>\"_id\"</span><span>:</span> <span>\"2\"</span>,\n  <span>\"_version\"</span><span>:</span> <span>2</span>,\n  <span>\"result\"</span><span>:</span> <span>\"updated\"</span>,\n  <span>\"_shards\"</span><span>:</span> <span>{</span>\n    <span>\"total\"</span><span>:</span> <span>2</span>,\n    <span>\"successful\"</span><span>:</span> <span>1</span>,\n    <span>\"failed\"</span><span>:</span> <span>0</span>\n  <span>}</span>,\n  <span>\"_seq_no\"</span><span>:</span> <span>2</span>,\n  <span>\"_primary_term\"</span><span>:</span> <span>1</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>查询：</strong></p>\n<div><pre><code>GET /db/user/2\n</code></pre>\n<div><span>1</span><br></div></div><p>返回数据如下：</p>\n<div><pre><code><span>{</span>\n  <span>\"_index\"</span><span>:</span> <span>\"db\"</span>,\n  <span>\"_type\"</span><span>:</span> <span>\"user\"</span>,\n  <span>\"_id\"</span><span>:</span> <span>\"2\"</span>,\n  <span>\"_version\"</span><span>:</span> <span>2</span>,\n  <span>\"found\"</span><span>:</span> true,\n  <span>\"_source\"</span><span>:</span> <span>{</span>\n    <span>\"username\"</span><span>:</span> <span>\"wmyskxz3\"</span>,\n    <span>\"password\"</span><span>:</span> <span>\"123456\"</span>,\n    <span>\"age\"</span><span>:</span> <span>\"22\"</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"搜索\"> 搜索</h3>\n<p>上面我们已经演示了基本的文档 CRUD 功能，然而 Elasticsearch 的核心功能是搜索，所以在学习之前，为更好的演示这个功能，我们先往 Elasticsearch 中插入一些数据：</p>\n<div><pre><code>PUT /movies/movie/1\n<span>{</span>\n  <span>\"title\"</span><span>:</span> <span>\"The Godfather\"</span>,\n  <span>\"director\"</span><span>:</span> <span>\"Francis Ford Coppola\"</span>,\n  <span>\"year\"</span><span>:</span> <span>1972</span>,\n  <span>\"genres\"</span><span>:</span> <span>[</span>\n    <span>\"Crime\"</span>,\n    <span>\"Drama\"</span>\n  <span>]</span>\n<span>}</span>\n\nPUT /movies/movie/2\n<span>{</span>\n  <span>\"title\"</span><span>:</span> <span>\"Lawrence of Arabia\"</span>,\n  <span>\"director\"</span><span>:</span> <span>\"David Lean\"</span>,\n  <span>\"year\"</span><span>:</span> <span>1962</span>,\n  <span>\"genres\"</span><span>:</span> <span>[</span>\n    <span>\"Adventure\"</span>,\n    <span>\"Biography\"</span>,\n    <span>\"Drama\"</span>\n  <span>]</span>\n<span>}</span>\n\nPUT /movies/movie/3\n<span>{</span>\n  <span>\"title\"</span><span>:</span> <span>\"To Kill a Mockingbird\"</span>,\n  <span>\"director\"</span><span>:</span> <span>\"Robert Mulligan\"</span>,\n  <span>\"year\"</span><span>:</span> <span>1962</span>,\n  <span>\"genres\"</span><span>:</span> <span>[</span>\n    <span>\"Crime\"</span>,\n    <span>\"Drama\"</span>,\n    <span>\"Mystery\"</span>\n  <span>]</span>\n<span>}</span>\n\nPUT /movies/movie/4\n<span>{</span>\n  <span>\"title\"</span><span>:</span> <span>\"Apocalypse Now\"</span>,\n  <span>\"director\"</span><span>:</span> <span>\"Francis Ford Coppola\"</span>,\n  <span>\"year\"</span><span>:</span> <span>1979</span>,\n  <span>\"genres\"</span><span>:</span> <span>[</span>\n    <span>\"Drama\"</span>,\n    <span>\"War\"</span>\n  <span>]</span>\n<span>}</span>\n\nPUT /movies/movie/5\n<span>{</span>\n  <span>\"title\"</span><span>:</span> <span>\"Kill Bill: Vol. 1\"</span>,\n  <span>\"director\"</span><span>:</span> <span>\"Quentin Tarantino\"</span>,\n  <span>\"year\"</span><span>:</span> <span>2003</span>,\n  <span>\"genres\"</span><span>:</span> <span>[</span>\n    <span>\"Action\"</span>,\n    <span>\"Crime\"</span>,\n    <span>\"Thriller\"</span>\n  <span>]</span>\n<span>}</span>\n\nPUT /movies/movie/6\n<span>{</span>\n  <span>\"title\"</span><span>:</span> <span>\"The Assassination of Jesse James by the Coward Robert Ford\"</span>,\n  <span>\"director\"</span><span>:</span> <span>\"Andrew Dominik\"</span>,\n  <span>\"year\"</span><span>:</span> <span>2007</span>,\n  <span>\"genres\"</span><span>:</span> <span>[</span>\n    <span>\"Biography\"</span>,\n    <span>\"Crime\"</span>,\n    <span>\"Drama\"</span>\n  <span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br></div></div><p><strong>_search端点</strong></p>\n<p>现在已经把一些电影信息放入了索引，可以通过搜索看看是否可找到它们。 为了使用 ElasticSearch 进行搜索，我们使用 <code>_search</code> 端点，可选择使用索引和类型。也就是说，按照以下模式向URL发出请求：<code>//_search</code>。其中，<code>index</code> 和 <code>type</code> 都是可选的。</p>\n<p>换句话说，为了搜索电影，可以对以下任一URL进行POST请求：</p>\n<ul>\n<li>http://localhost:9200/_search - 搜索所有索引和所有类型。</li>\n<li>http://localhost:9200/movies/_search - 在电影索引中搜索所有类型</li>\n<li>http://localhost:9200/movies/movie/_search - 在电影索引中显式搜索电影类型的文档。</li>\n</ul>\n<p><strong>搜索请求正文和ElasticSearch查询DSL</strong></p>\n<p>如果只是发送一个请求到上面的URL，我们会得到所有的电影信息。为了创建更有用的搜索请求，还需要向请求正文中提供查询。 请求正文是一个JSON对象，除了其它属性以外，它还要包含一个名称为 <code>“query”</code> 的属性，这就可使用ElasticSearch的查询DSL。</p>\n<div><pre><code><span>{</span>\n    <span>\"query\"</span><span>:</span> <span>{</span>\n        //Query DSL here\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>你可能想知道查询DSL是什么。它是ElasticSearch自己基于JSON的域特定语言，可以在其中表达查询和过滤器。你可以把它简单同SQL对应起来，就相当于是条件语句吧。</p>\n<p><strong>基本自由文本搜索：</strong></p>\n<p>查询DSL具有一长列不同类型的查询可以使用。 对于“普通”自由文本搜索，最有可能想使用一个名称为“查询字符串查询”。</p>\n<p><a href=\"http://www.elasticsearch.org/guide/reference/query-dsl/query-string-query/\" target=\"_blank\" rel=\"noopener noreferrer\">查询字符串查询</a>是一个高级查询，有很多不同的选项，ElasticSearch将解析和转换为更简单的查询树。如果忽略了所有的可选参数，并且只需要给它一个字符串用于搜索，它可以很容易使用。</p>\n<p>现在尝试在两部电影的标题中搜索有“kill”这个词的电影信息：</p>\n<div><pre><code>GET /_search\n<span>{</span>\n  <span>\"query\"</span><span>:</span> <span>{</span>\n    <span>\"query_string\"</span><span>:</span> <span>{</span>\n      <span>\"query\"</span><span>:</span> <span>\"kill\"</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>执行上面的请求并查看结果，如下所示 -</p>\n<p>正如预期的，得到两个命中结果，每个电影的标题中都带有“kill”单词。再看看另一种情况，在特定字段中搜索。</p>\n<p><strong>指定搜索的字段</strong></p>\n<p>在前面的例子中，使用了一个非常简单的查询，一个只有一个属性 <code>“query”</code> 的查询字符串查询。 如前所述，查询字符串查询有一些可以指定设置，如果不使用，它将会使用默认的设置值。</p>\n<p>这样的设置称为“fields”，可用于指定要搜索的字段列表。如果不使用“fields”字段，ElasticSearch查询将默认自动生成的名为 <code>“_all”</code> 的特殊字段，来基于所有文档中的各个字段匹配搜索。</p>\n<p>为了做到这一点，修改以前的搜索请求正文，以便查询字符串查询有一个 <code>fields</code> 属性用来要搜索的字段数组：</p>\n<div><pre><code>GET /_search\n<span>{</span>\n  <span>\"query\"</span><span>:</span> <span>{</span>\n    <span>\"query_string\"</span><span>:</span> <span>{</span>\n      <span>\"query\"</span><span>:</span> <span>\"ford\"</span>,\n      <span>\"fields\"</span><span>:</span> <span>[</span>\n        <span>\"title\"</span>\n      <span>]</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>执行上面查询它，看看会有什么结果(应该只匹配到 1 行数据)：</p>\n<p>正如预期的得到一个命中，电影的标题中的单词“ford”。现在，从查询中移除fields属性，应该能匹配到 3 行数据：</p>\n<h3 id=\"过滤\"> 过滤</h3>\n<p>前面已经介绍了几个简单的自由文本搜索查询。现在来看看另一个示例，搜索 <code>“drama”</code>，不明确指定字段，如下查询 -</p>\n<div><pre><code>GET /_search\n<span>{</span>\n  <span>\"query\"</span><span>:</span> <span>{</span>\n    <span>\"query_string\"</span><span>:</span> <span>{</span>\n      <span>\"query\"</span><span>:</span> <span>\"drama\"</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>因为在索引中有五部电影在 <code>_all</code> 字段(从类别字段)中包含单词 <code>“drama”</code>，所以得到了上述查询的 <code>5</code> 个命中。 现在，想象一下，如果我们想限制这些命中为只是 <code>1962</code> 年发布的电影。要做到这点，需要应用一个过滤器，要求 <code>“year”</code> 字段等于 <code>1962</code>。要添加过滤器，修改搜索请求正文，以便当前的顶级查询(查询字符串查询)包含在过滤的查询中：</p>\n<div><pre><code><span>{</span>\n    <span>\"query\"</span><span>:</span> <span>{</span>\n        <span>\"filtered\"</span><span>:</span> <span>{</span>\n            <span>\"query\"</span><span>:</span> <span>{</span>\n                <span>\"query_string\"</span><span>:</span> <span>{</span>\n                    <span>\"query\"</span><span>:</span> <span>\"drama\"</span>\n                <span>}</span>\n            <span>}</span>,\n            <span>\"filter\"</span><span>:</span> <span>{</span>\n                //Filter to apply to the query\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>过滤的查询是具有两个属性(<code>query</code>和<code>filter</code>)的查询。执行时，它使用过滤器过滤查询的结果。要完成这样的查询还需要添加一个过滤器，要求<code>year</code>字段的值为<code>1962</code>。</p>\n<p><strong>ElasticSearch</strong>查询DSL有各种各样的过滤器可供选择。对于这个简单的情况，某个字段应该匹配一个特定的值，一个<a href=\"http://www.elasticsearch.org/guide/reference/query-dsl/term-filter/\" target=\"_blank\" rel=\"noopener noreferrer\">条件过滤器</a>就能很好地完成工作。</p>\n<div><pre><code><span>\"filter\"</span><span>:</span> <span>{</span>\n    <span>\"term\"</span><span>:</span> <span>{</span> <span>\"year\"</span><span>:</span> <span>1962</span> <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>完整的搜索请求如下所示：</p>\n<div><pre><code>GET /_search\n<span>{</span>\n  <span>\"query\"</span><span>:</span> <span>{</span>\n    <span>\"filtered\"</span><span>:</span> <span>{</span>\n      <span>\"query\"</span><span>:</span> <span>{</span>\n        <span>\"query_string\"</span><span>:</span> <span>{</span>\n          <span>\"query\"</span><span>:</span> <span>\"drama\"</span>\n        <span>}</span>\n      <span>}</span>,\n      <span>\"filter\"</span><span>:</span> <span>{</span>\n        <span>\"term\"</span><span>:</span> <span>{</span>\n          <span>\"year\"</span><span>:</span> <span>1962</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>当执行上面请求，只得到两个命中，这个两个命中的数据的 <code>year</code> 字段的值都是等于 <code>1962</code>。</p>\n<p><strong>无需查询即可进行过滤</strong></p>\n<p>在上面的示例中，使用过滤器限制查询字符串查询的结果。如果想要做的是应用一个过滤器呢？ 也就是说，我们希望所有电影符合一定的标准。</p>\n<p>在这种情况下，我们仍然在搜索请求正文中使用 <code>“query”</code> 属性。但是，我们不能只是添加一个过滤器，需要将它包装在某种查询中。</p>\n<p>一个解决方案是修改当前的搜索请求，替换查询字符串 <code>query</code> 过滤查询中的 <code>match_all</code> 查询，这是一个查询，只是匹配一切。类似下面这个：</p>\n<div><pre><code>GET /_search\n<span>{</span>\n  <span>\"query\"</span><span>:</span> <span>{</span>\n    <span>\"filtered\"</span><span>:</span> <span>{</span>\n      <span>\"query\"</span><span>:</span> <span>{</span>\n        <span>\"match_all\"</span><span>:</span> <span>{</span><span>}</span>\n      <span>}</span>,\n      <span>\"filter\"</span><span>:</span> <span>{</span>\n        <span>\"term\"</span><span>:</span> <span>{</span>\n          <span>\"year\"</span><span>:</span> <span>1962</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>另一个更简单的方法是使用常数分数查询：</p>\n<div><pre><code>GET /_search\n<span>{</span>\n  <span>\"query\"</span><span>:</span> <span>{</span>\n    <span>\"constant_score\"</span><span>:</span> <span>{</span>\n      <span>\"filter\"</span><span>:</span> <span>{</span>\n        <span>\"term\"</span><span>:</span> <span>{</span>\n          <span>\"year\"</span><span>:</span> <span>1962</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200315102059-818795.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "学习Elastic Search",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/elstaicsearch/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/elstaicsearch/",
      "content_html": "<h1 id=\"学习elastic-search\"> 学习Elastic Search</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Git 常用命令",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/git/Git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/git/Git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/",
      "content_html": "<h2 id=\"git-常用命令\"> Git 常用命令</h2>\n<h3 id=\"仓库\"> 仓库</h3>\n<div><pre><code># 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"配置\"> 配置</h3>\n<div><pre><code># 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name &quot;[name]&quot;\n$ git config [--global] user.email &quot;[email address]&quot;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"增加-删除文件\"> 增加/删除文件</h3>\n<div><pre><code># 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"代码提交\"> 代码提交</h3>\n<div><pre><code># 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"分支\"> 分支</h3>\n<div><pre><code># 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h3 id=\"标签\"> 标签</h3>\n<div><pre><code># 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id=\"查看信息\"> 查看信息</h3>\n<div><pre><code># 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat &quot;@{0 day ago}&quot;\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><h3 id=\"远程同步\"> 远程同步</h3>\n<div><pre><code># 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id=\"撤销\"> 撤销</h3>\n<div><pre><code># 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h3 id=\"其他\"> 其他</h3>\n<div><pre><code># 生成一个可供发布的压缩包\n$ git archive\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "CentOS7安装git",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/git/CentOS7%E5%AE%89%E8%A3%85git/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/git/CentOS7%E5%AE%89%E8%A3%85git/",
      "content_html": "<h1 id=\"centos7安装git\"> CentOS7安装git</h1>\n<p>使用yum安装git</p>\n<div><pre><code>yum -y <span>install</span> <span>git</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>查看是否安装成功</p>\n<div><pre><code><span>git</span> --version\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2020-02-27T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "jenkins镜像加速",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/jenkins/jenkins%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/jenkins/jenkins%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/",
      "content_html": "<h1 id=\"jenkins镜像加速\"> jenkins镜像加速</h1>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200222122519-197191.png\" alt=\"image-20200222122518788\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200222122558-369903.png\" alt=\"image-20200222122541403\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200222122620-834644.png\" alt=\"image-20200222122602880\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200222122625-208564.png\" alt=\"image-20200222122623044\" /></p>\n<p>https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200222122519-197191.png",
      "date_published": "2020-02-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring Boot连接Elastic Search",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/elstaicsearch/04-Spring%20Boot%E8%BF%9E%E6%8E%A5Elastic%20Search/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/elstaicsearch/04-Spring%20Boot%E8%BF%9E%E6%8E%A5Elastic%20Search/",
      "content_html": "<h1 id=\"spring-boot连接elastic-search\"> Spring Boot连接Elastic Search</h1>\n<h2 id=\"版本要求\"> 版本要求</h2>\n<p><strong>Spring Data Elasticsearch</strong>与<strong>Elasticsearch</strong>与<strong>Spring Boot</strong>版版本要求如下，必须一一对应，否则启动不了</p>\n<h2 id=\"搭建工程\"> 搭建工程</h2>\n<p>我这里使用的是</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>版本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Spring Data Elasticsearch</strong></td>\n<td><strong>3.1.6.RELEASE</strong></td>\n</tr>\n<tr>\n<td><strong>Elasticsearch</strong></td>\n<td><strong>6.2.2</strong></td>\n</tr>\n<tr>\n<td><strong>Spring Boot</strong></td>\n<td><strong>2.1.9.RELEASE</strong></td>\n</tr>\n</tbody>\n</table>\n<p>pom.xml</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span><span>&lt;</span>project</span> <span>xmlns</span><span><span>=</span><span>\"</span>http://maven.apache.org/POM/4.0.0<span>\"</span></span> <span><span>xmlns:</span>xsi</span><span><span>=</span><span>\"</span>http://www.w3.org/2001/XMLSchema-instance<span>\"</span></span>\n         <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>\"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>modelVersion</span><span>></span></span>4.0.0<span><span><span>&lt;/</span>modelVersion</span><span>></span></span>\n    <span><span><span>&lt;</span>parent</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-parent<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;</span>version</span><span>></span></span>2.1.9.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;</span>relativePath</span><span>/></span></span> <span>&lt;!-- lookup parent from repository --></span>\n    <span><span><span>&lt;/</span>parent</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>top.alanlee.hello<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>test-elasticsearch<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>0.0.1-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;</span>name</span><span>></span></span>test-elasticsearch<span><span><span>&lt;/</span>name</span><span>></span></span>\n    <span><span><span>&lt;</span>description</span><span>></span></span>Demo project for Spring Boot<span><span><span>&lt;/</span>description</span><span>></span></span>\n\n    <span><span><span>&lt;</span>properties</span><span>></span></span>\n        <span><span><span>&lt;</span>java.version</span><span>></span></span>1.8<span><span><span>&lt;/</span>java.version</span><span>></span></span>\n    <span><span><span>&lt;/</span>properties</span><span>></span></span>\n\n    <span><span><span>&lt;</span>dependencies</span><span>></span></span>\n\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-web<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span>&lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-elasticsearch --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.data<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-data-elasticsearch<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>3.1.6.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n    <span><span><span>&lt;/</span>dependencies</span><span>></span></span>\n\n    <span><span><span>&lt;</span>build</span><span>></span></span>\n        <span><span><span>&lt;</span>plugins</span><span>></span></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n    <span><span><span>&lt;/</span>build</span><span>></span></span>\n\n<span><span><span>&lt;/</span>project</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>配置文件：application.yml</p>\n<div><pre><code><span>server</span><span>:</span>\n  <span>port</span><span>:</span> <span>8080</span>\n<span>spring</span><span>:</span>\n  <span>data</span><span>:</span>\n    <span>elasticsearch</span><span>:</span>\n      <span>cluster-nodes</span><span>:</span> 192.168.12.113<span>:</span><span>9300</span>\t<span># java连接es的端口是9300,9200是http连接的端口</span>\n      <span>cluster-name</span><span>:</span> docker<span>-</span>cluster\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>启动类：ElasticSearchApplication.java</p>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>test<span>.</span>elasticsearch</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>boot<span>.</span></span><span>SpringApplication</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>boot<span>.</span>autoconfigure<span>.</span></span><span>SpringBootApplication</span><span>;</span>\n\n<span>@SpringBootApplication</span>\n<span>public</span> <span>class</span> <span>ElasticSearchApplication</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>ElasticSearchApplication</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>dao层：UserDao.java</p>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>test<span>.</span>elasticsearch<span>.</span>dao</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>data<span>.</span>elasticsearch<span>.</span>repository<span>.</span></span><span>ElasticsearchRepository</span><span>;</span>\n<span>import</span> <span>top<span>.</span>alanlee<span>.</span>test<span>.</span>elasticsearch<span>.</span>entity<span>.</span></span><span>User</span><span>;</span>\n\n<span>public</span> <span>interface</span> <span>UserDao</span> <span>extends</span> <span>ElasticsearchRepository</span><span><span>&lt;</span><span>User</span><span>,</span> <span>Integer</span><span>></span></span> <span>{</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>因为这里只是学习、测试，所以省略service层</p>\n<div><pre><code><span>// service层 略</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>controller层：UserController.java</p>\n<div><pre><code><span>package</span> <span>top<span>.</span>alanlee<span>.</span>test<span>.</span>elasticsearch<span>.</span>controller</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span>factory<span>.</span>annotation<span>.</span></span><span>Autowired</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>*</span><span>;</span>\n<span>import</span> <span>top<span>.</span>alanlee<span>.</span>test<span>.</span>elasticsearch<span>.</span>dao<span>.</span></span><span>UserDao</span><span>;</span>\n<span>import</span> <span>top<span>.</span>alanlee<span>.</span>test<span>.</span>elasticsearch<span>.</span>entity<span>.</span></span><span>User</span><span>;</span>\n\n<span>@RestController</span>\n<span>public</span> <span>class</span> <span>UserController</span> <span>{</span>\n    <span>@Autowired</span>\n    <span>UserDao</span> userDao<span>;</span>\n\n    <span>//增</span>\n    <span>@PostMapping</span><span>(</span><span>\"/addUser\"</span><span>)</span>\n    <span>public</span> <span>String</span> <span>addUser</span><span>(</span><span>String</span> username<span>,</span> <span>String</span> password<span>,</span> <span>Integer</span> age<span>)</span> <span>{</span>\n        <span>User</span> user <span>=</span> <span>new</span> <span>User</span><span>(</span><span>)</span><span>;</span>\n        user<span>.</span><span>setUsername</span><span>(</span>username<span>)</span><span>;</span>\n        user<span>.</span><span>setPassword</span><span>(</span>password<span>)</span><span>;</span>\n        user<span>.</span><span>setAge</span><span>(</span>age<span>)</span><span>;</span>\n        <span>return</span> <span>String</span><span>.</span><span>valueOf</span><span>(</span>userDao<span>.</span><span>save</span><span>(</span>user<span>)</span><span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span><span>// 返回id做验证</span>\n    <span>}</span>\n\n    <span>//删</span>\n    <span>@DeleteMapping</span><span>(</span><span>\"/deleteUser\"</span><span>)</span>\n    <span>public</span> <span>String</span> <span>deleteUser</span><span>(</span><span>Integer</span> id<span>)</span> <span>{</span>\n        userDao<span>.</span><span>deleteById</span><span>(</span>id<span>)</span><span>;</span>\n        <span>return</span> <span>\"Success!\"</span><span>;</span>\n    <span>}</span>\n\n    <span>//改</span>\n    <span>@PutMapping</span><span>(</span><span>\"/updateUser\"</span><span>)</span>\n    <span>public</span> <span>String</span> <span>updateUser</span><span>(</span><span>Integer</span> id<span>,</span> <span>String</span> username<span>,</span> <span>String</span> password<span>,</span> <span>Integer</span> age<span>)</span> <span>{</span>\n        <span>User</span> user <span>=</span> <span>new</span> <span>User</span><span>(</span><span>)</span><span>;</span>\n        user<span>.</span><span>setId</span><span>(</span>id<span>)</span><span>;</span>\n        user<span>.</span><span>setUsername</span><span>(</span>username<span>)</span><span>;</span>\n        user<span>.</span><span>setPassword</span><span>(</span>password<span>)</span><span>;</span>\n        user<span>.</span><span>setAge</span><span>(</span>age<span>)</span><span>;</span>\n        <span>return</span> <span>String</span><span>.</span><span>valueOf</span><span>(</span>userDao<span>.</span><span>save</span><span>(</span>user<span>)</span><span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span><span>// 返回id做验证</span>\n    <span>}</span>\n\n    <span>//查</span>\n    <span>@GetMapping</span><span>(</span><span>\"/getUser\"</span><span>)</span>\n    <span>public</span> <span>User</span> <span>getUser</span><span>(</span><span>Integer</span> id<span>)</span> <span>{</span>\n        <span>return</span> userDao<span>.</span><span>findById</span><span>(</span>id<span>)</span><span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>//查 所有</span>\n    <span>@GetMapping</span><span>(</span><span>\"/getAllUsers\"</span><span>)</span>\n    <span>public</span> <span>Iterable</span><span><span>&lt;</span><span>User</span><span>></span></span> <span>getAllUsers</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> userDao<span>.</span><span>findAll</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Git",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/git/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/git/",
      "content_html": "<h1 id=\"git\"> Git</h1>\n<img :src=\"$withBase=('/note_images/git.jpg')\"/>\nGit(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。  Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "问题",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/git/%E9%97%AE%E9%A2%98/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/git/%E9%97%AE%E9%A2%98/",
      "content_html": "<h1 id=\"问题\"> 问题</h1>\n<h2 id=\"问题1\"> 问题1</h2>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "安装jenkins",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/jenkins/%E5%AE%89%E8%A3%85jenkins/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/jenkins/%E5%AE%89%E8%A3%85jenkins/",
      "content_html": "<h1 id=\"安装jenkins\"> 安装jenkins</h1>\n<p>在docker中安装jenkins</p>\n<p>输入以下代码</p>\n<div><pre><code>docker run <span>\\</span>\n  -u root <span>\\</span>\n  -d -p <span>8001</span>:8080 <span>\\</span>\n  -v /var/jenkins_home:/var/jenkins_home <span>\\</span>\n  -v /usr/bin/docker:/usr/bin/docker <span>\\</span>\n  -v /usr/lib64/libltdl.so.7:/usr/lib64/libltdl.so.7 <span>\\</span>\n  -v /etc/profile:/etc/profile <span>\\</span>\n  -v /var/run/docker.sock:/var/run/docker.sock <span>\\</span>\n  -v /usr/local/maven/maven3:/usr/local/maven/maven3 <span>\\</span>\n  -v /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64 <span>\\</span>\n  -v <span>\"<span>$HOME</span>\"</span>:/home <span>\\</span>\n  --name jenkins2 <span>\\</span>\n  jenkinsci/blueocean\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>复制密码</p>\n<p>docker logs jenkinsci/blueocean容器id</p>\n<div><pre><code>790bf04c1383422c9da78397bcb7cbef\n\nc6f6cba51094442b8d966b9aec592435\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>访问localhost:8000</p>\n<p>输入刚刚的一串密码</p>\n<p>进入插件安装页面</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200221131921-120772.png\" alt=\"image-20200221131921028\" /></p>\n<p>安装完之后创建账户</p>\n<p>实例配置</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200221144024-647535.png\" alt=\"image-20200221144023800\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200221144041-516818.png\" alt=\"image-20200221144041189\" /></p>\n<p>进入主界面</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200221144320-539671.png\" alt=\"image-20200221144319625\" /></p>\n<p>创建项目</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200221144337-897131.png\" alt=\"image-20200221144336311\" /></p>\n<p>输入任务名称--&gt;点击流水线--&gt;点确定</p>\n<p>在 <strong>Description</strong> 字段中填写流水线的简要描述 （例如 <code>一个演示如何使用Jenkins构建Maven管理的简单Java应用程序的入门级流水线。</code>）</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200221144607-603556.png\" alt=\"image-20200221144606880\" /></p>\n<p>在 <strong>Definition</strong> 域中，选择 <strong>Pipeline script from SCM</strong> 选项。此选项指示Jenkins从源代码管理（SCM）仓库获取你的流水线， 这里的仓库就是你clone到本地的Git仓库。</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200221144927-676464.png\" alt=\"image-20200221144926604\" /></p>\n<p>在 <strong>SCM</strong> 域中，选择 <strong>Git</strong>。</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200221145055-950423.png\" alt=\"image-20200221145055435\" /></p>\n<p>在 <strong>Repository URL</strong> 域中，填写你本地仓库的 <a href=\"https://jenkins.io/zh/doc/tutorials/build-a-java-app-with-maven/#fork-sample-repository\" target=\"_blank\" rel=\"noopener noreferrer\">目录路径</a>， 这是从你主机上的用户账户home目录映射到Jenkins容器的 <code>/home</code> 目录：</p>\n<ul>\n<li>MacOS系统 - <code>/home/Documents/GitHub/simple-java-maven-app</code></li>\n<li>Linux系统 - <code>/home/GitHub/simple-java-maven-app</code></li>\n<li>Windows系统 - <code>/home/Documents/GitHub/simple-java-maven-app</code></li>\n</ul>\n<p>在克隆下来的java maven项目中创建Jenkinsfile文件</p>\n<p>内容如下</p>\n<div><pre><code>pipeline {\n    agent {\n        docker {\n            image &#39;maven:3-alpine&#39; \n            args &#39;-v /root/.m2:/root/.m2&#39; \n        }\n    }\n    stages {\n        stage(&#39;Build&#39;) { \n            steps {\n                sh &#39;mvn -B -DskipTests clean package&#39; \n            }\n        }\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200221131921-120772.png",
      "date_published": "2020-02-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Kubernetes 创建第一个容器",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-02-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-02-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/",
      "content_html": "<h1 id=\"kubernetes-创建第一个容器\"> Kubernetes 创建第一个容器</h1>\n<p>以安装nginx为例</p>\n<h2 id=\"创建容器\"> 创建容器</h2>\n<h3 id=\"在master机器上操作\"> 在master机器上操作</h3>\n<p><strong>创建容器</strong></p>\n<div><pre><code>kubectl run nginx --image<span>=</span>nginx --replicas<span>=</span><span>2</span> --port<span>=</span><span>80</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>--image=nginx 指定镜像为nginx</p>\n<p>--replicas=2 创建实例的数量为2</p>\n<p>--port=80 指定容器端口为80</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229202958-354893.png\" alt=\"image-20200229105126482\" /></p>\n<p><strong>查看创建的容器</strong></p>\n<div><pre><code>kubectl get pods\n</code></pre>\n<div><span>1</span><br></div></div><p>刚刚创建就查看容器，READY为0/1，STATUS为ContainerCreating</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229105321-235684.png\" alt=\"image-20200229105259402\" /></p>\n<p>等待容器创建玩就能启动起来</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229203003-10452.png\" alt=\"image-20200229105555499\" /></p>\n<p><strong>查看部署</strong></p>\n<div><pre><code>kubectl get deployment\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229105624-365409.png\" alt=\"image-20200229105624150\" /></p>\n<p><strong>暴露服务</strong></p>\n<div><pre><code>kubectl expose deployment nginx --port<span>=</span><span>80</span> --type<span>=</span>LoadBalancer\n</code></pre>\n<div><span>1</span><br></div></div><p>--port=80 容器的端口为80</p>\n<p>--type=LoadBalancer 类型为负载均衡</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229203005-862018.png\" alt=\"image-20200229110032228\" /></p>\n<p><strong>查看服务</strong></p>\n<div><pre><code>kubectl get <span>service</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229105800-470736.png\" alt=\"image-20200229105800297\" /></p>\n<p><strong>查看服务详情</strong></p>\n<div><pre><code>kubectl describe <span>service</span> nginx\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229203008-498443.png\" alt=\"image-20200229110615410\" /></p>\n<h3 id=\"在node节点机器上操作\"> 在node节点机器上操作</h3>\n<p><strong>在node节点机器上查看运行中的容器</strong></p>\n<div><pre><code>docker <span>ps</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229110804-950910.png\" alt=\"image-20200229110803809\" /></p>\n<h2 id=\"删除容器\"> 删除容器</h2>\n<h3 id=\"在master节点上操作\"> 在master节点上操作</h3>\n<p><strong>删除部署</strong></p>\n<div><pre><code>kubectl delete deployment nginx\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229203013-83914.png\" alt=\"image-20200229111611631\" /></p>\n<p><strong>删除服务</strong></p>\n<div><pre><code>kubectl delete <span>service</span> nginx\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229111731-516235.png\" alt=\"image-20200229111730556\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229202958-354893.png",
      "date_published": "2020-02-29T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "CentOS 安装kubernetes",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-01-CentOS%20%E5%AE%89%E8%A3%85kubernetes/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-01-CentOS%20%E5%AE%89%E8%A3%85kubernetes/",
      "content_html": "<h1 id=\"centos-安装kubernetes\"> CentOS 安装kubernetes</h1>\n<p>机器配置要求：</p>\n<ul>\n<li>\n<p>3台 机器</p>\n<ul>\n<li>第1台：my-master 这台机必须配置2个cpu以上， 2G内存以上</li>\n<li>第2台：my-node-1（1核2G）</li>\n<li>第2台：my-node-2（1核2G）</li>\n</ul>\n</li>\n<li>\n<p>系统Cent OS 7.6 或ubuntu</p>\n</li>\n</ul>\n<h2 id=\"安装docker\"> 安装docker</h2>\n<p>（安装过docker的可以跳过此步骤）</p>\n<p>设置 yum repository</p>\n<div><pre><code><span># 在 master 节点和 node 节点都要执行</span>\n\nyum update\n\n<span>sudo</span> yum <span>install</span> -y yum-utils device-mapper-persistent-data lvm2\n\n<span>sudo</span> yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>安装并启动 docker</p>\n<div><pre><code><span># 在 master 节点和 node 节点都要执行</span>\n<span>sudo</span> yum <span>install</span> -y docker-ce-18.09.7 docker-ce-cli-18.09.7 containerd.io\n<span>sudo</span> systemctl <span>enable</span> docker\n<span>sudo</span> systemctl start docker\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>检查 docker 版本</p>\n<div><pre><code><span># 在 master 节点和 node 节点都要执行</span>\ndocker version\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"安装-nfs-utils\"> 安装 nfs-utils</h2>\n<div><pre><code><span># 在 master 节点和 node 节点都要执行</span>\n<span>sudo</span> yum <span>install</span> -y nfs-utils\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>必须先安装 nfs-utils 才能挂载 nfs 网络存储</p>\n<h2 id=\"k8s基本配置\"> K8S基本配置</h2>\n<p>配置K8S的yum源</p>\n<div><pre><code><span># 在 master 节点和 node 节点都要执行</span>\n<span>cat</span> <span>&lt;&lt;</span><span>EOF<span> <span>></span> /etc/yum.repos.d/kubernetes.repo</span>\n[kubernetes]\nname=Kubernetes\nbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64\nenabled=1\ngpgcheck=0\nrepo_gpgcheck=0\ngpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg\n       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\nEOF</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>关闭 防火墙、SeLinux、swap</p>\n<div><pre><code><span># 在 master 节点和 node 节点都要执行</span>\nsystemctl stop firewalld\nsystemctl disable firewalld\n\nsetenforce <span>0</span>\n<span>sed</span> -i <span>\"s/SELINUX=enforcing/SELINUX=disabled/g\"</span> /etc/selinux/config\n\nswapoff -a\n<span>yes</span> <span>|</span> <span>cp</span> /etc/fstab /etc/fstab_bak\n<span>cat</span> /etc/fstab_bak <span>|</span><span>grep</span> -v swap <span>></span> /etc/fstab\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>修改 /etc/sysctl.conf</p>\n<div><pre><code><span># 在 master 节点和 node 节点都要执行</span>\n<span>vim</span> /etc/sysctl.conf\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>在文件最后面添加</p>\n<div><pre><code><span># 在 master 节点和 node 节点都要执行</span>\nnet.ipv4.ip_forward <span>=</span> <span>1</span>\nnet.bridge.bridge-nf-call-ip6tables <span>=</span> <span>1</span>\nnet.bridge.bridge-nf-call-iptables <span>=</span> <span>1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229091826-112446.png\" alt=\"image-20190715085036593\" /></p>\n<p>执行命令以应用</p>\n<div><pre><code><span># 在 master 节点和 node 节点都要执行</span>\nsysctl -p\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>安装kubelet、kubeadm、kubectl</p>\n<div><pre><code><span># 在 master 节点和 node 节点都要执行</span>\nyum <span>install</span> -y kubelet-1.15.1 kubeadm-1.15.1 kubectl-1.15.1\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>修改docker Cgroup Driver为systemd</p>\n<div><pre><code><span># 在 master 节点和 node 节点都要执行</span>\n<span>vim</span> /usr/lib/systemd/system/docker.service\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>向其中添加</p>\n<div><pre><code>--exec-opt native.cgroupdriver<span>=</span>systemd\n</code></pre>\n<div><span>1</span><br></div></div><p>设置 docker 镜像</p>\n<p>执行以下命令使用 docker 国内镜像，提高 docker 镜像下载速度和稳定性</p>\n<div><pre><code><span># 在 master 节点和 node 节点都要执行</span>\n<span>curl</span> -sSL https://get.daocloud.io/daotools/set_mirror.sh <span>|</span> <span>sh</span> -s http://f1361db2.m.daocloud.io\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>重启 docker，并启动 kubelet</p>\n<div><pre><code><span># 在 master 节点和 node 节点都要执行</span>\nsystemctl daemon-reload\nsystemctl restart docker\nsystemctl <span>enable</span> kubelet <span>&amp;&amp;</span> systemctl start kubelet\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"初始化-master-节点\"> 初始化 master 节点</h2>\n<p>以 root 身份在 my-master 机器上执行</p>\n<p>配置 apiserver.demo 的域名</p>\n<div><pre><code><span># 只在 master 节点执行</span>\n<span>echo</span> <span>\"x.x.x.x  apiserver.demo\"</span> <span>>></span> /etc/hosts\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>请替换其中的 x.x.x.x 为您的 my-master 的实际 ip 地址</p>\n<p>创建 ./kubeadm-config.yaml</p>\n<div><pre><code><span># 只在 master 节点执行</span>\n<span>cat</span> <span>&lt;&lt;</span><span>EOF<span> <span>></span> ./kubeadm-config.yaml</span>\napiVersion: kubeadm.k8s.io/v1beta1\nkind: ClusterConfiguration\nkubernetesVersion: v1.15.1\nimageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers\ncontrolPlaneEndpoint: \"apiserver.demo:6443\"\nnetworking:\n  podSubnet: \"10.100.0.1/20\"\nEOF</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>podSubnet 所使用的网段不能与节点所在的网段重叠</p>\n<p>初始化 apiserver</p>\n<div><pre><code><span># 只在 master 节点执行</span>\nkubeadm init --config<span>=</span>kubeadm-config.yaml --upload-certs\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>根据您服务器网速的情况，您需要等候 1 – 10 分钟</p>\n<p>执行结果如下图所示：</p>\n<p>初始化 root 用户的 kubectl 配置</p>\n<div><pre><code><span># 只在 master 节点执行</span>\n<span>rm</span> -rf /root/.kube/\n<span>mkdir</span> /root/.kube/\n<span>cp</span> -i /etc/kubernetes/admin.conf /root/.kube/config\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>安装 calico</p>\n<div><pre><code><span># 只在 master 节点执行</span>\nkubectl apply -f https://docs.projectcalico.org/v3.6/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>等待calico安装就绪：</p>\n<p>执行如下命令，等待 3-10 分钟，直到所有的容器组处于 Running 状态</p>\n<div><pre><code><span># 只在 master 节点执行</span>\n<span>watch</span> kubectl get pod -n kube-system\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>检查 master 初始化结果</p>\n<p>在 master 节点 my-master 上执行</p>\n<div><pre><code><span># 只在 master 节点执行</span>\nkubectl get nodes\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"初始化-node节点\"> 初始化 node节点</h2>\n<h3 id=\"获得-join命令参数\"> 获得 join命令参数</h3>\n<p>在 master 节点 my-master 节点执行</p>\n<div><pre><code><span># 只在 master 节点执行</span>\nkubeadm token create --print-join-command\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>可获取kubeadm join 命令及参数，如下所示</p>\n<div><pre><code><span># kubeadm token create 命令的输出</span>\nkubeadm <span>join</span> apiserver.demo:6443 --token mpfjma.4vjjg8flqihor4vt     --discovery-token-ca-cert-hash sha256:6f7a8e40a810323672de5eee6f4d19aa2dbdb38411845a1bf5dd63485c43d303\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"初始化node\"> 初始化node</h3>\n<p>针对所有的 node 节点执行</p>\n<div><pre><code><span># 只在 node 节点执行</span>\n<span>echo</span> <span>\"x.x.x.x  apiserver.demo\"</span> <span>>></span> /etc/hosts\nkubeadm <span>join</span> apiserver.demo:6443 --token mpfjma.4vjjg8flqihor4vt     --discovery-token-ca-cert-hash sha256:6f7a8e40a810323672de5eee6f4d19aa2dbdb38411845a1bf5dd63485c43d303\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li>将 x.x.x.x 替换为 my-master 的实际 ip</li>\n<li>将 kubeadm join 命令后的参数替换为上一个步骤中实际从 my-master 节点获得的参数</li>\n</ul>\n<h3 id=\"检查初始化结果\"> 检查初始化结果</h3>\n<p>在 master 节点 my-master 上执行</p>\n<div><pre><code><span># 只在 master 节点执行</span>\nkubectl get nodes\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"移除-node-节点\"> 移除 node 节点</h2>\n<p>正常情况下，无需移除 node 节点，如果添加到集群出错，可以移除 node 节点，再重新尝试添加</p>\n<p>在准备移除的 node 节点上执行</p>\n<div><pre><code><span># 只在 node 节点执行</span>\nkubeadm reset\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>在 master 节点 my-master 上执行</p>\n<div><pre><code><span># 只在 master 节点执行</span>\nkubectl delete node demo-node-x-x\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ul>\n<li>将 demo-node-x-x 替换为要移除的 node 节点的名字</li>\n<li>node 节点的名字可以通过在节点 my-master 上执行 kubectl get nodes 命令获得</li>\n</ul>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229091826-112446.png",
      "date_published": "2020-02-29T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Kubernetes 通过资源配置运行容器",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-03-%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-03-%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8/",
      "content_html": "<h1 id=\"kubernetes-通过资源配置运行容器\"> Kubernetes 通过资源配置运行容器</h1>\n<p>我们知道通过 <code>run</code> 命令启动容器非常麻烦，Docker 提供了 Compose 为我们解决了这个问题。那 Kubernetes 是如何解决这个问题的呢？其实很简单，使用 <code>kubectl create</code> 命令就可以做到和 Compose 一样的效果了，该命令可以通过配置文件快速创建一个集群资源对象。</p>\n<h2 id=\"创建容器\"> 创建容器</h2>\n<p>以部署nginx为例</p>\n<h3 id=\"在master机器上操作\"> 在master机器上操作</h3>\n<p><strong>创建一个文件夹，存放yml配置</strong></p>\n<div><pre><code><span>mkdir</span> -p /usr/local/k8s/nginx <span>&amp;&amp;</span> <span>cd</span> /usr/local/k8s/nginx\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>创建nginx-deployment.yml配置</strong></p>\n<div><pre><code><span>vim</span> nginx-deployment.yml\n</code></pre>\n<div><span>1</span><br></div></div><p>内容如下</p>\n<p><strong>注意：</strong> <code>extensions/v1beta1</code> 不再支持部署 <code>Deployment</code>，并且修改了少量命令</p>\n<p><em>k8s v1.16.0 之前的版本</em></p>\n<div><pre><code><span># Api版本号</span>\n<span>apiVersion</span><span>:</span> extensions/v1beta1\n<span># 类型，如：Pod/ReplicationController/Deployment/Service/Ingress</span>\n<span>kind</span><span>:</span> Deployment\n<span># 元数据</span>\n<span>metadata</span><span>:</span>\n  <span># kind的名称</span>\n  <span>name</span><span>:</span> nginx<span>-</span>app\n<span>spec</span><span>:</span>\n  <span># 部署实例数量</span>\n  <span>replicas</span><span>:</span> <span>2</span>\n  <span>template</span><span>:</span>\n    <span>metadata</span><span>:</span>\n      <span>labels</span><span>:</span>\n        <span># 容器标签的名字</span>\n        <span>name</span><span>:</span> nginx\n    <span>spec</span><span>:</span>\n      <span># 配置容器</span>\n      <span>containers</span><span>:</span>\n      <span># 容器名称</span>\n      <span>-</span> <span>name</span><span>:</span> nginx\n        <span># 容器镜像，必须指定镜像版本，不能省略，不能为lastest</span>\n        <span>image</span><span>:</span> nginx<span>:</span><span>1.17</span>\n        <span># 镜像拉取策略：只有镜像不存在时才拉取</span>\n        <span>imagePullPolicy</span><span>:</span> IfNotPresent\n        <span># 暴露端口</span>\n        <span>ports</span><span>:</span> \n        <span># pod 端口</span>\n        <span>-</span> <span>containerPort</span><span>:</span> <span>80</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p><em>k8s v1.16之后的版本</em></p>\n<div><pre><code><span># API 版本号：由 extensions/v1beta1 修改为 apps/v1</span>\n<span>apiVersion</span><span>:</span> apps/v1\n<span>kind</span><span>:</span> Deployment\n<span>metadata</span><span>:</span>\n  <span>name</span><span>:</span> nginx<span>-</span>app\n<span>spec</span><span>:</span>\n  <span># 增加了选择器配置</span>\n  <span>selector</span><span>:</span>\n    <span>matchLabels</span><span>:</span>\n      <span>app</span><span>:</span> nginx\n  <span>replicas</span><span>:</span> <span>2</span>\n  <span>template</span><span>:</span>\n    <span>metadata</span><span>:</span>\n      <span>labels</span><span>:</span>\n        <span># 设置标签由 name 修改为 app</span>\n        <span>app</span><span>:</span> nginx\n    <span>spec</span><span>:</span>\n      <span>containers</span><span>:</span>\n      <span>-</span> <span>name</span><span>:</span> nginx\n        <span>image</span><span>:</span> nginx\n        <span>ports</span><span>:</span>\n        <span>-</span> <span>containerPort</span><span>:</span> <span>80</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><strong>部署</strong></p>\n<div><pre><code>kubectl create -f nginx-deployment.yml\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229203359-740611.png\" alt=\"image-20200229115621381\" /></p>\n<p><strong>查看容器</strong></p>\n<div><pre><code>kubectl get pods\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229115737-467172.png\" alt=\"image-20200229115736891\" /></p>\n<p><strong>查看部署</strong></p>\n<div><pre><code>kubectl get deployments\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229115825-952502.png\" alt=\"image-20200229115824642\" /></p>\n<p><strong>删除部署</strong></p>\n<div><pre><code>kubectl delete -f nginx-deployment.yml\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229120359-704061.png\" alt=\"image-20200229120359266\" /></p>\n<h2 id=\"发布service\"> 发布service</h2>\n<p>创建nginx-service.yml</p>\n<p>(也可以在nginx-deployment.yml文件后面追加配置)</p>\n<div><pre><code><span>vim</span> nginx-service.yml\n</code></pre>\n<div><span>1</span><br></div></div><p>添加内容</p>\n<div><pre><code><span># k8s v1.16.0 之前</span>\n<span># API 版本号</span>\napiVersion: v1\n<span># 类型，如：Pod/ReplicationController/Deployment/Service/Ingress</span>\nkind: Service\n<span># 元数据</span>\nmetadata:\n  <span># Kind 的名称</span>\n  name: nginx-http\nspec:\n  <span># 暴露端口</span>\n  ports:\n    <span>## Service 暴露的端口</span>\n    - port: <span>80</span>\n      <span>## Pod 上的端口，这里是将 Service 暴露的端口转发到 Pod 端口上</span>\n      targetPort: <span>80</span>\n  <span># 类型</span>\n  type: LoadBalancer\n  <span># 标签选择器</span>\n  selector:\n    <span># 需要和上面部署的 Deployment 标签名对应</span>\n    name: nginx\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>*k8s v1.16.0 之前后</p>\n<div><pre><code><span># k8s v1.16.0 之后</span>\n<span>apiVersion</span><span>:</span> v1\n<span>kind</span><span>:</span> Service\n<span>metadata</span><span>:</span>\n  <span>name</span><span>:</span> nginx<span>-</span>http\n<span>spec</span><span>:</span>\n  <span>ports</span><span>:</span>\n    <span>-</span> <span>port</span><span>:</span> <span>80</span>\n      <span>targetPort</span><span>:</span> <span>80</span>\n  <span>type</span><span>:</span> LoadBalancer\n  <span>selector</span><span>:</span>\n    <span># 标签选择器由 name 修改为 app</span>\n    <span>app</span><span>:</span> nginx\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>部署</strong></p>\n<div><pre><code>kubectl create -f nginx-deployment.yml\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>kubectl create -f nginx-service.yml\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229203407-929884.png\" alt=\"image-20200229121107682\" /></p>\n<p><strong>查看服务</strong></p>\n<div><pre><code>kubectl get <span>service</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229121153-682260.png\" alt=\"image-20200229121152885\" /></p>\n<p><strong>浏览器中访问</strong></p>\n<p>主机ip:30878</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229121356-855491.png\" alt=\"image-20200229121355995\" /></p>\n<p><strong>删除service</strong></p>\n<div><pre><code>kubectl delete -f nginx-service.yml\n</code></pre>\n<div><span>1</span><br></div></div>",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229203359-740611.png",
      "date_published": "2020-02-29T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Kubernetes 修改默认的端口范围",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-04-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%8C%83%E5%9B%B4/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-04-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%8C%83%E5%9B%B4/",
      "content_html": "<h1 id=\"kubernetes-修改默认的端口范围\"> Kubernetes 修改默认的端口范围</h1>\n<p>Kubernetes 服务的 NodePort 默认端口范围是 30000-32767，在某些场合下，这个限制不太适用，我们可以自定义它的端口范围，操作步骤如下：</p>\n<p>编辑 <code>vi /etc/kubernetes/manifests/kube-apiserver.yaml</code> 配置文件，增加配置 <code>--service-node-port-range=2-65535</code></p>\n<div><pre><code><span>apiVersion</span><span>:</span> v1\n<span>kind</span><span>:</span> Pod\n<span>metadata</span><span>:</span>\n  <span>creationTimestamp</span><span>:</span> <span>null</span>\n  <span>labels</span><span>:</span>\n    <span>component</span><span>:</span> kube<span>-</span>apiserver\n    <span>tier</span><span>:</span> control<span>-</span>plane\n  <span>name</span><span>:</span> kube<span>-</span>apiserver\n  <span>namespace</span><span>:</span> kube<span>-</span>system\n<span>spec</span><span>:</span>\n  <span>containers</span><span>:</span>\n  <span>-</span> <span>command</span><span>:</span>\n    <span>-</span> kube<span>-</span>apiserver\n    <span># 在这里增加配置即可</span>\n    <span>-</span> <span>-</span><span>-</span>service<span>-</span>node<span>-</span>port<span>-</span>range=2<span>-</span><span>65535</span>\n    <span>-</span> <span>-</span><span>-</span>advertise<span>-</span>address=192.168.141.150\n    <span>-</span> <span>-</span><span>-</span>allow<span>-</span>privileged=true\n    <span>-</span> <span>-</span><span>-</span>authorization<span>-</span>mode=Node<span>,</span>RBAC\n    <span>-</span> <span>-</span><span>-</span>client<span>-</span>ca<span>-</span>file=/etc/kubernetes/pki/ca.crt\n    <span>-</span> <span>-</span><span>-</span>enable<span>-</span>admission<span>-</span>plugins=NodeRestriction\n    <span>-</span> <span>-</span><span>-</span>enable<span>-</span>bootstrap<span>-</span>token<span>-</span>auth=true\n    <span>-</span> <span>-</span><span>-</span>etcd<span>-</span>cafile=/etc/kubernetes/pki/etcd/ca.crt\n    <span>-</span> <span>-</span><span>-</span>etcd<span>-</span>certfile=/etc/kubernetes/pki/apiserver<span>-</span>etcd<span>-</span>client.crt\n// 以下配置省略<span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>使用 <code>docker ps</code> 命令找到 <code>kube-apiserver</code> 容器，再使用 <code>docker restart</code> 即可生效。</p>\n",
      "date_published": "2020-02-29T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Ingress 统一访问入口",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-06-Ingress%20%E7%BB%9F%E4%B8%80%E8%AE%BF%E9%97%AE%E5%85%A5%E5%8F%A3/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-06-Ingress%20%E7%BB%9F%E4%B8%80%E8%AE%BF%E9%97%AE%E5%85%A5%E5%8F%A3/",
      "content_html": "<h1 id=\"ingress-统一访问入口\"> Ingress 统一访问入口</h1>\n<h2 id=\"什么是-ingress\"> 什么是 Ingress</h2>\n<p>通常情况下，Service 和 Pod 的 IP 仅可在集群内部访问。集群外部的请求需要通过负载均衡转发到 Service 在 Node 上暴露的 NodePort 上，然后再由 kube-proxy 通过边缘路由器 (edge router) 将其转发给相关的 Pod 或者丢弃。而 Ingress 就是为进入集群的请求提供路由规则的集合</p>\n<p>Ingress 可以给 Service 提供集群外部访问的 URL、负载均衡、SSL 终止、HTTP 路由等。为了配置这些 Ingress 规则，集群管理员需要部署一个 Ingress Controller，它监听 Ingress 和 Service 的变化，并根据规则配置负载均衡并提供访问入口。</p>\n<h2 id=\"使用-nginx-ingress-controller\"> 使用 Nginx Ingress Controller</h2>\n<p>本次实践的主要目的就是将入口统一，不再通过 LoadBalancer 等方式将端口暴露出来，而是使用 Ingress 提供的反向代理负载均衡功能作为我们的唯一入口。通过以下步骤操作仔细体会。</p>\n<blockquote>\n<p><strong>注意：</strong> 下面包含资源配置的步骤都是自行创建 YAML 配置文件通过 <code>kubectl create -f</code> 和 <code>kubectl delete -f</code> 部署和删除</p>\n</blockquote>\n<h3 id=\"部署-tomcat\"> 部署 Tomcat</h3>\n<p>部署 Tomcat 但仅允许在内网访问，我们要通过 Ingress 提供的反向代理功能路由到 Tomcat 之上</p>\n<div><pre><code><span>apiVersion</span><span>:</span> extensions/v1beta1\n<span>kind</span><span>:</span> Deployment\n<span>metadata</span><span>:</span>\n  <span>name</span><span>:</span> tomcat<span>-</span>app\n<span>spec</span><span>:</span>\n  <span>replicas</span><span>:</span> <span>1</span>\n  <span>template</span><span>:</span>\n    <span>metadata</span><span>:</span>\n      <span>labels</span><span>:</span>\n        <span>name</span><span>:</span> tomcat\n    <span>spec</span><span>:</span>\n      <span>containers</span><span>:</span>\n      <span>-</span> <span>name</span><span>:</span> tomcat\n        <span>image</span><span>:</span> tomcat\n        <span>ports</span><span>:</span>\n        <span>-</span> <span>containerPort</span><span>:</span> <span>8080</span>\n<span>---</span>\n<span>apiVersion</span><span>:</span> v1\n<span>kind</span><span>:</span> Service\n<span>metadata</span><span>:</span>\n  <span>name</span><span>:</span> tomcat<span>-</span>http\n<span>spec</span><span>:</span>\n  <span>ports</span><span>:</span>\n    <span>-</span> <span>port</span><span>:</span> <span>8080</span>\n      <span>targetPort</span><span>:</span> <span>8080</span>\n  <span># ClusterIP, NodePort, LoadBalancer</span>\n  <span>type</span><span>:</span> ClusterIP\n  <span>selector</span><span>:</span>\n    <span>name</span><span>:</span> tomcat\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p><strong>部署</strong></p>\n<div><pre><code>kubectl apply -f tomcat.yml\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"安装-nginx-ingress-controller\"> 安装 Nginx Ingress Controller</h3>\n<p>Ingress Controller 有许多种，我们选择最熟悉的 Nginx 来处理请求，其它可以参考 <a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></p>\n<p><strong>创建一个ingress文件夹</strong></p>\n<div><pre><code><span>mkdir</span> -p /usr/local/k8s/ingress <span>&amp;&amp;</span> <span>cd</span> /usr/local/k8s/ingress\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>下载 Nginx Ingress Controller 配置文件</strong></p>\n<div><pre><code><span>wget</span> https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/mandatory.yaml\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229204445-983627.png\" alt=\"image-20200229123213081\" /></p>\n<p><strong>修改配置文件，找到配置如下位置 在下面增加一句 <code>hostNetwork: true</code></strong></p>\n<div><pre><code><span>vim</span> mandatory.yaml\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229204439-413345.png\" alt=\"image-20200229124628506\" /></p>\n<p><strong>安装</strong></p>\n<div><pre><code>kubectl apply -f mandatory.yaml\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229124838-452996.png\" alt=\"image-20200229124707856\" /></p>\n<p><strong>部署 Ingress</strong></p>\n<p>新建一个ingress-deployment.yml</p>\n<div><pre><code><span>vim</span> ingress-deployment.yml\n</code></pre>\n<div><span>1</span><br></div></div><p>内容如下</p>\n<div><pre><code><span>apiVersion</span><span>:</span> networking.k8s.io/v1beta1\n<span>kind</span><span>:</span> Ingress\n<span>metadata</span><span>:</span>\n  <span>name</span><span>:</span> nginx<span>-</span>web\n  <span>annotations</span><span>:</span>\n    <span># 指定 Ingress Controller 的类型</span>\n    <span>kubernetes.io/ingress.class</span><span>:</span> <span>\"nginx\"</span>\n    <span># 指定我们的 rules 的 path 可以使用正则表达式</span>\n    <span>nginx.ingress.kubernetes.io/use-regex</span><span>:</span> <span>\"true\"</span>\n    <span># 连接超时时间，默认为 5s</span>\n    <span>nginx.ingress.kubernetes.io/proxy-connect-timeout</span><span>:</span> <span>\"600\"</span>\n    <span># 后端服务器回转数据超时时间，默认为 60s</span>\n    <span>nginx.ingress.kubernetes.io/proxy-send-timeout</span><span>:</span> <span>\"600\"</span>\n    <span># 后端服务器响应超时时间，默认为 60s</span>\n    <span>nginx.ingress.kubernetes.io/proxy-read-timeout</span><span>:</span> <span>\"600\"</span>\n    <span># 客户端上传文件，最大大小，默认为 20m</span>\n    <span>nginx.ingress.kubernetes.io/proxy-body-size</span><span>:</span> <span>\"10m\"</span>\n    <span># URL 重写</span>\n    <span>nginx.ingress.kubernetes.io/rewrite-target</span><span>:</span> /\n<span>spec</span><span>:</span>\n  <span># 路由规则</span>\n  <span>rules</span><span>:</span>\n  <span># 主机名，只能是域名，修改为你自己的</span>\n  <span>-</span> <span>host</span><span>:</span> k8s.test.com\n    <span>http</span><span>:</span>\n      <span>paths</span><span>:</span>\n      <span>-</span> <span>path</span><span>:</span>\n        <span>backend</span><span>:</span>\n          <span># 后台部署的 Service Name，与上面部署的 Tomcat 对应</span>\n          <span>serviceName</span><span>:</span> tomcat<span>-</span>http\n          <span># 后台部署的 Service Port，与上面部署的 Tomcat 对应</span>\n          <span>servicePort</span><span>:</span> <span>8080</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p><strong>部署</strong></p>\n<div><pre><code>kubectl apply -f ingress-deployment.yml\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229204452-955347.png\" alt=\"image-20200229130255313\" /></p>\n<p><strong>查看 Nginx Ingress Controller</strong></p>\n<div><pre><code>kubectl get pods -n ingress-nginx -o wide\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229130715-301394.png\" alt=\"image-20200229130715233\" /></p>\n<p><strong>查看 Ingress</strong></p>\n<div><pre><code>kubectl get ingress\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229130757-707833.png\" alt=\"image-20200229130756480\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200229204445-983627.png",
      "date_published": "2020-02-29T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "kubernetes常用命令",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-05-kubernetes%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-05-kubernetes%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
      "content_html": "<h1 id=\"kubernetes常用命令\"> kubernetes常用命令</h1>\n<p><strong>查看组件状态</strong></p>\n<div><pre><code>kubectl get cs\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>查看环境信息</strong></p>\n<div><pre><code>kubectl cluster-info\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>查看节点</strong></p>\n<div><pre><code>kubectl get nodes\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>查看命名空间</strong></p>\n<div><pre><code>kubectl get namespace\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>创建命名空间</strong></p>\n<div><pre><code><span>apiVersion</span><span>:</span> v1\n<span>kind</span><span>:</span> Namespace\n<span>metadata</span><span>:</span>\n  <span>name</span><span>:</span> development\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>运行容器</strong></p>\n<div><pre><code>kubectl run nginx --image<span>=</span>nginx --replicas<span>=</span><span>2</span> --port<span>=</span><span>80</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>--image=nginx 指定镜像为nginx</p>\n<p>--replicas=2 创建实例的数量为2</p>\n<p>--port=80 指定容器端口为80</p>\n<p><strong>配置方式运行容器</strong></p>\n<div><pre><code>kubectl create -f xxx.yml\n</code></pre>\n<div><span>1</span><br></div></div><p>或</p>\n<div><pre><code>kubectl apply -f xxx.yml\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>暴露服务</strong></p>\n<div><pre><code>kubectl expose deployment nginx --port<span>=</span><span>80</span> --type<span>=</span>LoadBalancer\n</code></pre>\n<div><span>1</span><br></div></div><p>--port=80 容器的端口为80</p>\n<p>--type=LoadBalancer 类型为负载均衡</p>\n<p><strong>查看容器</strong></p>\n<div><pre><code>kubectl get pods -o wide\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>查看部署</strong></p>\n<div><pre><code>kubectl get deployment -o wide\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>查看服务</strong></p>\n<div><pre><code>kubectl get <span>service</span> -o wide\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>查看ingress</strong></p>\n<div><pre><code>kubectl get ingress\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>查看持久卷</strong></p>\n<div><pre><code>kubectl get <span>pv</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>查看持久卷消费者</strong></p>\n<div><pre><code>kubectl get pvc\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>查看 ConfigMap</strong></p>\n<div><pre><code>kubectl get cm <span>&lt;</span>ConfigMap Name<span>></span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>修改 ConfigMap</strong></p>\n<div><pre><code>kubectl edit cm <span>&lt;</span>ConfigMap Name<span>></span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>查看详情</strong></p>\n<div><pre><code>kubectl describe pod pod名字\nkubectl describe deployment deployment名字\nkubectl describe <span>service</span> service名字\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>查看日志</strong></p>\n<div><pre><code>kubectl logs -f pod名字\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>删除容器</strong></p>\n<div><pre><code>kubectl delete deploy名字\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>配置方式删除容器</strong></p>\n<div><pre><code>kubectl delete -f xxx.yml\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>删除服务</strong></p>\n<div><pre><code>kubectl delete service名字\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>查看kube system信息</strong></p>\n<div><pre><code>kubectl get pods -n kube-system -o wide\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2020-02-29T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Kubernetes 集群卸载清理",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-07-Kubernetes%20%E9%9B%86%E7%BE%A4%E5%8D%B8%E8%BD%BD%E6%B8%85%E7%90%86/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-07-Kubernetes%20%E9%9B%86%E7%BE%A4%E5%8D%B8%E8%BD%BD%E6%B8%85%E7%90%86/",
      "content_html": "<h1 id=\"kubernetes-集群卸载清理\"> Kubernetes 集群卸载清理</h1>\n<div><pre><code>kubeadm reset -f\nmodprobe -r ipip\nlsmod\n<span>rm</span> -rf ~/.kube/\n<span>rm</span> -rf /etc/kubernetes/\n<span>rm</span> -rf /etc/systemd/system/kubelet.service.d\n<span>rm</span> -rf /etc/systemd/system/kubelet.service\n<span>rm</span> -rf /usr/bin/kube*\n<span>rm</span> -rf /etc/cni\n<span>rm</span> -rf /opt/cni\n<span>rm</span> -rf /var/lib/etcd\n<span>rm</span> -rf /var/etcd\nyum clean all\nyum remove kube*\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Kubernetes - 从私服中拉取镜像",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-08-%E4%BB%8E%E7%A7%81%E6%9C%8D%E4%B8%AD%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-08-%E4%BB%8E%E7%A7%81%E6%9C%8D%E4%B8%AD%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F/",
      "content_html": "<h1 id=\"kubernetes-从私服中拉取镜像\"> Kubernetes - 从私服中拉取镜像</h1>\n<h2 id=\"docker-私有仓库地址配置\"> docker 私有仓库地址配置</h2>\n<p>修改docker的daemon.json</p>\n<div><pre><code><span>vim</span> /etc/docker/daemon.json \n</code></pre>\n<div><span>1</span><br></div></div><p>加入如下节点</p>\n<div><pre><code><span>\"insecure-registries\"</span>:<span>[</span><span>\"私服ip:端口\"</span><span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>完整配置如下</p>\n<div><pre><code><span>{</span>\n    <span>\"registry-mirrors\"</span><span>:</span> <span>[</span><span>\"http://f1361db2.m.daocloud.io\"</span><span>]</span>,\n    <span>\"insecure-registries\"</span>:<span>[</span><span>\"172.10.10.10:5000\"</span><span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>配置完成后重启docker</p>\n<div><pre><code>systemctl daemon-reload\nsystemctl restart docker \n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"登录docker\"> 登录Docker</h2>\n<div><pre><code>docker login --username<span>=</span>镜像仓库帐号 <span>172.10</span>.10.10:5000\n</code></pre>\n<div><span>1</span><br></div></div><p>输入密码完成登录</p>\n<p>查看 ~/.docker/config.json</p>\n<div><pre><code><span>cat</span> ~/.docker/config.json\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"创建一个secret来保存你的验证口令\"> 创建一个Secret来保存你的验证口令</h2>\n<p>创建一个名为dockercfg-192的secret</p>\n<div><pre><code>kubectl create secret docker<span>-</span>registry dockercfg<span>-</span><span>192</span> <span>--</span>docker<span>-</span>server<span>=</span><span>172.10</span><span>.10</span><span>.10</span><span>:</span><span>5000</span> <span>--</span>docker<span>-</span>username<span>=</span>username <span>--</span>docker<span>-</span>password<span>=</span>password <span>--</span>docker<span>-</span>email<span>=</span>m<span>@m</span><span>.</span>com<span>.</span>cn\n</code></pre>\n<div><span>1</span><br></div></div><p>--docker-server 私有仓库</p>\n<p>--docker-username 仓库 用户名</p>\n<p>--docker-password 仓库 密码</p>\n<p>--docker-email 仓库 邮箱</p>\n<h2 id=\"查看创建的dockercfg-192\"> 查看创建的dockercfg-192</h2>\n<div><pre><code>kubectl <span>get</span> secret <span>|</span>grep dockercfg<span>-</span><span>192</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"创建一个deployment来自私库的镜像\"> 创建一个Deployment来自私库的镜像</h2>\n<p>创建资源文件k8s-nginx.yml</p>\n<div><pre><code>vim k8s<span>-</span>nginx.yml\n</code></pre>\n<div><span>1</span><br></div></div><p>内容如下</p>\n<div><pre><code><span>apiVersion</span><span>:</span> extensions/v1beta1\n<span>kind</span><span>:</span> Deployment\n<span>metadata</span><span>:</span>\n  <span>name</span><span>:</span> nginx\n<span>spec</span><span>:</span>\n  <span>replicas</span><span>:</span> <span>1</span>\n  <span>template</span><span>:</span>\n    <span>metadata</span><span>:</span>\n      <span>labels</span><span>:</span>\n        <span>name</span><span>:</span> nginx\n    <span>spec</span><span>:</span>\n      <span>containers</span><span>:</span>\n      <span>-</span> <span>name</span><span>:</span> nginx\n        <span>image</span><span>:</span> registry.cn<span>-</span>shenzhen.aliyuncs.com/alanlee2020/demo<span>-</span>nginx<span>:</span>1.0.0\n        <span>imagePullPolicy</span><span>:</span> IfNotPresent\n        <span>ports</span><span>:</span> \n        <span>-</span> <span>containerPort</span><span>:</span> <span>80</span>\n      <span># imagePullSecrets 告诉 Kubernets 应该从名为 dockercfg-192 的 Secret 里获取验证口令</span>\n      <span>imagePullSecrets</span><span>:</span>\n      <span>-</span> <span>name</span><span>:</span> dockercfg<span>-</span><span>192</span> \n<span>---</span>\n\n<span>apiVersion</span><span>:</span> v1\n<span>kind</span><span>:</span> Service\n<span>metadata</span><span>:</span>\n  <span>name</span><span>:</span> nginx<span>-</span>http\n<span>spec</span><span>:</span>\n  <span>ports</span><span>:</span>\n    <span>-</span> <span>port</span><span>:</span> <span>80</span>\n      <span>targetPort</span><span>:</span> <span>80</span>\n      <span>nodePort</span><span>:</span> <span>30001</span>\n      <span>protocol</span><span>:</span> TCP\n  <span>type</span><span>:</span> NodePort\n  <span>selector</span><span>:</span>\n    <span>name</span><span>:</span> nginx\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h2 id=\"部署service\"> 部署service</h2>\n<div><pre><code>kubectl apply -f k8s-nginx.yml\n</code></pre>\n<div><span>1</span><br></div></div><p>查看部署</p>\n<div><pre><code>kubectl get pods -o wide\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Kubernetes 指定外部访问service的端口",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-09-%E6%8C%87%E5%AE%9A%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AEservice%E7%9A%84%E7%AB%AF%E5%8F%A3/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-09-%E6%8C%87%E5%AE%9A%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AEservice%E7%9A%84%E7%AB%AF%E5%8F%A3/",
      "content_html": "<h1 id=\"kubernetes-指定外部访问service的端口\"> Kubernetes 指定外部访问service的端口</h1>\n<h2 id=\"集群外部方式访问-nodeport\"> 集群外部方式访问：NodePort</h2>\n<p>NodePort在kubenretes里是一个早期广泛应用的服务暴露方式。Kubernetes中的service默认情况下都是使用的ClusterIP这种类型，这样的service会产生一个ClusterIP，这个IP只能在集群内部访问，要想让外部能够直接访问service，需要将service type修改为 nodePort。将service监听端口映射到node节点。</p>\n<p><strong>配置</strong></p>\n<p>在Service的spec节点中</p>\n<p>指定类型：type NodePort</p>\n<p>指定端口：nodePort: 30001</p>\n<p>指定协议：protocol: TCP</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200303105547-576040.png\" alt=\"：\" /></p>\n<p>完整Service的配置如下：</p>\n<div><pre><code><span>apiVersion</span><span>:</span> v1\n<span>kind</span><span>:</span> Service\n<span>metadata</span><span>:</span>\n  <span>name</span><span>:</span> panda<span>-</span>config<span>-</span>http\n<span>spec</span><span>:</span>\n  <span>ports</span><span>:</span>\n    <span>-</span> <span>port</span><span>:</span> <span>8888</span>\n      <span>targetPort</span><span>:</span> <span>8888</span>\n      <span>nodePort</span><span>:</span> <span>30001</span>\n      <span>protocol</span><span>:</span> TCP\n  <span>type</span><span>:</span> NodePort\n  <span>selector</span><span>:</span>\n    <span>name</span><span>:</span> panda<span>-</span>config\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>运行</strong></p>\n<div><pre><code>kubectl apply -f k8s-panda-config.yml\n</code></pre>\n<div><span>1</span><br></div></div><p>查看service</p>\n<div><pre><code>kubectl get <span>service</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200303110206-20539.png\" alt=\"image-20200303110206020\" /></p>\n<p><strong>结果</strong></p>\n<p>浏览器访问</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200303110250-294715.png\" alt=\"image-20200303110250136\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200303105547-576040.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx的默认配置文件",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx02%20-%20Nginx%E7%9A%84%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx02%20-%20Nginx%E7%9A%84%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE/",
      "content_html": "<h1 id=\"nginx的默认配置文件\"> Nginx的默认配置文件</h1>\n<p>nginx.conf</p>\n<div><pre><code>\n#user  nobody;\nworker_processes  1;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n# load modules compiled as Dynamic Shared Object (DSO)\n#\n#dso {\n#    load ngx_http_fastcgi_module.so;\n#    load ngx_http_rewrite_module.so;\n#}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n\n    #access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    server {\n        listen       80;\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n\n        # deny access to .htaccess files, if Apache&#39;s document root\n        # concurs with nginx&#39;s one\n        #\n        #location ~ /\\.ht {\n        #    deny  all;\n        #}\n    }\n\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n\n    # HTTPS server\n    #\n    #server {\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br></div></div><p>删除注释的nginx.conf</p>\n<div><pre><code>\nuser  root;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n    }\n\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx实现虚拟主机",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx03%20-%20Nginx%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx03%20-%20Nginx%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/",
      "content_html": "<h1 id=\"nginx实现虚拟主机\"> Nginx实现虚拟主机</h1>\n<p>通过nginx可以实现虚拟主机的配置，nginx支持三种类型的虚拟主机配置</p>\n<ul>\n<li>\n<p>基于ip的虚拟主机， （一块主机绑定多个ip地址）</p>\n</li>\n<li>\n<p>基于域名的虚拟主机（servername）</p>\n</li>\n<li>\n<p>基于端口的虚拟主机（listen如果不写ip端口模式）</p>\n</li>\n</ul>\n<h2 id=\"基于ip的虚拟主机\"> 基于ip的虚拟主机</h2>\n<h3 id=\"编辑配置文件\"> 编辑配置文件</h3>\n<div><pre><code>\nuser  root;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n    }\n\t\n\t# 基于ip的虚拟主机 - ip1\n\tserver {\n\t\tlisten 182.61.200.6:80;\n\t\tserver_name www.vhost-ip1.com;\n\t\t\n\t\tlocation / {\n\t\t    root html;\n\t\t\tindex vhost-ip1/index.html;\n\t\t}\n\n    }\n\t\n\t# 基于ip的虚拟主机 - ip2\n\tserver {\n\t\tlisten 192.168.1.9:80;\n\t\tserver_name www.vhost-ip2.com;\n\t\t\n\t\tlocation / {\n\t\t    root html;\n\t\t\tindex vhost-ip2/index.html;\n\t\t}\n\n    }\n\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><h3 id=\"创建网站目录及文件\"> 创建网站目录及文件</h3>\n<p>在nginx的目录下创建2个网站目录</p>\n<p>创建目录</p>\n<div><pre><code><span>mkdir</span> vhost-ip1\n</code></pre>\n<div><span>1</span><br></div></div><p>编写一个html文件</p>\n<div><pre><code><span>vim</span> index.html\n</code></pre>\n<div><span>1</span><br></div></div><p>内容如下</p>\n<div><pre><code>测试搭建虚拟主机  ip1\n</code></pre>\n<div><span>1</span><br></div></div><p>复制该文件夹</p>\n<div><pre><code><span>cp</span> -rf vhost-ip1 vhost-ip2\n</code></pre>\n<div><span>1</span><br></div></div><p>将vhost-ip2目录下的index.html的内容改为下面的内容</p>\n<div><pre><code>测试搭建虚拟主机  ip2\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"基于域名的虚拟主机\"> 基于域名的虚拟主机</h2>\n<h3 id=\"编辑配置文件-2\"> 编辑配置文件</h3>\n<div><pre><code>\nuser  root;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n    }\n\t\n\t# 基于域名的虚拟主机 - ip1\n\tserver {\n\t\tlisten 80;\n\t\tserver_name v1.vhost.com;\n\t\t\n\t\tlocation / {\n\t\t    root html;\n\t\t\tindex vhost-ip1/index.html;\n\t\t}\n\n    }\n\t\n\t# 基于域名的虚拟主机 - ip2\n\tserver {\n\t\tlisten 80;\n\t\tserver_name v2.vhost.com;\n\t\t\n\t\tlocation / {\n\t\t    root html;\n\t\t\tindex vhost-ip2/index.html;\n\t\t}\n\n    }\n\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><h3 id=\"重新加载配置\"> 重新加载配置</h3>\n<div><pre><code>sbin/nginx -s reload\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"配置hosts\"> 配置hosts</h3>\n<p>配置hosts</p>\n<div><pre><code>vim /etc/hosts\n</code></pre>\n<div><span>1</span><br></div></div><p>添加内容</p>\n<div><pre><code>127.0.0.1 v1.vhost.com\n127.0.0.1 v2.vhost.com\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200424133724032.png\" alt=\"image-20200424133724032\" /></p>\n<h3 id=\"访问测试\"> 访问测试</h3>\n<div><pre><code><span>curl</span> v1.vhost.com\n\n<span>curl</span> v2.vhost.com\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"基于端口的虚拟主机\"> 基于端口的虚拟主机</h2>\n<h3 id=\"编辑配置文件-3\"> 编辑配置文件</h3>\n<div><pre><code>\nuser  root;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n    }\n\t\n\t# 基于端口的虚拟主机 - port1\n\tserver {\n\t\tlisten 81;\n\t\tserver_name localhost;\n\t\t\n\t\tlocation / {\n\t\t    root html;\n\t\t\tindex vhost-ip1/index.html;\n\t\t}\n\n    }\n\t\n\t# 基于端口的虚拟主机 - port2\n\tserver {\n\t\tlisten 82;\n\t\tserver_name localhost;\n\t\t\n\t\tlocation / {\n\t\t    root html;\n\t\t\tindex vhost-ip2/index.html;\n\t\t}\n\n    }\n\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><h3 id=\"重新加载配置-2\"> 重新加载配置</h3>\n<div><pre><code>sbin/nginx -s reload\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"访问测试-2\"> 访问测试</h3>\n<h4 id=\"访问81端口\"> 访问81端口</h4>\n<p>浏览器访问http://192.168.1.7:81</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/20200424135035-175355.png\" alt=\"image-20200424135033003\" /></p>\n<h4 id=\"访问82端口\"> 访问82端口</h4>\n<p>浏览器访问http://192.168.1.7:82</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200424134908205.png\" alt=\"image-20200424134908205\" /></p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200424133724032.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "什么是代理服务器？",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx04%20-%20Nginx%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx04%20-%20Nginx%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/",
      "content_html": "<h2 id=\"什么是代理服务器\"> 什么是代理服务器？</h2>\n<p>代理服务器，客户机在发送请求时，不会直接发送给目的主机，而是先发送给代理服务器，代理服务接受客户机请求之后，再向主机发出，并接收目的主机返回的数据，存放在代理服务器的硬盘中，再发送给客户机。</p>\n<p><img src=\"https://funtl.com/assets/Lusifer2018080517010001.png\" alt=\"img\" /></p>\n<h2 id=\"为什么要使用代理服务器\"> 为什么要使用代理服务器？</h2>\n<h3 id=\"提高访问速度\"> 提高访问速度</h3>\n<p>由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到了缓存的作用，尤其对于热门站点能明显提高请求速度。</p>\n<h3 id=\"防火墙作用\"> 防火墙作用</h3>\n<p>由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可在代理服务器上设限，过滤某些不安全信息。</p>\n<h3 id=\"通过代理服务器访问不能访问的目标站点\"> 通过代理服务器访问不能访问的目标站点</h3>\n<p>互联网上有许多开放的代理服务器，客户机在访问受限时，可通过不受限的代理服务器访问目标站点，通俗说，我们使用的翻墙浏览器就是利用了代理服务器，虽然不能出国，但也可直接访问外网。</p>\n<h2 id=\"什么是正向代理\"> 什么是正向代理？</h2>\n<p>正向代理，架设在客户机与目标主机之间，只用于代理内部网络对 Internet 的连接请求，客户机必须指定代理服务器,并将本来要直接发送到 Web 服务器上的 Http 请求发送到代理服务器中。</p>\n<p><img src=\"https://funtl.com/assets/Lusifer2018080517010002.png\" alt=\"img\" /></p>\n<h2 id=\"什么是反向代理\"> 什么是反向代理？</h2>\n<p>反向代理服务器架设在服务器端，通过缓冲经常被请求的页面来缓解服务器的工作量，将客户机请求转发给内部网络上的目标服务器；并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器与目标主机一起对外表现为一个服务器。</p>\n<p><img src=\"https://funtl.com/assets/Lusifer2018080517010003.png\" alt=\"img\" /></p>\n<h2 id=\"反向代理有哪些主要应用\"> 反向代理有哪些主要应用？</h2>\n<p>现在许多大型 web 网站都用到反向代理。除了可以防止外网对内网服务器的恶性攻击、缓存以减少服务器的压力和访问安全控制之外，还可以进行负载均衡，将用户请求分配给多个服务器。</p>\n<h2 id=\"使用-nginx-反向代理-tomcat\"> 使用 Nginx 反向代理 Tomcat</h2>\n<h3 id=\"需求\"> 需求</h3>\n<ul>\n<li>两个 tomcat 服务通过 nginx 反向代理</li>\n<li>nginx 服务器：192.168.75.145:80</li>\n<li>tomcat1 服务器：192.168.75.145:9090</li>\n<li>tomcat2 服务器：192.168.75.145:9091</li>\n</ul>\n<h3 id=\"启动-tomcat-容器\"> 启动 Tomcat 容器</h3>\n<p>启动两个 Tomcat 容器，映射端口为 9090 和 9091，docker-compose.yml 如下：</p>\n<div><pre><code>version: &#39;3&#39;\nservices:\n  tomcat1:\n    image: tomcat\n    container_name: tomcat1\n    ports:\n      - 9090:8080\n\n  tomcat2:\n    image: tomcat\n    container_name: tomcat2\n    ports:\n      - 9091:8080\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"配置-nginx-反向代理\"> 配置 Nginx 反向代理</h3>\n<p>修改 <code>/usr/local/docker/nginx/conf</code> 目录下的 nginx.conf 配置文件：</p>\n<div><pre><code>worker_processes 1;\n\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n    include mime.types;\n    default_type application/octet-stream;\n    sendfile on;\n    keepalive_timeout 65;\n\n    upstream myapp {\n        server 192.168.75.145:9000;\n    }\n\n    server {\n        listen 80;\n        server_name 192.168.75.145;\n        location / {\n        \tproxy_pass http://myapp;\n        \tindex index.html index.htm;\n        }\n    }\n    \n    server {\n        listen 9000;\n        server_name 192.168.75.145;\n        location / {\n        \tproxy_pass http://myapp;\n        \tindex index.html index.htm;\n        }\n    }\n\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p><strong>注意：新版 Nginx 的 <code>upstream</code> 配置中的名称不可以有下划线(&quot;_&quot;)，否则会报 <code>400</code> 错误</strong></p>\n",
      "image": "https://funtl.com/assets/Lusifer2018080517010001.png",
      "date_published": "2020-02-28T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "安装Kubernetes Dashboard",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-10-%E5%AE%89%E8%A3%85Kubernetes%20Dashboard/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/kubernetes/k8s-10-%E5%AE%89%E8%A3%85Kubernetes%20Dashboard/",
      "content_html": "<h1 id=\"安装kubernetes-dashboard\"> 安装Kubernetes Dashboard</h1>\n<h2 id=\"安装\"> 安装</h2>\n<p>下载yaml文件</p>\n<div><pre><code><span>wget</span> https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta5/aio/deploy/recommended.yaml\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>如果访问不了该 yaml 文件，请使用下面的命令，效果是等价的</p>\n<div><pre><code><span>wget</span> https://kuboard.cn/install-script/k8s-dashboard/v2.0.0-beta5.yaml\n</code></pre>\n<div><span>1</span><br></div></div></blockquote>\n<p>修改文件内容，找到kind:Service节点下的spec节点，增加内容</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200303170948-763126.png\" alt=\"image-20200303164505363\" /></p>\n<blockquote>\n<p>或者直接复制下面的代码，我改好了的，暴露的端口为30001</p>\n<p>创建kubernetes-dashboard.yaml</p>\n<div><pre><code><span>vim</span> kubernetes-dashboard.yaml\n</code></pre>\n<div><span>1</span><br></div></div><p>粘贴下面的代码</p>\n<div><pre><code><span># Copyright 2017 The Kubernetes Authors.</span>\n<span>#</span>\n<span># Licensed under the Apache License, Version 2.0 (the \"License\");</span>\n<span># you may not use this file except in compliance with the License.</span>\n<span># You may obtain a copy of the License at</span>\n<span>#</span>\n<span>#     http://www.apache.org/licenses/LICENSE-2.0</span>\n<span>#</span>\n<span># Unless required by applicable law or agreed to in writing, software</span>\n<span># distributed under the License is distributed on an \"AS IS\" BASIS,</span>\n<span># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>\n<span># See the License for the specific language governing permissions and</span>\n<span># limitations under the License.</span>\n\n<span>apiVersion</span><span>:</span> v1\n<span>kind</span><span>:</span> Namespace\n<span>metadata</span><span>:</span>\n<span>name</span><span>:</span> kubernetes<span>-</span>dashboard\n\n<span>---</span>\n\n<span>apiVersion</span><span>:</span> v1\n<span>kind</span><span>:</span> ServiceAccount\n<span>metadata</span><span>:</span>\n<span>labels</span><span>:</span>\n <span>k8s-app</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>name</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>namespace</span><span>:</span> kubernetes<span>-</span>dashboard\n\n<span>---</span>\n\n<span>kind</span><span>:</span> Service\n<span>apiVersion</span><span>:</span> v1\n<span>metadata</span><span>:</span>\n<span>labels</span><span>:</span>\n <span>k8s-app</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>name</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>namespace</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>spec</span><span>:</span>\n<span>type</span><span>:</span> NodePort\n<span>ports</span><span>:</span>\n    <span>-</span> <span>port</span><span>:</span> <span>443</span>\n      <span>targetPort</span><span>:</span> <span>8443</span>\n      <span>nodePort</span><span>:</span> <span>30001</span>\n  <span>selector</span><span>:</span>\n    <span>k8s-app</span><span>:</span> kubernetes<span>-</span>dashboard\n\n<span>---</span>\n\n<span>apiVersion</span><span>:</span> v1\n<span>kind</span><span>:</span> Secret\n<span>metadata</span><span>:</span>\n  <span>labels</span><span>:</span>\n    <span>k8s-app</span><span>:</span> kubernetes<span>-</span>dashboard\n  <span>name</span><span>:</span> kubernetes<span>-</span>dashboard<span>-</span>certs\n  <span>namespace</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>type</span><span>:</span> Opaque\n\n<span>---</span>\n\n<span>apiVersion</span><span>:</span> v1\n<span>kind</span><span>:</span> Secret\n<span>metadata</span><span>:</span>\n  <span>labels</span><span>:</span>\n    <span>k8s-app</span><span>:</span> kubernetes<span>-</span>dashboard\n  <span>name</span><span>:</span> kubernetes<span>-</span>dashboard<span>-</span>csrf\n  <span>namespace</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>type</span><span>:</span> Opaque\n<span>data</span><span>:</span>\n  <span>csrf</span><span>:</span> <span>\"\"</span>\n\n<span>---</span>\n\n<span>apiVersion</span><span>:</span> v1\n<span>kind</span><span>:</span> Secret\n<span>metadata</span><span>:</span>\n  <span>labels</span><span>:</span>\n    <span>k8s-app</span><span>:</span> kubernetes<span>-</span>dashboard\n  <span>name</span><span>:</span> kubernetes<span>-</span>dashboard<span>-</span>key<span>-</span>holder\n  <span>namespace</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>type</span><span>:</span> Opaque\n\n<span>---</span>\n\n<span>kind</span><span>:</span> ConfigMap\n<span>apiVersion</span><span>:</span> v1\n<span>metadata</span><span>:</span>\n  <span>labels</span><span>:</span>\n    <span>k8s-app</span><span>:</span> kubernetes<span>-</span>dashboard\n  <span>name</span><span>:</span> kubernetes<span>-</span>dashboard<span>-</span>settings\n  <span>namespace</span><span>:</span> kubernetes<span>-</span>dashboard\n\n<span>---</span>\n\n<span>kind</span><span>:</span> Role\n<span>apiVersion</span><span>:</span> rbac.authorization.k8s.io/v1\n<span>metadata</span><span>:</span>\n  <span>labels</span><span>:</span>\n    <span>k8s-app</span><span>:</span> kubernetes<span>-</span>dashboard\n  <span>name</span><span>:</span> kubernetes<span>-</span>dashboard\n  <span>namespace</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>rules</span><span>:</span>\n  <span># Allow Dashboard to get, update and delete Dashboard exclusive secrets.</span>\n  <span>-</span> <span>apiGroups</span><span>:</span> <span>[</span><span>\"\"</span><span>]</span>\n    <span>resources</span><span>:</span> <span>[</span><span>\"secrets\"</span><span>]</span>\n    <span>resourceNames</span><span>:</span> <span>[</span><span>\"kubernetes-dashboard-key-holder\"</span><span>,</span> <span>\"kubernetes-dashboard-certs\"</span><span>,</span> <span>\"kubernetes-dashboard-csrf\"</span><span>]</span>\n    <span>verbs</span><span>:</span> <span>[</span><span>\"get\"</span><span>,</span> <span>\"update\"</span><span>,</span> <span>\"delete\"</span><span>]</span>\n    <span># Allow Dashboard to get and update 'kubernetes-dashboard-settings' config map.</span>\n  <span>-</span> <span>apiGroups</span><span>:</span> <span>[</span><span>\"\"</span><span>]</span>\n    <span>resources</span><span>:</span> <span>[</span><span>\"configmaps\"</span><span>]</span>\n    <span>resourceNames</span><span>:</span> <span>[</span><span>\"kubernetes-dashboard-settings\"</span><span>]</span>\n    <span>verbs</span><span>:</span> <span>[</span><span>\"get\"</span><span>,</span> <span>\"update\"</span><span>]</span>\n    <span># Allow Dashboard to get metrics.</span>\n  <span>-</span> <span>apiGroups</span><span>:</span> <span>[</span><span>\"\"</span><span>]</span>\n    <span>resources</span><span>:</span> <span>[</span><span>\"services\"</span><span>]</span>\n    <span>resourceNames</span><span>:</span> <span>[</span><span>\"heapster\"</span><span>,</span> <span>\"dashboard-metrics-scraper\"</span><span>]</span>\n    <span>verbs</span><span>:</span> <span>[</span><span>\"proxy\"</span><span>]</span>\n  <span>-</span> <span>apiGroups</span><span>:</span> <span>[</span><span>\"\"</span><span>]</span>\n    <span>resources</span><span>:</span> <span>[</span><span>\"services/proxy\"</span><span>]</span>\n    <span>resourceNames</span><span>:</span> <span>[</span><span>\"heapster\"</span><span>,</span> <span>\"http:heapster:\"</span><span>,</span> <span>\"https:heapster:\"</span><span>,</span> <span>\"dashboard-metrics-scraper\"</span><span>,</span> <span>\"http:dashboard-metrics-scraper\"</span><span>]</span>\n    <span>verbs</span><span>:</span> <span>[</span><span>\"get\"</span><span>]</span>\n\n<span>---</span>\n\n<span>kind</span><span>:</span> ClusterRole\n<span>apiVersion</span><span>:</span> rbac.authorization.k8s.io/v1\n<span>metadata</span><span>:</span>\n  <span>labels</span><span>:</span>\n    <span>k8s-app</span><span>:</span> kubernetes<span>-</span>dashboard\n  <span>name</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>rules</span><span>:</span>\n  <span># Allow Metrics Scraper to get metrics from the Metrics server</span>\n  <span>-</span> <span>apiGroups</span><span>:</span> <span>[</span><span>\"metrics.k8s.io\"</span><span>]</span>\n    <span>resources</span><span>:</span> <span>[</span><span>\"pods\"</span><span>,</span> <span>\"nodes\"</span><span>]</span>\n    <span>verbs</span><span>:</span> <span>[</span><span>\"get\"</span><span>,</span> <span>\"list\"</span><span>,</span> <span>\"watch\"</span><span>]</span>\n\n<span>---</span>\n\n<span>apiVersion</span><span>:</span> rbac.authorization.k8s.io/v1\n<span>kind</span><span>:</span> RoleBinding\n<span>metadata</span><span>:</span>\n  <span>labels</span><span>:</span>\n    <span>k8s-app</span><span>:</span> kubernetes<span>-</span>dashboard\n  <span>name</span><span>:</span> kubernetes<span>-</span>dashboard\n  <span>namespace</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>roleRef</span><span>:</span>\n  <span>apiGroup</span><span>:</span> rbac.authorization.k8s.io\n  <span>kind</span><span>:</span> Role\n  <span>name</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>subjects</span><span>:</span>\n  <span>-</span> <span>kind</span><span>:</span> ServiceAccount\n    <span>name</span><span>:</span> kubernetes<span>-</span>dashboard\n    <span>namespace</span><span>:</span> kubernetes<span>-</span>dashboard\n\n<span>---</span>\n\n<span>apiVersion</span><span>:</span> rbac.authorization.k8s.io/v1\n<span>kind</span><span>:</span> ClusterRoleBinding\n<span>metadata</span><span>:</span>\n  <span>name</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>roleRef</span><span>:</span>\n  <span>apiGroup</span><span>:</span> rbac.authorization.k8s.io\n  <span>kind</span><span>:</span> ClusterRole\n  <span>name</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>subjects</span><span>:</span>\n  <span>-</span> <span>kind</span><span>:</span> ServiceAccount\n    <span>name</span><span>:</span> kubernetes<span>-</span>dashboard\n    <span>namespace</span><span>:</span> kubernetes<span>-</span>dashboard\n\n<span>---</span>\n\n<span>kind</span><span>:</span> Deployment\n<span>apiVersion</span><span>:</span> apps/v1\n<span>metadata</span><span>:</span>\n  <span>labels</span><span>:</span>\n    <span>k8s-app</span><span>:</span> kubernetes<span>-</span>dashboard\n  <span>name</span><span>:</span> kubernetes<span>-</span>dashboard\n  <span>namespace</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>spec</span><span>:</span>\n  <span>replicas</span><span>:</span> <span>1</span>\n  <span>revisionHistoryLimit</span><span>:</span> <span>10</span>\n  <span>selector</span><span>:</span>\n    <span>matchLabels</span><span>:</span>\n      <span>k8s-app</span><span>:</span> kubernetes<span>-</span>dashboard\n  <span>template</span><span>:</span>\n    <span>metadata</span><span>:</span>\n      <span>labels</span><span>:</span>\n        <span>k8s-app</span><span>:</span> kubernetes<span>-</span>dashboard\n    <span>spec</span><span>:</span>\n      <span>containers</span><span>:</span>\n        <span>-</span> <span>name</span><span>:</span> kubernetes<span>-</span>dashboard\n          <span>image</span><span>:</span> kubernetesui/dashboard<span>:</span>v2.0.0<span>-</span>beta5\n          <span>imagePullPolicy</span><span>:</span> Always\n          <span>ports</span><span>:</span>\n            <span>-</span> <span>containerPort</span><span>:</span> <span>8443</span>\n              <span>protocol</span><span>:</span> TCP\n          <span>args</span><span>:</span>\n            <span>-</span> <span>-</span><span>-</span>auto<span>-</span>generate<span>-</span>certificates\n            <span>-</span> <span>-</span><span>-</span>namespace=kubernetes<span>-</span>dashboard\n            <span># Uncomment the following line to manually specify Kubernetes API server Host</span>\n            <span># If not specified, Dashboard will attempt to auto discover the API server and connect</span>\n            <span># to it. Uncomment only if the default does not work.</span>\n            <span># - --apiserver-host=http://my-address:port</span>\n          <span>volumeMounts</span><span>:</span>\n            <span>-</span> <span>name</span><span>:</span> kubernetes<span>-</span>dashboard<span>-</span>certs\n              <span>mountPath</span><span>:</span> /certs\n              <span># Create on-disk volume to store exec logs</span>\n            <span>-</span> <span>mountPath</span><span>:</span> /tmp\n              <span>name</span><span>:</span> tmp<span>-</span>volume\n          <span>livenessProbe</span><span>:</span>\n            <span>httpGet</span><span>:</span>\n              <span>scheme</span><span>:</span> HTTPS\n              <span>path</span><span>:</span> /\n              <span>port</span><span>:</span> <span>8443</span>\n            <span>initialDelaySeconds</span><span>:</span> <span>30</span>\n            <span>timeoutSeconds</span><span>:</span> <span>30</span>\n          <span>securityContext</span><span>:</span>\n            <span>allowPrivilegeEscalation</span><span>:</span> <span>false</span>\n            <span>readOnlyRootFilesystem</span><span>:</span> <span>true</span>\n            <span>runAsUser</span><span>:</span> <span>1001</span>\n            <span>runAsGroup</span><span>:</span> <span>2001</span>\n      <span>volumes</span><span>:</span>\n        <span>-</span> <span>name</span><span>:</span> kubernetes<span>-</span>dashboard<span>-</span>certs\n          <span>secret</span><span>:</span>\n            <span>secretName</span><span>:</span> kubernetes<span>-</span>dashboard<span>-</span>certs\n        <span>-</span> <span>name</span><span>:</span> tmp<span>-</span>volume\n          <span>emptyDir</span><span>:</span> <span>{</span><span>}</span>\n      <span>serviceAccountName</span><span>:</span> kubernetes<span>-</span>dashboard\n      <span>nodeSelector</span><span>:</span>\n        <span>\"beta.kubernetes.io/os\"</span><span>:</span> linux\n      <span># Comment the following tolerations if Dashboard must not be deployed on master</span>\n      <span>tolerations</span><span>:</span>\n        <span>-</span> <span>key</span><span>:</span> node<span>-</span>role.kubernetes.io/master\n          <span>effect</span><span>:</span> NoSchedule\n\n<span>---</span>\n\n<span>kind</span><span>:</span> Service\n<span>apiVersion</span><span>:</span> v1\n<span>metadata</span><span>:</span>\n  <span>labels</span><span>:</span>\n    <span>k8s-app</span><span>:</span> dashboard<span>-</span>metrics<span>-</span>scraper\n  <span>name</span><span>:</span> dashboard<span>-</span>metrics<span>-</span>scraper\n  <span>namespace</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>spec</span><span>:</span>\n  <span>ports</span><span>:</span>\n    <span>-</span> <span>port</span><span>:</span> <span>8000</span>\n      <span>targetPort</span><span>:</span> <span>8000</span>\n  <span>selector</span><span>:</span>\n    <span>k8s-app</span><span>:</span> dashboard<span>-</span>metrics<span>-</span>scraper\n\n<span>---</span>\n\n<span>kind</span><span>:</span> Deployment\n<span>apiVersion</span><span>:</span> apps/v1\n<span>metadata</span><span>:</span>\n  <span>labels</span><span>:</span>\n    <span>k8s-app</span><span>:</span> dashboard<span>-</span>metrics<span>-</span>scraper\n  <span>name</span><span>:</span> dashboard<span>-</span>metrics<span>-</span>scraper\n  <span>namespace</span><span>:</span> kubernetes<span>-</span>dashboard\n<span>spec</span><span>:</span>\n  <span>replicas</span><span>:</span> <span>1</span>\n  <span>revisionHistoryLimit</span><span>:</span> <span>10</span>\n  <span>selector</span><span>:</span>\n    <span>matchLabels</span><span>:</span>\n      <span>k8s-app</span><span>:</span> dashboard<span>-</span>metrics<span>-</span>scraper\n  <span>template</span><span>:</span>\n    <span>metadata</span><span>:</span>\n      <span>labels</span><span>:</span>\n        <span>k8s-app</span><span>:</span> dashboard<span>-</span>metrics<span>-</span>scraper\n      <span>annotations</span><span>:</span>\n        <span>seccomp.security.alpha.kubernetes.io/pod</span><span>:</span> <span>'runtime/default'</span>\n    <span>spec</span><span>:</span>\n      <span>containers</span><span>:</span>\n        <span>-</span> <span>name</span><span>:</span> dashboard<span>-</span>metrics<span>-</span>scraper\n          <span>image</span><span>:</span> kubernetesui/metrics<span>-</span>scraper<span>:</span>v1.0.1\n          <span>ports</span><span>:</span>\n            <span>-</span> <span>containerPort</span><span>:</span> <span>8000</span>\n              <span>protocol</span><span>:</span> TCP\n          <span>livenessProbe</span><span>:</span>\n            <span>httpGet</span><span>:</span>\n              <span>scheme</span><span>:</span> HTTP\n              <span>path</span><span>:</span> /\n              <span>port</span><span>:</span> <span>8000</span>\n            <span>initialDelaySeconds</span><span>:</span> <span>30</span>\n            <span>timeoutSeconds</span><span>:</span> <span>30</span>\n          <span>volumeMounts</span><span>:</span>\n          <span>-</span> <span>mountPath</span><span>:</span> /tmp\n            <span>name</span><span>:</span> tmp<span>-</span>volume\n          <span>securityContext</span><span>:</span>\n            <span>allowPrivilegeEscalation</span><span>:</span> <span>false</span>\n            <span>readOnlyRootFilesystem</span><span>:</span> <span>true</span>\n            <span>runAsUser</span><span>:</span> <span>1001</span>\n            <span>runAsGroup</span><span>:</span> <span>2001</span>\n      <span>serviceAccountName</span><span>:</span> kubernetes<span>-</span>dashboard\n      <span>nodeSelector</span><span>:</span>\n        <span>\"beta.kubernetes.io/os\"</span><span>:</span> linux\n      <span># Comment the following tolerations if Dashboard must not be deployed on master</span>\n      <span>tolerations</span><span>:</span>\n        <span>-</span> <span>key</span><span>:</span> node<span>-</span>role.kubernetes.io/master\n          <span>effect</span><span>:</span> NoSchedule\n      <span>volumes</span><span>:</span>\n        <span>-</span> <span>name</span><span>:</span> tmp<span>-</span>volume\n          <span>emptyDir</span><span>:</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br><span>301</span><br><span>302</span><br><span>303</span><br><span>304</span><br></div></div></blockquote>\n<p>运行yml文件的配置</p>\n<div><pre><code>kubectl apply -f kubernetes-dashboard.yaml\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>使用火狐浏览器访问</strong></p>\n<p>一定要火狐浏览器，其他浏览器打不开</p>\n<p>在火狐浏览器中打开https://主机ip:30001</p>\n<blockquote>\n<p>注意是https协议，一定要是https，不然访问不了</p>\n</blockquote>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200303170958-633114.png\" alt=\"image-20200303165743444\" /></p>\n<p>火狐浏览器 点击高级  <code>接受风险</code> 即可</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200303171000-629747.png\" alt=\"image-20200303165814253\" /></p>\n<p>进入到认证页面</p>\n<h2 id=\"访问\"> 访问</h2>\n<p>Kubernetes Dashboard 当前，只支持使用 Bearer Token登录。 由于 Kubernetes Dashboard 默认部署时，只配置了最低权限的 RBAC。因此，我们要创建一个名为 <code>admin-user</code> 的 ServiceAccount，再创建一个 ClusterRolebinding，将其绑定到 Kubernetes 集群中默认初始化的 <code>cluster-admin</code> 这个 ClusterRole。</p>\n<p>创建 Service Account 和 ClusterRoleBinding</p>\n<p>使用 <code>kubeadm</code> 安装集群时，默认创建了 ClusterRole <code>cluster-admin</code>。此时我们可以直接为刚才的 ServiceAccount 创建 ClusterRoleBinding。</p>\n<p>创建auth.yml</p>\n<div><pre><code><span>vim</span> auth.yaml\n</code></pre>\n<div><span>1</span><br></div></div><p>粘贴如下内容</p>\n<div><pre><code><span>apiVersion</span><span>:</span> v1\n<span>kind</span><span>:</span> ServiceAccount\n<span>metadata</span><span>:</span>\n  <span>name</span><span>:</span> admin<span>-</span>user\n  <span>namespace</span><span>:</span> kubernetes<span>-</span>dashboard\n\n<span>---</span>\n<span>apiVersion</span><span>:</span> rbac.authorization.k8s.io/v1\n<span>kind</span><span>:</span> ClusterRoleBinding\n<span>metadata</span><span>:</span>\n  <span>name</span><span>:</span> admin<span>-</span>user\n<span>roleRef</span><span>:</span>\n  <span>apiGroup</span><span>:</span> rbac.authorization.k8s.io\n  <span>kind</span><span>:</span> ClusterRole\n  <span>name</span><span>:</span> cluster<span>-</span>admin\n<span>subjects</span><span>:</span>\n<span>-</span> <span>kind</span><span>:</span> ServiceAccount\n  <span>name</span><span>:</span> admin<span>-</span>user\n  <span>namespace</span><span>:</span> kubernetes<span>-</span>dashboard\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>执行命令</p>\n<div><pre><code>kubectl apply -f auth.yml\n</code></pre>\n<div><span>1</span><br></div></div><p>获取Bearer Token</p>\n<p>执行命令</p>\n<div><pre><code>kubectl -n kubernetes-dashboard describe secret <span><span>$(</span>kubectl -n kubernetes-dashboard get secret <span>|</span> <span>grep</span> admin-user <span>|</span> <span>awk</span> <span>'{print $1}'</span><span>)</span></span>\n</code></pre>\n<div><span>1</span><br></div></div><p>复制token</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200303171003-607434.png\" alt=\"image-20200303170251809\" /></p>\n<p>将上一个步骤中获得的 Token 输入到登录界面中，点击 <strong>Sign in</strong> 按钮，完成登录</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200303170419-850121.png\" alt=\"image-20200303170419004\" /></p>\n<p>登录进来的页面</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200303171005-415412.png\" alt=\"image-20200303170451111\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200303170948-763126.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Docker中搭建nginx",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx01%20-%20Docker%E4%B8%AD%E6%90%AD%E5%BB%BANginx/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx01%20-%20Docker%E4%B8%AD%E6%90%AD%E5%BB%BANginx/",
      "content_html": "<h1 id=\"docker中搭建nginx\"> Docker中搭建nginx</h1>\n<h2 id=\"方式1-docker-compose\"> 方式1：docker-compose</h2>\n<h3 id=\"创建目录\"> 创建目录</h3>\n<div><pre><code><span>mkdir</span> -p /usr/local/docker/nginx\n<span>cd</span> /usr/local/docker/nginx\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"编写docker-compose-yml文件\"> 编写docker-compose.yml文件</h3>\n<div><pre><code><span>vim</span> docker-compose.yml\n</code></pre>\n<div><span>1</span><br></div></div><p>docker-compose.yml</p>\n<div><pre><code><span>version</span><span>:</span> <span>'3.1'</span>\n<span>services</span><span>:</span>\n  <span>nginx</span><span>:</span>\n    <span>restart</span><span>:</span> always\n    <span>image</span><span>:</span> nginx\n    <span>container_name</span><span>:</span> nginx\n    <span>ports</span><span>:</span>\n     <span>-</span> <span>80:80</span>\n    <span>volumes</span><span>:</span>\n     <span>-</span> ./conf/nginx.conf<span>:</span>/etc/nginx/nginx.conf\n     <span>-</span> ./wwwroot<span>:</span>/usr/share/nginx/wwwroot\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"创建目录用于挂载配置文件\"> 创建目录用于挂载配置文件</h3>\n<div><pre><code><span>mkdir</span> ./wwwroot\n<span>vim</span> ./conf/nginx.conf\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>nginx.conf的内容，见文章后面的附录</p>\n<h3 id=\"运行\"> 运行</h3>\n<div><pre><code>docker-compose up -d\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"方式2-docker\"> 方式2：docker</h2>\n<h3 id=\"创建目录用于挂载配置文件-2\"> 创建目录用于挂载配置文件</h3>\n<div><pre><code><span>mkdir</span> -p /usr/local/docker/nginx/wwwroot\n<span>vim</span> /usr/local/docker/nginx/conf\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"运行-2\"> 运行</h3>\n<p>直接输入命令</p>\n<div><pre><code>docker run <span>\\</span>\n-d --name nginx-1 <span>\\</span>\n-p <span>80</span>:80 <span>\\</span>\n-v /usr/local/docker/nginx/conf:/etc/nginx/nginx.conf <span>\\</span>\n-v /usr/local/docker/nginx/wwwroot:/usr/share/nginx/wwwroot <span>\\</span>\nnginx\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"附录\"> 附录</h2>\n<p>nginx.conf</p>\n<div><pre><code>\nuser  root;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n    }\n\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div>",
      "date_published": "2020-02-28T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx实现反向代理",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx05%20-%20Nginx%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%882%EF%BC%89/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx05%20-%20Nginx%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%882%EF%BC%89/",
      "content_html": "<h1 id=\"nginx实现反向代理\"> Nginx实现反向代理</h1>\n<h2 id=\"编辑配置文件\"> 编辑配置文件</h2>\n<div><pre><code>\nuser  root;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n    }\n\n\t\n\t# =============BEGIN 反向代理 =============\n\tserver {\n\t\tlisten 83;\n\t\tserver_name localhost;\n\t\t\n\t\tlocation / {\n\t\t\tproxy_pass http://localhost:8080;\n\t\t}\n\n    }\n\t\n\t# =============END 反向代理 =============\n\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>这里主要配置了2个地方</p>\n<ul>\n<li>listen 后面是要监听本机的端口</li>\n<li>proxy_pass， 后面接的是要代理的网址</li>\n</ul>\n<blockquote>\n<p><strong>说明</strong></p>\n<p>这里使用本机的83端口代理8080端口的Tomcat服务器，即实现在浏览器访问83端口，nginx将请求转发到8080端口，显示tomcat的页面，而83端口是没有开服务的。</p>\n</blockquote>\n<h3 id=\"重新加载配置\"> 重新加载配置</h3>\n<div><pre><code>sbin/nginx -s reload\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"访问测试\"> 访问测试</h2>\n<p>先访问8080端口，http://192.168.1.20:8080/</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200424211524141.png\" alt=\"image-20200424211524141\" /></p>\n<p>访问83端口，http://192.168.1.20:83/</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200424211728660.png\" alt=\"image-20200424211728660\" /></p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200424211524141.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx搭建伪CDN服务器",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx07%20-%20Nginx%E6%90%AD%E5%BB%BA%E4%BC%AACDN%E6%9C%8D%E5%8A%A1%E5%99%A8/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx07%20-%20Nginx%E6%90%AD%E5%BB%BA%E4%BC%AACDN%E6%9C%8D%E5%8A%A1%E5%99%A8/",
      "content_html": "<h1 id=\"nginx搭建伪cdn服务器\"> Nginx搭建伪CDN服务器</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx实现动静分离",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx06%20-%20Nginx%E5%AE%9E%E7%8E%B0%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx06%20-%20Nginx%E5%AE%9E%E7%8E%B0%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/",
      "content_html": "<h1 id=\"nginx实现动静分离\"> Nginx实现动静分离</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx实现负载均衡",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx09%20-%20Nginx%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%882%EF%BC%89/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx09%20-%20Nginx%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%882%EF%BC%89/",
      "content_html": "<h1 id=\"nginx实现负载均衡\"> Nginx实现负载均衡</h1>\n<h2 id=\"准备资源\"> 准备资源</h2>\n<p>准备1个Nginx服务器和2个Tomcat服务器</p>\n<table>\n<thead>\n<tr>\n<th>服务器</th>\n<th>IP</th>\n<th>端口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Nginx</td>\n<td>192.168.1.20</td>\n<td>84</td>\n</tr>\n<tr>\n<td>Tomcat 1</td>\n<td>192.168.1.21</td>\n<td>8080</td>\n</tr>\n<tr>\n<td>Tomcat 2</td>\n<td>192.168.1.22</td>\n<td>8080</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"编辑配置文件\"> 编辑配置文件</h2>\n<div><pre><code>\nuser  root;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n    }\n\t\n\t# =============BEGIN 负载均衡 =============\n\t# 配置负载均衡要使用 upstream\n\tupstream myServers{\n\t\tserver 192.168.1.21:8080;\n\t\tserver 192.168.1.22:8080;\n\t}\n\t\t\n\tserver {\n\t\tlisten 84;\n\t\tserver_name localhost;\n\t\t\n\t\tlocation / {\n\t\t\tproxy_pass http://myServers;\n\t\t}\n\n    }\n\t\n\t# =============END 负载均衡 =============\n\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><h2 id=\"重新加载配置\"> 重新加载配置</h2>\n<div><pre><code>sbin/nginx -s reload\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"访问测试\"> 访问测试</h2>\n<p>访问Nginx的http://192.168.1.20:84，请求会轮流的转发到<code>Tomcat1</code>和<code>Tomcat2</code></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200424223452544.png\" alt=\"image-20200424223452544\" /></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/20200424223616-818039.png\" alt=\"image-20200424223615713\" /></p>\n<blockquote>\n<p><strong>注意</strong></p>\n<p>为了区分两个Tomcat，我在index.jsp上分别加了Node - 1 - Tomcat 和 Node - 2 - Tomcat 的字样</p>\n</blockquote>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200424223452544.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Tengine健康检查",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx11%20-%20Tengine%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx11%20-%20Tengine%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/",
      "content_html": "<h1 id=\"tengine健康检查\"> Tengine健康检查</h1>\n<h2 id=\"编辑配置文件\"> 编辑配置文件</h2>\n<div><pre><code>\nuser  root;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n    }\n\t\n\t# =============BEGIN 健康检查 =============\n\t# 配置负载均衡要使用 upstream\n\tupstream myServers-hc{\n\t\tserver 192.168.1.20:9090\n\t\tserver 192.168.1.20:9091\n\t\t\n\t\t# 加入健康检查\n\t\tcheck interval=3000 rise=2 fall=5 timeout=1000 type=http;\n        check_keepalive_requests 100;\n        check_http_send &quot;HEAD / HTTP/1.1\\r\\nConnection: keep-alive\\r\\n\\r\\n&quot;;\n        check_http_expect_alive http_2xx http_3xx;\n\t}\n\t\t\n\tserver {\n\t\tlisten 86;\n\t\tserver_name localhost;\n\t\t\n\t\tlocation / {\n\t\t\tproxy_pass myServers-hc;\n\t\t}\n\t\t\n\t\tlocation /status {\n            check_status;\n\n        }\n\n    }\n\t\n\t# =============END 健康检查 =============\n\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><blockquote>\n<p>这段代码就是在负载均衡的基础上加入健康检查的代码</p>\n<div><pre><code>check interval=3000 rise=2 fall=5 timeout=1000 type=http;\ncheck_keepalive_requests 100;\ncheck_http_send &quot;HEAD / HTTP/1.1\\r\\nConnection: keep-alive\\r\\n\\r\\n&quot;;\ncheck_http_expect_alive http_2xx http_3xx;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></blockquote>\n<h2 id=\"重新加载配置\"> 重新加载配置</h2>\n<div><pre><code>sbin/nginx -s reload\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"访问测试\"> 访问测试</h2>\n<p>输入http://192.168.1.20:86/status，进入监控检查页面</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200424225356444.png\" alt=\"image-20200424225356444\" /></p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200424225356444.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Tengine的会话保持",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx12%20-%20Tengine%E7%9A%84%E4%BC%9A%E8%AF%9D%E4%BF%9D%E6%8C%81/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx12%20-%20Tengine%E7%9A%84%E4%BC%9A%E8%AF%9D%E4%BF%9D%E6%8C%81/",
      "content_html": "<h1 id=\"tengine的会话保持\"> Tengine的会话保持</h1>\n<h2 id=\"概述\"> 概述</h2>\n<p>该模块是一个负载均衡模块，通过cookie实现客户端与后端服务器的会话保持, 在一定条件下可以保证同一个客户端访问的都是同一个后端服务器。</p>\n<h2 id=\"编辑配置文件\"> 编辑配置文件</h2>\n<p>nginx.conf</p>\n<div><pre><code>\nuser  root;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n\n\t\n\t# =============BEGIN 会话保持 =============\n\t# 配置负载均衡要使用 upstream\n\tupstream myServers-session-keep{\n        # 添加会话保持\n\t\tsession_sticky cookie=uid fallback=on path=/ mode=insert option=indirect;\n\t\tserver 192.168.1.21:8080;\n\t\tserver 192.168.1.22:8080;\n\t}\n\t\t\n\tserver {\n\t    listen       80;\n        server_name  localhost;\n\t\tlocation / {\n\t\t    # 添加会话保持\n\t\t\tsession_sticky_hide_cookie upstream=myServers-session-keep;\n\t\t\tproxy_pass http://myServers-session-keep;\n\t\t}\n    }\n\t# =============END 会话保持 =============\n\t\n\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id=\"重启nginx\"> 重启Nginx</h2>\n<div><pre><code><span>service</span> nginx stop\n<span>service</span> nginx start\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"访问测试\"> 访问测试</h2>\n<p>浏览器输入http://192.168.1.20/，多次刷新，会一直保持在同一个Tomcat</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200430101212385.png\" alt=\"image-20200430101212385\" /></p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200430101212385.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx实现负载均衡",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx08%20-%20Nginx%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx08%20-%20Nginx%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/",
      "content_html": "<h1 id=\"nginx实现负载均衡\"> Nginx实现负载均衡</h1>\n<h2 id=\"什么是负载均衡\"> 什么是负载均衡</h2>\n<p>负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p>\n<p>负载均衡，英文名称为 Load Balance，其意思就是分摊到多个操作单元上进行执行，例如 Web 服务器、FTP 服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p>\n<h2 id=\"nginx-实现负载均衡\"> Nginx 实现负载均衡</h2>\n<ul>\n<li>nginx 作为负载均衡服务器，用户请求先到达 nginx，再由 nginx 根据负载配置将请求转发至 tomcat 服务器</li>\n<li>nginx 负载均衡服务器：192.168.75.145:80</li>\n<li>tomcat1 服务器：192.168.75.145:9090</li>\n<li>tomcat2 服务器：192.168.75.145:9091</li>\n</ul>\n<h2 id=\"nginx-配置负载均衡\"> Nginx 配置负载均衡</h2>\n<p>修改 <code>/usr/local/docker/nginx/conf</code> 目录下的 nginx.conf 配置文件：</p>\n<div><pre><code>worker_processes <span>1</span><span>;</span>\n\nevents <span>{</span>\n    worker_connections <span>1024</span><span>;</span>\n<span>}</span>\n\nhttp <span>{</span>\n    include mime.types<span>;</span>\n    default_type application/octet-stream<span>;</span>\n    sendfile on<span>;</span>\n    keepalive_timeout <span>65</span><span>;</span>\n\n    upstream myapp <span>{</span>\n        server <span>192.168</span>.75.145:9090 <span>weight</span><span>=</span><span>10</span><span>;</span>\n        server <span>192.168</span>.75.145:9091 <span>weight</span><span>=</span><span>10</span><span>;</span>\n\n    <span>}</span>\n    \n\n    server <span>{</span>\n        listen <span>80</span><span>;</span>\n        server_name <span>192.168</span>.75.145<span>;</span>\n        location / <span>{</span>\n        \troot /usr/share/nginx/wwwroot/html80<span>;</span>\n        \tindex index.html index.htm<span>;</span>\n        <span>}</span>\n    <span>}</span>\n    \n    server <span>{</span>\n        listen <span>9000</span><span>;</span>\n        server_name <span>192.168</span>.75.145<span>;</span>\n        location / <span>{</span>\n        \tproxy_pass http://myapp<span>;</span>\n        \tindex index.html index.htm<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>定义负载均衡设备的 Ip及设备状态</p>\n<p>upstream myServer {\nserver 127.0.0.1:9090 down;\nserver 127.0.0.1:8080 weight=2;\nserver 127.0.0.1:6060;\nserver 127.0.0.1:7070 backup;\n}</p>\n<p>在需要使用负载的 Server 节点下添加</p>\n<div><pre><code>proxy_pass http://myServer;\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li><code>upstream</code>：每个设备的状态:</li>\n<li><code>down</code>：表示当前的 <code>server</code> 暂时不参与负载</li>\n<li><code>weight</code>：默认为 1 <code>weight</code> 越大，负载的权重就越大。</li>\n<li><code>max_fails</code>：允许请求失败的次数默认为 1 当超过最大次数时，返回 <code>proxy_next_upstream</code> 模块定义的错误</li>\n<li><code>fail_timeout</code>:<code>max_fails</code> 次失败后，暂停的时间。</li>\n<li><code>backup</code>：其它所有的非 <code>backup</code> 机器 <code>down</code> 或者忙的时候，请求 <code>backup</code> 机器。所以这台机器压力会最轻</li>\n</ul>\n",
      "date_published": "2020-02-28T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "访问控制",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx10%20-%20IP%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx10%20-%20IP%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/",
      "content_html": "<h1 id=\"访问控制\"> 访问控制</h1>\n<h2 id=\"编辑配置文件\"> 编辑配置文件</h2>\n<div><pre><code>\nuser  root;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n    }\n\t\n\t# =============BEGIN IP访问控制 =============\t\n\tserver {\n\t\tlisten 85;\n\t\tserver_name localhost;\n\t\t\n\t\tlocation / {\n\t\t\t# 禁止外网访问\n\t\t\tdeny  192.168.1.1;\n\t\t\t# 允许内部局域网访问\n\t\t\tallow 192.168.1.0/24;\n\t\t\tdeny  all;\n\t\t\troot html;\n\t\t\tindex index.html index.htm;\n\t\t}\n\n    }\n\t\n\t# =============END IP访问控制 =============\n\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><h2 id=\"重新加载配置\"> 重新加载配置</h2>\n<div><pre><code>sbin/nginx -s reload\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"访问测试\"> 访问测试</h2>\n<p>浏览器输入http://192.168.1.20:85/，出现禁止访问</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/20200424224222-227178.png\" alt=\"image-20200424224214370\" /></p>\n<p>服务器内访问</p>\n<div><pre><code>curl 192.168.1.20:85\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/20200424224410-308849.png\" alt=\"image-20200424224409857\" /></p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/20200424224222-227178.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "利用Memcached解决session一致性问题",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx13%20-%20%E5%88%A9%E7%94%A8Memcached%E8%A7%A3%E5%86%B3session%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx13%20-%20%E5%88%A9%E7%94%A8Memcached%E8%A7%A3%E5%86%B3session%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/",
      "content_html": "<h1 id=\"利用memcached解决session一致性问题\"> 利用Memcached解决session一致性问题</h1>\n<h2 id=\"安装memcached\"> 安装memcached</h2>\n<div><pre><code>yum -y <span>install</span> memcached\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"启动memcached\"> 启动memcached</h2>\n<div><pre><code><span>service</span> memcached start\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"将memcached所需jar文件上传到后端服务器tomcat的lib目录\"> 将memcached所需jar文件上传到后端服务器tomcat的lib目录</h2>\n<h2 id=\"配置tomcat的server-xml文件和context-xml\"> 配置tomcat的server.xml文件和context.xml</h2>\n<p>编辑context.xml</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200424231646984.png\" alt=\"image-20200424231646984\" /></p>\n<h2 id=\"编辑tomcat的index-jsp\"> 编辑Tomcat的index.jsp</h2>\n<p>添加如下语句，打印出sessionId</p>\n<div><pre><code>&lt;h1&gt;\n    SessionID: \n    &lt;%= session.getId() %&gt;\n&lt;/h1&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200424232543499.png\" alt=\"image-20200424232543499\" /></p>\n<p>未启动memcahced之前，看一下sessionId</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200424232716815.png\" alt=\"image-20200424232716815\" /></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/20200424232738-222426.png\" alt=\"image-20200424232738662\" /></p>\n<p>很明显，两个sessionId不同。</p>\n<p>开启memcached，需重启Tomcat，再次访问</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/20200430084227-579223.png\" alt=\"image-20200430084226671\" /></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/20200430084250-37687.png\" alt=\"image-20200430084250282\" /></p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200424231646984.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx+Keepalived实现高可用",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx14%20-%20Nginx+Keepalived%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/Nginx14%20-%20Nginx+Keepalived%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8/",
      "content_html": "<h1 id=\"nginx-keepalived实现高可用\"> Nginx+Keepalived实现高可用</h1>\n<h2 id=\"准备资源\"> 准备资源</h2>\n<p>2台Nginx，2台Tomcat</p>\n<table>\n<thead>\n<tr>\n<th>服务器</th>\n<th>IP</th>\n<th>端口</th>\n<th>角色</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基于ip的虚拟主机</td>\n<td>192.168.1.20</td>\n<td>80</td>\n<td>MASTER</td>\n</tr>\n<tr>\n<td>Nginx - master - 2</td>\n<td>192.168.1.200</td>\n<td>80</td>\n<td>BACKUP</td>\n</tr>\n<tr>\n<td>Tomcat - 1</td>\n<td>192.168.1.21</td>\n<td>8080</td>\n<td>WEB SERVER</td>\n</tr>\n<tr>\n<td>Tomcat - 2</td>\n<td>192.168.1.22</td>\n<td>8080</td>\n<td>WEB SERVER</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"安装keepalived\"> 安装Keepalived</h2>\n<p>在2台Nginx下都安装Keepalived</p>\n<div><pre><code>yum -y install keepalived\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"配置keepalived\"> 配置Keepalived</h2>\n<p>主要配置4个地方</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200425095003540.png\" alt=\"image-20200425095003540\" /></p>\n<h3 id=\"主节点配置\"> 主节点配置</h3>\n<p>修改主Nginx服务器的/etc/keepalived/keepalived.conf文件，内容如下</p>\n<div><pre><code>! Configuration File for keepalived\n\n#全局配置\nglobal_defs {\n   notification_email {  #指定keepalived在发生切换时需要发送email到的对象，一行一个\n     XXX@XXX.com\n   }\n   notification_email_from XXX@XXX.com  #指定发件人\n   #smtp_server XXX.smtp.com                             #指定smtp服务器地址\n   #smtp_connect_timeout 30                               #指定smtp连接超时时间\n   router_id LVS_DEVEL                                    #运行keepalived机器的一个标识\n}\n\nvrrp_instance VI_1 { \n    state MASTER           #标示状态为MASTER 备份机为BACKUP\n    interface ens33         #设置实例绑定的网卡\n    virtual_router_id 51   #同一实例下virtual_router_id必须相同\n    priority 100           #MASTER权重要高于BACKUP 比如BACKUP为99  \n    advert_int 1           #MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒\n    authentication {       #设置认证\n        auth_type PASS     #主从服务器验证方式\n        auth_pass 8888\n    }\n    virtual_ipaddress {    #设置vip\n        192.168.1.100       #可以多个虚拟IP，换行即可\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>查看ip</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200425102447353.png\" alt=\"image-20200425102447353\" /></p>\n<h3 id=\"备用节点配置\"> 备用节点配置</h3>\n<p>修改备用Nginx服务器的/etc/keepalived/keepalived.conf文件，内容如下</p>\n<div><pre><code>! Configuration File for keepalived\n\n#全局配置\nglobal_defs {\n   notification_email {  #指定keepalived在发生切换时需要发送email到的对象，一行一个\n     XXX@XXX.com\n   }\n   notification_email_from XXX@XXX.com  #指定发件人\n   #smtp_server XXX.smtp.com                             #指定smtp服务器地址\n   #smtp_connect_timeout 30                               #指定smtp连接超时时间\n   router_id LVS_DEVEL                                    #运行keepalived机器的一个标识\n}\n\nvrrp_instance VI_1 { \n    state BACKUP           #标示状态为MASTER 备份机为BACKUP\n    interface ens33         #设置实例绑定的网卡\n    virtual_router_id 51   #同一实例下virtual_router_id必须相同\n    priority 99           #MASTER权重要高于BACKUP 比如BACKUP为99  \n    advert_int 1           #MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒\n    authentication {       #设置认证\n        auth_type PASS     #主从服务器验证方式\n        auth_pass 8888\n    }\n    virtual_ipaddress {    #设置vip\n        192.168.1.100       #可以多个虚拟IP，换行即可\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>查看ip</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/20200425112737-652506.png\" alt=\"image-20200425102552945\" /></p>\n<p>只有当主节点的Keepalived停掉时，备用节点才会生成虚拟ip</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/20200425120320-891120.png\" alt=\"image-20200425120316441\" /></p>\n<h2 id=\"配置主从切换\"> 配置主从切换</h2>\n<p>keepalived是通过检测keepalived进程是否存在判断服务器是否宕机，如果keepalived进程在但是nginx进程不在了那么keepalived是不会做主备切换，所以我们需要写个脚本来监控nginx进程是否存在，如果nginx不存在就将keepalived进程杀掉。</p>\n<p>在主nginx上需要编写nginx进程检测脚本（check_nginx.sh），判断nginx进程是否存在，如果nginx不存在就将keepalived进程杀掉</p>\n<p><strong>check_nginx.sh内容如下：</strong></p>\n<div><pre><code><span>#!/bin/bash</span>\n<span># 如果进程中没有nginx则将keepalived进程kill掉</span>\n<span>A</span><span>=</span><span><span>`</span><span>ps</span> -C nginx --no-header <span>|</span><span>wc</span> -l<span>`</span></span>      <span>## 查看是否有 nginx进程 把值赋给变量A </span>\n<span>if</span> <span>[</span> <span>$A</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>                    <span>## 如果没有进程值得为 零</span>\n       <span>service</span> keepalived stop          <span>## 则结束 keepalived 进程</span>\n<span>fi</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>添加客执行权限</strong></p>\n<div><pre><code><span>chmod</span> +x /etc/keepalived/check_nginx.sh\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>修改主Nginx的配置</strong></p>\n<p>添加如下两段代码</p>\n<p>在vrrp_instance VI_1上面添加下面这段代码</p>\n<div><pre><code>vrrp_script check_nginx {\n    script &quot;/etc/keepalived/check_nginx.sh&quot;         ##监控脚本\n    interval 2                                      ##时间间隔，2秒\n    weight 2                                        ##权重\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在virtual_ipaddress上面添加下面这段代码</p>\n<div><pre><code>track_script {\n\tcheck_nginx        #监控脚本\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"访问测试\"> 访问测试</h2>\n<p>启动keepalived</p>\n<div><pre><code><span>service</span> keepalived start\n</code></pre>\n<div><span>1</span><br></div></div><p>为了区分主备Nginx，修改一下Nginx主页</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/20200425100407-304620.png\" alt=\"image-20200425100407097\" /></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/20200425100502-880517.png\" alt=\"image-20200425100502281\" /></p>\n<p>浏览器访问虚拟ip，http://192.168.1.100/</p>\n<p>首先进来的是主Nginx</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200425100638472.png\" alt=\"image-20200425100638472\" /></p>\n<p>当停掉主Nginx，会访问到备用Nginx</p>\n<div><pre><code><span>service</span> nginx stop\n</code></pre>\n<div><span>1</span><br></div></div><p>再次访问http://192.168.1.100/，进入到备用Nginx</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200425111547000.png\" alt=\"image-20200425111547000\" /></p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200425095003540.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "npm 安装yarn",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/node/npm%20%E5%AE%89%E8%A3%85yarn/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/node/npm%20%E5%AE%89%E8%A3%85yarn/",
      "content_html": "<h1 id=\"npm-安装yarn\"> npm 安装yarn</h1>\n<p>安装</p>\n<div><pre><code><span>npm</span> <span>install</span> -g <span>yarn</span> --registry<span>=</span>https://registry.npm.taobao.org\n</code></pre>\n<div><span>1</span><br></div></div><p>再配置下源</p>\n<div><pre><code><span>yarn</span> config <span>set</span> registry https://registry.npm.taobao.org -g\n<span>yarn</span> config <span>set</span> sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "yarn (npm) 切换设置镜像源",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/node/%E5%88%87%E6%8D%A2yarn%E9%95%9C%E5%83%8F%E6%BA%90/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/node/%E5%88%87%E6%8D%A2yarn%E9%95%9C%E5%83%8F%E6%BA%90/",
      "content_html": "<h1 id=\"yarn-npm-切换设置镜像源\"> yarn (npm) 切换设置镜像源</h1>\n<h2 id=\"设置镜像源\"> 设置镜像源</h2>\n<p>1、查看一下当前源</p>\n<div><pre><code>yarn config get registry\n</code></pre>\n<div><span>1</span><br></div></div><p>2、切换为淘宝源</p>\n<div><pre><code>yarn config set registry https://registry.npm.taobao.org\n</code></pre>\n<div><span>1</span><br></div></div><p>3、或者切换为自带的</p>\n<div><pre><code>yarn config set registry https://registry.yarnpkg.com\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "出现的问题",
      "url": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/",
      "id": "http://blog.alanlee.top/blog-vuepress/devtool/nginx/%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/",
      "content_html": "<h1 id=\"出现的问题\"> 出现的问题</h1>\n<h2 id=\"问题1\"> 问题1</h2>\n<h3 id=\"问题\"> 问题</h3>\n<p>[root@master init.d]# service nginx start\nStarting nginx (via systemctl):  Job for nginx.service failed because the control process exited with error code. See &quot;systemctl status nginx.service&quot; and &quot;journalctl -xe&quot; for details.</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/20200425104238-894457.png\" alt=\"image-20200425104236968\" /></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200425104519014.png\" alt=\"image-20200425104519014\" /></p>\n<h3 id=\"原因\"> 原因</h3>\n<p>nginx文件中nginx的执行文件的路径没写对</p>\n<h3 id=\"解决\"> 解决</h3>\n<p>修正路径就就可以解决了</p>\n<p>重新加载配置</p>\n<div><pre><code>systemctl daemon-reload\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"问题2\"> 问题2</h2>\n<p>keepalived加载检查脚本失败</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200425122656224.png\" alt=\"image-20200425122656224\" /></p>\n<blockquote>\n<p>这个问题未解决</p>\n</blockquote>\n<h2 id=\"问题3\"> 问题3</h2>\n<p>负载均衡时，连接拒绝代理的节点</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200430095223530.png\" alt=\"image-20200430095223530\" /></p>\n<h3 id=\"解决-2\"> 解决</h3>\n<p>我这边是使用了service nginx restart命令，然后出现了这个问题，解决方法就是使用</p>\n<div><pre><code>service nginx stop\nservice nginx start\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>这两个命令就可以了。</p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/20200425104238-894457.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "浏览器",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/browser/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/browser/",
      "content_html": "<h1 id=\"浏览器\"> 浏览器</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "前端",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/",
      "content_html": "<h1 id=\"前端\"> 前端</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "flex的使用",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/01-flex%E7%9A%84%E4%BD%BF%E7%94%A8/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/01-flex%E7%9A%84%E4%BD%BF%E7%94%A8/",
      "content_html": "<h1 id=\"flex的使用\"> flex的使用</h1>\n<p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214085345-14998.png\" alt=\"20200214085257-237480\" /></p>\n<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p>\n<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>\n<p>默认情况下flex items全部放在一行，当flex items宽度和大于flex container时，每个items的宽度会被压缩</p>\n<div><pre><code>块级元素弹性布局\ndisplay: flex;\n行内元素弹性布局\ndisplay: inline-flex;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214085345-14998.png",
      "date_published": "2020-02-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "flex container的flex-direction属性",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/02-flex%20container%E7%9A%84flex-direction%E5%B1%9E%E6%80%A7/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/02-flex%20container%E7%9A%84flex-direction%E5%B1%9E%E6%80%A7/",
      "content_html": "<h1 id=\"flex-container的flex-direction属性\"> flex container的flex-direction属性</h1>\n<p>flex items 默认都是沿着main axis（主轴方向）从main start 开始往main end方向排布</p>\n<p>flex direction 决定了main axis的方向，有4个取值</p>\n<ul>\n<li>\n<p>row 从左到右（默认）</p>\n</li>\n<li>\n<p>row-reverse 从右到左</p>\n</li>\n<li>\n<p>column 从上到下</p>\n</li>\n<li>\n<p>column-reverse 从下到上</p>\n</li>\n</ul>\n<p><strong>决定主轴的方向</strong></p>\n<p>flex-direction</p>\n<p>可选值：</p>\n<p>row 主轴水平方向从左到右（默认）</p>\n<div><pre><code><span>flex-direction</span><span>:</span> row<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214085503-225346.png\" alt=\"20200214085416-160476\" /></p>\n<p>row-reverse 主轴水平方向从右到左</p>\n<div><pre><code><span>flex-direction</span><span>:</span> row-reverse<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214085547-823110.png\" alt=\"20200214085520-498000\" /></p>\n<p>column 主轴垂直方向从上到下</p>\n<div><pre><code>flex-direction: column;\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214085613-997016.png\" alt=\"20200214085552-523345\" /></p>\n<p>column 主轴垂直方向从下到上</p>\n<div><pre><code>flex-direction: column-reverse;\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214085632-935439.png\" alt=\"20200214085553-935580\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214085503-225346.png",
      "date_published": "2020-02-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "flex container的justify-content属性",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/03-flex%20container%E7%9A%84justify-content%E5%B1%9E%E6%80%A7/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/03-flex%20container%E7%9A%84justify-content%E5%B1%9E%E6%80%A7/",
      "content_html": "<h1 id=\"flex-container的justify-content属性\"> flex container的justify-content属性</h1>\n<p>justify-content决定了 flex items在main axis上的对齐方式</p>\n<ul>\n<li>flex-start（默认值）：与main start对齐</li>\n</ul>\n<div><pre><code><span>justify-content</span><span>:</span> flex-start<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214085659-736239.png\" alt=\"20200214085639-317266\" /></p>\n<ul>\n<li>flex-end：与main end对齐</li>\n</ul>\n<div><pre><code><span>justify-content</span><span>:</span> flex-end<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214085748-15894.png\" alt=\"20200214085703-471034\" /></p>\n<ul>\n<li>center：居中对齐</li>\n</ul>\n<div><pre><code><span>justify-content</span><span>:</span> center<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214085815-645854.png\" alt=\"20200214085751-676322\" /></p>\n<ul>\n<li>space-between：\n<ul>\n<li>flex items之间的距离相等</li>\n<li>与main start、main end两端对齐</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>justify-content</span><span>:</span> space-between<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214085837-870054.png\" alt=\"20200214085819-71423\" /></p>\n<ul>\n<li>space-evenly：\n<ul>\n<li>flex items之间的距离相等</li>\n<li>flex items与main start、main end之间的距离等于flex items之间的距离</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>justify-content</span><span>:</span> space-evenly<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214085917-516926.png\" alt=\"20200214085844-497265\" /></p>\n<ul>\n<li>space-around：\n<ul>\n<li>flex items之间的距离相等</li>\n<li>flex items与main start、main end之间的距离是flex items之间的距离的一半</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>justify-content</span><span>:</span> space-around<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214085933-806001.png\" alt=\"20200214085841-847112\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214085659-736239.png",
      "date_published": "2020-02-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "css",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/css/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/css/",
      "content_html": "<h1 id=\"css\"> css</h1>\n<img :src=\"$withBase('/note_images/css.jpg')\" />\n<p>层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "flex container的align-items属性",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/04-flex%20container%E7%9A%84align-items%E5%B1%9E%E6%80%A7/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/04-flex%20container%E7%9A%84align-items%E5%B1%9E%E6%80%A7/",
      "content_html": "<h1 id=\"flex-container的align-items属性\"> flex container的align-items属性</h1>\n<p>align-items决定了flex items在cross axis上的对齐方式</p>\n<ul>\n<li>normal：在弹性布局中，效果和stretch一样</li>\n</ul>\n<div><pre><code><span>align-items</span><span>:</span> normal<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200211212159-423616.png\" alt=\"image-20200211212156148\" /></p>\n<ul>\n<li>stretch：当flex items在cross axis方向的size为auto时，会自动拉伸值填充flex container</li>\n</ul>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200211212159-423616.png\" alt=\"image-20200211212156148\" /></p>\n<ul>\n<li>flex-start：与cross start对齐</li>\n</ul>\n<div><pre><code><span>align-items</span><span>:</span> flex-start<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090007-859253.png\" alt=\"20200214085950-195395\" /></p>\n<ul>\n<li>flex-end：与cross end对齐</li>\n</ul>\n<div><pre><code><span>align-items</span><span>:</span> flex-end<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090057-585615.png\" alt=\"20200214085942-7818\" /></p>\n<ul>\n<li>center：居中对齐</li>\n</ul>\n<div><pre><code><span>align-items</span><span>:</span> center<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090125-151807.png\" alt=\"20200214090009-803998\" /></p>\n<ul>\n<li>baseline：与基准线对齐</li>\n</ul>\n<div><pre><code><span>align-items</span><span>:</span> baseline<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090156-577811.png\" alt=\"20200214090107-722490\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200211212159-423616.png",
      "date_published": "2020-02-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "flex-wrap",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/05-flex%20container%E7%9A%84flex-wrap%E5%B1%9E%E6%80%A7/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/05-flex%20container%E7%9A%84flex-wrap%E5%B1%9E%E6%80%A7/",
      "content_html": "<h1 id=\"flex-wrap\"> flex-wrap</h1>\n<p>默认情况下flex items全部放在一行，当flex items宽度和大于flex container时，每个items的宽度会被压缩，flex-wrap:wrap则是让items在一行中放不下的时候会自动换行</p>\n<ul>\n<li>nowrap（默认值）：</li>\n</ul>\n<div><pre><code><span>flex-wrap</span><span>:</span> nowrap<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090221-851269.png\" alt=\"20200214090207-735046\" /></p>\n<ul>\n<li>wrap：让items在一行中放不下的时候会自动换行</li>\n</ul>\n<div><pre><code><span>flex-wrap</span><span>:</span> wrap<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090241-514730.png\" alt=\"20200214090227-491786\" /></p>\n<ul>\n<li>wrap-reverse：多行、反转</li>\n</ul>\n<div><pre><code><span>flex-wrap</span><span>:</span> wrap-reverse<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div>",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090221-851269.png",
      "date_published": "2020-02-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "flex items的align self属性",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/09-flex%20items%E7%9A%84align%20self%E5%B1%9E%E6%80%A7/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/09-flex%20items%E7%9A%84align%20self%E5%B1%9E%E6%80%A7/",
      "content_html": "<h1 id=\"flex-items的align-self属性\"> flex items的align self属性</h1>\n<p>flex items可以通过align-self覆盖flex container设置的align-items</p>\n<ul>\n<li>auto（默认值）：遵从flex container的align-items的设置</li>\n<li>stretch、flex-start、flex-end、baseline，效果跟align-items一致</li>\n</ul>\n<p>以flex-end为例</p>\n<div><pre><code><span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>\"</span>en<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;</span>head</span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>\"</span>UTF-8<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>title</span><span>></span></span>flex items的align self属性<span><span><span>&lt;/</span>title</span><span>></span></span>\n  <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>\"</span>stylesheet<span>\"</span></span> <span>href</span><span><span>=</span><span>\"</span>al-css.css<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n    <span>.box</span><span>{</span>\n      <span>width</span><span>:</span> 500px<span>;</span>\n      <span>height</span><span>:</span> 300px<span>;</span>\n      <span>background-color</span><span>:</span> aqua<span>;</span>\n      <span>margin</span><span>:</span> 50px auto 0<span>;</span>\n\n      <span>/*块级元素弹性布局*/</span>\n      <span>display</span><span>:</span> flex<span>;</span>\n      <span>align-items</span><span>:</span> center<span>;</span>\n\n    <span>}</span>\n\n    <span>.item</span><span>{</span>\n      <span>width</span><span>:</span> 100px<span>;</span>\n      <span>height</span><span>:</span> 100px<span>;</span>\n      <span>line-height</span><span>:</span> 100px<span>;</span>\n      <span>text-align</span><span>:</span> center<span>;</span>\n    <span>}</span>\n\n    <span>.item1</span><span>{</span>\n      <span>order</span><span>:</span> 3<span>;</span>\n      <span>align-self</span><span>:</span> flex-end<span>;</span>\n    <span>}</span>\n\n    <span>.item2</span><span>{</span>\n      <span>order</span><span>:</span> 1<span>;</span>\n    <span>}</span>\n\n    <span>.item3</span><span>{</span>\n      <span>order</span><span>:</span> 2<span>;</span>\n    <span>}</span>\n  </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n<span><span><span>&lt;/</span>head</span><span>></span></span>\n<span><span><span>&lt;</span>body</span><span>></span></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>box<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item item1 al-bg-color-light-blue<span>\"</span></span><span>></span></span>item1<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item item2 al-bg-color-light-purple<span>\"</span></span><span>></span></span>item2<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item item3 al-bg-color-light-red<span>\"</span></span><span>></span></span>item3<span><span><span>&lt;/</span>div</span><span>></span></span>\n\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n\n<span><span><span>&lt;/</span>body</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090654-986105.png\" alt=\"20200214090642-131906\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090654-986105.png",
      "date_published": "2020-02-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "flex-flow",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/06-flex%20container%E7%9A%84flex-flow%E5%B1%9E%E6%80%A7/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/06-flex%20container%E7%9A%84flex-flow%E5%B1%9E%E6%80%A7/",
      "content_html": "<h1 id=\"flex-flow\"> flex-flow</h1>\n<p>flex-flow是flex-direction与flex-warp的缩写</p>\n<div><pre><code>flex-flow: row wrap;\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090329-938984.png\" alt=\"20200214090319-491103\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090329-938984.png",
      "date_published": "2020-02-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "align-content",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/07-flex%20container%E7%9A%84align-content%E5%B1%9E%E6%80%A7/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/07-flex%20container%E7%9A%84align-content%E5%B1%9E%E6%80%A7/",
      "content_html": "<h1 id=\"align-content\"> align-content</h1>\n<p>align-content决定了 flex items在cross axis上的对齐方式</p>\n<ul>\n<li>flex-start（默认值）：与cross start对齐</li>\n</ul>\n<div><pre><code><span>flex-flow</span><span>:</span> row wrap<span>;</span>\n<span>justify-content</span><span>:</span> space-evenly<span>;</span>\n\n<span>/*cross axis方向*/</span>\n<span>align-content</span><span>:</span> flex-start<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090400-834493.png\" alt=\"20200214090334-7813\" /></p>\n<ul>\n<li>flex-end：与cross end对齐</li>\n</ul>\n<div><pre><code><span>flex-flow</span><span>:</span> row wrap<span>;</span>\n<span>justify-content</span><span>:</span> space-evenly<span>;</span>\n\n<span>/*cross axis方向*/</span>\n<span>align-content</span><span>:</span> flex-end<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090424-134033.png\" alt=\"20200214090337-271583\" /></p>\n<ul>\n<li>center：居中对齐</li>\n</ul>\n<div><pre><code><span>flex-flow</span><span>:</span> row wrap<span>;</span>\n<span>justify-content</span><span>:</span> space-evenly<span>;</span>\n\n<span>/*cross axis方向*/</span>\n<span>align-content</span><span>:</span> center<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090457-856542.png\" alt=\"20200214090338-37021\" /></p>\n<ul>\n<li>\n<p>space-between：</p>\n<ul>\n<li>flex items之间的距离相等</li>\n<li>与cross start、cross end两端对齐</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>flex-flow</span><span>:</span> row wrap<span>;</span>\n<span>justify-content</span><span>:</span> space-evenly<span>;</span>\n\n<span>/*cross axis方向*/</span>\n<span>align-content</span><span>:</span> space-between<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090525-761567.png\" alt=\"20200214090504-951603\" /></p>\n<ul>\n<li>\n<p>space-evenly：</p>\n<ul>\n<li>flex items之间的距离相等</li>\n<li>flex items与cross start、cross end之间的距离等于flex items之间的距离</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>flex-flow</span><span>:</span> row wrap<span>;</span>\n<span>justify-content</span><span>:</span> space-evenly<span>;</span>\n\n<span>/*cross axis方向*/</span>\n<span>align-content</span><span>:</span> space-evenly<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090544-710455.png\" alt=\"20200214090529-718409\" /></p>\n<ul>\n<li>space-around：\n<ul>\n<li>flex items之间的距离相等</li>\n<li>flex items与cross start、cross end之间的距离是flex items之间的距离的一半</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>flex-flow</span><span>:</span> row wrap<span>;</span>\n<span>justify-content</span><span>:</span> space-evenly<span>;</span>\n\n<span>/*cross axis方向*/</span>\n<span>align-content</span><span>:</span> space-around<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090600-68558.png\" alt=\"20200214090551-615140\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090400-834493.png",
      "date_published": "2020-02-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "flex-items的order属性",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/08-flex-items%E7%9A%84order%E5%B1%9E%E6%80%A7/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/08-flex-items%E7%9A%84order%E5%B1%9E%E6%80%A7/",
      "content_html": "<h1 id=\"flex-items的order属性\"> flex-items的order属性</h1>\n<p>order决定了flex items的排布顺序</p>\n<ul>\n<li>可以设置任意整数（正整数、负整数、0），值越小排越前面</li>\n<li>默认值是0</li>\n</ul>\n<div><pre><code><span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n  <span>.box</span><span>{</span>\n    <span>width</span><span>:</span> 500px<span>;</span>\n    <span>height</span><span>:</span> 300px<span>;</span>\n    <span>background-color</span><span>:</span> aqua<span>;</span>\n    <span>margin</span><span>:</span> 50px auto 0<span>;</span>\n\n    <span>/*块级元素弹性布局*/</span>\n    <span>display</span><span>:</span> flex<span>;</span>\n\n  <span>}</span>\n\n  <span>.item</span><span>{</span>\n    <span>width</span><span>:</span> 100px<span>;</span>\n    <span>height</span><span>:</span> 100px<span>;</span>\n    <span>line-height</span><span>:</span> 100px<span>;</span>\n    <span>text-align</span><span>:</span> center<span>;</span>\n  <span>}</span>\n\n  <span>.item1</span><span>{</span>\n    <span>order</span><span>:</span> 3<span>;</span>\n  <span>}</span>\n\n  <span>.item2</span><span>{</span>\n    <span>order</span><span>:</span> 1<span>;</span>\n  <span>}</span>\n\n  <span>.item3</span><span>{</span>\n    <span>order</span><span>:</span> 2<span>;</span>\n  <span>}</span>\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>box<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item item1 al-bg-color-light-blue<span>\"</span></span><span>></span></span>item1<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item item2 al-bg-color-light-purple<span>\"</span></span><span>></span></span>item2<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item item3 al-bg-color-light-red<span>\"</span></span><span>></span></span>item3<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090634-408722.png\" alt=\"20200214090624-827844\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090634-408722.png",
      "date_published": "2020-02-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "flex items的flex-grow属性",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/10-flex%20items%E7%9A%84flex-grow%E5%B1%9E%E6%80%A7/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/10-flex%20items%E7%9A%84flex-grow%E5%B1%9E%E6%80%A7/",
      "content_html": "<h1 id=\"flex-items的flex-grow属性\"> flex items的flex-grow属性</h1>\n<ul>\n<li>flex-grow决定了flex items如何扩展\n<ul>\n<li>可以设置任意非负数（正小数，正整数，0），默认值是0</li>\n<li>当flex container在main axis方向上右剩余的size时，flex-grow才会生效</li>\n</ul>\n</li>\n<li>如果所有flex items的flex-grow总和sum超过1，每个flex item扩展的size为flex container的剩余size * flex-grow/sum</li>\n</ul>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090710-279103.png\" alt=\"20200214090700-378358\" /></p>\n<ul>\n<li>如果所有flex items的flex-grow总和sum不超过1，每个flex item扩展的size为flex container的剩余size * flex-grow-sum</li>\n</ul>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090721-928144.png\" alt=\"20200214090701-716042\" /></p>\n<ul>\n<li>flex items扩展后的最终size不能超过max-width/max-height</li>\n</ul>\n<div><pre><code><span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>\"</span>en<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;</span>head</span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>\"</span>UTF-8<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>title</span><span>></span></span>flex items的flex-grow属性<span><span><span>&lt;/</span>title</span><span>></span></span>\n  <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>\"</span>stylesheet<span>\"</span></span> <span>href</span><span><span>=</span><span>\"</span>al-css.css<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n    <span>.box</span><span>{</span>\n      <span>width</span><span>:</span> 500px<span>;</span>\n      <span>height</span><span>:</span> 300px<span>;</span>\n      <span>background-color</span><span>:</span> aqua<span>;</span>\n      <span>margin</span><span>:</span> 50px auto 0<span>;</span>\n\n      <span>/*块级元素弹性布局*/</span>\n      <span>display</span><span>:</span> flex<span>;</span>\n      <span>align-items</span><span>:</span> center<span>;</span>\n\n    <span>}</span>\n\n    <span>.item</span><span>{</span>\n      <span>width</span><span>:</span> 100px<span>;</span>\n      <span>height</span><span>:</span> 100px<span>;</span>\n      <span>line-height</span><span>:</span> 100px<span>;</span>\n      <span>text-align</span><span>:</span> center<span>;</span>\n    <span>}</span>\n\n    <span>.item1</span><span>{</span>\n      <span>/*flex-grow: 1;*/</span>\n      <span>flex-grow</span><span>:</span> 0.5<span>;</span>\n    <span>}</span>\n\n    <span>.item2</span><span>{</span>\n      <span>/*flex-grow: 1;*/</span>\n      <span>flex-grow</span><span>:</span> 0.1<span>;</span>\n    <span>}</span>\n\n    <span>.item3</span><span>{</span>\n      <span>/*flex-grow: 1;*/</span>\n      <span>flex-grow</span><span>:</span> 0.1<span>;</span>\n    <span>}</span>\n  </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n<span><span><span>&lt;/</span>head</span><span>></span></span>\n<span><span><span>&lt;</span>body</span><span>></span></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>box<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item item1 al-bg-color-light-blue<span>\"</span></span><span>></span></span>item1<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item item2 al-bg-color-light-purple<span>\"</span></span><span>></span></span>item2<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item item3 al-bg-color-light-red<span>\"</span></span><span>></span></span>item3<span><span><span>&lt;/</span>div</span><span>></span></span>\n\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n\n<span><span><span>&lt;/</span>body</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div>",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090710-279103.png",
      "date_published": "2020-02-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "学习弹性布局",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/",
      "content_html": "<h1 id=\"学习弹性布局\"> 学习弹性布局</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "flex items的flex-basis属性",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/12-flex%20items%E7%9A%84flex-basis%E5%B1%9E%E6%80%A7/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/12-flex%20items%E7%9A%84flex-basis%E5%B1%9E%E6%80%A7/",
      "content_html": "<h1 id=\"flex-items的flex-basis属性\"> flex items的flex-basis属性</h1>\n<p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>\n<ul>\n<li>flex-basis用来设置flex items在main axis方向上的base size\n<ul>\n<li>auto（默认值）：item的自身宽度</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090815-124724.png\" alt=\"20200214090803-83446\" /></p>\n<div><pre><code><span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>\"</span>en<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;</span>head</span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>\"</span>UTF-8<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>title</span><span>></span></span>flex items的flex-basis属性<span><span><span>&lt;/</span>title</span><span>></span></span>\n  <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>\"</span>stylesheet<span>\"</span></span> <span>href</span><span><span>=</span><span>\"</span>al-css.css<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n    <span>.box</span><span>{</span>\n      <span>width</span><span>:</span> 500px<span>;</span>\n      <span>height</span><span>:</span> 300px<span>;</span>\n      <span>background-color</span><span>:</span> aqua<span>;</span>\n      <span>margin</span><span>:</span> 50px auto 0<span>;</span>\n\n      <span>/*块级元素弹性布局*/</span>\n      <span>display</span><span>:</span> flex<span>;</span>\n      <span>align-items</span><span>:</span> center<span>;</span>\n\n    <span>}</span>\n\n    <span>.item</span><span>{</span>\n      <span>width</span><span>:</span> 100px<span>;</span>\n      <span>height</span><span>:</span> 100px<span>;</span>\n      <span>line-height</span><span>:</span> 100px<span>;</span>\n      <span>text-align</span><span>:</span> center<span>;</span>\n    <span>}</span>\n\n    <span>.item1</span><span>{</span>\n      <span>flex-basis</span><span>:</span> 200px<span>;</span>\n    <span>}</span>\n\n    <span>.item2</span><span>{</span>\n\n    <span>}</span>\n\n    <span>.item3</span><span>{</span>\n\n    <span>}</span>\n  </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n<span><span><span>&lt;/</span>head</span><span>></span></span>\n<span><span><span>&lt;</span>body</span><span>></span></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>box<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item item1 al-bg-color-light-blue<span>\"</span></span><span>></span></span>item1<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item item2 al-bg-color-light-purple<span>\"</span></span><span>></span></span>item2<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item item3 al-bg-color-light-red<span>\"</span></span><span>></span></span>item3<span><span><span>&lt;/</span>div</span><span>></span></span>\n\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n\n<span><span><span>&lt;/</span>body</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div>",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090815-124724.png",
      "date_published": "2020-02-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "flex items的flex-shrink属性",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/11-flex%20items%E7%9A%84flex-shrink%E5%B1%9E%E6%80%A7/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/11-flex%20items%E7%9A%84flex-shrink%E5%B1%9E%E6%80%A7/",
      "content_html": "<h1 id=\"flex-items的flex-shrink属性\"> flex items的flex-shrink属性</h1>\n<p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>\n<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>\n<p>负值对该属性无效。</p>\n<p><strong>例子：</strong></p>\n<p>现有一个box的宽度为550px，里面包裹着3个宽度为250px的item</p>\n<p><strong>假设收缩比例都为1，收缩计算</strong></p>\n<p>所以250px+250px+250px = 750px  &gt; 550px</p>\n<p>750px - 550px = 200px</p>\n<p>200px / 3 = 66.6666px</p>\n<p>每个item将收缩66.6666px，即宽度变为250px - 66.6666px = 183.3333px</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090751-894209.png\" alt=\"20200214090731-81638\" /></p>\n<p><strong>假设收缩比例为3:1:1，收缩计算</strong></p>\n<p>container宽度：550px</p>\n<p>item宽度和：250px + 250px + 250px = 750px &gt; 550px</p>\n<p>多出的宽度：750px - 250px = 200px</p>\n<p>item1收缩后的宽度: 250px - 200px * (3/5) = 130px</p>\n<p>item2收缩后的宽度: 250px - 200px * (1/5) = 210px</p>\n<p>item3收缩后的宽度: 250px - 200px * (1/5) = 210px</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200212003911-301067.png\" alt=\"image-20200212003614034\" /></p>\n<div><pre><code><span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>\"</span>en<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;</span>head</span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>\"</span>UTF-8<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>title</span><span>></span></span>flex items的flex-shrink属性<span><span><span>&lt;/</span>title</span><span>></span></span>\n  <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>\"</span>stylesheet<span>\"</span></span> <span>href</span><span><span>=</span><span>\"</span>al-css.css<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n    <span>.box</span><span>{</span>\n      <span>width</span><span>:</span> 550px<span>;</span>\n      <span>height</span><span>:</span> 300px<span>;</span>\n      <span>background-color</span><span>:</span> aqua<span>;</span>\n      <span>margin</span><span>:</span> 50px auto 0<span>;</span>\n\n      <span>/*块级元素弹性布局*/</span>\n      <span>display</span><span>:</span> flex<span>;</span>\n      <span>align-items</span><span>:</span> center<span>;</span>\n      <span>/*flex-wrap: wrap;*/</span>\n\n    <span>}</span>\n\n    <span>.item</span><span>{</span>\n      <span>width</span><span>:</span> 250px<span>;</span>\n      <span>height</span><span>:</span> 100px<span>;</span>\n      <span>line-height</span><span>:</span> 100px<span>;</span>\n      <span>text-align</span><span>:</span> center<span>;</span>\n    <span>}</span>\n\n    <span>.item1</span><span>{</span>\n      <span>flex-shrink</span><span>:</span> 3<span>;</span>\n    <span>}</span>\n\n    <span>.item2</span><span>{</span>\n      <span>flex-shrink</span><span>:</span> 1<span>;</span>\n    <span>}</span>\n\n    <span>.item3</span><span>{</span>\n      <span>flex-shrink</span><span>:</span> 1<span>;</span>\n    <span>}</span>\n  </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n<span><span><span>&lt;/</span>head</span><span>></span></span>\n<span><span><span>&lt;</span>body</span><span>></span></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>box<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item item1 al-bg-color-light-blue<span>\"</span></span><span>></span></span>item1<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item item2 al-bg-color-light-purple<span>\"</span></span><span>></span></span>item2<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item item3 al-bg-color-light-red<span>\"</span></span><span>></span></span>item3<span><span><span>&lt;/</span>div</span><span>></span></span>\n\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n\n<span><span><span>&lt;/</span>body</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div>",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200214090751-894209.png",
      "date_published": "2020-02-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Electron",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/electron/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/electron/",
      "content_html": "<h1 id=\"electron\"> Electron</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "HTML基础",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/html/HTML02-%E5%9F%BA%E7%A1%80/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/html/HTML02-%E5%9F%BA%E7%A1%80/",
      "content_html": "<h1 id=\"html基础\"> HTML基础</h1>\n<h2 id=\"html-标题\"> HTML 标题</h2>\n<h3 id=\"知识点\"> 知识点</h3>\n<p>HTML 标题（Heading）是通过<code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> 标签来定义的。</p>\n<p><code>&lt;h1&gt;</code> 定义最大的标题。 <code>&lt;h6&gt;</code> 定义最小的标题。</p>\n<p>浏览器会自动地在标题的前后添加换行。</p>\n<h3 id=\"实例\"> 实例</h3>\n<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>这是一级标题。<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>h2</span><span>></span></span>这是二级标题。<span><span><span>&lt;/</span>h2</span><span>></span></span>\n<span><span><span>&lt;</span>h3</span><span>></span></span>这是三级标题。<span><span><span>&lt;/</span>h3</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"说明\"> 说明</h3>\n<p>请确保将 HTML 标题 标签只用于标题。不要仅仅是为了生成<strong>粗体</strong>或<strong>大号</strong>的文本而使用标题。</p>\n<p>搜索引擎使用标题为您的网页的结构和内容编制索引。</p>\n<p>因为用户可以通过标题来快速浏览您的网页，所以用标题来呈现文档结构是很重要的。</p>\n<p>应该将 h1 用作主标题（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。</p>\n<h2 id=\"html-段落\"> HTML 段落</h2>\n<h3 id=\"知识点-2\"> 知识点</h3>\n<p>HTML 可以将文档分割为若干段落。</p>\n<p>段落是通过 <code>&lt;p&gt;</code> 标签定义的。</p>\n<h3 id=\"实例-2\"> 实例</h3>\n<div><pre><code>&lt;p&gt;这是一个段落 &lt;p&gt;\n&lt;p&gt;这是另一个段落&lt;p&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"说明-2\"> 说明</h3>\n<p>浏览器会自动地在段落的前后添加空行。（<code>&lt;p&gt;</code> 是块级元素）</p>\n<h2 id=\"html-换行\"> HTML 换行</h2>\n<h3 id=\"知识点-3\"> 知识点</h3>\n<p>如果您希望在不产生一个新段落的情况下进行换行（新行），请使用 <code>&lt;br/&gt;</code> 标签。</p>\n<p><code>&lt;br&gt;</code> 元素是一个空的 HTML 元素。由于关闭标签没有任何意义，因此它没有结束标签。</p>\n<h3 id=\"实例-3\"> 实例</h3>\n<div><pre><code>&lt;p&gt;这个&lt;br&gt;段落&lt;br&gt;演示了分行的效果&lt;/p&gt;\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"说明-3\"> 说明</h3>\n<p>无</p>\n<h2 id=\"html-空格\"> HTML 空格</h2>\n<h3 id=\"知识点-4\"> 知识点</h3>\n<p>我们无法确定 HTML 被显示的确切效果。屏幕的大小，以及对窗口的调整都可能导致不同的结果。</p>\n<p>对于 HTML，您无法通过在 HTML 代码中添加额外的空格或换行来改变输出的效果。</p>\n<p>当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格。</p>\n",
      "date_published": "2020-01-27T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "flex items的flex属性",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/13-flex%20items%E7%9A%84flex%E5%B1%9E%E6%80%A7/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/css/flex/13-flex%20items%E7%9A%84flex%E5%B1%9E%E6%80%A7/",
      "content_html": "<h1 id=\"flex-items的flex属性\"> flex items的flex属性</h1>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200212004222-570137.png\" alt=\"image-20200212004214711\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200212004222-570137.png",
      "date_published": "2020-02-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "HTML简介",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/html/HTML01-%E7%AE%80%E4%BB%8B/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/html/HTML01-%E7%AE%80%E4%BB%8B/",
      "content_html": "<h1 id=\"html简介\"> HTML简介</h1>\n<h2 id=\"什么是html\"> 什么是HTML?</h2>\n<p>HTML 是用来描述网页的一种语言。</p>\n<ul>\n<li>HTML 指的是超文本标记语言: <strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage</li>\n<li>HTML 不是一种编程语言，而是一种<strong>标记</strong>语言</li>\n<li>标记语言是一套<strong>标记标签</strong> (markup tag)</li>\n<li>HTML 使用标记标签来<strong>描述</strong>网页</li>\n<li>HTML 文档包含了HTML <strong>标签</strong>及<strong>文本</strong>内容</li>\n<li>HTML文档也叫做 <strong>web 页面</strong></li>\n</ul>\n<h2 id=\"html-标签\"> HTML 标签</h2>\n<p>HTML 标记标签通常被称为 HTML 标签 (HTML tag)。</p>\n<ul>\n<li>HTML 标签是由<em>尖括号</em>包围的关键词，比如 <code>&lt;html&gt;</code></li>\n<li>HTML 标签通常是<strong>成对出现</strong>的，比如 <code>&lt;b&gt;</code>和 <code>&lt;/b&gt;</code></li>\n<li>标签对中的第一个标签是<strong>开始标签</strong>，第二个标签是<strong>结束标签</strong></li>\n<li>开始和结束标签也被称为<strong>开放标签</strong>和<strong>闭合标签</strong></li>\n</ul>\n<div><pre><code>&lt;标签&gt;内容&lt;/标签&gt;\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"html-元素\"> HTML 元素</h2>\n<p>&quot;HTML 标签&quot; 和 &quot;HTML 元素&quot; 通常都是描述同样的意思.</p>\n<p>但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签，如下实例:</p>\n<p>HTML 元素:</p>\n<div><pre><code>&lt;p&gt;这是一个段落&lt;p&gt;\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"html-网页结构\"> HTML 网页结构</h2>\n<p>下面是一个可视化的HTML页面结构：</p>\n<img :src=\"$withBase('/note_images/image-20200126155054458.png')\" />\n<p><strong>注：</strong> 只有 <code>&lt;body&gt;</code> 区域 (白色部分) 才会在浏览器中显示。</p>\n<h2 id=\"html版本\"> HTML版本</h2>\n<p>从初期的网络诞生后，已经出现了许多HTML版本:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">版本</th>\n<th style=\"text-align:center\">发布时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">HTML</td>\n<td style=\"text-align:center\">1991</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">HTML+</td>\n<td style=\"text-align:center\">1993</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">HTML 2.0</td>\n<td style=\"text-align:center\">1995</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">HTML 3.2</td>\n<td style=\"text-align:center\">1997</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">HTML 4.01</td>\n<td style=\"text-align:center\">1999</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">XHTML 1.0</td>\n<td style=\"text-align:center\">2000</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">HTML5</td>\n<td style=\"text-align:center\">2012</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">XHTML5</td>\n<td style=\"text-align:center\">2013</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"doctype-声明\"> &lt;!DOCTYPE&gt; 声明</h2>\n<p>声明有助于浏览器中正确显示网页。</p>\n<p>网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。</p>\n<p>doctype 声明是不区分大小写的，以下方式均可：</p>\n<div><pre><code>&lt;!DOCTYPE html&gt;\n \n&lt;!DOCTYPE HTML&gt;\n \n&lt;!doctype html&gt;\n \n&lt;!Doctype Html&gt; \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"通用声明\"> 通用声明</h2>\n<h3 id=\"html5\"> HTML5</h3>\n<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"html-4-01\"> HTML 4.01</h3>\n<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>HTML</span> <span>PUBLIC</span> <span>\"-//W3C//DTD HTML 4.01 Transitional//EN\"</span>\n<span>\"http://www.w3.org/TR/html4/loose.dtd\"</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"xhtml-1-0\"> XHTML 1.0</h3>\n<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span> <span>PUBLIC</span> <span>\"-//W3C//DTD XHTML 1.0 Transitional//EN\"</span>\n<span>\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"中文编码\"> 中文编码</h2>\n<p>目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 UTF-8 或 GBK。</p>\n<p><strong>HTML 实例</strong></p>\n<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>\n<span><span><span>&lt;</span>html</span><span>></span></span>\n<span><span><span>&lt;</span>head</span><span>></span></span>\n<span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>\"</span>UTF-8<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;</span>title</span><span>></span></span>页面标题<span><span><span>&lt;/</span>title</span><span>></span></span>\n<span><span><span>&lt;/</span>head</span><span>></span></span>\n<span><span><span>&lt;</span>body</span><span>></span></span>\n    <span><span><span>&lt;</span>h1</span><span>></span></span>我的第一个标题<span><span><span>&lt;/</span>h1</span><span>></span></span>\n    <span><span><span>&lt;</span>p</span><span>></span></span>我的第一个段落。<span><span><span>&lt;/</span>p</span><span>></span></span>\n<span><span><span>&lt;/</span>body</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>",
      "date_published": "2020-01-27T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "HTML 元素",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/html/HTML03-%E5%85%83%E7%B4%A0/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/html/HTML03-%E5%85%83%E7%B4%A0/",
      "content_html": "<h1 id=\"html-元素\"> HTML 元素</h1>\n<h2 id=\"知识点\"> 知识点</h2>\n<p>HTML 文档由 HTML 元素定义。</p>\n<h3 id=\"html-元素-2\"> HTML 元素</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">开始标签 *</th>\n<th style=\"text-align:center\">元素内容</th>\n<th style=\"text-align:center\">结束标签 *</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>&lt;p&gt;</code></td>\n<td style=\"text-align:center\">这是一个段落</td>\n<td style=\"text-align:center\"><code>&lt;/p&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>&lt;a href=&quot;default.htm&quot;&gt;</code></td>\n<td style=\"text-align:center\">这是一个链接</td>\n<td style=\"text-align:center\"><code>&lt;/a&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>&lt;br&gt;</code></td>\n<td style=\"text-align:center\">换行</td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<p>开始标签常被称为<strong>起始标签（opening tag）</strong>，结束标签常称为<strong>闭合标签（closing tag）</strong>。</p>\n<h3 id=\"html-元素语法\"> HTML 元素语法</h3>\n<ul>\n<li>HTML 元素以<strong>开始标签</strong>起始</li>\n<li>HTML 元素以<strong>结束标签</strong>终止</li>\n<li><strong>元素的内容</strong>是开始标签与结束标签之间的内容</li>\n<li>某些 HTML 元素具有<strong>空内容（empty content）</strong></li>\n<li>空元素<strong>在开始标签中进行关闭</strong>（以开始标签的结束而结束）</li>\n<li>大多数 HTML 元素可拥有<strong>属性</strong></li>\n</ul>\n<h3 id=\"嵌套的-html-元素\"> 嵌套的 HTML 元素</h3>\n<p>HTML 文档由嵌套的 HTML 元素构成。</p>\n<h3 id=\"html-空元素\"> HTML 空元素</h3>\n<p>没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。</p>\n<p><code>&lt;br&gt;</code> 就是没有关闭标签的空元素（<code>&lt;br&gt;</code> 标签定义换行）。</p>\n<p>在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。</p>\n<p>在开始标签中添加斜杠，比如 <code>&lt;br&gt;</code>，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。</p>\n<p>即使 <code>&lt;br&gt;</code> 在所有浏览器中都是有效的，但使用 <code>&lt;br /&gt;</code> 其实是更长远的保障。</p>\n<h2 id=\"实例\"> 实例</h2>\n<h3 id=\"html-文档实例\"> HTML 文档实例</h3>\n<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>\n<span><span><span>&lt;</span>html</span><span>></span></span>\n<span><span><span>&lt;</span>body</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span>这是第一个段落。<span><span><span>&lt;/</span>p</span><span>></span></span>\n<span><span><span>&lt;/</span>body</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>以上实例包含了三个 HTML 元素。</p>\n<ul>\n<li><code>&lt;p&gt;</code> 元素:</li>\n</ul>\n<div><pre><code>&lt;p&gt;这是第一个段落。&lt;/p&gt;\n</code></pre>\n<div><span>1</span><br></div></div><p>这个 <code>&lt;p&gt;</code> 元素定义了 HTML 文档中的一个段落。\n这个元素拥有一个开始标签 <code>&lt;p&gt;</code> 以及一个结束标签 <code>&lt;/p&gt;</code>。\n元素内容是: 这是第一个段落。</p>\n<ul>\n<li><code>&lt;body&gt;</code> 元素:</li>\n</ul>\n<div><pre><code><span><span><span>&lt;</span>body</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span>这是第一个段落。<span><span><span>&lt;/</span>p</span><span>></span></span>\n<span><span><span>&lt;/</span>body</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>&lt;body&gt;</code> 元素定义了 HTML 文档的主体。\n这个元素拥有一个开始标签 <code>&lt;body&gt;</code> 以及一个结束标签 <code>&lt;/body&gt;</code>。\n元素内容是另一个 HTML 元素（p 元素）。</p>\n<ul>\n<li><code>&lt;html&gt;</code> 元素：</li>\n</ul>\n<div><pre><code><span><span><span>&lt;</span>html</span><span>></span></span>\n<span><span><span>&lt;</span>body</span><span>></span></span>\n    <span><span><span>&lt;</span>p</span><span>></span></span>这是第一个段落。<span><span><span>&lt;/</span>p</span><span>></span></span>\n<span><span><span>&lt;/</span>body</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>&lt;html&gt;</code> 元素定义了整个 HTML 文档。\n这个元素拥有一个开始标签 <code>&lt;html&gt;</code> ，以及一个结束标签 <code>&lt;/html&gt;</code>。\n元素内容是另一个 HTML 元素（body 元素）。</p>\n<h2 id=\"说明\"> 说明</h2>\n<h3 id=\"不要忘记结束标签\"> 不要忘记结束标签</h3>\n<p>即使您忘记了使用结束标签，大多数浏览器也会正确地显示 HTML：</p>\n<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>这是一个段落\n<span><span><span>&lt;</span>p</span><span>></span></span>这是一个段落\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>以上实例在浏览器中也能正常显示，因为关闭标签是可选的。</p>\n<p>但不要依赖这种做法。忘记使用结束标签会产生不可预料的结果或错误。</p>\n<h3 id=\"html-提示-使用小写标签\"> HTML 提示：使用小写标签</h3>\n<p>HTML 标签对大小写不敏感：<code>&lt;B&gt;</code> 等同于 <code>&lt;b&gt;</code>。许多网站都使用大写的 HTML 标签。</p>\n",
      "date_published": "2020-01-27T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "html",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/html/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/html/",
      "content_html": "<h1 id=\"html\"> html</h1>\n<img :src=\"$withBase('/note_images/html.jpg')\" />\n<p>HTML称为超文本标记语言，是一种标识性的语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字，图形、动画、声音、表格、链接等。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Javascript",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/js/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/js/",
      "content_html": "<h1 id=\"javascript\"> Javascript</h1>\n<img :src=\"$withBase('/note_images/javascript.jpg')\" />\n<p>JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "let关键字和const关键字",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/01-let%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cconst%E5%85%B3%E9%94%AE%E5%AD%97/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/01-let%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cconst%E5%85%B3%E9%94%AE%E5%AD%97/",
      "content_html": "<h1 id=\"let关键字和const关键字\"> let关键字和const关键字</h1>\n<p><strong>var关键字</strong></p>\n<ul>\n<li>可以重复声明</li>\n<li>无法限制修改</li>\n<li>没有块级作用域</li>\n</ul>\n<p><strong>let关键字</strong></p>\n<ul>\n<li>不能重复声明</li>\n<li>变量，可以修改</li>\n<li>有块级作用域</li>\n</ul>\n<p><strong>const关键字</strong></p>\n<ul>\n<li>不能重复声明</li>\n<li>常量，不能修改</li>\n<li>有块级作用域</li>\n</ul>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "JQuery",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/jquery/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/jquery/",
      "content_html": "<h1 id=\"jquery\"> JQuery</h1>\n<img :src=\"$withBase('/note_images/jquery.jpg')\" />\n<p>jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "函数的参数",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/02-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/02-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/",
      "content_html": "<h1 id=\"函数的参数\"> 函数的参数</h1>\n<p><strong><code>...</code>收集参数</strong></p>\n<p><strong><code>...</code>展开数组</strong></p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "解构赋值",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/03-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/03-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/",
      "content_html": "<h1 id=\"解构赋值\"> 解构赋值</h1>\n<p>内容 = 内容；</p>\n<p>左右两边要一样</p>\n<p>右边是个合法的对象</p>\n<p>声明和赋值不能分开，必须写在一句话里</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "字符串",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/05-%E5%AD%97%E7%AC%A6%E4%B8%B2/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/05-%E5%AD%97%E7%AC%A6%E4%B8%B2/",
      "content_html": "<h1 id=\"字符串\"> 字符串</h1>\n<p><strong>startWith</strong></p>\n<p><strong>endWith</strong></p>\n<p><strong>字符串模板</strong></p>\n<div><pre><code>`  反单引号\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code><span>let</span> a <span>=</span> <span><span>`</span><span>12</span><span>`</span></span><span>;</span>\n<span>let</span> str <span>=</span> <span><span>`</span><span>a</span><span><span>${</span>a<span>}</span></span><span>bc</span><span>`</span></span><span>;</span>\n<span>alert</span><span>(</span>str<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>引用字符串模板的内容使用<code>${变量名}</code></p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "数组",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/04-%E6%95%B0%E7%BB%84/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/04-%E6%95%B0%E7%BB%84/",
      "content_html": "<h1 id=\"数组\"> 数组</h1>\n<p>新增</p>\n<p><strong>map 映射</strong></p>\n<p>[22,72,99]</p>\n<p>[不及格，及格，及格]</p>\n<p><strong>reduce</strong></p>\n<p><strong>filter</strong></p>\n<p><strong>forEach</strong></p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "JSON",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/07-JSON/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/07-JSON/",
      "content_html": "<h1 id=\"json\"> JSON</h1>\n<p>JOSN.stringify()  把json数据变成字符串</p>\n<p>JSON.parse()  把字符串解析成josn</p>\n<p>简写：</p>\n<p>名字与值一样的时候可以省略名字</p>\n<div><pre><code><span>{</span>a<span>:</span> a<span>,</span> b<span>:</span> b<span>}</span>\n<span>=</span>\n<span>{</span>a<span>,</span>b<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "面向对象",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/06-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/06-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",
      "content_html": "<h1 id=\"面向对象\"> 面向对象</h1>\n<p>class关键字、构造器和类分开了</p>\n<p>继承</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "微前端",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/micro-front-end/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/micro-front-end/",
      "content_html": "<h1 id=\"微前端\"> 微前端</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "学习ES6",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/js/es6/",
      "content_html": "<h1 id=\"学习es6\"> 学习ES6</h1>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/es6-tutorial-1589599106210.jpg\" alt=\"es6-tutorial\" /></p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/es6-tutorial-1589599106210.jpg",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "安装React",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/react/01-%E5%AE%89%E8%A3%85React/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/react/01-%E5%AE%89%E8%A3%85React/",
      "content_html": "<h1 id=\"安装react\"> 安装React</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "02-JSX的使用",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/react/02-JSX%E7%9A%84%E4%BD%BF%E7%94%A8/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/react/02-JSX%E7%9A%84%E4%BD%BF%E7%94%A8/",
      "content_html": "<h1 id=\"_02-jsx的使用\"> 02-JSX的使用</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "04-组件拆分与组件传值",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/react/04-%E7%BB%84%E4%BB%B6%E6%8B%86%E5%88%86%E4%B8%8E%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/react/04-%E7%BB%84%E4%BB%B6%E6%8B%86%E5%88%86%E4%B8%8E%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/",
      "content_html": "<h1 id=\"_04-组件拆分与组件传值\"> 04-组件拆分与组件传值</h1>\n<p>子组件不能直接修改父组件的数据，应该创建一个数据副本来修改，修改后再重新赋值给父组件的数据</p>\n<h2 id=\"组件传值\"> 组件传值</h2>\n<p>父组件<code>&lt;TodoList /&gt;</code></p>\n<p>子组件<code>&lt;TodoItem /&gt;</code></p>\n<h3 id=\"父传子\"> 父传子</h3>\n<p>父组件设置 传递的属性</p>\n<p>在父组件中给子组件添加属性</p>\n<div><pre><code>&lt;TodoItem content={item}/&gt;\t//item为要传的数据\n</code></pre>\n<div><span>1</span><br></div></div><p>子组件接收数据，在要显示的地方使用this.props</p>\n<div><pre><code>&lt;li&gt;{this.props.content}&lt;/li&gt;\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "React组件",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/react/03-React%E7%BB%84%E4%BB%B6/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/react/03-React%E7%BB%84%E4%BB%B6/",
      "content_html": "<h1 id=\"react组件\"> React组件</h1>\n<p>props</p>\n<p>state:存放数据</p>\n<p>setState({})修改数据</p>\n<p>当props或state发生改变时，react会重新执行render函数</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "ref属性",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/react/07-ref%E5%B1%9E%E6%80%A7/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/react/07-ref%E5%B1%9E%E6%80%A7/",
      "content_html": "<h1 id=\"ref属性\"> ref属性</h1>\n<p>ref属性是直接操作DOM的，不推荐经常使用</p>\n<div><pre><code>&lt;input id=\"inp\" className=\"input\" type=\"text\"\n       onChange={this.handleChange}\n       value={this.state.inputValue}\n       ref={(input) => {this.input = input}}\n/>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>handleChange</span><span>(</span><span>e</span><span>)</span> <span>{</span>\n  <span>// const value = e.target.value;</span>\n  <span>const</span> value <span>=</span> <span>this</span><span>.</span>input<span>.</span>value<span>;</span>\n  <span>this</span><span>.</span><span>setState</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span>\n    inputValue<span>:</span> value\n  <span>}</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "PropTypes与DefaultTypes",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/react/05-PropTypes%E4%B8%8EDefaultTypes/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/react/05-PropTypes%E4%B8%8EDefaultTypes/",
      "content_html": "<h1 id=\"proptypes与defaulttypes\"> PropTypes与DefaultTypes</h1>\n<h2 id=\"proptypes\"> PropTypes</h2>\n<p>PropTypes可以用来检验父组件传递给子组件的内容的类型</p>\n<p>使用</p>\n<ol>\n<li>在子组件中引入PropTypes</li>\n</ol>\n<div><pre><code>import PropTypes from &quot;prop-types&quot;;\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"2\">\n<li>子组件中定义要传的内容的属性</li>\n</ol>\n<div><pre><code><span>TodoItem.propTypes =</span> <span>{</span>\n  <span>content</span><span>:</span> PropTypes.string.isRequired<span>,</span>\t\t//isRequired表示必传的内容\n  <span>deleteItem</span><span>:</span> PropTypes.func<span>,</span>\n  <span>index</span><span>:</span> PropTypes.number\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这段代码要写在类外面</p>\n<h2 id=\"defaulttypes\"> DefaultTypes</h2>\n<p>给要传的内容设定默认值，如果父组件没给传递的属性传值，可通过DefaultTypes设定一个默认值</p>\n<p><strong>使用</strong></p>\n<p>在类外面加上这段代码</p>\n<div><pre><code>TodoItem.defaultProps = {\n  testDefaultProps: &#39;test defaultTypes&#39;\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "虚拟DOM",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/react/06-%E8%99%9A%E6%8B%9FDOM/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/react/06-%E8%99%9A%E6%8B%9FDOM/",
      "content_html": "<h1 id=\"虚拟dom\"> 虚拟DOM</h1>\n<ol>\n<li>state数据</li>\n<li>jsx模板</li>\n<li>数据 + 模板结合，生成真实的DOM，来显示</li>\n<li>生成虚拟DOM（虚拟DOM就是一个js对象，用它来描述真实的DOM）</li>\n</ol>\n<div><pre><code>真实DOM：<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>'</span>hello<span>'</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span>hello react<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n虚拟DOM：['div',{id: 'hello'},['span', {}, 'hello react']]\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ol start=\"5\">\n<li>state发生变化</li>\n<li>数据+模板 生成新的虚拟DOM</li>\n</ol>\n<div><pre><code>假设将数据hello react该为hello world，则会生成新的虚拟DOM\n原虚拟DOM：['div',{id: 'hello'},['span', {}, 'hello react']]\n新虚拟DOM：['div',{id: 'hello'},['span', {}, 'hello world']]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start=\"7\">\n<li>比较两个虚拟DOM，找出改变的内容</li>\n<li>直接操作DOM，改变span中的内容</li>\n</ol>\n<p>深入了解虚拟DOM</p>\n<p>render函数返回的内容实际上是调用React.createElement('标签',{属性},'内容');来完成</p>\n<p>jsx -&gt; createElement() -&gt; js对象（虚拟DOM） -&gt; 真实DOM</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "react的生命周期函数",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/react/08-react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/react/08-react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/",
      "content_html": "<h1 id=\"react的生命周期函数\"> react的生命周期函数</h1>\n<p>生命周期函数是某一时刻会自动执行的函数</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1128201/201910/1128201-20191001232453114-1666226727.png\" alt=\"react生命周期\" /></p>\n<ol>\n<li>componentWillMount：组件将要被挂载时执行</li>\n<li>render</li>\n<li>componentDidMount：组件已经被挂载时执行</li>\n<li>shouldComponentUpdate：组件更新之前执行，需返回一个布尔值</li>\n<li>componentWillUpdate：在shouldComponentUpdate返回true时执行</li>\n<li>componentDidUpdate：组件更新完成后执行</li>\n<li>componentWillReceiveProps：一个组件从父组件接收参数，只要父组件的render函数执行了，子组件的这个生命周期函数就会被执行。第一次不会执行</li>\n<li>componentWillUnmount:组件将要被解除挂载的时候执行</li>\n</ol>\n<p>实例</p>\n<p>当父组件TodoList更新时，子组件TodoItem不更新，当父组件向子组件传递内容时才更新子组件</p>\n<p>TodoItem.js</p>\n<div><pre><code><span>shouldComponentUpdate</span><span>(</span><span>nextProps<span>,</span> nextState<span>,</span> nextContext</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'TodoItem shouldComponentUpdate'</span><span>)</span><span>;</span>\n  <span>// return false;</span>\n  <span>return</span> nextProps<span>.</span>content <span>!==</span> <span>this</span><span>.</span>props<span>.</span>content<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>",
      "image": "https://img2018.cnblogs.com/blog/1128201/201910/1128201-20191001232453114-1666226727.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "使用Redux",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/react/10-%E4%BD%BF%E7%94%A8redux/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/react/10-%E4%BD%BF%E7%94%A8redux/",
      "content_html": "<h1 id=\"使用redux\"> 使用Redux</h1>\n<p>redux是一个管理数据的框架</p>\n<p>redux工作流</p>\n<h2 id=\"使用store\"> 使用store</h2>\n<p><strong>1. 安装</strong></p>\n<div><pre><code><span>yarn</span> <span>add</span> redux\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>2. 创建文件</strong></p>\n<ul>\n<li>在src目录下创建<code>store</code>文件夹</li>\n<li>在store文件夹下创建index.js文件和reducer.js文件</li>\n</ul>\n<p>index.js内容如下</p>\n<div><pre><code><span>import</span> <span>{</span>createStore<span>}</span> <span>from</span> <span>\"redux\"</span><span>;</span>\n<span>import</span> reducer <span>from</span> <span>\"./reducer\"</span><span>;</span>\n\n<span>const</span> store <span>=</span> <span>createStore</span><span>(</span>reducer<span>)</span><span>;</span>\n\n<span>export</span> <span>default</span> store<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>reducer.js内容如下</p>\n<div><pre><code><span>const</span> defaultState <span>=</span> <span>{</span>\n  <span>//存放我们要管理的数据</span>\n  inputValue<span>:</span><span>'hello'</span><span>,</span>\t\n  list<span>:</span><span>[</span><span>'122222'</span><span>,</span> <span>'hhhh'</span><span>]</span>\n<span>}</span><span>;</span>\n\n<span>export</span> <span>default</span> <span>(</span><span>state <span>=</span> defaultState<span>,</span> action</span><span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> state<span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>3. 使用</strong></p>\n<ul>\n<li>先在组件中导入store</li>\n</ul>\n<div><pre><code><span>import</span> store <span>from</span> <span>\"../../store\"</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>在组件的构造函数中使用</li>\n</ul>\n<div><pre><code><span>this</span><span>.</span>state <span>=</span> store<span>.</span><span>getState</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"使用redux-devtools\"> 使用Redux DevTools</h2>\n<p>1.在chrome浏览器中安装Redux DevTools插件</p>\n<p>2.在store目录下的index.js文件中加入下面的代码</p>\n<div><pre><code>window<span>.</span>__REDUX_DEVTOOLS_EXTENSION__ <span>&amp;&amp;</span> window<span>.</span><span>__REDUX_DEVTOOLS_EXTENSION__</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>index.js</p>\n<div><pre><code><span>import</span> <span>{</span>createStore<span>}</span> <span>from</span> <span>\"redux\"</span><span>;</span>\n<span>import</span> reducer <span>from</span> <span>\"./reducer\"</span><span>;</span>\n\n<span>const</span> store <span>=</span> <span>createStore</span><span>(</span>\n    reducer<span>,</span>\n    window<span>.</span>__REDUX_DEVTOOLS_EXTENSION__ <span>&amp;&amp;</span> window<span>.</span><span>__REDUX_DEVTOOLS_EXTENSION__</span><span>(</span><span>)</span>\n<span>)</span><span>;</span>\n\n<span>export</span> <span>default</span> store<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>3.在浏览器的开发者工具中，找到redux选项卡</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200213210327-960629.png\" alt=\"image-20200213210326833\" /></p>\n<h2 id=\"使用action\"> 使用action</h2>\n<p>先监听改变事件</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200213211554-767706.png\" alt=\"image-20200213211553739\" /></p>\n<div><pre><code><span>handleChange</span><span>(</span><span>e</span><span>)</span><span>{</span>\n    <span>//创建Action</span>\n    <span>const</span> action <span>=</span> <span>{</span>\n        type<span>:</span> <span>'change_target_value'</span><span>,</span>\t<span>//描述这个action，也可以理解为做个标记</span>\n        value<span>:</span> e<span>.</span>target<span>.</span>value\n    <span>}</span><span>;</span>\n    <span>// 转发Action</span>\n    store<span>.</span><span>dispatch</span><span>(</span>action<span>)</span><span>;</span>\n    console<span>.</span><span>log</span><span>(</span>e<span>.</span>target<span>.</span>value<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>然后在reducer.js中接收action</p>\n<div><pre><code><span>const</span> defaultState <span>=</span> <span>{</span>\n  inputValue<span>:</span><span>'hello'</span><span>,</span>\n  list<span>:</span><span>[</span><span>'122222'</span><span>,</span> <span>'hhhh'</span><span>]</span>\n<span>}</span><span>;</span>\n\n<span>export</span> <span>default</span> <span>(</span><span>state <span>=</span> defaultState<span>,</span> action</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>state<span>,</span> action<span>)</span><span>;</span>\t<span>//先打印state和action</span>\n  <span>return</span> state<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200213211953-663104.png\" alt=\"image-20200213211953650\" /></p>\n<p>reducer返回一个state数据副本，再传递给store，store接收到state数据副本后，更新自己的state</p>\n<p><em>reducer只能接收state，但不能去修改state</em></p>\n<p>reducer.js</p>\n<div><pre><code><span>const</span> defaultState <span>=</span> <span>{</span>\n  inputValue<span>:</span><span>'hello'</span><span>,</span>\n  list<span>:</span><span>[</span><span>'122222'</span><span>,</span> <span>'hhhh'</span><span>]</span>\n<span>}</span><span>;</span>\n\n<span>//reducer只能接收state，但不能去修改state</span>\n<span>export</span> <span>default</span> <span>(</span><span>state <span>=</span> defaultState<span>,</span> action</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>state<span>,</span> action<span>)</span><span>;</span>\n\n  <span>if</span> <span>(</span>action<span>.</span>type <span>===</span> <span>'change_target_value'</span><span>)</span><span>{</span>\n    <span>//先拷贝一份state</span>\n    <span>const</span> newState <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>state<span>)</span><span>)</span><span>;</span>\n    <span>//把action的值给新的state</span>\n    newState<span>.</span>inputValue <span>=</span> action<span>.</span>value<span>;</span>\n    <span>//返回新的state，这个state会传给store，store会更新它的state</span>\n    <span>return</span> newState<span>;</span>\n  <span>}</span>\n\n  <span>return</span> state<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>在组件的构造函数中监听和处理store的改变</p>\n<div><pre><code><span>//在组件的构造函数中加入这段代码</span>\n<span>//监听和处理store改变</span>\n<span>this</span><span>.</span>handleStoreChange <span>=</span> <span>this</span><span>.</span><span>handleStoreChange</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>;</span>\nstore<span>.</span><span>subscribe</span><span>(</span><span>this</span><span>.</span>handleStoreChange<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>handleStoreChange()</p>\n<div><pre><code><span>handleStoreChange</span><span>(</span><span>)</span><span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'store changed'</span><span>)</span><span>;</span>\n  <span>//监听到store数据改变时，就可以修改state了</span>\n  <span>this</span><span>.</span><span>setState</span><span>(</span>store<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200213210327-960629.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "使用axios发送网络请求",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/react/09-%E4%BD%BF%E7%94%A8axios%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/react/09-%E4%BD%BF%E7%94%A8axios%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/",
      "content_html": "<h1 id=\"使用axios发送网络请求\"> 使用axios发送网络请求</h1>\n<ol>\n<li>安装axios</li>\n</ol>\n<div><pre><code><span>yarn</span> <span>add</span> axios\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"2\">\n<li>在componentDidMount函数中使用axios</li>\n</ol>\n<div><pre><code><span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>\n  axios<span>.</span><span>get</span><span>(</span><span>'http://47.103.204.62:8083/test/get-user'</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>res<span>)</span><span>;</span>\n    <span>let</span> data <span>=</span> res<span>.</span>data<span>.</span>data<span>;</span>\n    console<span>.</span><span>log</span><span>(</span>data<span>)</span><span>;</span>\n\n    <span>let</span> newData <span>=</span> <span>[</span><span>]</span><span>;</span>\n    data<span>.</span><span>forEach</span><span>(</span><span>function</span> <span>(</span><span>currentValue<span>,</span> index</span><span>)</span> <span>{</span>\n      newData<span>.</span><span>push</span><span>(</span>currentValue<span>.</span>username<span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n    console<span>.</span><span>log</span><span>(</span>newData<span>)</span><span>;</span>\n\n    <span>this</span><span>.</span><span>setState</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>return</span><span>{</span>\n        list<span>:</span>newData\n      <span>}</span>\n    <span>}</span><span>)</span>\n  <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>err<span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "react",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/react/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/react/",
      "content_html": "<h1 id=\"react\"> react</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "react-doc",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/react/react-doc/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/react/react-doc/",
      "content_html": "<h1 id=\"react-doc\"> react-doc</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "复习",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/review/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/review/",
      "content_html": "<h1 id=\"复习\"> 复习</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "TypeScript",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/ts/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/ts/",
      "content_html": "<h1 id=\"typescript\"> TypeScript</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Vite",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/vite/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/vite/",
      "content_html": "<h1 id=\"vite\"> Vite</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Vue.js",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/vue/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/vue/",
      "content_html": "<h1 id=\"vue-js\"> Vue.js</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Vuepress 在md文件中引入图片资源",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/vue/Vuepress%E5%9C%A8md%E6%96%87%E4%BB%B6%E4%B8%AD%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/vue/Vuepress%E5%9C%A8md%E6%96%87%E4%BB%B6%E4%B8%AD%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90/",
      "content_html": "<h1 id=\"vuepress-在md文件中引入图片资源\"> Vuepress 在md文件中引入图片资源</h1>\n<h2 id=\"问题\"> 问题</h2>\n<p>我想在md文件中引入图片，结果使用了相对路径，编译后找不到图片</p>\n<h2 id=\"解决\"> 解决</h2>\n<ol>\n<li>\n<p>在.vuepress文件夹下放置图片foo.png</p>\n</li>\n<li>\n<p>在md文件中直接加入下面的代码</p>\n</li>\n</ol>\n<div><pre><code><span><span><span>&lt;</span>img</span> <span>:src</span><span><span>=</span><span>\"</span>$withBase(<span>'</span>/foo.png<span>'</span>)<span>\"</span></span> <span>alt</span><span><span>=</span><span>\"</span>foo<span>\"</span></span><span>></span></span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"原因\"> 原因</h2>\n<p>无</p>\n",
      "date_published": "2020-01-22T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "element-ui自定义图片上传",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/vue/element-ui%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/vue/element-ui%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/",
      "content_html": "<h1 id=\"element-ui自定义图片上传\"> element-ui自定义图片上传</h1>\n<p>html</p>\n<div><pre><code><span><span><span>&lt;</span>el-upload</span>\n    <span>ref</span><span><span>=</span><span>\"</span>upload2<span>\"</span></span>\n    <span>:action</span><span><span>=</span><span>\"</span>uploadImg.url<span>\"</span></span>\n    <span>:data</span><span><span>=</span><span>\"</span>uploadImg.params<span>\"</span></span>\n    <span>list-type</span><span><span>=</span><span>\"</span>picture-card<span>\"</span></span>\n    <span>multiple</span>\n    <span>name</span><span><span>=</span><span>\"</span>file<span>\"</span></span>\n    <span>:http-request</span><span><span>=</span><span>\"</span>customUpload<span>\"</span></span>\n    <span>:on-success</span><span><span>=</span><span>\"</span>uploadSuccess<span>\"</span></span>\n    <span>:auto-upload</span><span><span>=</span><span>\"</span>false<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>i</span> <span>slot</span><span><span>=</span><span>\"</span>default<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>el-icon-plus<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>i</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>slot</span><span><span>=</span><span>\"</span>file<span>\"</span></span> <span>slot-scope</span><span><span>=</span><span>\"</span>{file}<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>img</span> <span>class</span><span><span>=</span><span>\"</span>el-upload-list__item-thumbnail<span>\"</span></span> <span>:src</span><span><span>=</span><span>\"</span>file.url<span>\"</span></span> <span>alt</span><span><span>=</span><span>\"</span><span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>\"</span>el-upload-list__item-actions<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>span</span>\n            <span>class</span><span><span>=</span><span>\"</span>el-upload-list__item-preview<span>\"</span></span>\n            <span>@click</span><span><span>=</span><span>\"</span>handlePictureCardPreview(file)<span>\"</span></span>\n        <span>></span></span>\n          <span><span><span>&lt;</span>i</span> <span>class</span><span><span>=</span><span>\"</span>el-icon-zoom-in<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>i</span><span>></span></span>\n        <span><span><span>&lt;/</span>span</span><span>></span></span>\n        <span><span><span>&lt;</span>span</span>\n            <span>v-if</span><span><span>=</span><span>\"</span>!disabled<span>\"</span></span>\n            <span>class</span><span><span>=</span><span>\"</span>el-upload-list__item-delete<span>\"</span></span>\n            <span>@click</span><span><span>=</span><span>\"</span>handleDownload(file)<span>\"</span></span>\n        <span>></span></span>\n          <span><span><span>&lt;</span>i</span> <span>class</span><span><span>=</span><span>\"</span>el-icon-download<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>i</span><span>></span></span>\n        <span><span><span>&lt;/</span>span</span><span>></span></span>\n        <span><span><span>&lt;</span>span</span>\n            <span>v-if</span><span><span>=</span><span>\"</span>!disabled<span>\"</span></span>\n            <span>class</span><span><span>=</span><span>\"</span>el-upload-list__item-delete<span>\"</span></span>\n            <span>@click</span><span><span>=</span><span>\"</span>handleRemove(file)<span>\"</span></span>\n        <span>></span></span>\n          <span><span><span>&lt;</span>i</span> <span>class</span><span><span>=</span><span>\"</span>el-icon-delete<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>i</span><span>></span></span>\n        <span><span><span>&lt;/</span>span</span><span>></span></span>\n    <span><span><span>&lt;/</span>span</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>el-upload</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>methods</p>\n<div><pre><code><span>customUpload</span><span>(</span><span>params</span><span>)</span><span>{</span>\n  console<span>.</span><span>log</span><span>(</span>params<span>)</span><span>;</span>\n\n  <span>let</span> formData <span>=</span> <span>new</span> <span>FormData</span><span>(</span><span>)</span><span>;</span>\n  formData<span>.</span><span>append</span><span>(</span><span>\"file\"</span><span>,</span> params<span>.</span>file<span>)</span><span>;</span>\n  formData<span>.</span><span>append</span><span>(</span><span>\"uid\"</span><span>,</span> <span>this</span><span>.</span>$store<span>.</span>state<span>.</span>storeUserInfo<span>.</span>id<span>)</span><span>;</span>\n  formData<span>.</span><span>append</span><span>(</span><span>\"isAlbum\"</span><span>,</span> <span>1</span><span>)</span><span>;</span>\n\n  <span>request</span><span>(</span><span>{</span>\n      url<span>:</span> <span>GATEWAY_BASE_URL</span> <span>+</span> <span>IMAGE_UPLOAD_RETURN_URL</span><span>,</span>\n      method<span>:</span><span>'post'</span><span>,</span>\n      data<span>:</span> formData<span>,</span>\n      headers<span>:</span><span>{</span>\n        <span>\"content-type\"</span> <span>:</span> <span>\"multipart/form-data\"</span>\n      <span>}</span>\n  <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span>res<span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span>err<span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "vue-doc",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/vue/vue-doc/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/vue/vue-doc/",
      "content_html": "<h1 id=\"vue-doc\"> vue-doc</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Webpack",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/webpack/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/webpack/",
      "content_html": "<h1 id=\"webpack\"> Webpack</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "父子组件通信",
      "url": "http://blog.alanlee.top/blog-vuepress/front-end/vue/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/",
      "id": "http://blog.alanlee.top/blog-vuepress/front-end/vue/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/",
      "content_html": "<h1 id=\"父子组件通信\"> 父子组件通信</h1>\n<img :src=\"$withBase('/note_images/image-20200104180355527.png')\" alt=\"foo\">\n<p>父子组件通信</p>\n<p>父传子：使用props或数组</p>\n<p>子传父：使用$emit</p>\n<p>props中声明的数据与组件data函数return的数据的主要区别就是props来自父级，而data中的是组件自己的数据，作用域是组件本身，这两中数据都可以在模板template及计算属性computed和方法methods中使用。</p>\n<h5 id=\"上代码\"> 上代码</h5>\n<p>App.vue</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n    <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>img</span> <span>alt</span><span><span>=</span><span>\"</span>Vue logo<span>\"</span></span> <span>src</span><span><span>=</span><span>\"</span>./assets/logo.png<span>\"</span></span><span>></span></span>\n\n        <span><span><span>&lt;</span>h1</span> <span>class</span><span><span>=</span><span>\"</span>al-font-weight-100<span>\"</span></span><span>></span></span>练习父子组件通信<span><span><span>&lt;/</span>h1</span><span>></span></span>\n        <span><span><span>&lt;</span>div</span><span>></span></span>\n            <span><span><span>&lt;</span>el-row</span><span>></span></span>\n                <span><span><span>&lt;</span>el-col</span> <span>:span</span><span><span>=</span><span>\"</span>8<span>\"</span></span> <span>:offset</span><span><span>=</span><span>\"</span>4<span>\"</span></span><span>></span></span>\n                    <span>&lt;!-- 父传子 --></span>\n                    <span><span><span>&lt;</span>father</span><span>/></span></span>\n                <span><span><span>&lt;/</span>el-col</span><span>></span></span>\n\n                <span><span><span>&lt;</span>el-col</span> <span>:span</span><span><span>=</span><span>\"</span>8<span>\"</span></span><span>></span></span>\n                    <span>&lt;!-- 子传父 --></span>\n                    <span><span><span>&lt;</span>father2</span><span>/></span></span>\n                <span><span><span>&lt;/</span>el-col</span><span>></span></span>\n            <span><span><span>&lt;/</span>el-row</span><span>></span></span>\n        <span><span><span>&lt;/</span>div</span><span>></span></span>\n\n\n    <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n\n    <span>//父传子</span>\n    <span>import</span> father <span>from</span> <span>'./components/father.vue'</span>\n\n    <span>//子传父</span>\n    <span>import</span> father2 <span>from</span> <span>'./components/father2.vue'</span>\n\n\n    <span>export</span> <span>default</span> <span>{</span>\n        name<span>:</span> <span>'app'</span><span>,</span>\n        components<span>:</span> <span>{</span>\n            father<span>,</span> father2\n        <span>}</span><span>,</span>\n\n    <span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\n\n<span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n    <span><span>@import</span> <span>\"style/al-css/al-css.css\"</span><span>;</span></span>\n\n    <span>#app</span> <span>{</span>\n        <span>font-family</span><span>:</span> <span>'Avenir'</span><span>,</span> Helvetica<span>,</span> Arial<span>,</span> sans-serif<span>;</span>\n        <span>-webkit-font-smoothing</span><span>:</span> antialiased<span>;</span>\n        <span>-moz-osx-font-smoothing</span><span>:</span> grayscale<span>;</span>\n        <span>text-align</span><span>:</span> center<span>;</span>\n        <span>color</span><span>:</span> #2c3e50<span>;</span>\n        <span>background-color</span><span>:</span> #FCFCFC<span>;</span>\n    <span>}</span>\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><hr>\n<h4 id=\"父传子-使用props\"> 父传子（使用props）：</h4>\n<img :src=\"$withBase('/note_images/父传子.gif')\" alt=\"父传子\">\n<p>father.vue</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n    <span><span><span>&lt;</span>div</span><span>></span></span>\n        <span><span><span>&lt;</span>h3</span> <span>class</span><span><span>=</span><span>\"</span>al-m-20px al-font-weight-100<span>\"</span></span><span>></span></span>父组件向子组件传递数据<span><span><span>&lt;/</span>h3</span><span>></span></span>\n        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>al-box-shadow-radius al-m-20px al-p-20px<span>\"</span></span><span>></span></span>\n            <span><span><span>&lt;</span>h4</span> <span>class</span><span><span>=</span><span>\"</span>al-m-20px al-font-weight-100<span>\"</span></span><span>></span></span>父组件<span><span><span>&lt;/</span>h4</span><span>></span></span>\n            <span><span><span>&lt;</span>el-input</span> <span>v-model</span><span><span>=</span><span>\"</span>inputData<span>\"</span></span>\n                      <span>placeholder</span><span><span>=</span><span>\"</span>输入要传递给子组件的内容<span>\"</span></span><span>/></span></span>\n\n            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>al-m-20px<span>\"</span></span><span>></span></span>\n                <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>\"</span>primary<span>\"</span></span>\n                           <span>@click</span><span><span>=</span><span>\"</span>sendData<span>\"</span></span><span>></span></span>向子组件传值<span><span><span>&lt;/</span>el-button</span><span>></span></span>\n            <span><span><span>&lt;/</span>div</span><span>></span></span>\n\n            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>al-bg-color-grey-lv4 al-p-20px<span>\"</span></span><span>></span></span>\n                <span><span><span>&lt;</span>h4</span> <span>class</span><span><span>=</span><span>\"</span>al-m-10px al-font-weight-100<span>\"</span></span><span>></span></span>子组件<span><span><span>&lt;/</span>h4</span><span>></span></span>\n\n                <span>&lt;!--引入子组件--></span>\n                <span><span><span>&lt;</span>son</span> <span>:receive-data</span><span><span>=</span><span>\"</span>fatherData<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>al-m-20px<span>\"</span></span><span>/></span></span>\n            <span><span><span>&lt;/</span>div</span><span>></span></span>\n\n        <span><span><span>&lt;/</span>div</span><span>></span></span>\n    <span><span><span>&lt;/</span>div</span><span>></span></span>\n\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n    <span>import</span> son <span>from</span> <span>'./son'</span>\n    <span>export</span> <span>default</span> <span>{</span>\n        name<span>:</span> <span>\"father\"</span><span>,</span>\n        components<span>:</span><span>{</span>\n            son\n        <span>}</span><span>,</span>\n        <span>data</span><span>(</span><span>)</span><span>{</span>\n          <span>return</span><span>{</span>\n              inputData<span>:</span><span>''</span><span>,</span>\n              fatherData<span>:</span><span>null</span>\n          <span>}</span>\n        <span>}</span><span>,</span>\n\n        methods<span>:</span><span>{</span>\n            <span>sendData</span><span>:</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n                <span>this</span><span>.</span>fatherData <span>=</span> <span>this</span><span>.</span>inputData<span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n    <span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\n<span><span><span>&lt;</span>style</span> <span>scoped</span><span>></span></span><span><span>\n\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><p>son.vue</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n    <span><span><span>&lt;</span>div</span><span>></span></span>\n        <span><span><span>&lt;</span>div</span><span>></span></span>\n            接收到的父组件数据：\n            <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>\"</span>al-text-color-blue<span>\"</span></span><span>></span></span>{{this.receiveData}}<span><span><span>&lt;/</span>span</span><span>></span></span>\n\n        <span><span><span>&lt;/</span>div</span><span>></span></span>\n\n    <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n    <span>export</span> <span>default</span> <span>{</span>\n        name<span>:</span> <span>\"son\"</span><span>,</span>\n        props<span>:</span><span>{</span>\n            receiveData<span>:</span>String\n        <span>}</span>\n\n    <span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\n<span><span><span>&lt;</span>style</span> <span>scoped</span><span>></span></span><span><span>\n\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h4 id=\"子传父\"> 子传父</h4>\n<img :src=\"$withBase('/note_images/子传父.gif')\" alt=\"子传父\">\n<p>father2.vue</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n    <span><span><span>&lt;</span>div</span><span>></span></span>\n        <span><span><span>&lt;</span>div</span><span>></span></span>\n            <span><span><span>&lt;</span>h3</span> <span>class</span><span><span>=</span><span>\"</span>al-m-20px al-font-weight-100<span>\"</span></span><span>></span></span>子组件向父组件传递数据<span><span><span>&lt;/</span>h3</span><span>></span></span>\n            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>al-box-shadow-radius al-m-20px al-p-20px<span>\"</span></span><span>></span></span>\n                <span><span><span>&lt;</span>h4</span> <span>class</span><span><span>=</span><span>\"</span>al-m-20px al-font-weight-100<span>\"</span></span><span>></span></span>父组件<span><span><span>&lt;/</span>h4</span><span>></span></span>\n\n                <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>al-m-20px<span>\"</span></span><span>></span></span>\n                    接收到的子组件的数据：\n                    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>\"</span>al-text-color-blue<span>\"</span></span><span>></span></span>{{this.receiveData}}<span><span><span>&lt;/</span>span</span><span>></span></span>\n                <span><span><span>&lt;/</span>div</span><span>></span></span>\n\n                <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>al-bg-color-grey-lv4 al-p-20px<span>\"</span></span><span>></span></span>\n                    <span><span><span>&lt;</span>h4</span> <span>class</span><span><span>=</span><span>\"</span>al-m-10px al-font-weight-100<span>\"</span></span><span>></span></span>子组件<span><span><span>&lt;/</span>h4</span><span>></span></span>\n                    <span>&lt;!--引入子组件--></span>\n                    <span>&lt;!-- 注意事件名不要加括号，不然没有作用 --></span>\n                    <span><span><span>&lt;</span>son2</span> <span>@sonData</span><span><span>=</span><span>\"</span>receiveSonData<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>al-m-20px<span>\"</span></span><span>/></span></span>\n                <span><span><span>&lt;/</span>div</span><span>></span></span>\n\n            <span><span><span>&lt;/</span>div</span><span>></span></span>\n        <span><span><span>&lt;/</span>div</span><span>></span></span>\n    <span><span><span>&lt;/</span>div</span><span>></span></span>\n\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n    <span>import</span> son2 <span>from</span> <span>'./son2'</span>\n\n    <span>export</span> <span>default</span> <span>{</span>\n        name<span>:</span> <span>\"father2\"</span><span>,</span>\n        components<span>:</span> <span>{</span>\n            son2\n        <span>}</span><span>,</span>\n        <span>data</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>{</span>\n                receiveData<span>:</span> <span>null</span>   <span>//接收的数据</span>\n            <span>}</span>\n        <span>}</span><span>,</span>\n\n        methods<span>:</span> <span>{</span>\n            <span>//接收子组件的数据</span>\n            <span>receiveSonData</span><span>:</span> <span>function</span> <span>(</span><span>data</span><span>)</span> <span>{</span>\n                <span>this</span><span>.</span>receiveData <span>=</span> data<span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n    <span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\n<span><span><span>&lt;</span>style</span> <span>scoped</span><span>></span></span><span><span>\n\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><p>son2.vue</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n    <span><span><span>&lt;</span>div</span><span>></span></span>\n        <span><span><span>&lt;</span>div</span><span>></span></span>\n            <span><span><span>&lt;</span>el-input</span> <span>v-model</span><span><span>=</span><span>\"</span>inputData<span>\"</span></span> <span>placeholder</span><span><span>=</span><span>\"</span>输入要传递给父组件的数据<span>\"</span></span><span>/></span></span>\n\n            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>al-m-20px<span>\"</span></span><span>></span></span>\n                <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>\"</span>primary<span>\"</span></span>\n                           <span>@click</span><span><span>=</span><span>\"</span>sendData()<span>\"</span></span><span>></span></span>向父组件传值<span><span><span>&lt;/</span>el-button</span><span>></span></span>\n            <span><span><span>&lt;/</span>div</span><span>></span></span>\n\n        <span><span><span>&lt;/</span>div</span><span>></span></span>\n\n    <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n    <span>export</span> <span>default</span> <span>{</span>\n        name<span>:</span> <span>\"son2\"</span><span>,</span>\n        <span>data</span><span>(</span><span>)</span><span>{</span>\n            <span>return</span><span>{</span>\n                inputData<span>:</span><span>''</span><span>,</span>   <span>//保存输入的数据</span>\n                sonData<span>:</span><span>null</span>    <span>//子组件的数据</span>\n            <span>}</span>\n        <span>}</span><span>,</span>\n\n        methods<span>:</span><span>{</span>\n            <span>sendData</span><span>:</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n                <span>this</span><span>.</span>sonData <span>=</span> <span>this</span><span>.</span>inputData<span>;</span>\n                <span>this</span><span>.</span><span>$emit</span><span>(</span><span>'sonData'</span><span>,</span> <span>this</span><span>.</span>sonData<span>)</span><span>;</span>    <span>//发送给父组件</span>\n            <span>}</span>\n        <span>}</span>\n\n    <span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\n<span><span><span>&lt;</span>style</span> <span>scoped</span><span>></span></span><span><span>\n\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p>在子组件中，使用$emit时，第一个参数是自定义的事件名，第二个参数是要发送的数据</p>\n<p>在父组件中，在子组件标签中先使用v-on来监听子组件触发的自定义事件，注意事件名不要加括号，不然没有作用。</p>\n",
      "date_published": "2020-01-22T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Project home",
      "url": "http://blog.alanlee.top/blog-vuepress/home/",
      "id": "http://blog.alanlee.top/blog-vuepress/home/",
      "content_html": "<p>This is an example of a normal homepage. You can place your main content here.</p>\n<p>To use this layout, you need to set <code>home: true</code> in the page front matter.</p>\n<p>For related descriptions of configuration items, please see <a href=\"https://vuepress-theme-hope.github.io/guide/layout/home/\" target=\"_blank\" rel=\"noopener noreferrer\">Project HomePage Layout Config</a>.</p>\n",
      "date_published": "2021-10-03T03:15:29.000Z",
      "date_modified": "2021-10-03T03:15:29.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Android知识总结",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/android/Android%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/android/Android%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/",
      "content_html": "<h1 id=\"android知识总结\"> Android知识总结</h1>\n<h2 id=\"android系统架构\"> Android系统架构</h2>\n<p>Android系统架构分为4层</p>\n<ol>\n<li>Linux内核层</li>\n<li>系统运行库层</li>\n<li>应用框架层</li>\n<li>应用层</li>\n</ol>\n<p><img src=\"https://bkimg.cdn.bcebos.com/pic/2fdda3cc7cd98d10ac7dfab52b3fb80e7aec908d?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5\" alt=\"img\" /></p>\n<h2 id=\"android四大组件-一-活动\"> Android四大组件（一） - 活动</h2>\n<ol>\n<li>Activity（活动）</li>\n<li>Service（服务）</li>\n<li>Broadcast Receiver（广播接收器）</li>\n<li>Content Provider（内容提供者）</li>\n</ol>\n<h3 id=\"activity-活动\"> Activity（活动）</h3>\n<p>一个Activity活动就是一个页面</p>\n<h4 id=\"创建活动\"> 创建活动</h4>\n<p>创建好活动需要在AndroidManifest.xml文件中注册Activity。加上<code>&lt;intent-filter&gt;</code>标签可以使该活动作为第一个显示的页面。</p>\n<h4 id=\"销毁活动\"> 销毁活动</h4>\n<p>有2种方式</p>\n<ol>\n<li>按返回按键</li>\n<li>使用Activity类提供的finish方法</li>\n</ol>\n<h4 id=\"使用intent跳转页面-活动\"> 使用Intent跳转页面（活动）</h4>\n<p>Intent又分为显式Intent和隐式Intent</p>\n<ul>\n<li>显式Intent：只能启动本应用的Activity</li>\n<li>隐式Intetn：可以启动本应用的Activity和其他应用的Activity</li>\n</ul>\n<h5 id=\"显式intent\"> 显式Intent</h5>\n<div><pre><code><span>Intent</span> intent <span>=</span> <span>new</span> <span>Intent</span><span>(</span><span>this</span><span>,</span> <span>XxxActivity</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>startActivity</span><span>(</span>intent<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h5 id=\"隐式intent\"> 隐式Intent</h5>\n<p>在AndroidManifest.xml的Activity的intent-filter标签中添加category标签</p>\n<div><pre><code><span>Intent</span> intent <span>=</span> <span>new</span> <span>Intent</span><span>(</span><span>\"com.xxx.xxx.XxxAction\"</span><span>)</span><span>;</span>\nintent<span>.</span><span>addCategory</span><span>(</span><span>\"com.xxx.xxx.XxxCategory\"</span><span>)</span><span>;</span>\n<span>startActivity</span><span>(</span>intent<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h5 id=\"使用intent跳转页面时传递数据\"> 使用Intent跳转页面时传递数据</h5>\n<p>使用Intent的putExtra()方法可以传递数据</p>\n<p>使用Activity类的getIntent()方法接收传递过来的数据，可以接收多种类型的数据，有不同的实现方法。</p>\n<h5 id=\"跳转页面后-返回上一个页面时需要带上数据\"> 跳转页面后，返回上一个页面时需要带上数据</h5>\n<p>使用startActivityForResult()方法，该方法有2个参数，第一个为Intent对象，第二个为请求码，用于标识数据的来源，判断是否是这个Activity来接收。还需要处理用户按下返回键的行为，因为不做处理的情况下，按下返回键并不能带着数据返回给上一个Activity，所以要重写返回按钮的监听事件onBackPressed方法，加入处理代码即可。</p>\n<h4 id=\"活动的生命周期\"> 活动的生命周期</h4>\n<p>Android是使用任务来保存Activity的，该任务是一个桟，打开一个活动就往桟里添加一个数据，退出一个页面就弹出一个数据，显示栈顶数据给用户。</p>\n<h5 id=\"活动的状态\"> 活动的状态</h5>\n<ol>\n<li>运行状态</li>\n<li>暂停状态</li>\n<li>停止状态</li>\n<li>销毁状态</li>\n</ol>\n<p>生命周期图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/19899316-00e4bd10008c4788.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/485/format/webp\" alt=\"img\" /></p>\n<h4 id=\"活动的启动模式\"> 活动的启动模式</h4>\n<ol>\n<li>standard</li>\n<li>singleTop</li>\n<li>singleTask</li>\n<li>singleInstance</li>\n</ol>\n<h2 id=\"常用控件\"> 常用控件</h2>\n<ol>\n<li>TextView</li>\n<li>Button</li>\n<li>EditView</li>\n<li>ImageView</li>\n<li>ProgressBar</li>\n<li>AlertDialog</li>\n<li>ProgressDialog</li>\n<li>ListView</li>\n<li>RecycleView</li>\n</ol>\n<p>ListView和RecycleView需要准备适配器来准备数据</p>\n<h2 id=\"常用布局\"> 常用布局</h2>\n<ol>\n<li>线性布局LinearLayout</li>\n<li>相对布局RelativeLayout</li>\n<li>帧布局FrameLayout</li>\n<li>百分比布局PercentFrameLayout</li>\n</ol>\n<h2 id=\"fragment-碎片\"> Fragment（碎片）</h2>\n<p>Fragment的生命周期</p>\n<h2 id=\"android四大组件-二-广播接收器\"> Android四大组件（二） - 广播接收器</h2>\n<p>广播接收器分类2种，一种是标准广播，另一种是有序广播。</p>\n<h3 id=\"动态注册广播\"> 动态注册广播</h3>\n<h3 id=\"静态注册广播\"> 静态注册广播</h3>\n",
      "image": "https://bkimg.cdn.bcebos.com/pic/2fdda3cc7cd98d10ac7dfab52b3fb80e7aec908d?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "移动端",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/",
      "content_html": "<h1 id=\"移动端\"> 移动端</h1>\n<img :src=\"$withBase=('/note_images/移动端.png')\"/>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Android",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/android/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/android/",
      "content_html": "<h1 id=\"android\"> Android</h1>\n<img :src=\"$withBase=('/note_images/android.jpg')\"/>\n<p>安卓（Android）是一种基于Linux的自由及开放源代码的操作系统。主要使用于移动设备，如智能手机和平板电脑，由Google公司和开放手机联盟领导及开发。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "遇到的问题",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter00%20-%20%E9%97%AE%E9%A2%98/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter00%20-%20%E9%97%AE%E9%A2%98/",
      "content_html": "<h1 id=\"遇到的问题\"> 遇到的问题</h1>\n<h2 id=\"问题1\"> 问题1</h2>\n<p>添加完image_picker插件后热更新，出现该错误</p>\n<div><pre><code>E/flutter ( 6251): [ERROR:flutter/lib/ui/ui_dart_state.cc(157)] Unhandled Exception: MissingPluginException(No implementation found for method pickImage on channel plugins.flutter.io/image_picker)\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"问题2\"> 问题2</h2>\n<p>添加完image_picker插件后重新运行，出现该错误</p>\n<div><pre><code>Launching lib\\main.dart on MI 8 in debug mode...\n[!] Your app isn&#39;t using AndroidX.\n    To avoid potential build failures, you can quickly migrate your app by following the steps on https://goo.gl/CP92wY.\nRunning Gradle task &#39;assembleDebug&#39;...\nF:\\Code\\MyCode\\Flutter\\learn\\my_flutter_app\\practice09_test\\android\\app\\src\\debug\\AndroidManifest.xml:22:18-91 Error:\n\tAttribute application@appComponentFactory value=(android.support.v4.app.CoreComponentFactory) from [com.android.support:support-compat:28.0.0] AndroidManifest.xml:22:18-91\n\tis also present at [androidx.core:core:1.0.2] AndroidManifest.xml:22:18-86 value=(androidx.core.app.CoreComponentFactory).\n\tSuggestion: add &#39;tools:replace=&quot;android:appComponentFactory&quot;&#39; to &lt;application&gt; element at AndroidManifest.xml:8:5-29:19 to override.\n\nFAILURE: Build failed with an exception.\n\n* What went wrong:\nExecution failed for task &#39;:app:processDebugManifest&#39;.\n&gt; Manifest merger failed : Attribute application@appComponentFactory value=(android.support.v4.app.CoreComponentFactory) from [com.android.support:support-compat:28.0.0] AndroidManifest.xml:22:18-91\n  \tis also present at [androidx.core:core:1.0.2] AndroidManifest.xml:22:18-86 value=(androidx.core.app.CoreComponentFactory).\n  \tSuggestion: add &#39;tools:replace=&quot;android:appComponentFactory&quot;&#39; to &lt;application&gt; element at AndroidManifest.xml:8:5-29:19 to override.\n\n* Try:\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.\n\n* Get more help at https://help.gradle.org\n\nBUILD FAILED in 16s\nAndroidX incompatibilities may have caused this build to fail. Please migrate your app to AndroidX. See https://goo.gl/CP92wY.\nFinished with error: Gradle task assembleDebug failed with exit code 1\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id=\"问题3\"> 问题3</h2>\n<div><pre><code>FAILURE: Build failed with an exception.\n\n* What went wrong:\nA problem occurred configuring root project &#39;android&#39;.\n&gt; Could not resolve all artifacts for configuration &#39;:classpath&#39;.\n   &gt; Could not download kotlin-compiler-embeddable.jar (org.jetbrains.kotlin:kotlin-compiler-embeddable:1.2.71)\n      &gt; Could not get resource &#39;https://jcenter.bintray.com/org/jetbrains/kotlin/kotlin-compiler-embeddable/1.2.71/kotlin-compiler-embeddable-1.2.71.jar&#39;.\n         &gt; Read timed out\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"解决方法\"> 解决方法</h3>\n<p>在project下的build.gradle文件中找到buildscript和allprojects节点下的repositories</p>\n<p>将</p>\n<div><pre><code><span>google</span><span>(</span><span>)</span>\n<span>jcenter</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>换成下面的内容</p>\n<div><pre><code>maven <span>{</span> url 'https<span>:</span>//maven.aliyun.com/repository/google' <span>}</span>\nmaven <span>{</span> url 'https<span>:</span>//maven.aliyun.com/repository/jcenter' <span>}</span>\nmaven <span>{</span> url 'http<span>:</span>//maven.aliyun.com/nexus/content/groups/public' <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200421151647-789815.png\" alt=\"image-20200421151645216\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200421151707-842748.png\" alt=\"image-20200421151707050\" /></p>\n<h2 id=\"问题3-2\"> 问题3</h2>\n<p>控制台出现 Waiting for another flutter command to release the startup lock...</p>\n<h3 id=\"解决\"> 解决</h3>\n<p>先在任务管理器中把所有的dart.exe的进程杀掉，</p>\n<p>然后进入到flutter的sdk的flutter\\bin\\cache目录下，把lockfile文件给删除掉即可</p>\n<h2 id=\"问题4\"> 问题4</h2>\n<p>Another exception was thrown: NoSuchMethodError: The method 'pushNamed' was called on null.</p>\n<h3 id=\"原因\"> 原因</h3>\n<p>原因是我建了一个全局类，定义了navigatorKey，而没有在MaterialApp里添加navigatorKey，导致这个错误</p>\n<h3 id=\"解决-2\"> 解决</h3>\n<p>在MaterialApp里添加navigatorKey</p>\n<div><pre><code>navigatorKey<span>:</span> <span>GlobalUtils</span><span>.</span>navigatorKey<span>,</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"问题5\"> 问题5</h2>\n<p>E/flutter (20769): [ERROR:flutter/lib/ui/ui_dart_state.cc(157)] Unhandled Exception: NoSuchMethodError: The method 'add' was called on null.\nE/flutter (20769): Receiver: null</p>\n<h3 id=\"原因-2\"> 原因</h3>\n<p>method 'add' 是List的add方法，出现这个问题是因为add了null值，但是我这边的数据不是null值，最后找到原因是定义List的时候没有给它初始化一下。</p>\n<h3 id=\"解决-3\"> 解决</h3>\n<p>之前没有初始化的定义为</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>AppointmentEntity</span><span>></span></span> _appointmentList <span>=</span> <span>[</span><span>]</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>给它加上<code>= [];</code> 就解决问题了</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>AppointmentEntity</span><span>></span></span> _appointmentList <span>=</span> <span>[</span><span>]</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"问题6\"> 问题6</h2>\n<p>No connected devices found; please connect a device, or see flutter.io/setup for getting started instructions.</p>\n<h3 id=\"解决-4\"> 解决</h3>\n<p>在flutter的sdk，目录下找到flutter_console.bat 文件，双击运行</p>\n<p>输入</p>\n<div><pre><code>flutter config --android-sdk &quot;D:\\SDK\\Android&quot;\n</code></pre>\n<div><span>1</span><br></div></div><p>&quot;D:\\SDK\\Android&quot;为Android的SDK目录</p>\n<p>重启IDE即可</p>\n<h2 id=\"问题7\"> 问题7</h2>\n<h3 id=\"问题\"> 问题</h3>\n<p>Unhandled Exception: MissingPluginException(No implementation found for method launch on channel)</p>\n<h3 id=\"解决-5\"> 解决</h3>\n<p>先停止APP，再重新启动即可</p>\n<h2 id=\"问题8\"> 问题8</h2>\n<p>Vertical viewport was given unbounded height.\nThe relevant error-causing widget was: ListView file:///G:/MyCode/Android/Project/flutter-panda-appointment/lib/pages/user/user_page.dart:97:35</p>\n<p>这个问题主要是<code>ListView.builder</code>出现的问题，如果是简单用的话，会出现这个问题的话，这时候，我们只需要在ListView.builder加入<code>shrinkWrap: true,</code></p>\n<div><pre><code>child<span>:</span> <span>ListView</span><span>.</span><span>builder</span><span>(</span>\n    itemCount<span>:</span> _appointmentList<span>.</span>length<span>,</span>\n    shrinkWrap<span>:</span> <span>true</span><span>,</span>\n    itemBuilder<span>:</span> <span>(</span>context<span>,</span> int index<span>)</span><span>{</span>\n        <span>return</span> <span>AppointmentInfoItem</span><span>(</span>_appointmentList<span>[</span>index<span>]</span><span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>,</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"问题9\"> 问题9</h2>\n<p>Flutter ListView嵌套在children中不能滚动</p>\n<h3 id=\"解决-6\"> 解决</h3>\n<p>使用Flex包裹Expanded，Expanded再包裹ListView</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200505132808858.png\" alt=\"image-20200505132808858\" /></p>\n<h2 id=\"问题10\"> 问题10</h2>\n<p>TabbarView在Container中不显示</p>\n<h3 id=\"解决-7\"> 解决</h3>\n<p>Container指定高度即可</p>\n<div><pre><code>height<span>:</span> double<span>.</span>maxFinite<span>,</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"问题11\"> 问题11</h2>\n<p>Swiper不能嵌套在有children属性的组件中</p>\n<h3 id=\"解决-8\"> 解决</h3>\n<p>用Container包裹，并且一定要指定Container的高度</p>\n<h2 id=\"问题12\"> 问题12</h2>\n<p>在有输入框的情况下，呼出键盘，导致屏幕溢出错误</p>\n<h3 id=\"解决-9\"> 解决</h3>\n<p>在Scaffold中添加<code>resizeToAvoidBottomPadding: false,</code></p>\n<div><pre><code><span>return</span> <span>Scaffold</span><span>(</span>\n  resizeToAvoidBottomPadding<span>:</span> <span>false</span><span>,</span>\n  appBar<span>:</span> <span>.</span><span>.</span><span>.</span>\n  body<span>:</span> <span>.</span><span>.</span><span>.</span>\n<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200421151647-789815.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "去除debug字样",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter01%20-%20%E5%8E%BB%E9%99%A4debug%E5%AD%97%E6%A0%B7/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter01%20-%20%E5%8E%BB%E9%99%A4debug%E5%AD%97%E6%A0%B7/",
      "content_html": "<h1 id=\"去除debug字样\"> 去除debug字样</h1>\n<p>在MaterialApp中添加如下代码</p>\n<div><pre><code>debugShowCheckedModeBanner<span>:</span> <span>false</span><span>,</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>例如</p>\n<div><pre><code><span>class</span> <span>MyApp</span> <span>extends</span> <span>StatelessWidget</span> <span>{</span>\n  <span>@override</span>\n  <span>Widget</span> <span>build</span><span>(</span><span>BuildContext</span> context<span>)</span> <span>{</span>\n    <span>return</span> <span>MaterialApp</span><span>(</span>\n      title<span>:</span> <span>'MyApp'</span><span>,</span>\n      debugShowCheckedModeBanner<span>:</span> <span>false</span><span>,</span>\t<span>//去除debug字样</span>\n      theme<span>:</span> <span>ThemeData</span><span>(</span>\n        primarySwatch<span>:</span> <span>Colors</span><span>.</span>blue<span>,</span>\n      <span>)</span><span>,</span>\n      home<span>:</span> <span>MyHomePage</span><span>(</span><span>)</span><span>,</span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "状态栏透明",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter02%20-%20%E7%8A%B6%E6%80%81%E6%A0%8F%E9%80%8F%E6%98%8E/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter02%20-%20%E7%8A%B6%E6%80%81%E6%A0%8F%E9%80%8F%E6%98%8E/",
      "content_html": "<h1 id=\"状态栏透明\"> 状态栏透明</h1>\n<p>在main函数中添加如下代码</p>\n<div><pre><code><span>if</span> <span>(</span><span>Platform</span><span>.</span>isAndroid<span>)</span> <span>{</span>\n    <span>// 以下两行 设置android状态栏为透明的沉浸。写在组件渲染之后，是为了在渲染后进行set赋值，覆盖状态栏，写在渲染之前MaterialApp组件会覆盖掉这个值。</span>\n    <span>SystemUiOverlayStyle</span> systemUiOverlayStyle <span>=</span>\n        <span>SystemUiOverlayStyle</span><span>(</span>statusBarColor<span>:</span> <span>Colors</span><span>.</span>transparent<span>)</span><span>;</span>\n    <span>SystemChrome</span><span>.</span><span>setSystemUIOverlayStyle</span><span>(</span>systemUiOverlayStyle<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>\n<p>示例</p>\n<div><pre><code><span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n  <span>runApp</span><span>(</span><span>new</span> <span>MyApp</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  <span>if</span> <span>(</span><span>Platform</span><span>.</span>isAndroid<span>)</span> <span>{</span>\n    <span>// 以下两行 设置android状态栏为透明的沉浸。写在组件渲染之后，是为了在渲染后进行set赋值，覆盖状态栏，写在渲染之前MaterialApp组件会覆盖掉这个值。</span>\n    <span>SystemUiOverlayStyle</span> systemUiOverlayStyle <span>=</span>\n    <span>SystemUiOverlayStyle</span><span>(</span>statusBarColor<span>:</span> <span>Colors</span><span>.</span>transparent<span>)</span><span>;</span>\n    <span>SystemChrome</span><span>.</span><span>setSystemUIOverlayStyle</span><span>(</span>systemUiOverlayStyle<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></blockquote>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "解决依赖冲突",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter03%20-%20%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter03%20-%20%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81/",
      "content_html": "<h1 id=\"解决依赖冲突\"> 解决依赖冲突</h1>\n<p>以image_picker插件为例</p>\n<div><pre><code><span>dependencies</span><span>:</span>\n  <span>flutter</span><span>:</span>\n    <span>sdk</span><span>:</span> flutter\n  <span>image_picker</span><span>:</span> <span>'0.6.5'</span>\t\t<span># 添加image_picker的依赖</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面指定了版本，如果出现如下错误，</p>\n<div><pre><code>depends on image_picker &gt;=0.6.2+3 which requires Flutter SDK version &gt;=1.10.0 &lt;2.0.0, version solving failed.\n</code></pre>\n<div><span>1</span><br></div></div><p>解决</p>\n<p>将版本号改为any</p>\n<div><pre><code><span>dependencies</span><span>:</span>\n  <span>flutter</span><span>:</span>\n    <span>sdk</span><span>:</span> flutter\n  <span>image_picker</span><span>:</span> any\t\t<span># 添加image_picker的依赖</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "JSON序列化",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter04%20-%20JSON%E5%BA%8F%E5%88%97%E5%8C%96/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter04%20-%20JSON%E5%BA%8F%E5%88%97%E5%8C%96/",
      "content_html": "<h1 id=\"json序列化\"> JSON序列化</h1>\n<h2 id=\"安装插件\"> 安装插件</h2>\n<p>安装插件JsonToDartAction</p>\n<h2 id=\"创建目录\"> 创建目录</h2>\n<p>创建models目录，用来存放model类</p>\n<h2 id=\"使用插件生成model\"> 使用插件生成model</h2>\n<p>在models目录下右键 选择 New -&gt; JsonToDartAction</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200422204129695.png\" alt=\"image-20200422204129695\" /></p>\n<p>填写相应的数据</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200422204500032.png\" alt=\"image-20200422204500032\" /></p>\n<p>点击make之后会生成对应的model类和一个generated文件夹</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200422204849666.png\" alt=\"image-20200422204849666\" /></p>\n<h2 id=\"使用\"> 使用</h2>\n<p>在xxx_entity_helper.dart文件中有一个xxxEntityFromJson()方法，调用该方法，返回数据</p>\n<p>以用户model为例</p>\n<div><pre><code><span>var</span> userEntity <span>=</span> <span>userEntityFromJson</span><span>(</span><span>UserEntity</span><span>(</span><span>)</span><span>,</span> res<span>[</span><span>\"data\"</span><span>]</span><span>)</span><span>;</span>\n<span>print</span><span>(</span>userEntity<span>.</span>username<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200422204129695.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "使用路由",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter05%20-%20%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter05%20-%20%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1/",
      "content_html": "<h1 id=\"使用路由\"> 使用路由</h1>\n<p>页面跳转时需要使用到路由</p>\n<h2 id=\"普通页面跳转\"> 普通页面跳转</h2>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200422160807936.png\" alt=\"image-20200422160807936\" /></p>\n<p>代码</p>\n<div><pre><code><span>FlatButton</span><span>(</span>\n    child<span>:</span> <span>Text</span><span>(</span><span>\"跳转到page 1\"</span><span>)</span><span>,</span>\n    textColor<span>:</span> <span>Colors</span><span>.</span>blue<span>,</span>\n    onPressed<span>:</span> <span>(</span><span>)</span> <span>{</span>\n        <span>//导航到新路由</span>\n        <span>Navigator</span><span>.</span><span>push</span><span>(</span> context<span>,</span>\n                      <span>MaterialPageRoute</span><span>(</span>builder<span>:</span> <span>(</span>context<span>)</span> <span>{</span>\n                           <span>return</span> <span>Page1</span><span>(</span><span>)</span><span>;</span>\n                       <span>}</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span><span>,</span>\n<span>)</span><span>,</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"带参数跳转\"> 带参数跳转</h2>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200422161234728.png\" alt=\"image-20200422161234728\" /></p>\n<p>main.dart</p>\n<div><pre><code><span>//跳转时带参数</span>\n<span>FlatButton</span><span>(</span>\n    child<span>:</span> <span>Text</span><span>(</span><span>\"跳转到page 2\"</span><span>)</span><span>,</span>\n    textColor<span>:</span> <span>Colors</span><span>.</span>deepOrange<span>,</span>\n    onPressed<span>:</span> <span>(</span><span>)</span> <span>async</span> <span>{</span>\n        <span>// 打开`Page2`，并等待返回结果</span>\n        <span>var</span> result <span>=</span> <span>await</span> <span>Navigator</span><span>.</span><span>push</span><span>(</span>\n            context<span>,</span>\n            <span>MaterialPageRoute</span><span>(</span>\n                builder<span>:</span> <span>(</span>context<span>)</span> <span>{</span>\n                    <span>return</span> <span>Page2</span><span>(</span>\n                        <span>// 路由参数</span>\n                        text<span>:</span> <span>\"我是 路由参数 内容\"</span><span>,</span>\n                    <span>)</span><span>;</span>\n                <span>}</span><span>,</span>\n            <span>)</span><span>,</span>\n        <span>)</span><span>;</span>\n        <span>//输出`TipRoute`路由返回结果</span>\n        <span>print</span><span>(</span><span>\"路由返回值: $result\"</span><span>)</span><span>;</span>\n    <span>}</span><span>,</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>page2.dart</p>\n<div><pre><code><span>import</span> <span>'package:flutter/cupertino.dart'</span><span>;</span>\n<span>import</span> <span>'package:flutter/material.dart'</span><span>;</span>\n\n<span>class</span> <span>Page2</span> <span>extends</span> <span>StatelessWidget</span> <span>{</span>\n  <span>Page2</span><span>(</span><span>{</span>\n    <span>Key</span> key<span>,</span>\n    <span>@required</span> <span>this</span><span>.</span>text<span>,</span>  <span>// 接收一个text参数</span>\n  <span>}</span><span>)</span> <span>:</span> <span>super</span><span>(</span>key<span>:</span> key<span>)</span><span>;</span>\n  <span>final</span> <span>String</span> text<span>;</span>\n\n  <span>@override</span>\n  <span>Widget</span> <span>build</span><span>(</span><span>BuildContext</span> context<span>)</span> <span>{</span>\n    <span>return</span> <span>Scaffold</span><span>(</span>\n      appBar<span>:</span> <span>AppBar</span><span>(</span>\n        title<span>:</span> <span>Text</span><span>(</span><span>\"提示\"</span><span>)</span><span>,</span>\n      <span>)</span><span>,</span>\n      body<span>:</span> <span>Padding</span><span>(</span>\n        padding<span>:</span> <span>EdgeInsets</span><span>.</span><span>all</span><span>(</span><span>18</span><span>)</span><span>,</span>\n        child<span>:</span> <span>Center</span><span>(</span>\n          child<span>:</span> <span>Column</span><span>(</span>\n            children<span>:</span> <span><span>&lt;</span><span>Widget</span><span>></span></span><span>[</span>\n              <span>Text</span><span>(</span>text<span>)</span><span>,</span>\n              <span>RaisedButton</span><span>(</span>\n                onPressed<span>:</span> <span>(</span><span>)</span> <span>=</span><span>></span> <span>Navigator</span><span>.</span><span>pop</span><span>(</span>context<span>,</span> <span>\"我是返回值\"</span><span>)</span><span>,</span>\n                child<span>:</span> <span>Text</span><span>(</span><span>\"返回\"</span><span>)</span><span>,</span>\n              <span>)</span>\n            <span>]</span><span>,</span>\n          <span>)</span><span>,</span>\n        <span>)</span><span>,</span>\n      <span>)</span><span>,</span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h2 id=\"命名路由\"> 命名路由</h2>\n<p>所谓“命名路由”（Named Route）即有名字的路由，我们可以先给路由起一个名字，然后就可以通过路由名字直接打开新的路由了，这为路由管理带来了一种直观、简单的方式。</p>\n<h3 id=\"路由表\"> 路由表</h3>\n<p>要想使用命名路由，我们必须先提供并注册一个路由表（routing table），这样应用程序才知道哪个名字与哪个路由组件相对应。其实注册路由表就是给路由起名字，路由表的定义如下：</p>\n<div><pre><code><span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>WidgetBuilder</span><span>></span></span> routes<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>它是一个<code>Map</code>，key为路由的名字，是个字符串；value是个<code>builder</code>回调函数，用于生成相应的路由widget。我们在通过路由名字打开新路由时，应用会根据路由名字在路由表中查找到对应的<code>WidgetBuilder</code>回调函数，然后调用该回调函数生成路由widget并返回。</p>\n<h3 id=\"注册路由表\"> 注册路由表</h3>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200422163142787.png\" alt=\"image-20200422163142787\" /></p>\n<p>路由表的注册方式很简单，在<code>MyApp</code>类的<code>build</code>方法中找到<code>MaterialApp</code>，添加<code>routes</code>属性，代码如下：</p>\n<div><pre><code><span>MaterialApp</span><span>(</span>\n    title<span>:</span> <span>'练习路由'</span><span>,</span>\n    theme<span>:</span> <span>ThemeData</span><span>(</span>\n        primarySwatch<span>:</span> <span>Colors</span><span>.</span>blue<span>,</span>\n    <span>)</span><span>,</span>\n    home<span>:</span> <span>MyHomePage</span><span>(</span>title<span>:</span> <span>'练习路由'</span><span>)</span><span>,</span>\n    <span>//注册路由</span>\n    routes<span>:</span> <span>{</span>\n        <span>\"/index\"</span><span>:</span> <span>(</span>context<span>)</span> <span>=</span><span>></span> <span>MyHomePage</span><span>(</span>title<span>:</span> <span>\"主页\"</span><span>)</span><span>,</span>\n        <span>\"page1\"</span><span>:</span> <span>(</span>context<span>)</span> <span>=</span><span>></span> <span>Page1</span><span>(</span><span>)</span><span>,</span>\n        <span>\"page2\"</span><span>:</span> <span>(</span>context<span>)</span> <span>=</span><span>></span> <span>Page2</span><span>(</span><span>)</span><span>,</span>\n    <span>}</span><span>,</span>\n    <span>//初始化路由首页</span>\n    initialRoute<span>:</span> <span>\"/\"</span><span>,</span>\n<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>现在我们就完成了路由表的注册。上面的代码中<code>home</code>路由并没有使用命名路由，如果我们也想将<code>home</code>注册为命名路由应该怎么做呢？其实很简单，直接看代码：</p>\n<div><pre><code><span>MaterialApp</span><span>(</span>\n  title<span>:</span> <span>'Flutter Demo'</span><span>,</span>\n  initialRoute<span>:</span><span>\"/\"</span><span>,</span> <span>//名为\"/\"的路由作为应用的home(首页)</span>\n  theme<span>:</span> <span>ThemeData</span><span>(</span>\n    primarySwatch<span>:</span> <span>Colors</span><span>.</span>blue<span>,</span>\n  <span>)</span><span>,</span>\n  <span>//注册路由表</span>\n  routes<span>:</span><span>{</span>\n   <span>\"new_page\"</span><span>:</span><span>(</span>context<span>)</span> <span>=</span><span>></span> <span>NewRoute</span><span>(</span><span>)</span><span>,</span>\n   <span>\"/\"</span><span>:</span><span>(</span>context<span>)</span> <span>=</span><span>></span> <span>MyHomePage</span><span>(</span>title<span>:</span> <span>'Flutter Demo Home Page'</span><span>)</span><span>,</span> <span>//注册首页路由</span>\n  <span>}</span> \n<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>可以看到，我们只需在路由表中注册一下<code>MyHomePage</code>路由，然后将其名字作为<code>MaterialApp</code>的<code>initialRoute</code>属性值即可，该属性决定应用的初始路由页是哪一个命名路由。</p>\n<h3 id=\"通过路由名打开新路由页\"> 通过路由名打开新路由页</h3>\n<p>要通过路由名称来打开新路由，可以使用<code>Navigator</code> 的<code>pushNamed</code>方法：</p>\n<div><pre><code><span>Future</span> <span>pushNamed</span><span>(</span><span>BuildContext</span> context<span>,</span> <span>String</span> routeName<span>,</span><span>{</span><span>Object</span> arguments<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><code>Navigator</code> 除了<code>pushNamed</code>方法，还有<code>pushReplacementNamed</code>等其他管理命名路由的方法，读者可以自行查看API文档。接下来我们通过路由名来打开新的路由页，修改<code>FlatButton</code>的<code>onPressed</code>回调代码，改为：</p>\n<div><pre><code><span>//使用命名路由跳转页面</span>\n<span>FlatButton</span><span>(</span>\n    child<span>:</span> <span>Text</span><span>(</span><span>\"使用命名路由 跳转到page 1\"</span><span>)</span><span>,</span>\n    textColor<span>:</span> <span>Colors</span><span>.</span>blue<span>,</span>\n    onPressed<span>:</span> <span>(</span><span>)</span> <span>{</span>\n        <span>//导航到 page1</span>\n        <span>Navigator</span><span>.</span><span>pushNamed</span><span>(</span>context<span>,</span> <span>\"page1\"</span><span>)</span><span>;</span>\n    <span>}</span><span>,</span>\n<span>)</span><span>,</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200422162916287.png\" alt=\"image-20200422162916287\" /></p>\n<h3 id=\"命名路由参数传递\"> 命名路由参数传递</h3>\n<p>在Flutter最初的版本中，命名路由是不能传递参数的，后来才支持了参数；下面展示命名路由如何传递并获取路由参数：</p>\n<p>我们先注册一个路由：</p>\n<div><pre><code> routes<span>:</span><span>{</span>\n   <span>\"page3\"</span><span>:</span> <span>(</span>context<span>)</span> <span>=</span><span>></span> <span>Page3</span><span>(</span><span>)</span><span>,</span>\n  <span>}</span> <span>,</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200422164626870.png\" alt=\"image-20200422164626870\" /></p>\n<p>在路由页通过<code>RouteSetting</code>对象获取路由参数：</p>\n<div><pre><code><span>import</span> <span>'package:flutter/cupertino.dart'</span><span>;</span>\n<span>import</span> <span>'package:flutter/material.dart'</span><span>;</span>\n\n<span>class</span> <span>Page3</span> <span>extends</span> <span>StatelessWidget</span> <span>{</span>\n\n  <span>@override</span>\n  <span>Widget</span> <span>build</span><span>(</span><span>BuildContext</span> context<span>)</span> <span>{</span>\n    <span>var</span> arguments <span>=</span> <span>ModalRoute</span><span>.</span><span>of</span><span>(</span>context<span>)</span><span>.</span>settings<span>.</span>arguments<span>;</span>\n    <span>print</span><span>(</span>arguments<span>)</span><span>;</span>\n\n    <span>return</span> <span>Scaffold</span><span>(</span>\n      appBar<span>:</span> <span>AppBar</span><span>(</span>\n        title<span>:</span> <span>Text</span><span>(</span><span>\"Page 3\"</span><span>)</span><span>,</span>\n      <span>)</span><span>,</span>\n      body<span>:</span> <span>Padding</span><span>(</span>\n        padding<span>:</span> <span>EdgeInsets</span><span>.</span><span>all</span><span>(</span><span>18</span><span>)</span><span>,</span>\n        child<span>:</span> <span>Center</span><span>(</span>\n          child<span>:</span> <span>Column</span><span>(</span>\n            children<span>:</span> <span><span>&lt;</span><span>Widget</span><span>></span></span><span>[</span>\n              <span>Text</span><span>(</span>arguments<span>)</span><span>,</span>\n            <span>]</span><span>,</span>\n          <span>)</span><span>,</span>\n        <span>)</span><span>,</span>\n      <span>)</span><span>,</span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200422164500407.png\" alt=\"image-20200422164500407\" /></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200422164536734.png\" alt=\"image-20200422164536734\" /></p>\n<p>在打开路由时传递参数</p>\n<div><pre><code><span>//使用命名路由跳转页面，带参数</span>\n<span>FlatButton</span><span>(</span>\n    child<span>:</span> <span>Text</span><span>(</span><span>\"使用命名路由 跳转到page 3\"</span><span>)</span><span>,</span>\n    textColor<span>:</span> <span>Colors</span><span>.</span>blue<span>,</span>\n    onPressed<span>:</span> <span>(</span><span>)</span> <span>{</span>\n        <span>//导航到 page1</span>\n        <span>Navigator</span><span>.</span><span>pushNamed</span><span>(</span>context<span>,</span> <span>\"page3\"</span><span>,</span> arguments<span>:</span> <span>\"我是携带的参数内容\"</span><span>)</span><span>;</span>\n    <span>}</span><span>,</span>\n<span>)</span><span>,</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"适配\"> 适配</h3>\n<p>假设我们也想将上面路由传参示例中的<code>TipRoute</code>路由页注册到路由表中，以便也可以通过路由名来打开它。但是，由于<code>TipRoute</code>接受一个<code>text</code> 参数，我们如何在不改变<code>TipRoute</code>源码的前提下适配这种情况？其实很简单：</p>\n<div><pre><code><span>MaterialApp</span><span>(</span>\n  <span>.</span><span>.</span><span>.</span> <span>//省略无关代码</span>\n  routes<span>:</span> <span>{</span>\n   <span>\"tip2\"</span><span>:</span> <span>(</span>context<span>)</span><span>{</span>\n     <span>return</span> <span>TipRoute</span><span>(</span>text<span>:</span> <span>ModalRoute</span><span>.</span><span>of</span><span>(</span>context<span>)</span><span>.</span>settings<span>.</span>arguments<span>)</span><span>;</span>\n   <span>}</span><span>,</span>\n <span>}</span><span>,</span> \n<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"路由生成钩子\"> 路由生成钩子</h2>\n<p>假设我们要开发一个电商APP，当用户没有登录时可以看店铺、商品等信息，但交易记录、购物车、用户个人信息等页面需要登录后才能看。为了实现上述功能，我们需要在打开每一个路由页前判断用户登录状态！如果每次打开路由前我们都需要去判断一下将会非常麻烦，那有什么更好的办法吗？答案是有！</p>\n<p><code>MaterialApp</code>有一个<code>onGenerateRoute</code>属性，它在打开命名路由时可能会被调用，之所以说可能，是因为当调用<code>Navigator.pushNamed(...)</code>打开命名路由时，如果指定的路由名在路由表中已注册，则会调用路由表中的<code>builder</code>函数来生成路由组件；如果路由表中没有注册，才会调用<code>onGenerateRoute</code>来生成路由。<code>onGenerateRoute</code>回调签名如下：</p>\n<div><pre><code><span>Route</span><span><span>&lt;</span><span>dynamic</span><span>></span></span> <span>Function</span><span>(</span><span>RouteSettings</span> settings<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>有了<code>onGenerateRoute</code>回调，要实现上面控制页面权限的功能就非常容易：我们放弃使用路由表，取而代之的是提供一个<code>onGenerateRoute</code>回调，然后在该回调中进行统一的权限控制，如：</p>\n<div><pre><code><span>MaterialApp</span><span>(</span>\n  <span>.</span><span>.</span><span>.</span> <span>//省略无关代码</span>\n  onGenerateRoute<span>:</span><span>(</span><span>RouteSettings</span> settings<span>)</span><span>{</span>\n      <span>return</span> <span>MaterialPageRoute</span><span>(</span>builder<span>:</span> <span>(</span>context<span>)</span><span>{</span>\n           <span>String</span> routeName <span>=</span> settings<span>.</span>name<span>;</span>\n       <span>// 如果访问的路由页需要登录，但当前未登录，则直接返回登录页路由，</span>\n       <span>// 引导用户登录；其它情况则正常打开路由。</span>\n     <span>}</span>\n   <span>)</span><span>;</span>\n  <span>}</span>\n<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>\n<p>注意，<code>onGenerateRoute</code>只会对命名路由生效。</p>\n</blockquote>\n<h2 id=\"封装路由\"> 封装路由</h2>\n<p>如果页面太多的话，路由表就会写得很多，那么多路由表放在main.dart文件里很不舒服，也不好维护，所以新建一个专门的Router类来管理路由表。</p>\n<p>在lib目录下创建一个router文件夹、在该文件夹下创建index.dart文件，代码如下</p>\n<div><pre><code><span>import</span> <span>'package:flutter/cupertino.dart'</span><span>;</span>\n<span>import</span> <span>'package:flutter/material.dart'</span><span>;</span>\n<span>import</span> <span>'package:practice08_router/pages/page_1.dart'</span><span>;</span>\n<span>import</span> <span>'package:practice08_router/pages/page_2.dart'</span><span>;</span>\n<span>import</span> <span>'package:practice08_router/pages/page_3.dart'</span><span>;</span>\n\n<span>import</span> <span>'../main.dart'</span><span>;</span>\n\n<span>class</span> <span>Router</span><span>{</span>\n  <span>static</span> <span>final</span> routes <span>=</span> <span>{</span>\n    <span>\"/index\"</span><span>:</span> <span>(</span>context<span>)</span> <span>=</span><span>></span> <span>MyHomePage</span><span>(</span>title<span>:</span> <span>\"主页\"</span><span>)</span><span>,</span>\n    <span>\"page1\"</span><span>:</span> <span>(</span>context<span>)</span> <span>=</span><span>></span> <span>Page1</span><span>(</span><span>)</span><span>,</span>\n    <span>\"page2\"</span><span>:</span> <span>(</span>context<span>)</span> <span>=</span><span>></span> <span>Page2</span><span>(</span><span>)</span><span>,</span>\n    <span>\"page3\"</span><span>:</span> <span>(</span>context<span>)</span> <span>=</span><span>></span> <span>Page3</span><span>(</span><span>)</span><span>,</span>\n  <span>}</span><span>;</span>\n\n  <span>static</span> <span>Router</span> _singleton<span>;</span>\n\n  <span>Router</span><span>.</span><span>_internal</span><span>(</span><span>)</span><span>;</span>\n\n  <span>factory</span> <span>Router</span><span>(</span><span>)</span><span>{</span>\n    <span>if</span><span>(</span>_singleton <span>==</span> <span>null</span><span>)</span><span>{</span>\n      _singleton <span>=</span> <span>Router</span><span>.</span><span>_internal</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> _singleton<span>;</span>\n  <span>}</span>\n\n  <span>//监听路由</span>\n  <span>Route</span> <span>getRouter</span><span>(</span><span>RouteSettings</span> settings<span>)</span><span>{</span>\n    <span>String</span> routeName <span>=</span> settings<span>.</span>name<span>;</span>\n    <span>final</span> <span>Function</span> builder <span>=</span> <span>Router</span><span>.</span>routes<span>[</span>routeName<span>]</span><span>;</span>\n\n    <span>if</span><span>(</span>builder <span>==</span> <span>null</span><span>)</span><span>{</span>\n      <span>return</span> <span>null</span><span>;</span>\n    <span>}</span><span>else</span><span>{</span>\n      <span>return</span> <span>MaterialPageRoute</span><span>(</span>\n        settings<span>:</span> settings<span>,</span>\n        builder<span>:</span> <span>(</span>context<span>)</span> <span>=</span><span>></span> <span>builder</span><span>(</span>context<span>)</span>\n      <span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>现在可以把main.dart下的routes属性给去掉了</p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200422181759037.png\" alt=\"image-20200422181759037\" /></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200422175701297.png\" alt=\"image-20200422175701297\" /></p>\n<blockquote>\n<p>routes和onGenerateRoute只能选择其中一个</p>\n</blockquote>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200422180516577.png\" alt=\"image-20200422180516577\" /></p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200422160807936.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "调用相机和手机相册",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter06%20-%20%E8%B0%83%E7%94%A8%E7%9B%B8%E6%9C%BA%E5%92%8C%E6%89%8B%E6%9C%BA%E7%9B%B8%E5%86%8C/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter06%20-%20%E8%B0%83%E7%94%A8%E7%9B%B8%E6%9C%BA%E5%92%8C%E6%89%8B%E6%9C%BA%E7%9B%B8%E5%86%8C/",
      "content_html": "<h1 id=\"调用相机和手机相册\"> 调用相机和手机相册</h1>\n<h2 id=\"添加插件依赖\"> 添加插件依赖</h2>\n<p>在pubspec.yaml中添加image_picker的依赖</p>\n<div><pre><code><span>dependencies</span><span>:</span>\n  <span>flutter</span><span>:</span>\n    <span>sdk</span><span>:</span> flutter\n  <span>image_picker</span><span>:</span> any\t\t<span># 添加image_picker的依赖</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<p>any可以自动的调用pub的版本分析器来寻找最合适的能够避免冲突的依赖版本并下载</p>\n</blockquote>\n<h2 id=\"调用相机\"> 调用相机</h2>\n<div><pre><code><span>//使用相机拍照获取照片</span>\n<span>Future</span> <span>getImageFromCamera</span><span>(</span><span>)</span> <span>async</span> <span>{</span>\n    <span>var</span> image <span>=</span> <span>await</span> <span>ImagePicker</span><span>.</span><span>pickImage</span><span>(</span>source<span>:</span> <span>ImageSource</span><span>.</span>camera<span>)</span><span>;</span>\n    <span>setState</span><span>(</span><span>(</span><span>)</span> <span>{</span>\n        _image <span>=</span> image<span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"调用手机相册\"> 调用手机相册</h2>\n<div><pre><code><span>//从图库中获取照片</span>\n<span>Future</span> <span>getImageFromGallery</span><span>(</span><span>)</span> <span>async</span> <span>{</span>\n    <span>var</span> image <span>=</span> <span>await</span> <span>ImagePicker</span><span>.</span><span>pickImage</span><span>(</span>source<span>:</span>  <span>ImageSource</span><span>.</span>gallery<span>)</span><span>;</span>\n    <span>setState</span><span>(</span><span>(</span><span>)</span> <span>{</span>\n        _image <span>=</span> image<span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"代码示例\"> 代码示例</h2>\n<p>main.dart</p>\n<div><pre><code><span>import</span> <span>'dart:io'</span><span>;</span>\n\n<span>import</span> <span>'package:flutter/material.dart'</span><span>;</span>\n<span>import</span> <span>'package:flutter/services.dart'</span><span>;</span>\n<span>import</span> <span>'package:image_picker/image_picker.dart'</span><span>;</span>\n\n<span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n  <span>runApp</span><span>(</span><span>new</span> <span>MyApp</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  <span>if</span> <span>(</span><span>Platform</span><span>.</span>isAndroid<span>)</span> <span>{</span>\n    <span>// 以下两行 设置android状态栏为透明的沉浸。写在组件渲染之后，是为了在渲染后进行set赋值，覆盖状态栏，写在渲染之前MaterialApp组件会覆盖掉这个值。</span>\n    <span>SystemUiOverlayStyle</span> systemUiOverlayStyle <span>=</span>\n    <span>SystemUiOverlayStyle</span><span>(</span>statusBarColor<span>:</span> <span>Colors</span><span>.</span>transparent<span>)</span><span>;</span>\n    <span>SystemChrome</span><span>.</span><span>setSystemUIOverlayStyle</span><span>(</span>systemUiOverlayStyle<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>MyApp</span> <span>extends</span> <span>StatelessWidget</span> <span>{</span>\n  <span>@override</span>\n  <span>Widget</span> <span>build</span><span>(</span><span>BuildContext</span> context<span>)</span> <span>{</span>\n    <span>return</span> <span>MaterialApp</span><span>(</span>\n      title<span>:</span> <span>'相机APP'</span><span>,</span>\n      debugShowCheckedModeBanner<span>:</span> <span>false</span><span>,</span>\n      theme<span>:</span> <span>ThemeData</span><span>(</span>\n        primarySwatch<span>:</span> <span>Colors</span><span>.</span>blue<span>,</span>\n      <span>)</span><span>,</span>\n      home<span>:</span> <span>MyHomePage</span><span>(</span><span>)</span><span>,</span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>MyHomePage</span> <span>extends</span> <span>StatefulWidget</span> <span>{</span>\n  <span>@override</span>\n  _MyHomePageState <span>createState</span><span>(</span><span>)</span> <span>=</span><span>></span> <span>_MyHomePageState</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>class</span> _MyHomePageState <span>extends</span> <span>State</span><span><span>&lt;</span><span>MyHomePage</span><span>></span></span> <span>{</span>\n  <span>File</span> _image<span>;</span>\n\n  <span>//使用相机拍照获取照片</span>\n  <span>Future</span> <span>getImageFromCamera</span><span>(</span><span>)</span> <span>async</span> <span>{</span>\n    <span>var</span> image <span>=</span> <span>await</span> <span>ImagePicker</span><span>.</span><span>pickImage</span><span>(</span>source<span>:</span> <span>ImageSource</span><span>.</span>camera<span>)</span><span>;</span>\n    <span>setState</span><span>(</span><span>(</span><span>)</span> <span>{</span>\n      _image <span>=</span> image<span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>//从图库中获取照片</span>\n  <span>Future</span> <span>getImageFromGallery</span><span>(</span><span>)</span> <span>async</span> <span>{</span>\n    <span>var</span> image <span>=</span> <span>await</span> <span>ImagePicker</span><span>.</span><span>pickImage</span><span>(</span>source<span>:</span>  <span>ImageSource</span><span>.</span>gallery<span>)</span><span>;</span>\n    <span>setState</span><span>(</span><span>(</span><span>)</span> <span>{</span>\n      _image <span>=</span> image<span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n  <span>}</span>\n\n\n  <span>@override</span>\n  <span>Widget</span> <span>build</span><span>(</span><span>BuildContext</span> context<span>)</span> <span>{</span>\n    <span>return</span> <span>Scaffold</span><span>(</span>\n      appBar<span>:</span> <span>AppBar</span><span>(</span>\n        title<span>:</span> <span>Text</span><span>(</span><span>'相机APP 示例'</span><span>)</span><span>,</span>\n      <span>)</span><span>,</span>\n      body<span>:</span> <span>Column</span><span>(</span>\n        mainAxisAlignment<span>:</span> <span>MainAxisAlignment</span><span>.</span>center<span>,</span>\n        children<span>:</span> <span><span>&lt;</span><span>Widget</span><span>></span></span><span>[</span>\n          <span>Center</span><span>(</span>\n            child<span>:</span> _image <span>==</span> <span>null</span>\n                <span>?</span> <span>Text</span><span>(</span><span>'未选中图片'</span><span>)</span>\n                <span>:</span> <span>Image</span><span>.</span><span>file</span><span>(</span>_image<span>)</span><span>,</span>\n          <span>)</span><span>,</span>\n          \n          <span>RaisedButton</span><span>(</span>\n            onPressed<span>:</span> getImageFromGallery<span>,</span>\n            child<span>:</span> <span>Text</span><span>(</span><span>\"从相册选取图片\"</span><span>)</span><span>,</span>\n          <span>)</span>\n        <span>]</span><span>,</span>\n      <span>)</span><span>,</span>\n      floatingActionButton<span>:</span> <span>FloatingActionButton</span><span>(</span>\n        onPressed<span>:</span> getImageFromCamera<span>,</span>\n        tooltip<span>:</span> <span>'Pick Image'</span><span>,</span>\n        child<span>:</span> <span>Icon</span><span>(</span><span>Icons</span><span>.</span>add_a_photo<span>)</span><span>,</span>\n      <span>)</span><span>,</span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br></div></div><p>iOS需要再项目内配置Info.plist文件，添加如下代码，申请访问权。</p>\n<div><pre><code><span><span><span>&lt;</span>key</span><span>></span></span>NSPhotoLibraryUsageDescription<span><span><span>&lt;/</span>key</span><span>></span></span>\n<span><span><span>&lt;</span>string</span><span>></span></span>测试访问手机相册<span><span><span>&lt;/</span>string</span><span>></span></span>\n<span><span><span>&lt;</span>key</span><span>></span></span>NSCameraUsageDescription<span><span><span>&lt;/</span>key</span><span>></span></span>\n<span><span><span>&lt;</span>string</span><span>></span></span>测试访问手机相机<span><span><span>&lt;/</span>string</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "使用Toast",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter07%20-%20%E4%BD%BF%E7%94%A8Toast/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter07%20-%20%E4%BD%BF%E7%94%A8Toast/",
      "content_html": "<h1 id=\"使用toast\"> 使用Toast</h1>\n<h2 id=\"添加依赖\"> 添加依赖</h2>\n<div><pre><code><span>dependencies</span><span>:</span>\n  <span>fluttertoast</span><span>:</span> any\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"简单使用\"> 简单使用</h2>\n<div><pre><code>Fluttertoast.showToast(\n    <span>msg</span><span>:</span> <span>\"提示消息\"</span><span>,</span>\n    <span>toastLength</span><span>:</span> Toast.LENGTH_SHORT<span>,</span>\n    <span>gravity</span><span>:</span> ToastGravity.CENTER<span>,</span>\n    <span>timeInSecForIosWeb</span><span>:</span> <span>1</span><span>,</span>\n    <span>backgroundColor</span><span>:</span> Colors.greenAccent<span>,</span>\n    <span>textColor</span><span>:</span> Colors.white<span>,</span>\n    <span>fontSize</span><span>:</span> <span>16.0</span>\n);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"简单封装\"> 简单封装</h2>\n<p>新建一个toast_util.dart文件</p>\n<p>内容如下：</p>\n<div><pre><code>\n<span>import</span> <span>'package:flutter/material.dart'</span><span>;</span>\n<span>import</span> <span>'package:fluttertoast/fluttertoast.dart'</span><span>;</span>\n\n<span>class</span> <span>ToastUtil</span><span>{</span>\n\n  <span>//成功</span>\n  <span>static</span> <span>void</span> <span>success</span><span>(</span><span>String</span> msg<span>)</span><span>{</span>\n    <span>Fluttertoast</span><span>.</span><span>showToast</span><span>(</span>\n        msg<span>:</span> msg<span>,</span>\n        toastLength<span>:</span> <span>Toast</span><span>.</span>LENGTH_SHORT<span>,</span>\n        gravity<span>:</span> <span>ToastGravity</span><span>.</span>CENTER<span>,</span>\n        timeInSecForIosWeb<span>:</span> <span>1</span><span>,</span>\n        backgroundColor<span>:</span> <span>Colors</span><span>.</span>greenAccent<span>,</span>\n        textColor<span>:</span> <span>Colors</span><span>.</span>white<span>,</span>\n        fontSize<span>:</span> <span>16.0</span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>//错误</span>\n  <span>static</span> <span>void</span> <span>error</span><span>(</span><span>String</span> msg<span>)</span><span>{</span>\n    <span>Fluttertoast</span><span>.</span><span>showToast</span><span>(</span>\n        msg<span>:</span> msg<span>,</span>\n        toastLength<span>:</span> <span>Toast</span><span>.</span>LENGTH_SHORT<span>,</span>\n        gravity<span>:</span> <span>ToastGravity</span><span>.</span>CENTER<span>,</span>\n        timeInSecForIosWeb<span>:</span> <span>1</span><span>,</span>\n        backgroundColor<span>:</span> <span>Colors</span><span>.</span>red<span>,</span>\n        textColor<span>:</span> <span>Colors</span><span>.</span>white<span>,</span>\n        fontSize<span>:</span> <span>16.0</span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n\n\n  <span>//警告</span>\n  <span>static</span> <span>void</span> <span>warning</span><span>(</span><span>String</span> msg<span>)</span><span>{</span>\n    <span>Fluttertoast</span><span>.</span><span>showToast</span><span>(</span>\n        msg<span>:</span> msg<span>,</span>\n        toastLength<span>:</span> <span>Toast</span><span>.</span>LENGTH_SHORT<span>,</span>\n        gravity<span>:</span> <span>ToastGravity</span><span>.</span>CENTER<span>,</span>\n        timeInSecForIosWeb<span>:</span> <span>1</span><span>,</span>\n        backgroundColor<span>:</span> <span>Colors</span><span>.</span>yellow<span>,</span>\n        textColor<span>:</span> <span>Colors</span><span>.</span>white<span>,</span>\n        fontSize<span>:</span> <span>16.0</span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>//信息</span>\n  <span>static</span> <span>void</span> <span>info</span><span>(</span><span>String</span> msg<span>)</span><span>{</span>\n    <span>Fluttertoast</span><span>.</span><span>showToast</span><span>(</span>\n        msg<span>:</span> msg<span>,</span>\n        toastLength<span>:</span> <span>Toast</span><span>.</span>LENGTH_SHORT<span>,</span>\n        gravity<span>:</span> <span>ToastGravity</span><span>.</span>CENTER<span>,</span>\n        timeInSecForIosWeb<span>:</span> <span>1</span><span>,</span>\n        backgroundColor<span>:</span> <span>Colors</span><span>.</span>grey<span>,</span>\n        textColor<span>:</span> <span>Colors</span><span>.</span>white<span>,</span>\n        fontSize<span>:</span> <span>16.0</span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br></div></div><p>使用</p>\n<div><pre><code><span>ToastUtil</span><span>.</span><span>warning</span><span>(</span><span>\"请输入用户名和密码\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "使用SharedPreference",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter08%20-%20%E4%BD%BF%E7%94%A8SharedPreference/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter08%20-%20%E4%BD%BF%E7%94%A8SharedPreference/",
      "content_html": "<h1 id=\"使用sharedpreference\"> 使用SharedPreference</h1>\n<h2 id=\"添加依赖\"> 添加依赖</h2>\n<div><pre><code><span>dependencies</span><span>:</span>\n  <span>shared_preferences</span><span>:</span> ^0.5.7\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"使用\"> 使用</h2>\n<p>保存数据到SharedPreferences</p>\n<div><pre><code><span>void</span> <span>saveLoginInfo</span><span>(</span><span>String</span> userInfo<span>)</span> <span>async</span><span>{</span>\n    <span>SharedPreferences</span> sp <span>=</span> <span>await</span> <span>SharedPreferences</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\n    sp<span>.</span><span>setBool</span><span>(</span><span>\"isLogin\"</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n    sp<span>.</span><span>setString</span><span>(</span><span>\"userInfo\"</span><span>,</span> userInfo<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>从SharedPreferences取出数据</p>\n<div><pre><code><span>//从SharedPreferences取出数据</span>\n<span>Future</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>getDataFromSharedPreferences</span><span>(</span><span>String</span> key<span>)</span> <span>async</span><span>{</span>\n    <span>SharedPreferences</span> sp <span>=</span> <span>await</span> <span>SharedPreferences</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> sp<span>.</span><span>getString</span><span>(</span>key<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/img.png\" alt=\"img\" /></p>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/img.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "使用Tabbar",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter09%20-%20%E4%BD%BF%E7%94%A8Tabbar/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/flutter/Flutter09%20-%20%E4%BD%BF%E7%94%A8Tabbar/",
      "content_html": "<h1 id=\"使用tabbar\"> 使用Tabbar</h1>\n<ul>\n<li>with TickerProviderStateMixin</li>\n<li>TabController _tabController;</li>\n<li>//初始化TabController\n_tabController = TabController(length: tabs.length, vsync: this);</li>\n<li>List tabs = [&quot;tab1&quot;, &quot;tab2&quot;, &quot;tab3&quot;];</li>\n<li>controller: _tabController,</li>\n<li>tabs: tabs.map((e) =&gt; Tab(text: e)).toList(),</li>\n</ul>\n<h2 id=\"实例\"> 实例</h2>\n<div><pre><code>\n<span>import</span> <span>'package:flutter/material.dart'</span><span>;</span>\n\n<span>class</span> <span>TestTabbarPage</span> <span>extends</span> <span>StatefulWidget</span><span>{</span>\n  <span>@override</span>\n  <span>State</span><span><span>&lt;</span><span>StatefulWidget</span><span>></span></span> <span>createState</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>TestTabbarState</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n<span>}</span>\n\n<span>class</span> <span>TestTabbarState</span> <span>extends</span> <span>State</span><span><span>&lt;</span><span>TestTabbarPage</span><span>></span></span> <span>with</span> <span>TickerProviderStateMixin</span><span>{</span>\n\n  <span>TabController</span> _tabController<span>;</span>\n  <span>List</span> tabs <span>=</span> <span>[</span><span>\"tab1\"</span><span>,</span> <span>\"tab2\"</span><span>,</span> <span>\"tab3\"</span><span>]</span><span>;</span>\n\n  <span>@override</span>\n  <span>void</span> <span>initState</span><span>(</span><span>)</span> <span>{</span>\n    <span>super</span><span>.</span><span>initState</span><span>(</span><span>)</span><span>;</span>\n\n    <span>//初始化TabController</span>\n    _tabController <span>=</span> <span>TabController</span><span>(</span>length<span>:</span> tabs<span>.</span>length<span>,</span> vsync<span>:</span> <span>this</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@override</span>\n  <span>Widget</span> <span>build</span><span>(</span><span>BuildContext</span> context<span>)</span> <span>{</span>\n    <span>return</span> <span>Scaffold</span><span>(</span>\n      appBar<span>:</span> <span>AppBar</span><span>(</span>\n        bottom<span>:</span> <span>TabBar</span><span>(</span>\n          controller<span>:</span> _tabController<span>,</span>\n          tabs<span>:</span> tabs<span>.</span><span>map</span><span>(</span><span>(</span>e<span>)</span> <span>=</span><span>></span> <span>Tab</span><span>(</span>text<span>:</span> e<span>)</span><span>)</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>,</span>\n        <span>)</span><span>,</span>\n      <span>)</span><span>,</span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h3 id=\"效果\"> 效果</h3>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200505105146707.png\" alt=\"image-20200505105146707\" /></p>\n<h2 id=\"添加tabbarview\"> 添加TabbarView</h2>\n<p>通过<code>TabBar</code>我们只能生成一个静态的菜单，真正的Tab页还没有实现。由于<code>Tab</code>菜单和Tab页的切换需要同步，我们需要通过<code>TabController</code>去监听Tab菜单的切换去切换Tab页。</p>\n<p>如果我们Tab页可以滑动切换的话，还需要在滑动过程中更新TabBar指示器的偏移！显然，要手动处理这些是很麻烦的，为此，Material库提供了一个<code>TabBarView</code>组件，通过它不仅可以轻松的实现Tab页，而且可以非常容易的配合TabBar来实现同步切换和滑动状态同步</p>\n<div><pre><code>body<span>:</span> <span>TabBarView</span><span>(</span>\n    controller<span>:</span> _tabController<span>,</span>\n    children<span>:</span> tabs<span>.</span><span>map</span><span>(</span><span>(</span>e<span>)</span> <span>{</span>\n        <span>return</span> <span>Container</span><span>(</span>\n            alignment<span>:</span> <span>Alignment</span><span>.</span>center<span>,</span>\n            child<span>:</span> <span>Text</span><span>(</span>e<span>)</span><span>,</span>\n        <span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>,</span>\n<span>)</span><span>,</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>现在，无论是点击导航栏Tab菜单还是在页面上左右滑动，Tab页面都会切换，并且Tab菜单的状态和Tab页面始终保持同步！那它们是如何实现同步的呢？细心的读者可能已经发现，上例中<code>TabBar</code>和<code>TabBarView</code>的<code>controller</code>是同一个！正是如此，<code>TabBar</code>和<code>TabBarView</code>正是通过同一个<code>controller</code>来实现菜单切换和滑动状态同步的，有关<code>TabController</code>的详细信息</p>\n<h3 id=\"效果-2\"> 效果</h3>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200505110909905.png\" alt=\"image-20200505110909905\" /></p>\n<h2 id=\"完整代码\"> 完整代码</h2>\n<div><pre><code>\n<span>import</span> <span>'package:flutter/material.dart'</span><span>;</span>\n\n<span>class</span> <span>TestTabbarPage</span> <span>extends</span> <span>StatefulWidget</span><span>{</span>\n  <span>@override</span>\n  <span>State</span><span><span>&lt;</span><span>StatefulWidget</span><span>></span></span> <span>createState</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>TestTabbarState</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n<span>}</span>\n\n<span>class</span> <span>TestTabbarState</span> <span>extends</span> <span>State</span><span><span>&lt;</span><span>TestTabbarPage</span><span>></span></span> <span>with</span> <span>TickerProviderStateMixin</span><span>{</span>\n\n  <span>TabController</span> _tabController<span>;</span>\n  <span>List</span> tabs <span>=</span> <span>[</span><span>\"tab1\"</span><span>,</span> <span>\"tab2\"</span><span>,</span> <span>\"tab3\"</span><span>]</span><span>;</span>\n\n  <span>@override</span>\n  <span>void</span> <span>initState</span><span>(</span><span>)</span> <span>{</span>\n    <span>super</span><span>.</span><span>initState</span><span>(</span><span>)</span><span>;</span>\n\n    <span>//初始化TabController</span>\n    _tabController <span>=</span> <span>TabController</span><span>(</span>length<span>:</span> tabs<span>.</span>length<span>,</span> vsync<span>:</span> <span>this</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@override</span>\n  <span>Widget</span> <span>build</span><span>(</span><span>BuildContext</span> context<span>)</span> <span>{</span>\n    <span>return</span> <span>Scaffold</span><span>(</span>\n      appBar<span>:</span> <span>AppBar</span><span>(</span>\n        bottom<span>:</span> <span>TabBar</span><span>(</span>\n          controller<span>:</span> _tabController<span>,</span>\n          tabs<span>:</span> tabs<span>.</span><span>map</span><span>(</span><span>(</span>e<span>)</span> <span>=</span><span>></span> <span>Tab</span><span>(</span>text<span>:</span> e<span>)</span><span>)</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>,</span>\n        <span>)</span><span>,</span>\n      <span>)</span><span>,</span>\n      \n      body<span>:</span> <span>TabBarView</span><span>(</span>\n        controller<span>:</span> _tabController<span>,</span>\n        children<span>:</span> tabs<span>.</span><span>map</span><span>(</span><span>(</span>e<span>)</span> <span>{</span>\n          <span>return</span> <span>Container</span><span>(</span>\n            alignment<span>:</span> <span>Alignment</span><span>.</span>center<span>,</span>\n            child<span>:</span> <span>Text</span><span>(</span>e<span>)</span><span>,</span>\n          <span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>,</span>\n      <span>)</span><span>,</span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div>",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200505105146707.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "微信小程序",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/miniprogram/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/miniprogram/",
      "content_html": "<h1 id=\"微信小程序\"> 微信小程序</h1>\n<img :src=\"$withBase=('/note_images/小程序.jpg')\"/>\n<p>微信小程序，简称小程序，英文名Mini Program，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。</p>\n<p>全面开放申请后，主体类型为企业、政府、媒体、其他组织或个人的开发者，均可申请注册小程序。小程序、订阅号、服务号、企业号是并行的体系。</p>\n<p>小程序是一种不用下载就能使用的应用，也是一项门槛非常高的创新，经过将近两年的发展，已经构造了新的小程序开发环境和开发者生态。小程序也是这么多年来中国IT行业里一个真正能够影响到普通程序员的创新成果，已经有超过150万的开发者加入到了小程序的开发，与我们一起共同发力推动小程序的发展，小程序应用数量超过了一百万，覆盖200多个细分的行业，日活用户达到两个亿，小程序还在许多城市实现了支持地铁、公交服务。小程序发展带来更多的就业机会，2017年小程序带动就业104万人，社会效应不断提升。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "React Native",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/react-native/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/react-native/",
      "content_html": "<h1 id=\"react-native\"> React Native</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "uni-app",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/uni-app/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/uni-app/",
      "content_html": "<h1 id=\"uni-app\"> uni-app</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Taro",
      "url": "http://blog.alanlee.top/blog-vuepress/mobile-end/taro/",
      "id": "http://blog.alanlee.top/blog-vuepress/mobile-end/taro/",
      "content_html": "<h1 id=\"taro\"> Taro</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "基于微服务架构的UI设计师与开发者合作平台",
      "url": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/UI%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%BB%93%E5%90%88%E7%9A%84%E5%B9%B3%E5%8F%B0/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/UI%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%BB%93%E5%90%88%E7%9A%84%E5%B9%B3%E5%8F%B0/",
      "content_html": "<h1 id=\"基于微服务架构的ui设计师与开发者合作平台\"> 基于微服务架构的UI设计师与开发者合作平台</h1>\n<p>——UI设计师与软件开发者合作平台，让UI作品落地的地方</p>\n<blockquote>\n<p>17软件工程 李步官</p>\n<p>毕业设计选题（初选）</p>\n</blockquote>\n<h2 id=\"项目背景\"> 项目背景</h2>\n<p>UI中国网站（ui.cn）和站酷网站（zcool.cn）上有许多UI设计者们发布精美的作品，我作为软件开发方向的学生，我从我自己的角度出发，首先的我精力不是花在UI的设计上，更多的精力是花在业务的实现和软件UI的实现上。而我平时在逛UI中国的时候，我想的是，我能不能直接直接使用这些UI作品去实现一个软件呢？在不侵权的情况下，可以用来学习和练习自己的技术，这样UI设计者可以知道自己的作品受欢迎的程度，软件开发者也可以获得练习技术的机会。如果设计者与开发者的合作的作品有商业价值，或许还可以相互合作创业。</p>\n<h2 id=\"功能点\"> 功能点</h2>\n<ul>\n<li>\n<p>UI设计师发布UI作品</p>\n</li>\n<li>\n<p>软件开发者寻找UI作品</p>\n</li>\n<li>\n<p>作品模块</p>\n<ul>\n<li>点赞、收藏、评论、分享</li>\n<li>详情</li>\n<li>版权申明</li>\n<li>作品实现：征集开发者实现、开发者主动申请实现</li>\n<li>实现量统计</li>\n</ul>\n</li>\n<li>\n<p>用户模块</p>\n<ul>\n<li>身份：UI设计师 / 软件开发者 / 游客</li>\n</ul>\n</li>\n<li>\n<p>实名认证</p>\n<ul>\n<li>点赞、收藏、关注、粉丝、作品、积分</li>\n<li>个人资料</li>\n<li>个人作品采用量（设计师）、个人软件完成量（开发者）</li>\n</ul>\n</li>\n<li>\n<p>推荐：作品推荐、设计师推荐、开发者推荐</p>\n</li>\n<li>\n<p>聊天（消息）</p>\n</li>\n<li>\n<p>短信通知、邮件通知</p>\n</li>\n<li>\n<p>积分商城</p>\n<ul>\n<li>兑换专区</li>\n<li>秒杀专区</li>\n</ul>\n</li>\n<li>\n<p>发布</p>\n<ul>\n<li>UI作品</li>\n<li>icon</li>\n<li>海报</li>\n<li>插画</li>\n<li>壁纸</li>\n</ul>\n</li>\n<li>\n<p>简历展示</p>\n</li>\n</ul>\n<h2 id=\"技术选型\"> 技术选型</h2>\n<h3 id=\"后端\"> 后端</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">技术</th>\n<th style=\"text-align:center\">名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Spring Boot</td>\n<td style=\"text-align:center\">微服务应用基础框架</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud 或 Apache Dubbo</td>\n<td style=\"text-align:center\">微服务集成框架</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Config</td>\n<td style=\"text-align:center\">分布式配置中心</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Eureka 或 Zookeeper</td>\n<td style=\"text-align:center\">服务注册与发现</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Zipkin</td>\n<td style=\"text-align:center\">链路追踪</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Zuul</td>\n<td style=\"text-align:center\">API网关</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Boot Admin</td>\n<td style=\"text-align:center\">服务监控</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Maven</td>\n<td style=\"text-align:center\">项目构建管理</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Nexus3</td>\n<td style=\"text-align:center\">Maven私服</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云云效 或 Jenkins</td>\n<td style=\"text-align:center\">持续集成CI/持续部署CD</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Github 或 Gitee</td>\n<td style=\"text-align:center\">代码仓库</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云云数据库RDS MySQL5.7</td>\n<td style=\"text-align:center\">数据库</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Druid</td>\n<td style=\"text-align:center\">数据库连接池</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MyBatis</td>\n<td style=\"text-align:center\">ORM框架</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PageHelper</td>\n<td style=\"text-align:center\">分页插件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Redis Sentinel</td>\n<td style=\"text-align:center\">哨兵集群</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云OSS</td>\n<td style=\"text-align:center\">云对象存储</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Swagger2</td>\n<td style=\"text-align:center\">API文档生成工具</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RESTful API</td>\n<td style=\"text-align:center\">RESTful风格API</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Nginx</td>\n<td style=\"text-align:center\">代理服务器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Docker</td>\n<td style=\"text-align:center\">应用容器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Kubernetes</td>\n<td style=\"text-align:center\">应用容器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云镜像仓库</td>\n<td style=\"text-align:center\">阿里云镜像仓库</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">OAuth2 或 Shiro</td>\n<td style=\"text-align:center\">身份/权限认证</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Quartz</td>\n<td style=\"text-align:center\">分布式任务调度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Elastic Search</td>\n<td style=\"text-align:center\">分布式全文搜索</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RabbitMQ 或 RocketMQ 或 Kafka</td>\n<td style=\"text-align:center\">消息队列</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">短信通知</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">邮件发送</td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"前端\"> 前端</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">技术</th>\n<th style=\"text-align:center\">名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">HTML</td>\n<td style=\"text-align:center\">超文本标记语言</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CSS</td>\n<td style=\"text-align:center\">层叠样式表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">JavaScript</td>\n<td style=\"text-align:center\">网页脚本语言</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Vue.js 或 React</td>\n<td style=\"text-align:center\">前端框架</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">VueRouter</td>\n<td style=\"text-align:center\">前端路由</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Vuex</td>\n<td style=\"text-align:center\">状态管理（数据存储）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Element-UI</td>\n<td style=\"text-align:center\">前端样式框架</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Axios</td>\n<td style=\"text-align:center\">网络请求</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">vue-waterfall-easy</td>\n<td style=\"text-align:center\">瀑布流组件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">vue2-admin</td>\n<td style=\"text-align:center\">基于vue的后台管理前端框架</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">echarts</td>\n<td style=\"text-align:center\">图表框架</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Flutter 或 React Native 或 uni-app</td>\n<td style=\"text-align:center\">移动端跨平台框架</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"备选名称\"> 备选名称</h2>\n<ul>\n<li>UUID（有UI，有Designer，有Devloper）</li>\n<li>DND（Designer and Devloper）</li>\n<li>DVD（Designer with Devloper）</li>\n<li>橙色星球（程序、设计星球）</li>\n</ul>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "UUID —— 基于微服务架构的UI设计师与开发者合作平台",
      "url": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/",
      "content_html": "<h1 id=\"uuid-基于微服务架构的ui设计师与开发者合作平台\"> UUID —— 基于微服务架构的UI设计师与开发者合作平台</h1>\n<blockquote>\n<p>中山大学新华学院 17级软件工程 李步官</p>\n<p>毕业设计选题</p>\n<p>项目地址1：https://github.com/U-UI-D</p>\n<p>项目地址2：https://gitee.com/U-UI-D</p>\n<p>项目正在开发中</p>\n</blockquote>\n<h2 id=\"开源项目地址\"> 开源项目地址</h2>\n<p>web前端（React）：https://gitee.com/U-UI-D/react-uuid-frontend</p>\n<p>移动端（React Native）：https://gitee.com/U-UI-D/uuid_react_native_app</p>\n<h2 id=\"项目背景\"> 项目背景</h2>\n<p>UI中国网站（ui.cn）和站酷网站（zcool.cn）上有许多UI设计者们发布精美的作品，我作为软件开发方向的学生，我从我自己的角度出发，首先的我精力不是花在UI的设计上，更多的精力是花在业务的实现和软件UI的实现上。而我平时在逛UI中国的时候，我想的是，我能不能直接直接使用这些UI作品去实现一个软件呢？在不侵权的情况下，可以用来学习和练习自己的技术，这样UI设计者可以知道自己的作品受欢迎的程度，软件开发者也可以获得练习技术的机会。如果设计者与开发者的合作的作品有商业价值，或许还可以相互合作创业。</p>\n<p>取这个项目的标题我也想了很长一段时间，最终选定为<strong>UUID</strong>。UUID本来是Java中一个通用字符串（UUID）类的类名，我把本项目的名称取名为UUID，一是因为包含单词**<code>UI</code><strong>和字母</strong><code>D</code>**，单词UI即我们熟悉的用户界面的意思，字母D则表示Designer和Developer，即设计师和开发者，比较符合本项目的开发目的。</p>\n<p>——这里有（<strong>U</strong>）</p>\n<p>——<strong>UI</strong>，</p>\n<p>——<strong>D</strong>esigner，<strong>D</strong>eveloper</p>\n<p>——UI设计师与软件开发者合作平台，让UI作品落地的地方</p>\n<h2 id=\"功能点\"> 功能点</h2>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/UUID.png\" alt=\"UUID\" /></p>\n<h2 id=\"技术选型\"> 技术选型</h2>\n<h3 id=\"后端\"> 后端</h3>\n<blockquote>\n<p>预选这些技术，实际开发可能会有所变动</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>技术</th>\n<th>名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Spring Boot</td>\n<td>微服务应用基础框架</td>\n</tr>\n<tr>\n<td>Spring Cloud</td>\n<td>微服务集成框架</td>\n</tr>\n<tr>\n<td>Spring Cloud Config</td>\n<td>分布式配置中心</td>\n</tr>\n<tr>\n<td>Spring Cloud Eureka</td>\n<td>服务注册与发现</td>\n</tr>\n<tr>\n<td>Zipkin</td>\n<td>链路追踪</td>\n</tr>\n<tr>\n<td>Zuul</td>\n<td>API网关</td>\n</tr>\n<tr>\n<td>Spring Boot Admin</td>\n<td>服务监控</td>\n</tr>\n<tr>\n<td>Maven</td>\n<td>项目构建管理</td>\n</tr>\n<tr>\n<td>Nexus3</td>\n<td>Maven私服</td>\n</tr>\n<tr>\n<td>阿里云云效 或 Jenkins</td>\n<td>持续集成CI/持续部署CD</td>\n</tr>\n<tr>\n<td>Github、Gitee</td>\n<td>代码仓库</td>\n</tr>\n<tr>\n<td>阿里云云数据库RDS MySQL5.7</td>\n<td>数据库</td>\n</tr>\n<tr>\n<td>Druid</td>\n<td>数据库连接池</td>\n</tr>\n<tr>\n<td>MyBatis</td>\n<td>ORM框架</td>\n</tr>\n<tr>\n<td>PageHelper</td>\n<td>分页插件</td>\n</tr>\n<tr>\n<td>Redis Sentinel</td>\n<td>哨兵集群</td>\n</tr>\n<tr>\n<td>阿里云OSS</td>\n<td>云对象存储</td>\n</tr>\n<tr>\n<td>Swagger2</td>\n<td>API文档生成工具</td>\n</tr>\n<tr>\n<td>RESTful API</td>\n<td>RESTful风格API</td>\n</tr>\n<tr>\n<td>Nginx</td>\n<td>代理服务器</td>\n</tr>\n<tr>\n<td>Docker</td>\n<td>应用容器</td>\n</tr>\n<tr>\n<td>Kubernetes</td>\n<td>应用容器</td>\n</tr>\n<tr>\n<td>阿里云镜像仓库</td>\n<td>阿里云镜像仓库</td>\n</tr>\n<tr>\n<td>OAuth2 或 Shiro</td>\n<td>身份/权限认证</td>\n</tr>\n<tr>\n<td>Quartz</td>\n<td>分布式任务调度</td>\n</tr>\n<tr>\n<td>Elastic Search</td>\n<td>分布式全文搜索</td>\n</tr>\n<tr>\n<td>RabbitMQ 或 RocketMQ 或 Kafka</td>\n<td>消息队列</td>\n</tr>\n<tr>\n<td>短信通知</td>\n<td></td>\n</tr>\n<tr>\n<td>邮件发送</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"前端\"> 前端</h3>\n<blockquote>\n<p>预选这些技术，实际开发可能会有所变动</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>技术</th>\n<th>名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HTML</td>\n<td>超文本标记语言</td>\n</tr>\n<tr>\n<td>CSS</td>\n<td>层叠样式表</td>\n</tr>\n<tr>\n<td>JavaScript</td>\n<td>网页脚本语言</td>\n</tr>\n<tr>\n<td>React</td>\n<td>前端框架</td>\n</tr>\n<tr>\n<td>ReactRouter</td>\n<td>前端路由</td>\n</tr>\n<tr>\n<td>Redux</td>\n<td>状态管理（数据存储）</td>\n</tr>\n<tr>\n<td>Ant Design</td>\n<td>前端样式框架</td>\n</tr>\n<tr>\n<td>Axios</td>\n<td>网络请求</td>\n</tr>\n<tr>\n<td>echarts</td>\n<td>图表框架</td>\n</tr>\n<tr>\n<td>React Native</td>\n<td>移动端跨平台框架</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"项目仓库\"> 项目仓库</h2>\n<blockquote>\n<p>服务端的项目正在开发中，暂不开源</p>\n<p>React前端项目也在开发中，可以先开放</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n<th>链接</th>\n<th>公开</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>react-uuid-frontend</td>\n<td>React前端项目</td>\n<td>https://github.com/U-UI-D/react-uuid-frontend</td>\n<td><img src=\"https://gitee.com/assets/emoji/o-ceeb7cc805471138507c063327e35636.png\" alt=\":o:\" /></td>\n</tr>\n<tr>\n<td>uuid-public-files</td>\n<td>公开文件</td>\n<td>https://github.com/U-UI-D/uuid-public-files</td>\n<td><img src=\"https://gitee.com/assets/emoji/o-ceeb7cc805471138507c063327e35636.png\" alt=\":o:\" /></td>\n</tr>\n<tr>\n<td>uuid-config-repo</td>\n<td>分布式配置中心-存放配置文件的仓库</td>\n<td>https://github.com/U-UI-D/uuid-config-repo</td>\n<td><img src=\"https://gitee.com/assets/emoji/x-c7f8694f70e339c194324671e39080c2.png\" alt=\":x:\" /></td>\n</tr>\n<tr>\n<td>uuid-dependencies</td>\n<td>统一的依赖管理</td>\n<td>https://github.com/U-UI-D/uuid-dependencies</td>\n<td><img src=\"https://gitee.com/assets/emoji/x-c7f8694f70e339c194324671e39080c2.png\" alt=\":x:\" /></td>\n</tr>\n<tr>\n<td>uuid-domain</td>\n<td>统一的领域模型（实体类）</td>\n<td>https://github.com/U-UI-D/uuid-domain</td>\n<td><img src=\"https://gitee.com/assets/emoji/x-c7f8694f70e339c194324671e39080c2.png\" alt=\":x:\" /></td>\n</tr>\n<tr>\n<td>uuid-config</td>\n<td>分布式配置中心</td>\n<td>https://github.com/U-UI-D/uuid-config</td>\n<td><img src=\"https://gitee.com/assets/emoji/x-c7f8694f70e339c194324671e39080c2.png\" alt=\":x:\" /></td>\n</tr>\n<tr>\n<td>uuid-eureka</td>\n<td>分布式服务注册与发现</td>\n<td>https://github.com/U-UI-D/uuid-eureka</td>\n<td><img src=\"https://gitee.com/assets/emoji/x-c7f8694f70e339c194324671e39080c2.png\" alt=\":x:\" /></td>\n</tr>\n<tr>\n<td>uuid-zipkin</td>\n<td>分布式链路追踪</td>\n<td>https://github.com/U-UI-D/uuid-zipkin</td>\n<td><img src=\"https://gitee.com/assets/emoji/x-c7f8694f70e339c194324671e39080c2.png\" alt=\":x:\" /></td>\n</tr>\n<tr>\n<td>uuid-gateway</td>\n<td>分布式网关</td>\n<td>https://github.com/U-UI-D/uuid-gateway</td>\n<td><img src=\"https://gitee.com/assets/emoji/x-c7f8694f70e339c194324671e39080c2.png\" alt=\":x:\" /></td>\n</tr>\n<tr>\n<td>uuid-common</td>\n<td>通用项目模块</td>\n<td>https://github.com/U-UI-D/uuid-common</td>\n<td><img src=\"https://gitee.com/assets/emoji/x-c7f8694f70e339c194324671e39080c2.png\" alt=\":x:\" /></td>\n</tr>\n<tr>\n<td>uuid-dependencies-spring-cloud-component</td>\n<td>微服务通用组件依赖</td>\n<td>https://github.com/U-UI-D/uuid-dependencies-spring-cloud-component</td>\n<td><img src=\"https://gitee.com/assets/emoji/x-c7f8694f70e339c194324671e39080c2.png\" alt=\":x:\" /></td>\n</tr>\n<tr>\n<td>uuid-service-common</td>\n<td>通用的服务提供者</td>\n<td>https://github.com/U-UI-D/uuid-service-common</td>\n<td><img src=\"https://gitee.com/assets/emoji/x-c7f8694f70e339c194324671e39080c2.png\" alt=\":x:\" /></td>\n</tr>\n<tr>\n<td>uuid-service-user</td>\n<td>服务提供者-用户</td>\n<td>https://github.com/U-UI-D/uuid-service-user</td>\n<td><img src=\"https://gitee.com/assets/emoji/x-c7f8694f70e339c194324671e39080c2.png\" alt=\":x:\" /></td>\n</tr>\n<tr>\n<td>uuid-service-work</td>\n<td>作品服务提供者</td>\n<td>https://github.com/U-UI-D/uuid-service-work</td>\n<td><img src=\"https://gitee.com/assets/emoji/x-c7f8694f70e339c194324671e39080c2.png\" alt=\":x:\" /></td>\n</tr>\n<tr>\n<td>待添加。。。</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"开发进度\"> 开发进度</h2>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>模块</th>\n<th>进度</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>用户模块</td>\n<td>60%</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>作品模块</td>\n<td>60%</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>轮播图模块</td>\n<td>80%</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>评论模块</td>\n<td>98%</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>素材模块</td>\n<td>20%</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>排行榜模块</td>\n<td>10%</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>积分商城模块</td>\n<td>10%</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>消息模块</td>\n<td>10%</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>上传模块</td>\n<td>100%</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>搜索模块</td>\n<td>0%</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/UUID.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "PageHelper分页不正常，pages始终等于1，total 始终等于pageSize的问题",
      "url": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/problems/1%E3%80%81pagehelper%E9%81%87%E5%88%B0%E5%88%86%E9%A1%B5%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E9%97%AE%E9%A2%98/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/problems/1%E3%80%81pagehelper%E9%81%87%E5%88%B0%E5%88%86%E9%A1%B5%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E9%97%AE%E9%A2%98/",
      "content_html": "<h1 id=\"pagehelper分页不正常-pages始终等于1-total-始终等于pagesize的问题\"> PageHelper分页不正常，pages始终等于1，total 始终等于pageSize的问题</h1>\n<h2 id=\"问题\"> 问题</h2>\n<p><strong><code>pages</code>始终等于1，<code>total</code> 始终等于<code>pageSize</code></strong></p>\n<p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200912095549024.png\" alt=\"image-20200912095549024\" /></p>\n<h2 id=\"原因\"> 原因</h2>\n<p>原因是我在查询到list数据之后，对list做了操作，导致分页不正常</p>\n<div><pre><code><span>// 这是service层的类</span>\n<span>public</span> <span>PageInfo</span><span><span>&lt;</span><span>TUiWork</span><span>></span></span> <span>getAllByPagination</span><span>(</span><span>Integer</span> pageNum<span>,</span> <span>Integer</span> pageSize<span>)</span> <span>{</span>\n    <span>PageHelper</span><span>.</span><span>startPage</span><span>(</span>pageNum<span>,</span> pageSize<span>)</span><span>;</span>\n    <span>List</span><span><span>&lt;</span><span>TUiWork</span><span>></span></span> workList <span>=</span> workMapper<span>.</span><span>getAll</span><span>(</span><span>)</span><span>;</span>\n    \n    <span>// 问题就在这里，我对workList做了操作</span>\n    <span>List</span><span><span>&lt;</span><span>TUiWork</span><span>></span></span> newWorkList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>TUiWork</span> work <span>:</span> workList<span>)</span> <span>{</span>\n        <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> imageUrlList <span>=</span> <span>getImageUrlListByIds</span><span>(</span>work<span>.</span><span>getImageId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        work<span>.</span><span>setImageUrls</span><span>(</span>imageUrlList<span>)</span><span>;</span>\n        newWorkList<span>.</span><span>add</span><span>(</span>work<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 把新的list传递给了PageInfo，导致分页不正常</span>\n    <span>PageInfo</span><span><span>&lt;</span><span>TUiWork</span><span>></span></span> tUiWorkPageInfo <span>=</span> <span>new</span> <span>PageInfo</span><span><span>&lt;</span><span>></span></span><span>(</span>newWorkList<span>)</span><span>;</span>\n    <span>return</span> tUiWorkPageInfo<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"解决\"> 解决</h2>\n<p>解决方法就是从数据库中查询出的list数据不要做其他操作，直接把list给<code>PageInfo</code>（这种做法不推荐，下面有更好的做法）</p>\n<div><pre><code><span>// 这是service层的类</span>\n<span>public</span> <span>PageInfo</span><span><span>&lt;</span><span>TUiWork</span><span>></span></span> <span>getAllByPagination</span><span>(</span><span>Integer</span> pageNum<span>,</span> <span>Integer</span> pageSize<span>)</span> <span>{</span>\n    <span>PageHelper</span><span>.</span><span>startPage</span><span>(</span>pageNum<span>,</span> pageSize<span>)</span><span>;</span>\n    <span>List</span><span><span>&lt;</span><span>TUiWork</span><span>></span></span> workList <span>=</span> workMapper<span>.</span><span>getAll</span><span>(</span><span>)</span><span>;</span>\n    <span>PageInfo</span><span><span>&lt;</span><span>TUiWork</span><span>></span></span> tUiWorkPageInfo <span>=</span> <span>new</span> <span>PageInfo</span><span><span>&lt;</span><span>></span></span><span>(</span>workList<span>)</span><span>;</span>\n    <span>return</span> tUiWorkPageInfo<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src=\"https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200912093915935.png\" alt=\"image-20200912093915935\" /></p>\n<p><strong>然而上面这种方法并不推荐，因为我们有的业务确实需要对查询后的<code>list</code>进行操作</strong></p>\n<p><strong>推荐下面这种做法</strong></p>\n<div><pre><code><span>// 这是service层的类</span>\n<span>public</span> <span>PageInfo</span><span><span>&lt;</span><span>TUiWork</span><span>></span></span> <span>getAllByPagination</span><span>(</span><span>Integer</span> pageNum<span>,</span> <span>Integer</span> pageSize<span>)</span> <span>{</span>\n    <span>PageHelper</span><span>.</span><span>startPage</span><span>(</span>pageNum<span>,</span> pageSize<span>)</span><span>;</span>\n    <span>List</span><span><span>&lt;</span><span>TUiWork</span><span>></span></span> workList <span>=</span> workMapper<span>.</span><span>getAll</span><span>(</span><span>)</span><span>;</span>\n    <span>// 对list做一些操作，新的list是newWorkList</span>\n    <span>List</span><span><span>&lt;</span><span>TUiWork</span><span>></span></span> newWorkList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>TUiWork</span> work <span>:</span> workList<span>)</span> <span>{</span>\n        <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> imageUrlList <span>=</span> <span>getImageUrlListByIds</span><span>(</span>work<span>.</span><span>getImageId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        work<span>.</span><span>setImageUrls</span><span>(</span>imageUrlList<span>)</span><span>;</span>\n        newWorkList<span>.</span><span>add</span><span>(</span>work<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 这里还是对数据中查询的list数据workList做分页</span>\n    <span>PageInfo</span><span><span>&lt;</span><span>TUiWork</span><span>></span></span> tUiWorkPageInfo <span>=</span> <span>new</span> <span>PageInfo</span><span><span>&lt;</span><span>></span></span><span>(</span>workList<span>)</span><span>;</span>\n    <span>// 重新设置PageInfo的list即可，把新的list数据newWorkList设置到PageInfo</span>\n    tUiWorkPageInfo<span>.</span><span>setList</span><span>(</span>newWorkList<span>)</span><span>;</span>\n    \n    <span>return</span> tUiWorkPageInfo<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div>",
      "image": "https://gitee.com/AlanLee97/assert/raw/master/note_images/image-20200912095549024.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "模块设计",
      "url": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/module-design/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/module-design/",
      "content_html": "<h1 id=\"模块设计\"> 模块设计</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "ReactNative ScrollView嵌套的问题",
      "url": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/problems/2%E3%80%81ReactNative%20ScrollView%E5%B5%8C%E5%A5%97%E7%9A%84%E9%97%AE%E9%A2%98/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/problems/2%E3%80%81ReactNative%20ScrollView%E5%B5%8C%E5%A5%97%E7%9A%84%E9%97%AE%E9%A2%98/",
      "content_html": "<h2 id=\"reactnative-scrollview嵌套的问题\"> ReactNative ScrollView嵌套的问题</h2>\n<p>两个ScrollView嵌套，内层的ScrollView不会滚动</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "js在移动端时间转换显示Invalid Date",
      "url": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/problems/3%E3%80%81js%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%98%BE%E7%A4%BAInvalid%20Date/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/problems/3%E3%80%81js%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%98%BE%E7%A4%BAInvalid%20Date/",
      "content_html": "<h1 id=\"js在移动端时间转换显示invalid-date\"> js在移动端时间转换显示Invalid Date</h1>\n<h6 id=\"问题\"> 问题</h6>\n<p>js在移动端时间转换显示Invalid Date</p>\n<p>在<code>new Date('2020-11-29 20:00:00')</code>时出现Invalid Date NaN:NaN:NaN的问题</p>\n<h6 id=\"解决\"> 解决</h6>\n<p>把字符串中的<code>-</code>符号替换成<code>/</code>符号即可解决，即将<code>2020-11-29 20:00:00</code>转换成<code>2020/11/29 20:00:00</code></p>\n<div><pre><code><span>let</span> date <span>=</span> <span>\"2020-11-29 20:00:00\"</span><span>;</span>\ndate <span>=</span> date<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>-</span><span>/</span><span>g</span></span><span>,</span> <span>\"/\"</span><span>)</span><span>;</span>  <span>// 得到 2020/11/29 20:00:00</span>\ndate <span>=</span> <span>new</span> <span>Date</span><span>(</span>date<span>)</span><span>;</span> <span>// 成功转换时间</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果是ISO时间（<code>2020-11-28T21:32:05.000+0000</code>），则需手动转换成<code>2020/11/28 21:32:05</code>的形式，再进行new Date()转换</p>\n<div><pre><code><span>let</span> date <span>=</span> <span>\"2020-11-28T21:32:05.000+0000\"</span><span>;</span>\n<span>let</span> d <span>=</span> date<span>.</span><span>split</span><span>(</span><span>\"T\"</span><span>)</span><span>[</span><span>0</span><span>]</span><span>;</span>\n<span>let</span> t <span>=</span> date<span>.</span><span>split</span><span>(</span><span>\"T\"</span><span>)</span><span>[</span><span>1</span><span>]</span><span>.</span><span>split</span><span>(</span><span>\".\"</span><span>)</span><span>[</span><span>0</span><span>]</span><span>;</span>\n<span>let</span> dt <span>=</span> d <span>+</span> <span>\" \"</span> <span>+</span> t<span>;</span>\ndate <span>=</span> dt<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>-</span><span>/</span><span>g</span></span><span>,</span> <span>\"/\"</span><span>)</span><span>;</span>  <span>// 得到 2020/11/28 21:32:05</span>\ndate <span>=</span> <span>new</span> <span>Date</span><span>(</span>date<span>)</span><span>;</span> <span>// 成功转换时间</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "秒杀模块设计",
      "url": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/module-design/%E7%A7%92%E6%9D%80%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/module-design/%E7%A7%92%E6%9D%80%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/",
      "content_html": "<h1 id=\"秒杀模块设计\"> 秒杀模块设计</h1>\n<h3 id=\"秒杀系统设计\"> 秒杀系统设计</h3>\n<h3 id=\"秒杀系统要解决的问题\"> 秒杀系统要解决的问题</h3>\n<h4 id=\"_1-防止超卖\"> 1. 防止超卖</h4>\n<h4 id=\"_2-防止重复下单\"> 2. 防止重复下单</h4>\n<h3 id=\"秒杀系统的优化\"> 秒杀系统的优化</h3>\n<h4 id=\"_1-接口限流\"> 1. 接口限流</h4>\n<h4 id=\"_2-接口地址隐藏\"> 2. 接口地址隐藏</h4>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "openfeign调用post服务并且传递对象参数是null",
      "url": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/problems/4%E3%80%81openfeign%E8%B0%83%E7%94%A8post%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%94%E4%BC%A0%E9%80%92%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0%E6%98%AFnull/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/problems/4%E3%80%81openfeign%E8%B0%83%E7%94%A8post%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%94%E4%BC%A0%E9%80%92%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0%E6%98%AFnull/",
      "content_html": "<h2 id=\"openfeign调用post服务并且传递对象参数是null\"> openfeign调用post服务并且传递对象参数是null</h2>\n<p>需要在feign接口和 controller的方法中都加上 @RequestBody注解</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "React Native App问题",
      "url": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/problems/React%20Native%20App%E9%97%AE%E9%A2%98/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/problems/React%20Native%20App%E9%97%AE%E9%A2%98/",
      "content_html": "<h1 id=\"react-native-app问题\"> React Native App问题</h1>\n<ol>\n<li>展示多张动图导致页面卡顿的问题</li>\n<li>ReactNative ScrollView嵌套的问题，两个ScrollView嵌套，内层的ScrollView不会滚动</li>\n</ol>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "招聘平台",
      "url": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/%E6%8B%9B%E8%81%98%E5%B9%B3%E5%8F%B0/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/%E6%8B%9B%E8%81%98%E5%B9%B3%E5%8F%B0/",
      "content_html": "<h1 id=\"招聘平台\"> 招聘平台</h1>\n<p>现在招聘平台的痛点</p>\n<ul>\n<li>求职者投完简历后，没有消息了（HR未给反馈）</li>\n<li>求职者投完简历后，投递状态变成已阅读，之后也没有消息了（HR未给反馈）</li>\n<li>求职者面试成功之后，offer被无故取消</li>\n<li>公司面试到合适的人选之后，求职者毁约不到公司入职</li>\n</ul>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "毕业设计选题",
      "url": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/%E9%80%89%E9%A2%98/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/%E9%80%89%E9%A2%98/",
      "content_html": "<h1 id=\"毕业设计选题\"> 毕业设计选题</h1>\n<ul>\n<li>\n<p>水果秒杀商城</p>\n</li>\n<li>\n<p>UI设计与软件开发结合的平台</p>\n</li>\n<li>\n<p>行动者APP</p>\n<blockquote>\n<p>一个计划管理的APP，懒癌和拖延症的拯救者</p>\n</blockquote>\n</li>\n<li>\n<ul>\n<li>UI设计与软件开发结合的平台</li>\n</ul>\n</li>\n<li>\n<p>招聘平台</p>\n</li>\n</ul>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "UI设计与软件开发结合的平台",
      "url": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/%E8%B0%83%E6%9F%A5%E9%97%AE%E9%A2%98/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/graduation-project/%E8%B0%83%E6%9F%A5%E9%97%AE%E9%A2%98/",
      "content_html": "<h1 id=\"ui设计与软件开发结合的平台\"> UI设计与软件开发结合的平台</h1>\n<p>想做一个UI设计者与软件开发者合作的平台</p>\n<p>UI中国上有许多UI设计者们发布精美的作品，我作为软件开发人员，我从我自己的角度出发，首先的我精力不是花在UI的设计上，更多的精力是花在业务的实现和软件UI的实现上。而我平时在逛UI中国的时候，看到很多用户都在发自己的求职简历，我觉得能设计出这么好的作品的人才，难道还找不到好公司吗？</p>\n<ol>\n<li>在UI中国网站上，发布的作品，是否有软件开发人员找你合作过，比如想用你的UI作品做成一个APP或网站？</li>\n<li>你是否愿意把自己的UI作品分享给软件开发人员，将作品实现在真正的软件上？或者是收费授权使用？</li>\n</ol>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "作业共享提醒APP",
      "url": "http://blog.alanlee.top/blog-vuepress/project/homework-reminder/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/homework-reminder/",
      "content_html": "<h1 id=\"作业共享提醒app\"> 作业共享提醒APP</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "熊猫约拍",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/",
      "content_html": "<h1 id=\"熊猫约拍\"> 熊猫约拍</h1>\n<blockquote>\n<p>项目链接 https://gitee.com/Panda_Appointment</p>\n</blockquote>\n<h2 id=\"项目背景\"> 项目背景</h2>\n<p>随着电商时代的蓬勃发展，线上网店逐渐取代了线下实体店，许多平面模特为线上服装店拍摄服装照片，以便于买家判断是否需要购买此服装，但是电商要通过中间商才能找到自己想要的模特和摄影师，中间商利用信息不对等赚取差价，电商既没有少花钱，模特和摄影师也没有多赚钱，效率不高，价格却不低。</p>\n<p>每年六月都是毕业季，许多学校都会有拍毕业照的需要，甚至有些人会需要摄影师跟拍他毕业时学校的场景，以此来记录自己在这所学校的青葱岁月，便于以后追忆自己的似水年华。</p>\n<p>因为中西文化的逐渐融合，婚纱照成为现在每个新婚家庭必不可少的东西，但是照相馆里的婚纱照又贵，时间又很容易冲突，摄影师的水平也不一定符合要求。</p>\n<p>艺术照成为许多人保留自己的美好时光的不二选择，但是要找到符合自己要求的摄影团队，时间不会冲突是很困难的。</p>\n<p>摄影成为了不少人的兴趣爱好，但是作为一个摄影萌新，如何挑选相机和镜头呢？如何调焦？如何处理照片？如何根据不同的场景调试相机？</p>\n<p>为了解决以上的问题和需求，我们创建了熊猫约拍。熊猫约拍致力于打造一个功能更加完善，效率更高的摄影约拍平台，让顾客和模特、摄影师可以直接对话，减少中间商赚差价，让模特和摄影师可以有更加高效的交流。让菜鸟摄影师从中学到摄影的技巧。熊猫约拍的web端与移动端并行，既可用电脑访问，也可以用手机app。</p>\n<h2 id=\"项目简介\"> 项目简介</h2>\n<p>熊猫约拍，一个模特、摄影师预约拍照，效率更高的摄影约拍平台，让顾客和模特、摄影师可以直接发布需求或接单，让模特和摄影师可以有更加优质的预约拍照体验。不仅如此，用户还可以在熊猫约拍网站分享自己的作品、寻找拍照打卡地点、寻找摄影师或模特；网站还有贴心的订单排期和邮件提醒等功能。</p>\n<p>熊猫约拍的后台采用微服务架构，使用Spring Cloud体系的技术，在服务器部署上，采用应用容器引擎Kubernetes和Docker集群部署，实现高可用。同时使用阿里云云效流水线技术实现持续集成、持续部署，自动化运维。</p>\n<p>熊猫约拍搭建了多个客户端、分别有网站、安卓APP、微信公众号、微信小程序，多客户端为用户带来更多的选择，用户根据自己喜好选择一个客户端即可体验预约拍照。</p>\n<h2 id=\"功能点\"> 功能点</h2>\n<p>图示：已完成 ⭕️ 、未开始 ❌ 、开发中 💻</p>\n<h3 id=\"用户功能\"> 用户功能</h3>\n<h4 id=\"核心功能\"> 核心功能</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">功能</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">完成度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">预约拍照</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">发布预约</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">发布作品</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">打卡点推荐</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">模特/摄影师推荐</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">约拍排期表</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">短信通知</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">邮件通知</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内容搜索</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"非核心功能\"> 非核心功能</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">功能</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">完成度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">查询发布的约拍</td>\n<td style=\"text-align:center\">查询自己发布的约拍</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">查询接单的约拍</td>\n<td style=\"text-align:center\">查询自己接单的约拍</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">修改约拍内容</td>\n<td style=\"text-align:center\">修改自己发布的约拍内容</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">删除约拍</td>\n<td style=\"text-align:center\">删除自己发布的约拍</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">查询作品</td>\n<td style=\"text-align:center\">查询自己发布的作品</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">删除作品</td>\n<td style=\"text-align:center\">删除自己发布的作品</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">修改用户信息</td>\n<td style=\"text-align:center\">修改头像、昵称、密码、身份信息等</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"管理员功能\"> 管理员功能</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">功能</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">完成度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">用户管理</td>\n<td style=\"text-align:center\">对用户增删查改</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">预约拍照管理</td>\n<td style=\"text-align:center\">对预约拍照增删查改</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">订单管理</td>\n<td style=\"text-align:center\">对订单增删查改</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">作品管理</td>\n<td style=\"text-align:center\">对作品增删查改</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">约拍类型管理</td>\n<td style=\"text-align:center\">对约拍类型增删查改</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">轮播图管理</td>\n<td style=\"text-align:center\">对轮播图增删查改</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">打卡点管理</td>\n<td style=\"text-align:center\">对打卡点增删查改</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">统计用户城市</td>\n<td style=\"text-align:center\">统计用户城市</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">统计约拍</td>\n<td style=\"text-align:center\">统计约拍</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">统计作品</td>\n<td style=\"text-align:center\">统计作品</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"共同功能\"> 共同功能</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">功能</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">完成度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">图片上传</td>\n<td style=\"text-align:center\">图片上传</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"技术选型\"> 技术选型</h2>\n<h3 id=\"后端\"> 后端</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">技术</th>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">集成状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Spring Boot</td>\n<td style=\"text-align:center\">微服务应用基础框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud</td>\n<td style=\"text-align:center\">微服务集成框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Config</td>\n<td style=\"text-align:center\">分布式配置中心</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Eureka</td>\n<td style=\"text-align:center\">服务注册与发现</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Feign</td>\n<td style=\"text-align:center\">声明式服务调用</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Ribbon</td>\n<td style=\"text-align:center\">客户端负载均衡</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Hystrix</td>\n<td style=\"text-align:center\">服务容错保护</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Zuul</td>\n<td style=\"text-align:center\">API网关</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Zipkin</td>\n<td style=\"text-align:center\">链路追踪</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Boot Admin</td>\n<td style=\"text-align:center\">服务监控</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Maven</td>\n<td style=\"text-align:center\">项目构建管理</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Nexus3</td>\n<td style=\"text-align:center\">Maven私服</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云 云效</td>\n<td style=\"text-align:center\">持续集成CI/持续部署CD</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Gitee</td>\n<td style=\"text-align:center\">代码仓库</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云云数据库RDS MySQL5.7</td>\n<td style=\"text-align:center\">数据库</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Druid</td>\n<td style=\"text-align:center\">数据库连接池</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MyBatis</td>\n<td style=\"text-align:center\">ORM框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PageHelper</td>\n<td style=\"text-align:center\">分页插件</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Redis Sentinel</td>\n<td style=\"text-align:center\">哨兵集群</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云OSS</td>\n<td style=\"text-align:center\">云对象存储</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Swagger2</td>\n<td style=\"text-align:center\">API文档生成工具</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RESTful API</td>\n<td style=\"text-align:center\">RESTful风格API</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Nginx</td>\n<td style=\"text-align:center\">代理服务器</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Docker</td>\n<td style=\"text-align:center\">应用容器</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Kubernetes</td>\n<td style=\"text-align:center\">应用容器</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云镜像仓库</td>\n<td style=\"text-align:center\">阿里云镜像仓库</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Scrapy</td>\n<td style=\"text-align:center\">Python爬虫框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">OAuth2</td>\n<td style=\"text-align:center\">身份/权限认证</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Quartz</td>\n<td style=\"text-align:center\">分布式任务调度</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Elastic Search</td>\n<td style=\"text-align:center\">分布式全文搜索</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RabbitMQ</td>\n<td style=\"text-align:center\">消息队列</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">短信通知</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">邮件发送</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">微信公众号</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"前端\"> 前端</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">技术</th>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">集成状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">HTML</td>\n<td style=\"text-align:center\">超文本标记语言</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CSS</td>\n<td style=\"text-align:center\">层叠样式表</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">JavaScript</td>\n<td style=\"text-align:center\">网页脚本语言</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Vue.js</td>\n<td style=\"text-align:center\">前端框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">VueRouter</td>\n<td style=\"text-align:center\">前端路由</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Vuex</td>\n<td style=\"text-align:center\">状态管理（数据存储）</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Element-UI</td>\n<td style=\"text-align:center\">前端样式框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Axios</td>\n<td style=\"text-align:center\">网络请求</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">vue-waterfall-easy</td>\n<td style=\"text-align:center\">瀑布流组件</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">vue2-admin</td>\n<td style=\"text-align:center\">基于vue的后台管理前端框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">echarts</td>\n<td style=\"text-align:center\">图表框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">uni-app</td>\n<td style=\"text-align:center\">移动端跨平台框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"服务器\"> 服务器</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器</th>\n<th style=\"text-align:center\">配置</th>\n<th style=\"text-align:center\">使用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">阿里云ECS - master</td>\n<td style=\"text-align:center\">2核4G 5M带宽</td>\n<td style=\"text-align:center\">k8s主节点</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云ECS - temp-node-1</td>\n<td style=\"text-align:center\">1核2G 1M带宽</td>\n<td style=\"text-align:center\">k8s子节点1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云ECS - temp-node-2</td>\n<td style=\"text-align:center\">1核2G 1M带宽</td>\n<td style=\"text-align:center\">k8s子节点2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云ECS - node-1</td>\n<td style=\"text-align:center\">1核2G 1M带宽</td>\n<td style=\"text-align:center\">部署config、eureka、zuul等组件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">百度智能云BCC</td>\n<td style=\"text-align:center\">2核4G 1M带宽</td>\n<td style=\"text-align:center\">部署微服务服务提供者</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">华为云ECS</td>\n<td style=\"text-align:center\">1核2G 1M带宽</td>\n<td style=\"text-align:center\">部署Nexus3 Maven私服</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">腾讯云ECS</td>\n<td style=\"text-align:center\">1核2G 1M带宽</td>\n<td style=\"text-align:center\">部署Redis集群</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"软件架构\"> 软件架构</h2>\n<h3 id=\"系统架构图\"> 系统架构图</h3>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200324124354-537300.png\" alt=\"熊猫约拍架构图\" /></p>\n<h3 id=\"部署架构图\"> 部署架构图</h3>\n<p><img src=\"https://images.gitee.com/uploads/images/2020/0310/113729_2c29a9dc_2231089.png\" alt=\"distributedSystem\" /></p>\n<h2 id=\"项目代码仓库链接\"> 项目代码仓库链接</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">链接</th>\n<th style=\"text-align:center\">公开</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment\" target=\"_blank\" rel=\"noopener noreferrer\">Panda_Appointment</a></td>\n<td style=\"text-align:center\">熊猫约拍项目</td>\n<td style=\"text-align:center\">https://gitee.com/organizations/Panda_Appointment/projects</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/spring_cloud_micro_service_panda_appointment\" target=\"_blank\" rel=\"noopener noreferrer\">spring_cloud_micro_service_panda_appointment</a></td>\n<td style=\"text-align:center\">熊猫约拍项目-该仓库只存放README文档</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/spring_cloud_micro_service_panda_appointment</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-files\" target=\"_blank\" rel=\"noopener noreferrer\">panda-files</a></td>\n<td style=\"text-align:center\">存放文件docker-compose.yml和shell文件</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-files</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-config-repo\" target=\"_blank\" rel=\"noopener noreferrer\">panda-config-repo</a></td>\n<td style=\"text-align:center\">分布式配置中心-存放配置文件的仓库</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-config-repo</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-dependencies\" target=\"_blank\" rel=\"noopener noreferrer\">panda-dependencies</a></td>\n<td style=\"text-align:center\">统一的依赖管理</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-dependencies</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-domain\" target=\"_blank\" rel=\"noopener noreferrer\">panda-domain</a></td>\n<td style=\"text-align:center\">统一的领域模型（实体类）</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-domain</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-config\" target=\"_blank\" rel=\"noopener noreferrer\">panda-config</a></td>\n<td style=\"text-align:center\">分布式配置中心</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-config</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-eureka\" target=\"_blank\" rel=\"noopener noreferrer\">panda-eureka</a></td>\n<td style=\"text-align:center\">分布式服务注册与发现</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-eureka</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-admin\" target=\"_blank\" rel=\"noopener noreferrer\">panda-admin</a></td>\n<td style=\"text-align:center\">分布式应用管理中心</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-admin</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-zipkin\" target=\"_blank\" rel=\"noopener noreferrer\">panda-zipkin</a></td>\n<td style=\"text-align:center\">分布式链路追踪</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-zipkin</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-gateway\" target=\"_blank\" rel=\"noopener noreferrer\">panda-gateway</a></td>\n<td style=\"text-align:center\">分布式网关</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-gateway</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-common\" target=\"_blank\" rel=\"noopener noreferrer\">panda-common</a></td>\n<td style=\"text-align:center\">通用项目模块</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-common</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-common-microservice-component\" target=\"_blank\" rel=\"noopener noreferrer\">panda-common-microservice-component</a></td>\n<td style=\"text-align:center\">微服务通用组件依赖</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-common-microservice-component</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-common-provider\" target=\"_blank\" rel=\"noopener noreferrer\">panda-common-provider</a></td>\n<td style=\"text-align:center\">通用的服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-common-provider</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-common-comsumer\" target=\"_blank\" rel=\"noopener noreferrer\">panda-common-comsumer</a></td>\n<td style=\"text-align:center\">通用的服务消费者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-common-comsumer</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-user\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-user</a></td>\n<td style=\"text-align:center\">服务提供者-用户</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-user</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-image\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-image</a></td>\n<td style=\"text-align:center\">图片服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-image</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-TCarousel\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-TCarousel</a></td>\n<td style=\"text-align:center\">轮播图服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-TCarousel</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-redis\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-redis</a></td>\n<td style=\"text-align:center\">缓存服务提供者redis</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-redis</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-appointment\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-appointment</a></td>\n<td style=\"text-align:center\">约拍服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-appointment</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-appointment-type\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-appointment-type</a></td>\n<td style=\"text-align:center\">约拍类型服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-appointment-type</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-works\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-works</a></td>\n<td style=\"text-align:center\">作品服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-works</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-order\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-order</a></td>\n<td style=\"text-align:center\">订单服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-order</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-spot\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-spot</a></td>\n<td style=\"text-align:center\">打卡点服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-spot</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-quartz\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-quartz</a></td>\n<td style=\"text-align:center\">定时任务服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-quartz</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-elasticsearch\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-elasticsearch</a></td>\n<td style=\"text-align:center\">elastic search服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-elasticsearch</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-sso\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-sso</a></td>\n<td style=\"text-align:center\">单点登录服务</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-sso</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-consumer-user\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-consumer-user</a></td>\n<td style=\"text-align:center\">服务消费者-用户</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-consumer-user</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-frontend\" target=\"_blank\" rel=\"noopener noreferrer\">panda-frontend</a></td>\n<td style=\"text-align:center\">vue前端部署项目</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-frontend</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/vue_panda_appointment\" target=\"_blank\" rel=\"noopener noreferrer\">vue_panda_appointment</a></td>\n<td style=\"text-align:center\">熊猫约拍 - Vue前端代码仓库</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/vue_panda_appointment</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-frontend-admin\" target=\"_blank\" rel=\"noopener noreferrer\">panda-frontend-admin</a></td>\n<td style=\"text-align:center\">后台管理系统部署项目</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-frontend-admin</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/vue_admin_panda_appointment\" target=\"_blank\" rel=\"noopener noreferrer\">vue_admin_panda_appointment</a></td>\n<td style=\"text-align:center\">熊猫约拍 - vue后台管理代码仓库</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/vue_admin_panda_appointment</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"安装说明\"> 安装说明</h2>\n<h3 id=\"网站\"> 网站</h3>\n<ul>\n<li>主地址：http://panda.alanlee.top</li>\n<li>备用地址1：http://panda.nibuguai.cn</li>\n</ul>\n<blockquote>\n<p>体验账号</p>\n<p>帐号：test</p>\n<p>密码：123456</p>\n</blockquote>\n<h3 id=\"微信公众号\"> 微信公众号</h3>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200323125706-298071.jpeg\" alt=\"qrcode_for_gh_a80b923fbc86_258\" /></p>\n<h3 id=\"微信小程序\"> 微信小程序</h3>\n<p>审核未通过、请使用安卓app</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200323125826-678960.jpeg\" alt=\"小程序\" /></p>\n<h3 id=\"安卓-app\"> 安卓 APP</h3>\n<p>下载地址：https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/package/panda-appointment.apk</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200323125827-616732.png\" alt=\"app\" /></p>\n<blockquote>\n<p>体验账号</p>\n<p>帐号：test</p>\n<p>密码：123456</p>\n</blockquote>\n<h3 id=\"作品截图\"> 作品截图</h3>\n<h4 id=\"网站-2\"> 网站</h4>\n<blockquote>\n<p>主页</p>\n</blockquote>\n<img style=\"magin:10px; box-shadow: 2px 2px 10px #f1f1f1f1\" src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/1%20-%20%E4%B8%BB%E9%A1%B5.png\" />\n<blockquote>\n<p>约拍</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/2 - 约拍.png\" alt=\"约拍\" /></p>\n<blockquote>\n<p>约拍详情页</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/2-1 - 约拍详情.png\" alt=\"约拍详情页\" /></p>\n<blockquote>\n<p>作品</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/3 - 作品.png\" alt=\"作品\" /></p>\n<blockquote>\n<p>作品详情页</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/3-1 - 作品详情.png\" alt=\"作品详情页\" /></p>\n<blockquote>\n<p>打卡点</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/4 - 打卡点.png\" alt=\"打卡点\" /></p>\n<blockquote>\n<p>打卡点详情页</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/4-1 - 打卡点详情页.png\" alt=\"打卡点详情页\" /></p>\n<blockquote>\n<p>搜索</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/5 - 搜索.png\" alt=\"搜索\" /></p>\n<blockquote>\n<p>发布约拍</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/6 - 发布约拍.png\" alt=\"\" /></p>\n<blockquote>\n<p>个人主页 - 我的约拍</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/7-1 - 个人主页 - 约拍.png\" alt=\"\" /></p>\n<blockquote>\n<p>个人主页 - 我的作品</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/7-2 - 个人主页 - 作品.png\" alt=\"\" /></p>\n<blockquote>\n<p>个人主页 - 我的相册</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/7-3 - 个人主页 - 相册.png\" alt=\"\" /></p>\n<blockquote>\n<p>个人主页 - 排期</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/7-4 -  个人主页 - 排期.png\" alt=\"个人主页 - 排期\" /></p>\n<blockquote>\n<p>约拍类型</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/8 - 约拍类型.png\" alt=\"约拍类型\" /></p>\n<blockquote>\n<p>注册</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/9 - 注册.png\" alt=\"\" /></p>\n<blockquote>\n<p>登录</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/10 - 登录.png\" alt=\"\" /></p>\n<h4 id=\"app-微信小程序\"> APP / 微信小程序</h4>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/app/0 - 页面合集.PNG\" alt=\"\" /></p>\n<h4 id=\"微信公众号-2\"> 微信公众号</h4>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/wx-public-platform/微信公众号页面合集.PNG\" alt=\"微信公众号页面合集\" /></p>\n<h4 id=\"后台管理系统\"> 后台管理系统</h4>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/back-manage-system/后台管理系统页面合集.png\" alt=\"\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200324124354-537300.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "项目搭建 - 服务监控",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-admin/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%20-%20%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-admin/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%20-%20%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/",
      "content_html": "<h1 id=\"项目搭建-服务监控\"> 项目搭建 - 服务监控</h1>\n<h2 id=\"服务端搭建\"> 服务端搭建</h2>\n<h3 id=\"添加依赖\"> 添加依赖</h3>\n<p>在pom.xml中添加Spring Boot Admin的依赖</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.jolokia<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>jolokia-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>de.codecentric<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-admin-starter-server<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>2.1.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>pom.xml</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span><span>&lt;</span>project</span> <span>xmlns</span><span><span>=</span><span>\"</span>http://maven.apache.org/POM/4.0.0<span>\"</span></span> <span><span>xmlns:</span>xsi</span><span><span>=</span><span>\"</span>http://www.w3.org/2001/XMLSchema-instance<span>\"</span></span>\n         <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>\"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>modelVersion</span><span>></span></span>4.0.0<span><span><span>&lt;/</span>modelVersion</span><span>></span></span>\n\n    <span><span><span>&lt;</span>parent</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>top.alanlee<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>panda-dependencies<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;</span>version</span><span>></span></span>1.0.0-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>parent</span><span>></span></span>\n\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>panda-admin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>1.0.0-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;</span>packaging</span><span>></span></span>jar<span><span><span>&lt;/</span>packaging</span><span>></span></span>\n\n    <span><span><span>&lt;</span>dependencies</span><span>></span></span>\n        <span>&lt;!-- Spring Boot Begin --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-web<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>2.1.9.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span>&lt;!-- ======BEGIN Spring Boot Admin server ====== --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.jolokia<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>jolokia-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>de.codecentric<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-admin-starter-server<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>2.1.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span>&lt;!-- ======END Spring Boot Admin server ====== --></span>\n\n\n        <span>&lt;!-- ======BEGIN Spring Cloud ====== --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-starter-netflix-eureka-server<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-starter-config<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span>&lt;!-- ======END Spring Cloud ====== --></span>\n\n    <span><span><span>&lt;/</span>dependencies</span><span>></span></span>\n\n\n    <span><span><span>&lt;</span>build</span><span>></span></span>\n        <span><span><span>&lt;</span>plugins</span><span>></span></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>mainClass</span><span>></span></span>top.alanlee.panda.admin.AdminApplication<span><span><span>&lt;/</span>mainClass</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n    <span><span><span>&lt;/</span>build</span><span>></span></span>\n\n\n<span><span><span>&lt;/</span>project</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br></div></div><h3 id=\"添加配置\"> 添加配置</h3>\n<p>配置文件bootstrap.yml</p>\n<div><pre><code><span>spring</span><span>:</span>\n  <span>cloud</span><span>:</span>\n    <span>config</span><span>:</span>\n      <span>uri</span><span>:</span> http<span>:</span>//localhost<span>:</span><span>8888</span>\n      <span>label</span><span>:</span> master\n      <span>name</span><span>:</span> panda<span>-</span>admin<span>,</span> panda<span>-</span>client<span>-</span>eureka<span>,</span> panda<span>-</span>client<span>-</span>zipkin\n      <span>profile</span><span>:</span> dev\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>\n<p>uri为配置中心服务端的地址</p>\n</blockquote>\n<p>git仓库中的配置文件panda-admin.yml</p>\n<div><pre><code><span>spring</span><span>:</span>\n  <span>application</span><span>:</span>\n    <span>name</span><span>:</span> panda<span>-</span>admin\n  <span>zipkin</span><span>:</span>\n    <span>base-url</span><span>:</span> http<span>:</span>//localhost<span>:</span><span>9411</span>\n\n<span>server</span><span>:</span>\n  <span>port</span><span>:</span> <span>8766</span>\n\n<span>eureka</span><span>:</span>\n  <span>client</span><span>:</span>\n    <span>service-url</span><span>:</span>\n      <span>default-zone</span><span>:</span> http<span>:</span>//localhost<span>:</span>8761/eureka/\n\n<span>management</span><span>:</span>\n  <span>endpoint</span><span>:</span>\n    <span>health</span><span>:</span>\n      <span>show-details</span><span>:</span> always\n  <span>endpoints</span><span>:</span>\n    <span>web</span><span>:</span>\n      <span>exposure</span><span>:</span>\n        <span>include</span><span>:</span> health<span>,</span> info\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id=\"添加注解\"> 添加注解</h3>\n<p>启动类上添加@EnableAdminServer注解</p>\n<div><pre><code><span>@SpringBootApplication</span>\n<span>@EnableAdminServer</span>\n<span>@EnableEurekaClient</span>\n<span>public</span> <span>class</span> <span>AdminApplication</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>AdminApplication</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"其他\"> 其他</h3>\n<p>Dockerfile</p>\n<div><pre><code><span># 指定基础镜像</span>\n<span><span>FROM</span> openjdk:8-jre-alpine</span>\n<span># 重命名</span>\n<span><span>ADD</span> [<span>\"/target/*.jar\"</span>,<span>\"panda-admin.jar\"</span>]</span>\n<span># 对外暴露端口号</span>\n<span><span>EXPOSE</span> 8888</span>\n<span># 运行</span>\n<span><span>ENTRYPOINT</span> [<span>\"java\"</span>,<span>\"-jar\"</span>,<span>\"/panda-admin.jar\"</span>, <span>\"--spring.profiles.active=prod\"</span>, <span>\"-Xmx32m\"</span>, <span>\"-Xms32m\"</span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"客户端搭建\"> 客户端搭建</h2>\n<blockquote>\n<p>以panda-eureka的项目为例</p>\n</blockquote>\n<h3 id=\"添加依赖-2\"> 添加依赖</h3>\n<p>在其他项目的pom.xml文件中添加spring-boot-admin的客户端依赖</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.jolokia<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>jolokia-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>de.codecentric<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-admin-starter-client<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "流水线配置",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-config/%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%85%8D%E7%BD%AE/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-config/%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%85%8D%E7%BD%AE/",
      "content_html": "<h1 id=\"流水线配置\"> 流水线配置</h1>\n<h2 id=\"部署配置\"> 部署配置</h2>\n<p><strong>在服务器中操作</strong></p>\n<p>创建目录</p>\n<div><pre><code><span>mkdir</span> - p /root/project/panda-appointment/panda-config\n</code></pre>\n<div><span>1</span><br></div></div><p>创建docker-compose.yml</p>\n<div><pre><code><span>vim</span> docker-compose.yml\n</code></pre>\n<div><span>1</span><br></div></div><p>粘贴如下内容</p>\n<div><pre><code><span>version</span><span>:</span> <span>'3.1'</span>\n<span>services</span><span>:</span>\n  <span>panda-config</span><span>:</span>\n    <span>image</span><span>:</span> registry.cn<span>-</span>shenzhen.aliyuncs.com/panda<span>-</span>appointment/panda<span>-</span>config<span>:</span>1.0.0\n    <span>container_name</span><span>:</span> panda<span>-</span>config\n    <span>ports</span><span>:</span>\n     <span>-</span> 8888<span>:</span><span>8888</span>\n    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>在云效中操作</strong></p>\n<p>部署方式：RDC脚本部署</p>\n<p>下载路径：不填</p>\n<p>部署脚本：</p>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-config-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/docker-compose/panda-config/panda-config-deploy.sh\n\n<span>sh</span> panda-config-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行用户：root</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "项目搭建 - 分布式配置中心",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-config/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%20-%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-config/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%20-%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/",
      "content_html": "<h1 id=\"项目搭建-分布式配置中心\"> 项目搭建 - 分布式配置中心</h1>\n<h2 id=\"服务端搭建\"> 服务端搭建</h2>\n<h3 id=\"添加依赖\"> 添加依赖</h3>\n<p>在pom.xml中添加Spring Cloud Config的依赖</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-config-server<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>pom.xml</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span><span>&lt;</span>project</span> <span>xmlns</span><span><span>=</span><span>\"</span>http://maven.apache.org/POM/4.0.0<span>\"</span></span> <span><span>xmlns:</span>xsi</span><span><span>=</span><span>\"</span>http://www.w3.org/2001/XMLSchema-instance<span>\"</span></span>\n         <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>\"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>modelVersion</span><span>></span></span>4.0.0<span><span><span>&lt;/</span>modelVersion</span><span>></span></span>\n\n    <span><span><span>&lt;</span>parent</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>top.alanlee<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>panda-dependencies<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;</span>version</span><span>></span></span>1.0.0-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>\n\n    <span><span><span>&lt;/</span>parent</span><span>></span></span>\n\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>panda-config<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>1.0.0-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;</span>packaging</span><span>></span></span>jar<span><span><span>&lt;/</span>packaging</span><span>></span></span>\n\n    <span><span><span>&lt;</span>dependencies</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-web<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-test<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span>&lt;!-- ====== BEGIN Spring Cloud===== --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-config-server<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-netflix-eureka-client<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-starter-zipkin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span>&lt;!-- ====== END Spring Cloud===== --></span>\n\n    <span><span><span>&lt;/</span>dependencies</span><span>></span></span>\n\n    <span><span><span>&lt;</span>build</span><span>></span></span>\n        <span><span><span>&lt;</span>plugins</span><span>></span></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>mainClass</span><span>></span></span>top.alanlee.panda.config.ConfigApplication<span><span><span>&lt;/</span>mainClass</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n    <span><span><span>&lt;/</span>build</span><span>></span></span>\n\n\n    <span><span><span>&lt;</span>repositories</span><span>></span></span>\n        <span><span><span>&lt;</span>repository</span><span>></span></span>\n            <span><span><span>&lt;</span>id</span><span>></span></span>nexus<span><span><span>&lt;/</span>id</span><span>></span></span>\n            <span><span><span>&lt;</span>name</span><span>></span></span>Nexus Repository<span><span><span>&lt;/</span>name</span><span>></span></span>\n            <span><span><span>&lt;</span>url</span><span>></span></span>http://114.116.245.65:8081/repository/maven-public/<span><span><span>&lt;/</span>url</span><span>></span></span>\n            <span><span><span>&lt;</span>snapshots</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>true<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>snapshots</span><span>></span></span>\n            <span><span><span>&lt;</span>releases</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>true<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>releases</span><span>></span></span>\n        <span><span><span>&lt;/</span>repository</span><span>></span></span>\n    <span><span><span>&lt;/</span>repositories</span><span>></span></span>\n\n<span><span><span>&lt;/</span>project</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div><h3 id=\"添加配置\"> 添加配置</h3>\n<p>配置文件bootstrap.yml</p>\n<div><pre><code><span>spring</span><span>:</span>\n  <span>application</span><span>:</span>\n    <span>name</span><span>:</span> panda<span>-</span>config\n  <span>cloud</span><span>:</span>\n    <span>config</span><span>:</span>\n      <span>label</span><span>:</span> master\n      <span>server</span><span>:</span>\n      \t<span># 配置git</span>\n        <span>git</span><span>:</span>\n          <span># git仓库地址</span>\n          <span>uri</span><span>:</span> https<span>:</span>//gitee.com/Panda_Appointment/panda<span>-</span>config<span>-</span>repo.git\n          <span>search-paths</span><span>:</span> repo\n          <span>username</span><span>:</span> AlanLee97\n          <span>password</span><span>:</span> AlanLee97\n        <span>bootstrap</span><span>:</span> <span>true</span>\n  <span># 配置zipkin</span>\n  <span>zipkin</span><span>:</span>\n    <span>base-url</span><span>:</span> http<span>:</span>//localhost<span>:</span><span>9411</span>\n\n<span>server</span><span>:</span>\n  <span>port</span><span>:</span> <span>8888</span>\n\n<span># 配置eureka</span>\n<span>eureka</span><span>:</span>\n  <span>client</span><span>:</span>\n    <span>service-url</span><span>:</span>\n      <span>default-zone</span><span>:</span> http<span>:</span>//localhost<span>:</span>8761/eureka/\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><blockquote>\n<p>在git仓库上创建一个仓库，用来存放配置文件，该仓库的地址就是上面配置文件的uri地址</p>\n</blockquote>\n<h3 id=\"添加注解\"> 添加注解</h3>\n<p>启动类上添加@EnableConfigServer注解</p>\n<div><pre><code><span>@SpringBootApplication</span>\n<span>@EnableConfigServer</span>\n<span>@EnableDiscoveryClient</span>\n<span>public</span> <span>class</span> <span>ConfigApplication</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>ConfigApplication</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"其他\"> 其他</h3>\n<p>Dockerfile</p>\n<div><pre><code><span># 指定基础镜像</span>\n<span><span>FROM</span> openjdk:8-jre-alpine</span>\n<span># 重命名</span>\n<span><span>ADD</span> [<span>\"/target/*.jar\"</span>,<span>\"panda-config.jar\"</span>]</span>\n<span># 对外暴露端口号</span>\n<span><span>EXPOSE</span> 8888</span>\n<span># 运行</span>\n<span><span>ENTRYPOINT</span> [<span>\"java\"</span>,<span>\"-jar\"</span>,<span>\"/panda-config.jar\"</span>, <span>\"--spring.profiles.active=prod\"</span>, <span>\"-Xmx32m\"</span>, <span>\"-Xms32m\"</span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"客户端搭建\"> 客户端搭建</h2>\n<blockquote>\n<p>以Eureka的项目为例</p>\n</blockquote>\n<h3 id=\"添加依赖-2\"> 添加依赖</h3>\n<p>在其他项目的pom.xml文件中添加config的客户端依赖</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-starter-config<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"添加配置-2\"> 添加配置</h3>\n<p>配置文件bootstrap.yml</p>\n<div><pre><code><span>spring</span><span>:</span>\n  <span>cloud</span><span>:</span>\n    <span>config</span><span>:</span>\n      <span>uri</span><span>:</span> http<span>:</span>//localhost<span>:</span><span>8888</span>\n      <span>label</span><span>:</span> master\n      <span># name 就是存放在git仓库中的配置文件的名字，可以有多个，用逗号隔开</span>\n      <span>name</span><span>:</span> panda<span>-</span>eureka<span>,</span> panda<span>-</span>client<span>-</span>zipkin\n      <span>profile</span><span>:</span> dev\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>完整的配置文件放在git仓库中</p>\n</blockquote>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "作业提醒APP",
      "url": "http://blog.alanlee.top/blog-vuepress/project/homework-reminder/%E4%BD%9C%E4%B8%9A%E6%8F%90%E9%86%92APP/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/homework-reminder/%E4%BD%9C%E4%B8%9A%E6%8F%90%E9%86%92APP/",
      "content_html": "<h1 id=\"作业提醒app\"> 作业提醒APP</h1>\n<p>作业题共享提醒 APP是一个作业提醒的Android APP。</p>\n<p>功能：记录作业、作业共享、定时提醒完成作业、番茄时钟、短信验证、获取当前天气信息等功能。</p>\n<p>后端采用ThinkPHP框架。</p>\n<h2 id=\"技术桟\"> 技术桟</h2>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n<th>版本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>QMUI</td>\n<td>UI库</td>\n<td>1.4.0</td>\n</tr>\n<tr>\n<td>banner</td>\n<td>轮播图组件</td>\n<td>1.4.10</td>\n</tr>\n<tr>\n<td>Okhttp3</td>\n<td>网络请求框架</td>\n<td>3.10.0</td>\n</tr>\n<tr>\n<td>Gson</td>\n<td>JSON序列化工具</td>\n<td>2.8.5</td>\n</tr>\n<tr>\n<td>bmob-sdk</td>\n<td>Bmob后端云SDK——短信验证</td>\n<td>3.7.3-rc1</td>\n</tr>\n<tr>\n<td>ThinkPHP</td>\n<td>后端服务框架</td>\n<td>5.0</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"遇到的问题\"> 遇到的问题</h2>\n<p>Fragment中跳转另一个Activity的Fragment</p>\n<p>从之前主页的抽屉界面换成底部Tabbar的界面时，出现了显示不了数据的问题</p>\n<h2 id=\"难点\"> 难点</h2>\n<ul>\n<li>\n<p>Tabbar的实现</p>\n</li>\n<li>\n<p>自定义时钟界面的实现</p>\n</li>\n<li>\n<p>RecylerView的实现，需要准备适配器，ViewHolder等等</p>\n</li>\n</ul>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "项目搭建 - 服务注册与发现",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-eureka/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%20-%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-eureka/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%20-%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/",
      "content_html": "<h1 id=\"项目搭建-服务注册与发现\"> 项目搭建 - 服务注册与发现</h1>\n<h2 id=\"服务端搭建\"> 服务端搭建</h2>\n<h3 id=\"添加依赖\"> 添加依赖</h3>\n<p>在pom.xml中添加Spring Cloud Eureka的依赖</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-starter-netflix-eureka-server<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>pom.xml</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span><span>&lt;</span>project</span> <span>xmlns</span><span><span>=</span><span>\"</span>http://maven.apache.org/POM/4.0.0<span>\"</span></span> <span><span>xmlns:</span>xsi</span><span><span>=</span><span>\"</span>http://www.w3.org/2001/XMLSchema-instance<span>\"</span></span>\n         <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>\"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>modelVersion</span><span>></span></span>4.0.0<span><span><span>&lt;/</span>modelVersion</span><span>></span></span>\n\n    <span><span><span>&lt;</span>parent</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>top.alanlee<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>panda-dependencies<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;</span>version</span><span>></span></span>1.0.0-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>parent</span><span>></span></span>\n\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>panda-eureka<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>packaging</span><span>></span></span>jar<span><span><span>&lt;/</span>packaging</span><span>></span></span>\n\n    <span><span><span>&lt;</span>name</span><span>></span></span>panda-eureka<span><span><span>&lt;/</span>name</span><span>></span></span>\n    <span><span><span>&lt;</span>inceptionYear</span><span>></span></span>2020-Now<span><span><span>&lt;/</span>inceptionYear</span><span>></span></span>\n\n    <span><span><span>&lt;</span>dependencies</span><span>></span></span>\n        <span>&lt;!-- ======BEGIN Spring Boot ====== --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-test<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span>&lt;!-- ======END Spring Boot ====== --></span>\n\n\n        <span>&lt;!-- ======BEGIN Spring Cloud  ====== --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-starter-zipkin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-starter-config<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-starter-netflix-eureka-server<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span>&lt;!-- ======END Spring Cloud ====== --></span>\n\n\n        <span>&lt;!-- ======BEGIN Spring Boot Admin ====== --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.jolokia<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>jolokia-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>de.codecentric<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-admin-starter-client<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span>&lt;!-- ======END Spring Boot Admin ====== --></span>\n\n    <span><span><span>&lt;/</span>dependencies</span><span>></span></span>\n\n    <span><span><span>&lt;</span>build</span><span>></span></span>\n        <span><span><span>&lt;</span>plugins</span><span>></span></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>mainClass</span><span>></span></span>top.alanlee.panda.eureka.EurekaApplication<span><span><span>&lt;/</span>mainClass</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n    <span><span><span>&lt;/</span>build</span><span>></span></span>\n\n    <span><span><span>&lt;</span>repositories</span><span>></span></span>\n        <span><span><span>&lt;</span>repository</span><span>></span></span>\n            <span><span><span>&lt;</span>id</span><span>></span></span>nexus<span><span><span>&lt;/</span>id</span><span>></span></span>\n            <span><span><span>&lt;</span>name</span><span>></span></span>Nexus Repository<span><span><span>&lt;/</span>name</span><span>></span></span>\n            <span><span><span>&lt;</span>url</span><span>></span></span>http://114.116.245.65:8081/repository/maven-public/<span><span><span>&lt;/</span>url</span><span>></span></span>\n            <span><span><span>&lt;</span>snapshots</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>true<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>snapshots</span><span>></span></span>\n            <span><span><span>&lt;</span>releases</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>true<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>releases</span><span>></span></span>\n        <span><span><span>&lt;/</span>repository</span><span>></span></span>\n    <span><span><span>&lt;/</span>repositories</span><span>></span></span>\n<span><span><span>&lt;/</span>project</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br></div></div><h3 id=\"添加配置\"> 添加配置</h3>\n<p>配置文件bootstrap.yml</p>\n<div><pre><code><span>spring</span><span>:</span>\n  <span>cloud</span><span>:</span>\n    <span>config</span><span>:</span>\n      <span>uri</span><span>:</span> http<span>:</span>//localhost<span>:</span><span>8888</span>\n      <span>label</span><span>:</span> master\n      <span>name</span><span>:</span> panda<span>-</span>eureka<span>,</span> panda<span>-</span>client<span>-</span>zipkin\n      <span>profile</span><span>:</span> dev\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>\n<p>uri为配置中心服务端的地址</p>\n</blockquote>\n<h3 id=\"添加注解\"> 添加注解</h3>\n<p>启动类上添加@EnableEurekaServer、@EnableDiscoveryClient注解</p>\n<div><pre><code><span>@SpringBootApplication</span>\n<span>@EnableEurekaServer</span>\n<span>@EnableDiscoveryClient</span>\n<span>public</span> <span>class</span> <span>EurekaApplication</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>EurekaApplication</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"其他\"> 其他</h3>\n<p>Dockerfile</p>\n<div><pre><code><span># 指定基础镜像</span>\n<span><span>FROM</span> openjdk:8-jre-alpine</span>\n<span># 重命名</span>\n<span><span>ADD</span> [<span>\"/target/*.jar\"</span>,<span>\"panda-eureka.jar\"</span>]</span>\n<span># 对外暴露端口号</span>\n<span><span>EXPOSE</span> 8761</span>\n<span># 运行</span>\n<span><span>ENTRYPOINT</span> [<span>\"java\"</span>,<span>\"-jar\"</span>,<span>\"/panda-eureka.jar\"</span>, <span>\"--spring.profiles.active=prod\"</span>, <span>\"-Xmx32m\"</span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"客户端搭建\"> 客户端搭建</h2>\n<blockquote>\n<p>以panda-service-provider-user的项目为例</p>\n</blockquote>\n<h3 id=\"添加依赖-2\"> 添加依赖</h3>\n<p>在其他项目的pom.xml文件中添加config的客户端依赖</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-starter-netflix-eureka-server<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"添加配置-2\"> 添加配置</h3>\n<p>配置文件bootstrap.yml</p>\n<div><pre><code><span>spring</span><span>:</span>\n  <span>cloud</span><span>:</span>\n    <span>config</span><span>:</span>\n      <span>uri</span><span>:</span> http<span>:</span>//localhost<span>:</span><span>8888</span>\n      <span>label</span><span>:</span> master\n      <span>name</span><span>:</span> panda<span>-</span>common<span>-</span>service<span>-</span>provider<span>,</span> panda<span>-</span>service<span>-</span>provider<span>-</span>user\n      <span>profile</span><span>:</span> dev\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>\n<p>完整的配置文件放在git仓库中</p>\n</blockquote>\n<p>panda-common-service-provider.yml</p>\n<div><pre><code><span>spring</span><span>:</span>\n  <span>datasource</span><span>:</span>\n    <span>type</span><span>:</span> com.alibaba.druid.pool.DruidDataSource\n    <span>url</span><span>:</span> jdbc<span>:</span>mysql<span>:</span>//localhost<span>:</span>3306/panda_appointment<span>?</span>characterEncoding=utf<span>-</span>8<span>&amp;serverTimezone=UTC</span>\n    <span>username</span><span>:</span> root\n    <span>password</span><span>:</span> <span>123456</span>\n    <span>driver-class-name</span><span>:</span> com.mysql.cj.jdbc.Driver\n  <span>zipkin</span><span>:</span>\n    <span>base-url</span><span>:</span> http<span>:</span>//localhost<span>:</span><span>9411</span>\n\n<span>eureka</span><span>:</span>\n  <span>client</span><span>:</span>\n    <span>service-url</span><span>:</span>\n      <span>defaultZone</span><span>:</span> http<span>:</span>//localhost<span>:</span>8761/eureka/\n\n<span>mybatis</span><span>:</span>\n  <span>configuration</span><span>:</span>\n    <span>map-underscore-to-camel-case</span><span>:</span> <span>true</span>\n\n<span>#pagehelper分页插件配置</span>\n<span>pagehelper</span><span>:</span>\n  <span>helperDialect</span><span>:</span> mysql\n  <span>reasonable</span><span>:</span> <span>true</span>\n  <span>supportMethodsArguments</span><span>:</span> <span>true</span>\n  <span>params</span><span>:</span> count=countSql\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>panda-service-provider-user.yml</p>\n<div><pre><code><span>spring</span><span>:</span>\n  <span>application</span><span>:</span>\n    <span>name</span><span>:</span> panda<span>-</span>service<span>-</span>provider<span>-</span>user\n\n<span>server</span><span>:</span>\n  <span>port</span><span>:</span> <span>8090</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"添加注解-2\"> 添加注解</h3>\n<p>在启动类上添加@EnableDiscoveryClient注解</p>\n<div><pre><code><span>@EnableDiscoveryClient</span>\n<span>@SpringBootApplication</span>\n<span>public</span> <span>class</span> <span>UserServiceProviderApplication</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>UserServiceProviderApplication</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "项目搭建 - 服务注册与发现",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-service-provider-user/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%20-%20%E7%94%A8%E6%88%B7%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-service-provider-user/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%20-%20%E7%94%A8%E6%88%B7%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85/",
      "content_html": "<h1 id=\"项目搭建-服务注册与发现\"> 项目搭建 - 服务注册与发现</h1>\n<h2 id=\"服务端搭建\"> 服务端搭建</h2>\n<h3 id=\"添加依赖\"> 添加依赖</h3>\n<p>在pom.xml中添加Spring Cloud Eureka的依赖</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-starter-netflix-eureka-server<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>pom.xml</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span><span>&lt;</span>project</span> <span>xmlns</span><span><span>=</span><span>\"</span>http://maven.apache.org/POM/4.0.0<span>\"</span></span> <span><span>xmlns:</span>xsi</span><span><span>=</span><span>\"</span>http://www.w3.org/2001/XMLSchema-instance<span>\"</span></span>\n         <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>\"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>modelVersion</span><span>></span></span>4.0.0<span><span><span>&lt;/</span>modelVersion</span><span>></span></span>\n\n    <span><span><span>&lt;</span>parent</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>top.alanlee<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>panda-dependencies<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;</span>version</span><span>></span></span>1.0.0-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>\n\n    <span><span><span>&lt;/</span>parent</span><span>></span></span>\n\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>panda-service-provider-user<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>1.0.0-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;</span>packaging</span><span>></span></span>jar<span><span><span>&lt;/</span>packaging</span><span>></span></span>\n\n    <span><span><span>&lt;</span>dependencies</span><span>></span></span>\n        <span>&lt;!-- ======BEGIN Spring Boot ====== --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-web<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-test<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span>&lt;!-- ======END Spring Boot ====== --></span>\n\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>top.alanlee<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>panda-common-provider<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>${parent.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n\n\n    <span><span><span>&lt;/</span>dependencies</span><span>></span></span>\n\n    <span><span><span>&lt;</span>build</span><span>></span></span>\n        <span><span><span>&lt;</span>plugins</span><span>></span></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-compiler-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>source</span><span>></span></span>1.8<span><span><span>&lt;/</span>source</span><span>></span></span>\n                    <span><span><span>&lt;</span>target</span><span>></span></span>1.8<span><span><span>&lt;/</span>target</span><span>></span></span>\n                    <span><span><span>&lt;</span>encoding</span><span>></span></span>UTF-8<span><span><span>&lt;/</span>encoding</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>mainClass</span><span>></span></span>top.alanlee.panda.service.provider.user.UserServiceProviderApplication<span><span><span>&lt;/</span>mainClass</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n    <span><span><span>&lt;/</span>build</span><span>></span></span>\n\n    <span><span><span>&lt;</span>repositories</span><span>></span></span>\n        <span><span><span>&lt;</span>repository</span><span>></span></span>\n            <span><span><span>&lt;</span>id</span><span>></span></span>nexus<span><span><span>&lt;/</span>id</span><span>></span></span>\n            <span><span><span>&lt;</span>name</span><span>></span></span>Nexus Repository<span><span><span>&lt;/</span>name</span><span>></span></span>\n            <span><span><span>&lt;</span>url</span><span>></span></span>http://114.116.245.65:8081/repository/maven-public/<span><span><span>&lt;/</span>url</span><span>></span></span>\n            <span><span><span>&lt;</span>snapshots</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>true<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>snapshots</span><span>></span></span>\n            <span><span><span>&lt;</span>releases</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>true<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>releases</span><span>></span></span>\n        <span><span><span>&lt;/</span>repository</span><span>></span></span>\n    <span><span><span>&lt;/</span>repositories</span><span>></span></span>\n\n\n<span><span><span>&lt;/</span>project</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br></div></div><h3 id=\"添加配置\"> 添加配置</h3>\n<p>配置文件bootstrap.yml</p>\n<div><pre><code><span>spring</span><span>:</span>\n  <span>cloud</span><span>:</span>\n    <span>config</span><span>:</span>\n      <span>uri</span><span>:</span> http<span>:</span>//localhost<span>:</span><span>8888</span>\n      <span>label</span><span>:</span> master\n      <span>name</span><span>:</span> panda<span>-</span>eureka<span>,</span> panda<span>-</span>client<span>-</span>zipkin\n      <span>profile</span><span>:</span> dev\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>\n<p>uri为配置中心服务端的地址</p>\n</blockquote>\n<h3 id=\"添加注解\"> 添加注解</h3>\n<p>启动类上添加@EnableEurekaServer、@EnableDiscoveryClient注解</p>\n<div><pre><code><span>@SpringBootApplication</span>\n<span>@EnableEurekaServer</span>\n<span>@EnableDiscoveryClient</span>\n<span>public</span> <span>class</span> <span>EurekaApplication</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>EurekaApplication</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"其他\"> 其他</h3>\n<p>Dockerfile</p>\n<div><pre><code><span># 指定基础镜像</span>\n<span><span>FROM</span> openjdk:8-jre-alpine</span>\n<span># 重命名</span>\n<span><span>ADD</span> [<span>\"/target/*.jar\"</span>,<span>\"panda-eureka.jar\"</span>]</span>\n<span># 对外暴露端口号</span>\n<span><span>EXPOSE</span> 8761</span>\n<span># 运行</span>\n<span><span>ENTRYPOINT</span> [<span>\"java\"</span>,<span>\"-jar\"</span>,<span>\"/panda-eureka.jar\"</span>, <span>\"--spring.profiles.active=prod\"</span>, <span>\"-Xmx32m\"</span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"客户端搭建\"> 客户端搭建</h2>\n<blockquote>\n<p>以panda-service-provider-user的项目为例</p>\n</blockquote>\n<h3 id=\"添加依赖-2\"> 添加依赖</h3>\n<p>在其他项目的pom.xml文件中添加config的客户端依赖</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-starter-netflix-eureka-server<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"添加配置-2\"> 添加配置</h3>\n<p>配置文件bootstrap.yml</p>\n<div><pre><code><span>spring</span><span>:</span>\n  <span>cloud</span><span>:</span>\n    <span>config</span><span>:</span>\n      <span>uri</span><span>:</span> http<span>:</span>//localhost<span>:</span><span>8888</span>\n      <span>label</span><span>:</span> master\n      <span>name</span><span>:</span> panda<span>-</span>common<span>-</span>service<span>-</span>provider<span>,</span> panda<span>-</span>service<span>-</span>provider<span>-</span>user\n      <span>profile</span><span>:</span> dev\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>\n<p>完整的配置文件放在git仓库中</p>\n</blockquote>\n<p>panda-common-service-provider.yml</p>\n<div><pre><code><span>spring</span><span>:</span>\n  <span>datasource</span><span>:</span>\n    <span>type</span><span>:</span> com.alibaba.druid.pool.DruidDataSource\n    <span>url</span><span>:</span> jdbc<span>:</span>mysql<span>:</span>//localhost<span>:</span>3306/panda_appointment<span>?</span>characterEncoding=utf<span>-</span>8<span>&amp;serverTimezone=UTC</span>\n    <span>username</span><span>:</span> root\n    <span>password</span><span>:</span> <span>123456</span>\n    <span>driver-class-name</span><span>:</span> com.mysql.cj.jdbc.Driver\n  <span>zipkin</span><span>:</span>\n    <span>base-url</span><span>:</span> http<span>:</span>//localhost<span>:</span><span>9411</span>\n\n<span>eureka</span><span>:</span>\n  <span>client</span><span>:</span>\n    <span>service-url</span><span>:</span>\n      <span>defaultZone</span><span>:</span> http<span>:</span>//localhost<span>:</span>8761/eureka/\n\n<span>mybatis</span><span>:</span>\n  <span>configuration</span><span>:</span>\n    <span>map-underscore-to-camel-case</span><span>:</span> <span>true</span>\n\n<span>#pagehelper分页插件配置</span>\n<span>pagehelper</span><span>:</span>\n  <span>helperDialect</span><span>:</span> mysql\n  <span>reasonable</span><span>:</span> <span>true</span>\n  <span>supportMethodsArguments</span><span>:</span> <span>true</span>\n  <span>params</span><span>:</span> count=countSql\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>panda-service-provider-user.yml</p>\n<div><pre><code><span>spring</span><span>:</span>\n  <span>application</span><span>:</span>\n    <span>name</span><span>:</span> panda<span>-</span>service<span>-</span>provider<span>-</span>user\n\n<span>server</span><span>:</span>\n  <span>port</span><span>:</span> <span>8090</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"添加注解-2\"> 添加注解</h3>\n<p>在启动类上添加@EnableDiscoveryClient注解</p>\n<div><pre><code><span>@EnableDiscoveryClient</span>\n<span>@SpringBootApplication</span>\n<span>public</span> <span>class</span> <span>UserServiceProviderApplication</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>UserServiceProviderApplication</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "项目搭建 - 统一的项目依赖",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-dependencies/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%20-%20%E7%BB%9F%E4%B8%80%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-dependencies/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%20-%20%E7%BB%9F%E4%B8%80%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96/",
      "content_html": "<h1 id=\"项目搭建-统一的项目依赖\"> 项目搭建 - 统一的项目依赖</h1>\n<h2 id=\"搭建项目\"> 搭建项目</h2>\n<blockquote>\n<p>本项目只创建pom.xml文件即可</p>\n</blockquote>\n<h3 id=\"添加依赖\"> 添加依赖</h3>\n<p>pom.xml</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span><span>&lt;</span>project</span> <span>xmlns</span><span><span>=</span><span>\"</span>http://maven.apache.org/POM/4.0.0<span>\"</span></span> <span><span>xmlns:</span>xsi</span><span><span>=</span><span>\"</span>http://www.w3.org/2001/XMLSchema-instance<span>\"</span></span>\n         <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>\"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>modelVersion</span><span>></span></span>4.0.0<span><span><span>&lt;/</span>modelVersion</span><span>></span></span>\n\n    <span>&lt;!-- ====== 父工程 ====== --></span>\n    <span><span><span>&lt;</span>parent</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-parent<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;</span>version</span><span>></span></span>2.1.9.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>parent</span><span>></span></span>\n\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>top.alanlee<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>panda-dependencies<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>1.0.0-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;</span>packaging</span><span>></span></span>pom<span><span><span>&lt;/</span>packaging</span><span>></span></span>\n\n    <span><span><span>&lt;</span>name</span><span>></span></span>panda-dependencies<span><span><span>&lt;/</span>name</span><span>></span></span>\n    <span><span><span>&lt;</span>url</span><span>></span></span>http://alanlee.top<span><span><span>&lt;/</span>url</span><span>></span></span>\n    <span><span><span>&lt;</span>inceptionYear</span><span>></span></span>2020-Now<span><span><span>&lt;/</span>inceptionYear</span><span>></span></span>\n\n\n    <span><span><span>&lt;</span>properties</span><span>></span></span>\n        <span>&lt;!-- ======BEGIN 环境设置 ====== --></span>\n        <span><span><span>&lt;</span>java.version</span><span>></span></span>1.8<span><span><span>&lt;/</span>java.version</span><span>></span></span>\n        <span><span><span>&lt;</span>project.build.sourceEncoding</span><span>></span></span>UTF-8<span><span><span>&lt;/</span>project.build.sourceEncoding</span><span>></span></span>\n        <span><span><span>&lt;</span>project.reporting.outputEncoding</span><span>></span></span>UTF-8<span><span><span>&lt;/</span>project.reporting.outputEncoding</span><span>></span></span>\n        <span>&lt;!-- ======END 环境设置 ====== --></span>\n\n\n        <span>&lt;!-- ======BEGIN Spring Cloud 微服务组件  ====== --></span>\n        <span><span><span>&lt;</span>spring-cloud.version</span><span>></span></span>Greenwich.RELEASE<span><span><span>&lt;/</span>spring-cloud.version</span><span>></span></span>\n        <span><span><span>&lt;</span>spring-boot-admin.version</span><span>></span></span>2.2.1<span><span><span>&lt;/</span>spring-boot-admin.version</span><span>></span></span>\n        <span><span><span>&lt;</span>zipkin.version</span><span>></span></span>2.10.1<span><span><span>&lt;/</span>zipkin.version</span><span>></span></span>\n        <span><span><span>&lt;</span>openfeign.version</span><span>></span></span>2.2.1.RELEASE<span><span><span>&lt;/</span>openfeign.version</span><span>></span></span>\n        <span>&lt;!-- ======END Spring Cloud 微服务组件 ====== --></span>\n\n\n        <span>&lt;!-- ======BEGIN 数据库相关 ====== --></span>\n        <span><span><span>&lt;</span>mysql.version</span><span>></span></span>8.0.16<span><span><span>&lt;/</span>mysql.version</span><span>></span></span>\n        <span><span><span>&lt;</span>druid.version</span><span>></span></span>1.1.20<span><span><span>&lt;/</span>druid.version</span><span>></span></span>\n        <span><span><span>&lt;</span>mybatis-spring-boot-starter.version</span><span>></span></span>1.3.2<span><span><span>&lt;/</span>mybatis-spring-boot-starter.version</span><span>></span></span>\n        <span><span><span>&lt;</span>pagehelper-spring-boot-starter.version</span><span>></span></span>1.2.13<span><span><span>&lt;/</span>pagehelper-spring-boot-starter.version</span><span>></span></span>\n        <span>&lt;!-- ======END 数据库相关 ====== --></span>\n\n\n        <span>&lt;!-- ======BEGIN 工具 ====== --></span>\n        <span><span><span>&lt;</span>lombok.version</span><span>></span></span>1.18.8<span><span><span>&lt;/</span>lombok.version</span><span>></span></span>\n        <span><span><span>&lt;</span>springfox-swagger-ui.version</span><span>></span></span>2.9.2<span><span><span>&lt;/</span>springfox-swagger-ui.version</span><span>></span></span>\n        <span><span><span>&lt;</span>springfox-swagger2.version</span><span>></span></span>2.9.2<span><span><span>&lt;/</span>springfox-swagger2.version</span><span>></span></span>\n        <span><span><span>&lt;</span>guava.version</span><span>></span></span>28.2-jre<span><span><span>&lt;/</span>guava.version</span><span>></span></span>\n        <span>&lt;!-- ======END 工具 ====== --></span>\n\n\n        <span>&lt;!-- ======BEGIN 其他 ====== --></span>\n        <span><span><span>&lt;</span>spring-data-elasticsearch.version</span><span>></span></span>3.1.6.RELEASE<span><span><span>&lt;/</span>spring-data-elasticsearch.version</span><span>></span></span>\n\n        <span>&lt;!-- ======END  ====== --></span>\n\n    <span><span><span>&lt;/</span>properties</span><span>></span></span>\n\n    <span><span><span>&lt;</span>dependencyManagement</span><span>></span></span>\n        <span><span><span>&lt;</span>dependencies</span><span>></span></span>\n            <span>&lt;!-- ======BEGIN Spring Cloud ====== --></span>\n            <span><span><span>&lt;</span>dependency</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-dependencies<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>${spring-cloud.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n                <span><span><span>&lt;</span>type</span><span>></span></span>pom<span><span><span>&lt;/</span>type</span><span>></span></span>\n                <span><span><span>&lt;</span>scope</span><span>></span></span>import<span><span><span>&lt;/</span>scope</span><span>></span></span>\n            <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n            <span>&lt;!-- ======END Spring Cloud ====== --></span>\n\n            \n            <span>&lt;!-- ======BEGIN Spring Boot Admin ====== --></span>\n            <span><span><span>&lt;</span>dependency</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>de.codecentric<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-admin-starter-server<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>${spring-boot-admin.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n            <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>dependency</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>de.codecentric<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-admin-starter-client<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>${spring-boot-admin.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n            <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n            <span>&lt;!-- ======END Spring Boot Admin ====== --></span>\n\n\n            <span>&lt;!-- ======BEGIN ZipKin ====== --></span>\n            <span><span><span>&lt;</span>dependency</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>io.zipkin.java<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>zipkin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>${zipkin.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n            <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>dependency</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>io.zipkin.java<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>zipkin-server<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>${zipkin.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n            <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>dependency</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>io.zipkin.java<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>zipkin-autoconfigure-ui<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>${zipkin.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n            <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n            <span>&lt;!-- ======END ZipKin ====== --></span>\n\n        <span><span><span>&lt;/</span>dependencies</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependencyManagement</span><span>></span></span>\n\n\n    <span><span><span>&lt;</span>build</span><span>></span></span>\n        <span><span><span>&lt;</span>plugins</span><span>></span></span>\n            <span>&lt;!-- Compiler 插件, 设定 JDK 版本 --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-compiler-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>showWarnings</span><span>></span></span>true<span><span><span>&lt;/</span>showWarnings</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- 打包 jar 文件时，配置 manifest 文件，加入 lib 包的 jar 依赖 --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-jar-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>archive</span><span>></span></span>\n                        <span><span><span>&lt;</span>addMavenDescriptor</span><span>></span></span>false<span><span><span>&lt;/</span>addMavenDescriptor</span><span>></span></span>\n                    <span><span><span>&lt;/</span>archive</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n                <span><span><span>&lt;</span>executions</span><span>></span></span>\n                    <span><span><span>&lt;</span>execution</span><span>></span></span>\n                        <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                            <span><span><span>&lt;</span>archive</span><span>></span></span>\n                                <span><span><span>&lt;</span>manifest</span><span>></span></span>\n                                    <span>&lt;!-- Add directory entries --></span>\n                                    <span><span><span>&lt;</span>addDefaultImplementationEntries</span><span>></span></span>true<span><span><span>&lt;/</span>addDefaultImplementationEntries</span><span>></span></span>\n                                    <span><span><span>&lt;</span>addDefaultSpecificationEntries</span><span>></span></span>true<span><span><span>&lt;/</span>addDefaultSpecificationEntries</span><span>></span></span>\n                                    <span><span><span>&lt;</span>addClasspath</span><span>></span></span>true<span><span><span>&lt;/</span>addClasspath</span><span>></span></span>\n                                <span><span><span>&lt;/</span>manifest</span><span>></span></span>\n                            <span><span><span>&lt;/</span>archive</span><span>></span></span>\n                        <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;/</span>execution</span><span>></span></span>\n                <span><span><span>&lt;/</span>executions</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- resource --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-resources-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- install --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-install-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- clean --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-clean-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- ant --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-antrun-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- dependency --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-dependency-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n\n        <span><span><span>&lt;</span>pluginManagement</span><span>></span></span>\n            <span><span><span>&lt;</span>plugins</span><span>></span></span>\n                <span>&lt;!-- Java Document Generate --></span>\n                <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                    <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-javadoc-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                    <span><span><span>&lt;</span>executions</span><span>></span></span>\n                        <span><span><span>&lt;</span>execution</span><span>></span></span>\n                            <span><span><span>&lt;</span>phase</span><span>></span></span>prepare-package<span><span><span>&lt;/</span>phase</span><span>></span></span>\n                            <span><span><span>&lt;</span>goals</span><span>></span></span>\n                                <span><span><span>&lt;</span>goal</span><span>></span></span>jar<span><span><span>&lt;/</span>goal</span><span>></span></span>\n                            <span><span><span>&lt;/</span>goals</span><span>></span></span>\n                        <span><span><span>&lt;/</span>execution</span><span>></span></span>\n                    <span><span><span>&lt;/</span>executions</span><span>></span></span>\n                <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n        <span><span><span>&lt;/</span>pluginManagement</span><span>></span></span>\n\n        <span>&lt;!-- 资源文件配置 --></span>\n        <span><span><span>&lt;</span>resources</span><span>></span></span>\n            <span><span><span>&lt;</span>resource</span><span>></span></span>\n                <span><span><span>&lt;</span>directory</span><span>></span></span>src/main/java<span><span><span>&lt;/</span>directory</span><span>></span></span>\n                <span><span><span>&lt;</span>excludes</span><span>></span></span>\n                    <span><span><span>&lt;</span>exclude</span><span>></span></span>**/*.java<span><span><span>&lt;/</span>exclude</span><span>></span></span>\n                <span><span><span>&lt;/</span>excludes</span><span>></span></span>\n            <span><span><span>&lt;/</span>resource</span><span>></span></span>\n            <span><span><span>&lt;</span>resource</span><span>></span></span>\n                <span><span><span>&lt;</span>directory</span><span>></span></span>src/main/resources<span><span><span>&lt;/</span>directory</span><span>></span></span>\n            <span><span><span>&lt;/</span>resource</span><span>></span></span>\n        <span><span><span>&lt;/</span>resources</span><span>></span></span>\n    <span><span><span>&lt;/</span>build</span><span>></span></span>\n\n    <span><span><span>&lt;</span>distributionManagement</span><span>></span></span>\n        <span><span><span>&lt;</span>repository</span><span>></span></span>\n            <span><span><span>&lt;</span>id</span><span>></span></span>nexus-releases<span><span><span>&lt;/</span>id</span><span>></span></span>\n            <span><span><span>&lt;</span>name</span><span>></span></span>Nexus Release Repository<span><span><span>&lt;/</span>name</span><span>></span></span>\n            <span><span><span>&lt;</span>url</span><span>></span></span>http://114.116.245.65:8081/repository/maven-releases/<span><span><span>&lt;/</span>url</span><span>></span></span>\n        <span><span><span>&lt;/</span>repository</span><span>></span></span>\n        <span><span><span>&lt;</span>snapshotRepository</span><span>></span></span>\n            <span><span><span>&lt;</span>id</span><span>></span></span>nexus-snapshots<span><span><span>&lt;/</span>id</span><span>></span></span>\n            <span><span><span>&lt;</span>name</span><span>></span></span>Nexus Snapshot Repository<span><span><span>&lt;/</span>name</span><span>></span></span>\n            <span><span><span>&lt;</span>url</span><span>></span></span>http://114.116.245.65:8081/repository/maven-snapshots/<span><span><span>&lt;/</span>url</span><span>></span></span>\n        <span><span><span>&lt;/</span>snapshotRepository</span><span>></span></span>\n    <span><span><span>&lt;/</span>distributionManagement</span><span>></span></span>\n\n    <span><span><span>&lt;</span>repositories</span><span>></span></span>\n        <span><span><span>&lt;</span>repository</span><span>></span></span>\n            <span><span><span>&lt;</span>id</span><span>></span></span>nexus<span><span><span>&lt;/</span>id</span><span>></span></span>\n            <span><span><span>&lt;</span>name</span><span>></span></span>Nexus Repository<span><span><span>&lt;/</span>name</span><span>></span></span>\n            <span><span><span>&lt;</span>url</span><span>></span></span>http://114.116.245.65:8081/repository/maven-public/<span><span><span>&lt;/</span>url</span><span>></span></span>\n            <span><span><span>&lt;</span>snapshots</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>true<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>snapshots</span><span>></span></span>\n            <span><span><span>&lt;</span>releases</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>true<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>releases</span><span>></span></span>\n        <span><span><span>&lt;/</span>repository</span><span>></span></span>\n\n        <span><span><span>&lt;</span>repository</span><span>></span></span>\n            <span><span><span>&lt;</span>id</span><span>></span></span>aliyun-repos<span><span><span>&lt;/</span>id</span><span>></span></span>\n            <span><span><span>&lt;</span>name</span><span>></span></span>Aliyun Repository<span><span><span>&lt;/</span>name</span><span>></span></span>\n            <span><span><span>&lt;</span>url</span><span>></span></span>http://maven.aliyun.com/nexus/content/groups/public<span><span><span>&lt;/</span>url</span><span>></span></span>\n            <span><span><span>&lt;</span>releases</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>true<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>releases</span><span>></span></span>\n            <span><span><span>&lt;</span>snapshots</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>false<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>snapshots</span><span>></span></span>\n        <span><span><span>&lt;/</span>repository</span><span>></span></span>\n\n        <span><span><span>&lt;</span>repository</span><span>></span></span>\n            <span><span><span>&lt;</span>id</span><span>></span></span>sonatype-repos<span><span><span>&lt;/</span>id</span><span>></span></span>\n            <span><span><span>&lt;</span>name</span><span>></span></span>Sonatype Repository<span><span><span>&lt;/</span>name</span><span>></span></span>\n            <span><span><span>&lt;</span>url</span><span>></span></span>https://oss.sonatype.org/content/groups/public<span><span><span>&lt;/</span>url</span><span>></span></span>\n            <span><span><span>&lt;</span>releases</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>true<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>releases</span><span>></span></span>\n            <span><span><span>&lt;</span>snapshots</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>false<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>snapshots</span><span>></span></span>\n        <span><span><span>&lt;/</span>repository</span><span>></span></span>\n        <span><span><span>&lt;</span>repository</span><span>></span></span>\n            <span><span><span>&lt;</span>id</span><span>></span></span>sonatype-repos-s<span><span><span>&lt;/</span>id</span><span>></span></span>\n            <span><span><span>&lt;</span>name</span><span>></span></span>Sonatype Repository<span><span><span>&lt;/</span>name</span><span>></span></span>\n            <span><span><span>&lt;</span>url</span><span>></span></span>https://oss.sonatype.org/content/repositories/snapshots<span><span><span>&lt;/</span>url</span><span>></span></span>\n            <span><span><span>&lt;</span>releases</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>false<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>releases</span><span>></span></span>\n            <span><span><span>&lt;</span>snapshots</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>true<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>snapshots</span><span>></span></span>\n        <span><span><span>&lt;/</span>repository</span><span>></span></span>\n\n        <span><span><span>&lt;</span>repository</span><span>></span></span>\n            <span><span><span>&lt;</span>id</span><span>></span></span>spring-snapshots<span><span><span>&lt;/</span>id</span><span>></span></span>\n            <span><span><span>&lt;</span>name</span><span>></span></span>Spring Snapshots<span><span><span>&lt;/</span>name</span><span>></span></span>\n            <span><span><span>&lt;</span>url</span><span>></span></span>https://repo.spring.io/snapshot<span><span><span>&lt;/</span>url</span><span>></span></span>\n            <span><span><span>&lt;</span>snapshots</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>true<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>snapshots</span><span>></span></span>\n        <span><span><span>&lt;/</span>repository</span><span>></span></span>\n        <span><span><span>&lt;</span>repository</span><span>></span></span>\n            <span><span><span>&lt;</span>id</span><span>></span></span>spring-milestones<span><span><span>&lt;/</span>id</span><span>></span></span>\n            <span><span><span>&lt;</span>name</span><span>></span></span>Spring Milestones<span><span><span>&lt;/</span>name</span><span>></span></span>\n            <span><span><span>&lt;</span>url</span><span>></span></span>https://repo.spring.io/milestone<span><span><span>&lt;/</span>url</span><span>></span></span>\n            <span><span><span>&lt;</span>snapshots</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>false<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>snapshots</span><span>></span></span>\n        <span><span><span>&lt;/</span>repository</span><span>></span></span>\n    <span><span><span>&lt;/</span>repositories</span><span>></span></span>\n\n    <span><span><span>&lt;</span>pluginRepositories</span><span>></span></span>\n        <span><span><span>&lt;</span>pluginRepository</span><span>></span></span>\n            <span><span><span>&lt;</span>id</span><span>></span></span>nexus<span><span><span>&lt;/</span>id</span><span>></span></span>\n            <span><span><span>&lt;</span>name</span><span>></span></span>Nexus Plugin Repository<span><span><span>&lt;/</span>name</span><span>></span></span>\n            <span><span><span>&lt;</span>url</span><span>></span></span>http://114.116.245.65:8081/repository/maven-public/<span><span><span>&lt;/</span>url</span><span>></span></span>\n            <span><span><span>&lt;</span>snapshots</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>true<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>snapshots</span><span>></span></span>\n            <span><span><span>&lt;</span>releases</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>true<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>releases</span><span>></span></span>\n        <span><span><span>&lt;/</span>pluginRepository</span><span>></span></span>\n\n        <span><span><span>&lt;</span>pluginRepository</span><span>></span></span>\n            <span><span><span>&lt;</span>id</span><span>></span></span>aliyun-repos<span><span><span>&lt;/</span>id</span><span>></span></span>\n            <span><span><span>&lt;</span>name</span><span>></span></span>Aliyun Repository<span><span><span>&lt;/</span>name</span><span>></span></span>\n            <span><span><span>&lt;</span>url</span><span>></span></span>http://maven.aliyun.com/nexus/content/groups/public<span><span><span>&lt;/</span>url</span><span>></span></span>\n            <span><span><span>&lt;</span>releases</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>true<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>releases</span><span>></span></span>\n            <span><span><span>&lt;</span>snapshots</span><span>></span></span>\n                <span><span><span>&lt;</span>enabled</span><span>></span></span>false<span><span><span>&lt;/</span>enabled</span><span>></span></span>\n            <span><span><span>&lt;/</span>snapshots</span><span>></span></span>\n        <span><span><span>&lt;/</span>pluginRepository</span><span>></span></span>\n    <span><span><span>&lt;/</span>pluginRepositories</span><span>></span></span>\n\n\n<span><span><span>&lt;/</span>project</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br><span>301</span><br><span>302</span><br><span>303</span><br><span>304</span><br><span>305</span><br><span>306</span><br><span>307</span><br><span>308</span><br><span>309</span><br><span>310</span><br><span>311</span><br><span>312</span><br><span>313</span><br><span>314</span><br><span>315</span><br><span>316</span><br><span>317</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "流水线配置",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-eureka/%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%85%8D%E7%BD%AE/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-eureka/%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%85%8D%E7%BD%AE/",
      "content_html": "<h1 id=\"流水线配置\"> 流水线配置</h1>\n<h2 id=\"部署配置\"> 部署配置</h2>\n<p><strong>在服务器中操作</strong></p>\n<p>创建目录</p>\n<div><pre><code><span>mkdir</span> - p /root/project/panda-appointment/panda-erreka\n</code></pre>\n<div><span>1</span><br></div></div><p>创建docker-compose.yml</p>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/panda-erreka\n\n<span>vim</span> docker-compose.yml\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>粘贴如下内容</p>\n<div><pre><code><span>version</span><span>:</span> <span>'3.1'</span>\n<span>services</span><span>:</span>\n  <span>panda-eureka-1</span><span>:</span>\n    <span>image</span><span>:</span> registry.cn<span>-</span>shenzhen.aliyuncs.com/panda<span>-</span>appointment/panda<span>-</span>eureka<span>:</span>1.0.0\n    <span>container_name</span><span>:</span> panda<span>-</span>eureka<span>-</span><span>1</span>\n    <span>ports</span><span>:</span>\n     <span>-</span> 8761<span>:</span><span>8761</span>\n    <span>restart</span><span>:</span> always\n\n  <span>panda-eureka-2</span><span>:</span>\n    <span>image</span><span>:</span> registry.cn<span>-</span>shenzhen.aliyuncs.com/panda<span>-</span>appointment/panda<span>-</span>eureka<span>:</span>1.0.0\n    <span>container_name</span><span>:</span> panda<span>-</span>eureka<span>-</span><span>2</span>\n    <span>ports</span><span>:</span>\n     <span>-</span> 8762<span>:</span><span>8761</span>\n    <span>restart</span><span>:</span> always\n     \n  <span>panda-eureka-3</span><span>:</span>\n    <span>image</span><span>:</span> registry.cn<span>-</span>shenzhen.aliyuncs.com/panda<span>-</span>appointment/panda<span>-</span>eureka<span>:</span>1.0.0\n    <span>container_name</span><span>:</span> panda<span>-</span>eureka<span>-</span><span>3</span>\n    <span>ports</span><span>:</span>\n     <span>-</span> 8763<span>:</span><span>8761</span>\n    <span>restart</span><span>:</span> always\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><strong>在云效中操作</strong></p>\n<p>部署方式：RDC脚本部署</p>\n<p>下载路径：不填</p>\n<p>部署脚本：</p>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/panda-config\n\ndocker-compose down\n\ndocker rmi registry.cn-shenzhen.aliyuncs.com/panda-appointment/panda-config:1.0.0\n\ndocker-compose up -d\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>执行用户：root</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Redis Sentinel 集群部署",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-service-redis/Redis%20Sentinel%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-service-redis/Redis%20Sentinel%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/",
      "content_html": "<h1 id=\"redis-sentinel-集群部署\"> Redis Sentinel 集群部署</h1>\n<h2 id=\"概述\"> 概述</h2>\n<p>Redis 集群可以在一组 redis 节点之间实现高可用性和 sharding。在集群中会有 1 个 master 和多个 slave 节点。当 master 节点失效时，应选举出一个 slave 节点作为新的 master。然而 Redis 本身(包括它的很多客户端)没有实现自动故障发现并进行主备切换的能力，需要外部的监控方案来实现自动故障恢复。</p>\n<p>Redis Sentinel 是官方推荐的高可用性解决方案。它是 Redis 集群的监控管理工具，可以提供节点监控、通知、自动故障恢复和客户端配置发现服务。</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200225222357-735290.jpeg\" alt=\"img\" /></p>\n<h2 id=\"搭建-redis-集群\"> 搭建 Redis 集群</h2>\n<p>搭建一主两从环境，docker-compose.yml 配置如下：</p>\n<div><pre><code>version: <span>'3.1'</span>\nservices:\n  master:\n    image: redis:4.0.11\n    container_name: redis-master\n    ports:\n      - <span>6379</span>:6379\n    command: redis-server --requirepass 密码\n\n  slave1:\n    image: redis:4.0.11\n    container_name: redis-slave-1\n    ports:\n      - <span>6380</span>:6379\n    command: redis-server --slaveof redis-master <span>6379</span> --requirepass 密码 --masterauth 密码\n\n  slave2:\n    image: redis:4.0.11\n    container_name: redis-slave-2\n    ports:\n      - <span>6381</span>:6379\n    command: redis-server --slaveof redis-master <span>6379</span> --requirepass 密码 --masterauth 密码\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id=\"搭建-sentinel-集群\"> 搭建 Sentinel 集群</h2>\n<p>我们至少需要创建三个 Sentinel 服务，docker-compose.yml 配置如下：</p>\n<div><pre><code>version: <span>'3.1'</span>\nservices:\n  sentinel1:\n    image: redis\n    container_name: redis-sentinel-1\n    ports:\n      - <span>26379</span>:26379\n    command: redis-sentinel /usr/local/etc/redis/sentinel.conf\n    volumes:\n      - ./sentinel1.conf:/usr/local/etc/redis/sentinel.conf\n\n  sentinel2:\n    image: redis\n    container_name: redis-sentinel-2\n    ports:\n      - <span>26380</span>:26379\n    command: redis-sentinel /usr/local/etc/redis/sentinel.conf\n    volumes:\n      - ./sentinel2.conf:/usr/local/etc/redis/sentinel.conf\n\n  sentinel3:\n    image: redis\n    container_name: redis-sentinel-3\n    ports:\n      - <span>26381</span>:26379\n    command: redis-sentinel /usr/local/etc/redis/sentinel.conf\n    volumes:\n      - ./sentinel3.conf:/usr/local/etc/redis/sentinel.conf\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id=\"修改-sentinel-配置文件\"> 修改 Sentinel 配置文件</h3>\n<p>需要三份 sentinel.conf 配置文件，分别为 <code>sentinel1.conf</code>，<code>sentinel2.conf</code>，<code>sentinel3.conf</code>，配置文件内容相同</p>\n<div><pre><code>port <span>26379</span>\n<span>dir</span> /tmp\n<span># 自定义集群名，其中 127.0.0.1 为 redis-master 的 ip，6379 为 redis-master 的端口，2 为最小投票数（因为有 3 台 Sentinel 所以可以设置成 2）</span>\nsentinel monitor mymaster <span>127.0</span>.0.1 <span>6379</span> <span>2</span>\nsentinel down-after-milliseconds mymaster <span>30000</span>\nsentinel parallel-syncs mymaster <span>1</span>\nsentinel failover-timeout mymaster <span>180000</span>\nsentinel deny-scripts-reconfig <span>yes</span>\nsentinel auth-pass mymaster 密码\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"查看集群是否生效\"> 查看集群是否生效</h3>\n<p>进入 Sentinel 容器，使用 Sentinel API 查看监控情况：</p>\n<div><pre><code>docker <span>exec</span> -it redis-sentinel-1 /bin/bash\nredis-cli -p <span>26379</span>\nsentinel master mymaster\nsentinel slaves mymaster\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200225222357-735290.jpeg",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "搭建OAuth2",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-spring-security-oauth2/%E6%90%AD%E5%BB%BAOAuth2/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/panda-spring-security-oauth2/%E6%90%AD%E5%BB%BAOAuth2/",
      "content_html": "<h1 id=\"搭建oauth2\"> 搭建OAuth2</h1>\n<h2 id=\"创建项目-添加依赖\"> 创建项目，添加依赖</h2>\n<h2 id=\"编写配置类\"> 编写配置类</h2>\n<h2 id=\"浏览器访问\"> 浏览器访问</h2>\n<p><strong>访问地址</strong></p>\n<div><pre><code>http://localhost:8079/oauth/authorize?client_id=client&amp;response_type=code\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>登录页面</strong></p>\n<p>登录进去后跳转到授权页面</p>\n<p><strong>授权页面</strong></p>\n<p>授权成功后自动跳转到之前设置的回调地址，并且会带上授权码</p>\n<p><strong>回调地址和授权码</strong></p>\n<h2 id=\"通过授权码向服务器申请令牌\"> 通过授权码向服务器申请令牌</h2>\n<p><strong>postman测试</strong></p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Docker中时区不匹配问题",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/problems/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%97%B6%E5%8C%BA%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/problems/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%97%B6%E5%8C%BA%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/",
      "content_html": "<h1 id=\"docker中时区不匹配问题\"> Docker中时区不匹配问题</h1>\n<p>在Dockerfile中添加如下代码即可</p>\n<div><pre><code>RUN <span>ln</span> -snf /usr/share/zoneinfo/<span>$TZ</span> /etc/localtime <span>&amp;&amp;</span> <span>echo</span> <span>$TZ</span> <span>></span> /etc/timezone\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "搭建Spring Boot Admin时依赖冲突问题",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/summary/%E6%90%AD%E5%BB%BASpring%20Boot%20Admin%E6%97%B6%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/summary/%E6%90%AD%E5%BB%BASpring%20Boot%20Admin%E6%97%B6%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/",
      "content_html": "<h1 id=\"搭建spring-boot-admin时依赖冲突问题\"> 搭建Spring Boot Admin时依赖冲突问题</h1>\n<h2 id=\"问题\"> 问题</h2>\n<p>依赖冲突</p>\n<div><pre><code>***************************\nAPPLICATION FAILED TO START\n***************************\n\nDescription:\n\nAn attempt was made to call a method that does not exist. The attempt was made from the following location:\n\n    de.codecentric.boot.admin.server.web.servlet.AdminControllerHandlerMapping.registerHandlerMethod(AdminControllerHandlerMapping.java:46)\n\nThe following method did not exist:\n\n    org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.registerHandlerMethod(Ljava/lang/Object;Ljava/lang/reflect/Method;Lorg/springframework/web/servlet/mvc/method/RequestMappingInfo;)V\n\nThe method&#39;s class, org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping, is available from the following locations:\n\n    jar:file:/F:/software/dev/maven_repo/org/springframework/spring-webmvc/5.1.10.RELEASE/spring-webmvc-5.1.10.RELEASE.jar!/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerMapping.class\n\nIt was loaded from the following location:\n\n    file:/F:/software/dev/maven_repo/org/springframework/spring-webmvc/5.1.10.RELEASE/spring-webmvc-5.1.10.RELEASE.jar\n\n\nAction:\n\nCorrect the classpath of your application so that it contains a single, compatible version of org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id=\"原因\"> 原因</h2>\n<p>jar包重复</p>\n<h2 id=\"解决\"> 解决</h2>\n<p>单独加入依赖</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "部署配置",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE/",
      "content_html": "<h1 id=\"部署配置\"> 部署配置</h1>\n<h5 id=\"panda-config\"> panda-config</h5>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-config-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/docker-compose/panda-config/panda-config-deploy.sh\n\n<span>sh</span> panda-config-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"panda-eureka\"> panda-eureka</h5>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-eureka-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/docker-compose/panda-eureka/panda-eureka-deploy.sh\n\n<span>sh</span> panda-eureka-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"panda-gateway\"> panda-gateway</h5>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-gateway-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/docker-compose/panda-gateway/panda-gateway-deploy.sh\n\n<span>sh</span> panda-gateway-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"panda-zipkin\"> panda-zipkin</h5>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-zipkin-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/docker-compose/panda-zipkin/panda-zipkin-deploy.sh\n\n<span>sh</span> panda-zipkin-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"panda-service-sso\"> panda-service-sso</h5>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-service-sso-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/docker-compose/panda-service-sso/panda-service-sso-deploy.sh\n\n<span>sh</span> panda-service-sso-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"panda-service-provider-user\"> panda-service-provider-user</h5>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-service-provider-user-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/docker-compose/panda-service-provider-user/panda-service-provider-user-deploy.sh\n\n<span>sh</span> panda-service-provider-user-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"panda-service-provider-redis\"> panda-service-provider-redis</h5>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-service-provider-redis-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/docker-compose/panda-service-provider-redis/panda-service-provider-redis-deploy.sh\n\n<span>sh</span> panda-service-provider-redis-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"panda-service-provider-appointment\"> panda-service-provider-appointment</h5>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-service-provider-appointment-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/docker-compose/panda-service-provider-appointment/panda-service-provider-appointment-deploy.sh\n\n<span>sh</span> panda-service-provider-appointment-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"panda-service-provider-appointment-type\"> panda-service-provider-appointment-type</h5>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-service-provider-appointment-type-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/docker-compose/panda-service-provider-appointment-type/panda-service-provider-appointment-type-deploy.sh\n\n<span>sh</span> panda-service-provider-appointment-type-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"panda-service-provider-works\"> panda-service-provider-works</h5>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-service-provider-works-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/docker-compose/panda-service-provider-works/panda-service-provider-works-deploy.sh\n\n<span>sh</span> panda-service-provider-works-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"panda-service-provider-order\"> panda-service-provider-order</h5>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-service-provider-order-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/docker-compose/panda-service-provider-order/panda-service-provider-order-deploy.sh\n\n<span>sh</span> panda-service-provider-order-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"panda-service-provider-image\"> panda-service-provider-image</h5>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-service-provider-image-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/docker-compose/panda-service-provider-image/panda-service-provider-image-deploy.sh\n\n<span>sh</span> panda-service-provider-image-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"panda-service-provider-carousel\"> panda-service-provider-carousel</h5>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-service-provider-carousel-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/docker-compose/panda-service-provider-carousel/panda-service-provider-carousel-deploy.sh\n\n<span>sh</span> panda-service-provider-carousel-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"panda-frontend-quartz\"> panda-frontend-quartz</h5>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-service-provider-quartz-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/docker-compose/panda-service-provider-quartz/panda-service-provider-quartz-deploy.sh\n\n<span>sh</span> panda-service-provider-quartz-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"panda-frontend-k8s\"> panda-frontend-k8s</h5>\n<div><pre><code><span>cd</span> /root/project/panda-appointment/sh\n\n<span>rm</span> -r -f panda-frontend-k8s-deploy.sh\n\n<span>wget</span> https://gitee.com/Panda_Appointment/panda-files/raw/master/k8s/panda-frontend/panda-frontend-k8s-deploy.sh\n\n<span>sh</span> panda-frontend-k8s-deploy.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "熊猫约拍",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/",
      "content_html": "<h1 id=\"熊猫约拍\"> 熊猫约拍</h1>\n<blockquote>\n<p>项目链接 https://gitee.com/Panda_Appointment</p>\n</blockquote>\n<h2 id=\"项目背景\"> 项目背景</h2>\n<p>随着电商时代的蓬勃发展，线上网店逐渐取代了线下实体店，许多平面模特为线上服装店拍摄服装照片，以便于买家判断是否需要购买此服装，但是电商要通过中间商才能找到自己想要的模特和摄影师，中间商利用信息不对等赚取差价，电商既没有少花钱，模特和摄影师也没有多赚钱，效率不高，价格却不低。</p>\n<p>每年六月都是毕业季，许多学校都会有拍毕业照的需要，甚至有些人会需要摄影师跟拍他毕业时学校的场景，以此来记录自己在这所学校的青葱岁月，便于以后追忆自己的似水年华。</p>\n<p>因为中西文化的逐渐融合，婚纱照成为现在每个新婚家庭必不可少的东西，但是照相馆里的婚纱照又贵，时间又很容易冲突，摄影师的水平也不一定符合要求。</p>\n<p>艺术照成为许多人保留自己的美好时光的不二选择，但是要找到符合自己要求的摄影团队，时间不会冲突是很困难的。</p>\n<p>摄影成为了不少人的兴趣爱好，但是作为一个摄影萌新，如何挑选相机和镜头呢？如何调焦？如何处理照片？如何根据不同的场景调试相机？</p>\n<p>为了解决以上的问题和需求，我们创建了熊猫约拍。熊猫约拍致力于打造一个功能更加完善，效率更高的摄影约拍平台，让顾客和模特、摄影师可以直接对话，减少中间商赚差价，让模特和摄影师可以有更加高效的交流。让菜鸟摄影师从中学到摄影的技巧。熊猫约拍的web端与移动端并行，既可用电脑访问，也可以用手机app。</p>\n<h2 id=\"项目简介\"> 项目简介</h2>\n<p>熊猫约拍，一个模特、摄影师预约拍照，效率更高的摄影约拍平台，让顾客和模特、摄影师可以直接发布需求或接单，让模特和摄影师可以有更加优质的预约拍照体验。不仅如此，用户还可以在熊猫约拍网站分享自己的作品、寻找拍照打卡地点、寻找摄影师或模特；网站还有贴心的订单排期和邮件提醒等功能。</p>\n<p>熊猫约拍的后台采用微服务架构，使用Spring Cloud体系的技术，在服务器部署上，采用应用容器引擎Kubernetes和Docker集群部署，实现高可用。同时使用阿里云云效流水线技术实现持续集成、持续部署，自动化运维。</p>\n<p>熊猫约拍搭建了多个客户端、分别有网站、安卓APP、微信公众号、微信小程序，多客户端为用户带来更多的选择，用户根据自己喜好选择一个客户端即可体验预约拍照。</p>\n<h2 id=\"功能点\"> 功能点</h2>\n<p>图示：已完成 ⭕️ 、未开始 ❌ 、开发中 💻</p>\n<h3 id=\"用户功能\"> 用户功能</h3>\n<h4 id=\"核心功能\"> 核心功能</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">功能</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">完成度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">预约拍照</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">发布预约</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">发布作品</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">打卡点推荐</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">模特/摄影师推荐</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">约拍排期表</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">短信通知</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">邮件通知</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内容搜索</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"非核心功能\"> 非核心功能</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">功能</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">完成度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">查询发布的约拍</td>\n<td style=\"text-align:center\">查询自己发布的约拍</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">查询接单的约拍</td>\n<td style=\"text-align:center\">查询自己接单的约拍</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">修改约拍内容</td>\n<td style=\"text-align:center\">修改自己发布的约拍内容</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">删除约拍</td>\n<td style=\"text-align:center\">删除自己发布的约拍</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">查询作品</td>\n<td style=\"text-align:center\">查询自己发布的作品</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">删除作品</td>\n<td style=\"text-align:center\">删除自己发布的作品</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">修改用户信息</td>\n<td style=\"text-align:center\">修改头像、昵称、密码、身份信息等</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"管理员功能\"> 管理员功能</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">功能</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">完成度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">用户管理</td>\n<td style=\"text-align:center\">对用户增删查改</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">预约拍照管理</td>\n<td style=\"text-align:center\">对预约拍照增删查改</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">订单管理</td>\n<td style=\"text-align:center\">对订单增删查改</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">作品管理</td>\n<td style=\"text-align:center\">对作品增删查改</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">约拍类型管理</td>\n<td style=\"text-align:center\">对约拍类型增删查改</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">轮播图管理</td>\n<td style=\"text-align:center\">对轮播图增删查改</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">打卡点管理</td>\n<td style=\"text-align:center\">对打卡点增删查改</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">统计用户城市</td>\n<td style=\"text-align:center\">统计用户城市</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">统计约拍</td>\n<td style=\"text-align:center\">统计约拍</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">统计作品</td>\n<td style=\"text-align:center\">统计作品</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"共同功能\"> 共同功能</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">功能</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">完成度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">图片上传</td>\n<td style=\"text-align:center\">图片上传</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"技术选型\"> 技术选型</h2>\n<h3 id=\"后端\"> 后端</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">技术</th>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">集成状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Spring Boot</td>\n<td style=\"text-align:center\">微服务应用基础框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud</td>\n<td style=\"text-align:center\">微服务集成框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Config</td>\n<td style=\"text-align:center\">分布式配置中心</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Eureka</td>\n<td style=\"text-align:center\">服务注册与发现</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Feign</td>\n<td style=\"text-align:center\">声明式服务调用</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Ribbon</td>\n<td style=\"text-align:center\">客户端负载均衡</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Hystrix</td>\n<td style=\"text-align:center\">服务容错保护</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Cloud Zuul</td>\n<td style=\"text-align:center\">API网关</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Zipkin</td>\n<td style=\"text-align:center\">链路追踪</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Spring Boot Admin</td>\n<td style=\"text-align:center\">服务监控</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Maven</td>\n<td style=\"text-align:center\">项目构建管理</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Nexus3</td>\n<td style=\"text-align:center\">Maven私服</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云 云效</td>\n<td style=\"text-align:center\">持续集成CI/持续部署CD</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Gitee</td>\n<td style=\"text-align:center\">代码仓库</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云云数据库RDS MySQL5.7</td>\n<td style=\"text-align:center\">数据库</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Druid</td>\n<td style=\"text-align:center\">数据库连接池</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MyBatis</td>\n<td style=\"text-align:center\">ORM框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PageHelper</td>\n<td style=\"text-align:center\">分页插件</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Redis Sentinel</td>\n<td style=\"text-align:center\">哨兵集群</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云OSS</td>\n<td style=\"text-align:center\">云对象存储</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Swagger2</td>\n<td style=\"text-align:center\">API文档生成工具</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RESTful API</td>\n<td style=\"text-align:center\">RESTful风格API</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Nginx</td>\n<td style=\"text-align:center\">代理服务器</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Docker</td>\n<td style=\"text-align:center\">应用容器</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Kubernetes</td>\n<td style=\"text-align:center\">应用容器</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云镜像仓库</td>\n<td style=\"text-align:center\">阿里云镜像仓库</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Scrapy</td>\n<td style=\"text-align:center\">Python爬虫框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">OAuth2</td>\n<td style=\"text-align:center\">身份/权限认证</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Quartz</td>\n<td style=\"text-align:center\">分布式任务调度</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Elastic Search</td>\n<td style=\"text-align:center\">分布式全文搜索</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RabbitMQ</td>\n<td style=\"text-align:center\">消息队列</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">短信通知</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">邮件发送</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">微信公众号</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"前端\"> 前端</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">技术</th>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">集成状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">HTML</td>\n<td style=\"text-align:center\">超文本标记语言</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CSS</td>\n<td style=\"text-align:center\">层叠样式表</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">JavaScript</td>\n<td style=\"text-align:center\">网页脚本语言</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Vue.js</td>\n<td style=\"text-align:center\">前端框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">VueRouter</td>\n<td style=\"text-align:center\">前端路由</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Vuex</td>\n<td style=\"text-align:center\">状态管理（数据存储）</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Element-UI</td>\n<td style=\"text-align:center\">前端样式框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Axios</td>\n<td style=\"text-align:center\">网络请求</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">vue-waterfall-easy</td>\n<td style=\"text-align:center\">瀑布流组件</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">vue2-admin</td>\n<td style=\"text-align:center\">基于vue的后台管理前端框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">echarts</td>\n<td style=\"text-align:center\">图表框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">uni-app</td>\n<td style=\"text-align:center\">移动端跨平台框架</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"服务器\"> 服务器</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器</th>\n<th style=\"text-align:center\">配置</th>\n<th style=\"text-align:center\">使用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">阿里云ECS - master</td>\n<td style=\"text-align:center\">2核4G 5M带宽</td>\n<td style=\"text-align:center\">k8s主节点</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云ECS - temp-node-1</td>\n<td style=\"text-align:center\">1核2G 1M带宽</td>\n<td style=\"text-align:center\">k8s子节点1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云ECS - temp-node-2</td>\n<td style=\"text-align:center\">1核2G 1M带宽</td>\n<td style=\"text-align:center\">k8s子节点2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阿里云ECS - node-1</td>\n<td style=\"text-align:center\">1核2G 1M带宽</td>\n<td style=\"text-align:center\">部署config、eureka、zuul等组件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">百度智能云BCC</td>\n<td style=\"text-align:center\">2核4G 1M带宽</td>\n<td style=\"text-align:center\">部署微服务服务提供者</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">华为云ECS</td>\n<td style=\"text-align:center\">1核2G 1M带宽</td>\n<td style=\"text-align:center\">部署Nexus3 Maven私服</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">腾讯云ECS</td>\n<td style=\"text-align:center\">1核2G 1M带宽</td>\n<td style=\"text-align:center\">部署Redis集群</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"软件架构\"> 软件架构</h2>\n<h3 id=\"系统架构图\"> 系统架构图</h3>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200324124354-537300.png\" alt=\"熊猫约拍架构图\" /></p>\n<h3 id=\"部署架构图\"> 部署架构图</h3>\n<p><img src=\"https://images.gitee.com/uploads/images/2020/0310/113729_2c29a9dc_2231089.png\" alt=\"distributedSystem\" /></p>\n<h2 id=\"项目代码仓库链接\"> 项目代码仓库链接</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">链接</th>\n<th style=\"text-align:center\">公开</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment\" target=\"_blank\" rel=\"noopener noreferrer\">Panda_Appointment</a></td>\n<td style=\"text-align:center\">熊猫约拍项目</td>\n<td style=\"text-align:center\">https://gitee.com/organizations/Panda_Appointment/projects</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/spring_cloud_micro_service_panda_appointment\" target=\"_blank\" rel=\"noopener noreferrer\">spring_cloud_micro_service_panda_appointment</a></td>\n<td style=\"text-align:center\">熊猫约拍项目-该仓库只存放README文档</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/spring_cloud_micro_service_panda_appointment</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-files\" target=\"_blank\" rel=\"noopener noreferrer\">panda-files</a></td>\n<td style=\"text-align:center\">存放文件docker-compose.yml和shell文件</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-files</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-config-repo\" target=\"_blank\" rel=\"noopener noreferrer\">panda-config-repo</a></td>\n<td style=\"text-align:center\">分布式配置中心-存放配置文件的仓库</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-config-repo</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-dependencies\" target=\"_blank\" rel=\"noopener noreferrer\">panda-dependencies</a></td>\n<td style=\"text-align:center\">统一的依赖管理</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-dependencies</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-domain\" target=\"_blank\" rel=\"noopener noreferrer\">panda-domain</a></td>\n<td style=\"text-align:center\">统一的领域模型（实体类）</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-domain</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-config\" target=\"_blank\" rel=\"noopener noreferrer\">panda-config</a></td>\n<td style=\"text-align:center\">分布式配置中心</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-config</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-eureka\" target=\"_blank\" rel=\"noopener noreferrer\">panda-eureka</a></td>\n<td style=\"text-align:center\">分布式服务注册与发现</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-eureka</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-admin\" target=\"_blank\" rel=\"noopener noreferrer\">panda-admin</a></td>\n<td style=\"text-align:center\">分布式应用管理中心</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-admin</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-zipkin\" target=\"_blank\" rel=\"noopener noreferrer\">panda-zipkin</a></td>\n<td style=\"text-align:center\">分布式链路追踪</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-zipkin</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-gateway\" target=\"_blank\" rel=\"noopener noreferrer\">panda-gateway</a></td>\n<td style=\"text-align:center\">分布式网关</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-gateway</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-common\" target=\"_blank\" rel=\"noopener noreferrer\">panda-common</a></td>\n<td style=\"text-align:center\">通用项目模块</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-common</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-common-microservice-component\" target=\"_blank\" rel=\"noopener noreferrer\">panda-common-microservice-component</a></td>\n<td style=\"text-align:center\">微服务通用组件依赖</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-common-microservice-component</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-common-provider\" target=\"_blank\" rel=\"noopener noreferrer\">panda-common-provider</a></td>\n<td style=\"text-align:center\">通用的服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-common-provider</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-common-comsumer\" target=\"_blank\" rel=\"noopener noreferrer\">panda-common-comsumer</a></td>\n<td style=\"text-align:center\">通用的服务消费者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-common-comsumer</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-user\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-user</a></td>\n<td style=\"text-align:center\">服务提供者-用户</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-user</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-image\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-image</a></td>\n<td style=\"text-align:center\">图片服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-image</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-TCarousel\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-TCarousel</a></td>\n<td style=\"text-align:center\">轮播图服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-TCarousel</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-redis\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-redis</a></td>\n<td style=\"text-align:center\">缓存服务提供者redis</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-redis</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-appointment\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-appointment</a></td>\n<td style=\"text-align:center\">约拍服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-appointment</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-appointment-type\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-appointment-type</a></td>\n<td style=\"text-align:center\">约拍类型服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-appointment-type</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-works\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-works</a></td>\n<td style=\"text-align:center\">作品服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-works</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-order\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-order</a></td>\n<td style=\"text-align:center\">订单服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-order</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-spot\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-spot</a></td>\n<td style=\"text-align:center\">打卡点服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-spot</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-quartz\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-quartz</a></td>\n<td style=\"text-align:center\">定时任务服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-quartz</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-provider-elasticsearch\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-provider-elasticsearch</a></td>\n<td style=\"text-align:center\">elastic search服务提供者</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-provider-elasticsearch</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-sso\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-sso</a></td>\n<td style=\"text-align:center\">单点登录服务</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-sso</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-service-consumer-user\" target=\"_blank\" rel=\"noopener noreferrer\">panda-service-consumer-user</a></td>\n<td style=\"text-align:center\">服务消费者-用户</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-service-consumer-user</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-frontend\" target=\"_blank\" rel=\"noopener noreferrer\">panda-frontend</a></td>\n<td style=\"text-align:center\">vue前端部署项目</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-frontend</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/vue_panda_appointment\" target=\"_blank\" rel=\"noopener noreferrer\">vue_panda_appointment</a></td>\n<td style=\"text-align:center\">熊猫约拍 - Vue前端代码仓库</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/vue_panda_appointment</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/panda-frontend-admin\" target=\"_blank\" rel=\"noopener noreferrer\">panda-frontend-admin</a></td>\n<td style=\"text-align:center\">后台管理系统部署项目</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/panda-frontend-admin</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://gitee.com/Panda_Appointment/vue_admin_panda_appointment\" target=\"_blank\" rel=\"noopener noreferrer\">vue_admin_panda_appointment</a></td>\n<td style=\"text-align:center\">熊猫约拍 - vue后台管理代码仓库</td>\n<td style=\"text-align:center\">https://gitee.com/Panda_Appointment/vue_admin_panda_appointment</td>\n<td style=\"text-align:center\">⭕️</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"安装说明\"> 安装说明</h2>\n<h3 id=\"网站\"> 网站</h3>\n<ul>\n<li>主地址：http://panda.alanlee.top</li>\n<li>备用地址1：http://panda.nibuguai.cn</li>\n</ul>\n<blockquote>\n<p>体验账号</p>\n<p>帐号：test</p>\n<p>密码：123456</p>\n</blockquote>\n<h3 id=\"微信公众号\"> 微信公众号</h3>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200323125706-298071.jpeg\" alt=\"qrcode_for_gh_a80b923fbc86_258\" /></p>\n<h3 id=\"微信小程序\"> 微信小程序</h3>\n<p>审核未通过、请使用安卓app</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200323125826-678960.jpeg\" alt=\"小程序\" /></p>\n<h3 id=\"安卓-app\"> 安卓 APP</h3>\n<p>下载地址：https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/package/panda-appointment.apk</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200323125827-616732.png\" alt=\"app\" /></p>\n<blockquote>\n<p>体验账号</p>\n<p>帐号：test</p>\n<p>密码：123456</p>\n</blockquote>\n<h3 id=\"作品截图\"> 作品截图</h3>\n<h4 id=\"网站-2\"> 网站</h4>\n<blockquote>\n<p>主页</p>\n</blockquote>\n<img style=\"magin:10px; box-shadow: 2px 2px 10px #f1f1f1f1\" src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/1%20-%20%E4%B8%BB%E9%A1%B5.png\" />\n<blockquote>\n<p>约拍</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/2 - 约拍.png\" alt=\"约拍\" /></p>\n<blockquote>\n<p>约拍详情页</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/2-1 - 约拍详情.png\" alt=\"约拍详情页\" /></p>\n<blockquote>\n<p>作品</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/3 - 作品.png\" alt=\"作品\" /></p>\n<blockquote>\n<p>作品详情页</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/3-1 - 作品详情.png\" alt=\"作品详情页\" /></p>\n<blockquote>\n<p>打卡点</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/4 - 打卡点.png\" alt=\"打卡点\" /></p>\n<blockquote>\n<p>打卡点详情页</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/4-1 - 打卡点详情页.png\" alt=\"打卡点详情页\" /></p>\n<blockquote>\n<p>搜索</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/5 - 搜索.png\" alt=\"搜索\" /></p>\n<blockquote>\n<p>发布约拍</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/6 - 发布约拍.png\" alt=\"\" /></p>\n<blockquote>\n<p>个人主页 - 我的约拍</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/7-1 - 个人主页 - 约拍.png\" alt=\"\" /></p>\n<blockquote>\n<p>个人主页 - 我的作品</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/7-2 - 个人主页 - 作品.png\" alt=\"\" /></p>\n<blockquote>\n<p>个人主页 - 我的相册</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/7-3 - 个人主页 - 相册.png\" alt=\"\" /></p>\n<blockquote>\n<p>个人主页 - 排期</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/7-4 -  个人主页 - 排期.png\" alt=\"个人主页 - 排期\" /></p>\n<blockquote>\n<p>约拍类型</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/8 - 约拍类型.png\" alt=\"约拍类型\" /></p>\n<blockquote>\n<p>注册</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/9 - 注册.png\" alt=\"\" /></p>\n<blockquote>\n<p>登录</p>\n</blockquote>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/website/10 - 登录.png\" alt=\"\" /></p>\n<h4 id=\"app-微信小程序\"> APP / 微信小程序</h4>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/app/0 - 页面合集.PNG\" alt=\"\" /></p>\n<h4 id=\"微信公众号-2\"> 微信公众号</h4>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/wx-public-platform/微信公众号页面合集.PNG\" alt=\"微信公众号页面合集\" /></p>\n<h4 id=\"后台管理系统\"> 后台管理系统</h4>\n<p><img src=\"https://alanlee-panda-appointment.oss-cn-shenzhen.aliyuncs.com/assert/images/back-manage-system/后台管理系统页面合集.png\" alt=\"\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200324124354-537300.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "项目中遇到的问题",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/",
      "content_html": "<h1 id=\"项目中遇到的问题\"> 项目中遇到的问题</h1>\n<h2 id=\"问题1\"> 问题1</h2>\n<h5 id=\"问题\"> 问题</h5>\n<p>多图片上传的问题，通过element-ui的el-upload组件上传多图片时，总是上传到最后一张图片</p>\n<h5 id=\"原因\"> 原因</h5>\n<p>按照普通的图片上传，如果多张图片上传一般是循环单次上传的接口，或者后端使用Multipart数组的方式，但是，经debug过程发现，在使用Element-ui的el-upload组件上传时，循环调用单文件上传接口时，会出现前一次的函数还没执行完，下一次循环又开始调用该接口了，导致文件上传的是最后一个文件。</p>\n<h5 id=\"解决\"> 解决</h5>\n<p>先获取el-upload组件获取的文件列表，保存到data中，然后使用递归调用上传图片的函数，只有当上一次上传成功时再次调用本函数，形成递归调用，实现多图片上传。</p>\n<div><pre><code><span>//发起上传的请求</span>\n<span>uploadRequest</span><span>(</span><span>formDataList<span>,</span> index</span><span>)</span><span>{</span>\n   <span>request</span><span>(</span><span>{</span>\n       url<span>:</span> <span>IMAGE_UPLOAD_RETURN_ID</span><span>,</span>\n       <span>// url: this.localUploadUrl,</span>\n       method<span>:</span> <span>'post'</span><span>,</span>\n       data<span>:</span> formDataList<span>[</span>index<span>]</span><span>,</span>\n       headers<span>:</span><span>{</span>\n           <span>\"content-type\"</span> <span>:</span> <span>\"multipart/form-data\"</span>\n       <span>}</span>\n   <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>\n       console<span>.</span><span>log</span><span>(</span>res<span>.</span>data<span>)</span><span>;</span>\n       <span>this</span><span>.</span>result<span>.</span><span>push</span><span>(</span>res<span>.</span>data<span>)</span><span>;</span>\n       console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>result<span>.</span><span>join</span><span>(</span><span>\";\"</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n       <span>this</span><span>.</span>sendData<span>.</span>imgIds <span>=</span> <span>this</span><span>.</span>result<span>.</span><span>join</span><span>(</span><span>\";\"</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n\n       <span>//递归上传下一张图片</span>\n       index<span>++</span><span>;</span>\n       <span>if</span> <span>(</span>index <span>&lt;</span> formDataList<span>.</span>length<span>)</span><span>{</span>\n           console<span>.</span><span>log</span><span>(</span><span>\"index: \"</span> <span>+</span> index<span>)</span><span>;</span>\n           <span>this</span><span>.</span><span>uploadRequest</span><span>(</span>formDataList<span>,</span> index<span>)</span><span>;</span>\n       <span>}</span>\n\n       <span>//上传完最后一张之后的操作</span>\n       <span>if</span> <span>(</span>index <span>==</span> formDataList<span>.</span>length<span>)</span><span>{</span>\n           <span>this</span><span>.</span>$message<span>.</span><span>success</span><span>(</span><span>\"上传完成\"</span><span>)</span><span>;</span>\n\n           <span>//图片上传完成，开始发布作品</span>\n           <span>this</span><span>.</span><span>startRequest</span><span>(</span><span>)</span><span>;</span>\n       <span>}</span>\n   <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>\n       console<span>.</span><span>log</span><span>(</span>err<span>)</span>\n   <span>}</span><span>)</span>\n<span>}</span><span>,</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h2 id=\"问题2\"> 问题2</h2>\n<h5 id=\"问题-2\"> 问题</h5>\n<p>使用el-image组件显示图片时，一点击图片，网页就不能动</p>\n<h5 id=\"原因-2\"> 原因</h5>\n<p>点击图片时，el-image组件会在body标签里添加一个overflow:hiden的属性，倒置网页卡住不动</p>\n<h5 id=\"解决-2\"> 解决</h5>\n<p>参考el-image组件源码，自己写了个简单的图片组件</p>\n<h2 id=\"问题3\"> 问题3</h2>\n<h5 id=\"问题-3\"> 问题</h5>\n<p>跨域问题CORS</p>\n<h5 id=\"原因-3\"> 原因</h5>\n<p>浏览器本身的限制</p>\n<h5 id=\"解决-3\"> 解决</h5>\n<p>在后端配置CORS即可</p>\n<h2 id=\"问题4\"> 问题4</h2>\n<h5 id=\"问题-4\"> 问题</h5>\n<p>Vue 路由跳转相同路径页面不刷新，例如/user/1，想要在本页面通过路由跳转到/user/2的页面，遇到页面没有跳转，只有地址栏的路径有变化的问题</p>\n<h5 id=\"原因-4\"> 原因</h5>\n<p>使用<code>router-view</code>时，如果在相同路由之间跳转，默认在跳转路由时会采用<code>缓存策略</code>,并不会刷新当前路由组件。\n所以生命周期钩子函数并不会触发。</p>\n<h5 id=\"解决-4\"> 解决</h5>\n<p>在router-view组件上添加<code>:key=&quot;$route.fullPath&quot;</code>属性</p>\n<div><pre><code><span>&lt;</span>router<span>-</span>view <span>:</span>key<span>=</span><span>\"$route.fullPath\"</span> <span>/</span><span>></span>\n</code></pre>\n<div><span>1</span><br></div></div><p>使用这个可以完美解决不刷新问题。</p>\n<p>强制刷新，可以在根路由上为其分配一个唯一key。采用<code>$route.fullpath</code>作为其唯一key。这样vue就回认为内部路由每个都是不同的路由，在跳转时便会强制刷新组件</p>\n<h2 id=\"问题5\"> 问题5</h2>\n<h5 id=\"问题-5\"> 问题</h5>\n<p>微服务之间在线上部署docker时相互调用</p>\n<h5 id=\"原因-5\"> 原因</h5>\n<p>docker容器本身有隔离机制，如果不做配置的话，两个容器之间是不能通过内网通信的。</p>\n<h5 id=\"解决-5\"> 解决</h5>\n<p>docker应用也需要创建docker的network，然后在运行每一容器时加入同一个网络或者在docker-compose.yml文件中指定特定的网络，这样每个服务之间才能通信。</p>\n<h2 id=\"问题6\"> 问题6</h2>\n<h5 id=\"问题-6\"> 问题</h5>\n<p>项目依赖冲突</p>\n<h5 id=\"原因-6\"> 原因</h5>\n<p>在Spring Boot项目中，maven仓库中有很多starter依赖，当我们在项目中导入相关依赖时，很多时候会直接引入某些starter依赖，然而很多starter依赖包含了许多相同的jar包，导致启动项目时，包依赖冲突，</p>\n<h5 id=\"解决-6\"> 解决</h5>\n<p>所以需要仔细查看各个依赖，减少引入相同包，在pom.xml文件中可以用exclude排除冲突的包。</p>\n<h2 id=\"问题7\"> 问题7</h2>\n<h5 id=\"问题-7\"> 问题</h5>\n<p>阿里云云效平台的流水线中Maven项目打包找不到符号</p>\n<h5 id=\"原因-7\"> 原因</h5>\n<p>出现这个问题是因为阿里云云效平台的maven打包时没有找到我们项目私服的jar包，</p>\n<h5 id=\"解决-7\"> 解决</h5>\n<p>配置maven的setting.xml文件之后就可以找到相关依赖的jar包了。</p>\n<p>另一种解决方案是，直接手动打jar包上传到代码仓库，让流水线只负责生成镜像容器并部署就可以了。</p>\n<h2 id=\"问题8\"> 问题8</h2>\n<h5 id=\"问题-8\"> 问题</h5>\n<p>docker容器中的java应用占的内存太高了，不优化的情况下，一个应用不做限制的话，会占用400M到500M的内存，而且随着服务器的本身内存越大，java应用占用的内存也越大。</p>\n<h5 id=\"解决-8\"> 解决</h5>\n<p>在启动java应用时，设置堆内存，指定堆内存的大小即可，如-Xmx128m和-Xms128m。</p>\n<h2 id=\"问题9\"> 问题9</h2>\n<h5 id=\"问题-9\"> 问题</h5>\n<p>应用docker容器中时区问题</p>\n<h5 id=\"原因-8\"> 原因</h5>\n<p>docker容器中默认的时区与中国的时区相差8个小时</p>\n<h5 id=\"解决-9\"> 解决</h5>\n<p>设置docker容器的时区，在Dockerfile中添加以下代码即可</p>\n<div><pre><code>RUN <span>ln</span> -snf /usr/share/zoneinfo/<span>$TZ</span> /etc/localtime <span>&amp;&amp;</span> <span>echo</span> <span>$TZ</span> <span>></span> /etc/timezone\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "vue前端Element-ui多图片上传",
      "url": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/problems/vue%E5%89%8D%E7%AB%AFElement-ui%E5%A4%9A%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/",
      "id": "http://blog.alanlee.top/blog-vuepress/project/panda-appointment/problems/vue%E5%89%8D%E7%AB%AFElement-ui%E5%A4%9A%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/",
      "content_html": "<h1 id=\"vue前端element-ui多图片上传\"> vue前端Element-ui多图片上传</h1>\n<h2 id=\"问题\"> 问题</h2>\n<p>使用普通的图片上传方式，如果选择多张图片上传的话，上传的图片始终是最后一张图片。</p>\n<h2 id=\"原因\"> 原因</h2>\n<p>按照普通的图片上传，如果多张图片上传一般是循环单次上传的接口，或者后端使用Multipart数组的方式，但是，经debug过程发现，在使用Element-ui的el-upload组件上传时，循环调用单文件上传接口时，会出现前一次的函数还没执行完，下一次循环又开始调用该接口了，导致文件上传的是最后一个文件。</p>\n<h2 id=\"解决\"> 解决</h2>\n<p>先获取el-upload组件获取的文件列表，保存到data中，然后使用递归调用上传图片的函数，只有当上一次上传成功时再次调用本函数，形成递归调用，实现多图片上传。</p>\n<p>代码如下</p>\n<div><pre><code><span>//发起上传的请求</span>\n<span>uploadRequest</span><span>(</span><span>formDataList<span>,</span> index</span><span>)</span><span>{</span>\n    <span>request</span><span>(</span><span>{</span>\n        url<span>:</span> <span>IMAGE_UPLOAD_RETURN_ID</span><span>,</span>\n        <span>// url: this.localUploadUrl,</span>\n        method<span>:</span> <span>'post'</span><span>,</span>\n        data<span>:</span> formDataList<span>[</span>index<span>]</span><span>,</span>\n        headers<span>:</span><span>{</span>\n            <span>\"content-type\"</span> <span>:</span> <span>\"multipart/form-data\"</span>\n        <span>}</span>\n    <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>\n        console<span>.</span><span>log</span><span>(</span>res<span>.</span>data<span>)</span><span>;</span>\n        <span>this</span><span>.</span>result<span>.</span><span>push</span><span>(</span>res<span>.</span>data<span>)</span><span>;</span>\n        console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>result<span>.</span><span>join</span><span>(</span><span>\";\"</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span>sendData<span>.</span>imgIds <span>=</span> <span>this</span><span>.</span>result<span>.</span><span>join</span><span>(</span><span>\";\"</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n\n        <span>//递归上传下一张图片</span>\n        index<span>++</span><span>;</span>\n        <span>if</span> <span>(</span>index <span>&lt;</span> formDataList<span>.</span>length<span>)</span><span>{</span>\n            console<span>.</span><span>log</span><span>(</span><span>\"index: \"</span> <span>+</span> index<span>)</span><span>;</span>\n            <span>this</span><span>.</span><span>uploadRequest</span><span>(</span>formDataList<span>,</span> index<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>//上传完最后一张之后的操作</span>\n        <span>if</span> <span>(</span>index <span>==</span> formDataList<span>.</span>length<span>)</span><span>{</span>\n            <span>this</span><span>.</span>$message<span>.</span><span>success</span><span>(</span><span>\"上传完成\"</span><span>)</span><span>;</span>\n\n            <span>//图片上传完成，开始发布作品</span>\n            <span>this</span><span>.</span><span>startRequest</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>\n        console<span>.</span><span>log</span><span>(</span>err<span>)</span>\n    <span>}</span><span>)</span>\n<span>}</span><span>,</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Blog Home",
      "url": "http://blog.alanlee.top/blog-vuepress/",
      "id": "http://blog.alanlee.top/blog-vuepress/",
      "content_html": "",
      "date_published": "2021-10-03T03:15:29.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "服务器",
      "url": "http://blog.alanlee.top/blog-vuepress/server/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/",
      "content_html": "<h1 id=\"服务器\"> 服务器</h1>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "LVS + keepalived实现高可用",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/LVS%20+%20keepalived%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/LVS%20+%20keepalived%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8/",
      "content_html": "<h1 id=\"lvs-keepalived实现高可用\"> LVS + keepalived实现高可用</h1>\n<p>LVS可以实现负载均衡，但是不能够进行健康检查，比如一个rs出现故障，LVS 仍然会把请求转发给故障的rs服务器，这样就会导致请求的无效性。keepalive 软件可以进行健康检查，而且能同时实现 LVS 的高可用性，解决 LVS 单点故障的问题，其实 keepalive 就是为 LVS 而生的。</p>\n<h2 id=\"准备资源\"> 准备资源</h2>\n<table>\n<thead>\n<tr>\n<th>主机</th>\n<th>ip</th>\n<th>角色</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>master1</td>\n<td>192.168.1.20</td>\n<td>DR1</td>\n</tr>\n<tr>\n<td>master1</td>\n<td>192.168.1.200</td>\n<td>DR2</td>\n</tr>\n<tr>\n<td>node1</td>\n<td>192.168.1.21</td>\n<td>RS1</td>\n</tr>\n<tr>\n<td>node2</td>\n<td>192.168.1.22</td>\n<td>RS2</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"操作步骤\"> 操作步骤</h2>\n<h3 id=\"dr上操作\"> DR上操作</h3>\n<h4 id=\"安装keepalived\"> 安装keepalived</h4>\n<div><pre><code>yum <span>install</span> ipvsadm keepalived -y\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"keepalived节点配置\"> keepalived节点配置</h3>\n<h4 id=\"dr1\"> DR1</h4>\n<p>编辑配置文件</p>\n<div><pre><code><span>vim</span> /etc/keepalived/keepalived.conf\n</code></pre>\n<div><span>1</span><br></div></div><p>keepalived.conf</p>\n<div><pre><code>! Configuration File for keepalived\n\nglobal_defs {\n   notification_email {\n     acassen@firewall.loc\n     failover@firewall.loc\n     sysadmin@firewall.loc\n   }\n   notification_email_from Alexandre.Cassen@firewall.loc\n   smtp_server 192.168.200.1\n   smtp_connect_timeout 30\n   router_id LVS_DEVEL\n   vrrp_skip_check_adv_addr\n   vrrp_strict\n   vrrp_garp_interval 0\n   vrrp_gna_interval 0\n}\n\nvrrp_instance VI_1 {\n    state MASTER\n    interface ens33\n    virtual_router_id 51\n    priority 100\n    advert_int 1\n    authentication {\n        auth_type PASS\n        auth_pass 1111\n    }\n    virtual_ipaddress {\n        192.168.1.100\n    }\n}\n\n\nvirtual_server 192.168.1.100 80 {#设置虚拟lvs服务，VIP PORT\n    delay_loop 6\n    lb_algo rr #调度算法wrr\n    lb_kind DR #lvs的模式\n    nat_mask 255.255.255.0\n    persistence_timeout 50 同一个IP地址在50秒内lvs转发给同一个后端服务器\n    protocol TCP\n\n    real_server 192.168.1.21 80 {#设置真实服务器的心跳机制 RID PORT\n        weight 1 #权重\n        HTTP_GET {#心跳检测的方式\n            url {\n              path / #心跳检查的地址\n              status_code 200 #心跳检查返回的状态\n            }\n            connect_timeout 2 #超时时间\n            nb_get_retry 3 #重复检查3次\n            delay_before_retry 1 #每隔1秒钟再次检查\n        }\n    }\n\t\n\treal_server 192.168.1.22 80 {#设置真实服务器的心跳机制 RID PORT\n        weight 1 #权重\n        HTTP_GET {#心跳检测的方式\n            url {\n              path / #心跳检查的地址\n              status_code 200 #心跳检查返回的状态\n            }\n            connect_timeout 2 #超时时间\n            nb_get_retry 3 #重复检查3次\n            delay_before_retry 1 #每隔1秒钟再次检查\n        }\n    }\n    \n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br></div></div><h4 id=\"dr2\"> DR2</h4>\n<p>编辑配置文件</p>\n<div><pre><code><span>vim</span> /etc/keepalived/keepalived.conf\n</code></pre>\n<div><span>1</span><br></div></div><p>keepalived.conf</p>\n<div><pre><code>! Configuration File for keepalived\n\nglobal_defs {\n   notification_email {\n     acassen@firewall.loc\n     failover@firewall.loc\n     sysadmin@firewall.loc\n   }\n   notification_email_from Alexandre.Cassen@firewall.loc\n   smtp_server 192.168.200.1\n   smtp_connect_timeout 30\n   router_id LVS_DEVEL\n   vrrp_skip_check_adv_addr\n   vrrp_strict\n   vrrp_garp_interval 0\n   vrrp_gna_interval 0\n}\n\nvrrp_instance VI_1 {\n    state BACKUP\n    interface ens33\n    virtual_router_id 51\n    priority 50\n    advert_int 1\n    authentication {\n        auth_type PASS\n        auth_pass 1111\n    }\n    virtual_ipaddress {\n        192.168.1.100\n    }\n}\n\n\nvirtual_server 192.168.1.100 80 {#设置虚拟lvs服务，VIP PORT\n    delay_loop 6\n    lb_algo rr #调度算法wrr\n    lb_kind DR #lvs的模式\n    nat_mask 255.255.255.0\n    persistence_timeout 50 同一个IP地址在50秒内lvs转发给同一个后端服务器\n    protocol TCP\n\n    real_server 192.168.1.21 80 {#设置真实服务器的心跳机制 RID PORT\n        weight 1 #权重\n        HTTP_GET {#心跳检测的方式\n            url {\n              path / #心跳检查的地址\n              status_code 200 #心跳检查返回的状态\n            }\n            connect_timeout 2 #超时时间\n            nb_get_retry 3 #重复检查3次\n            delay_before_retry 1 #每隔1秒钟再次检查\n        }\n    }\n\t\n\treal_server 192.168.1.22 80 {#设置真实服务器的心跳机制 RID PORT\n        weight 1 #权重\n        HTTP_GET {#心跳检测的方式\n            url {\n              path / #心跳检查的地址\n              status_code 200 #心跳检查返回的状态\n            }\n            connect_timeout 2 #超时时间\n            nb_get_retry 3 #重复检查3次\n            delay_before_retry 1 #每隔1秒钟再次检查\n        }\n    }\n    \n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br></div></div><blockquote>\n<ul>\n<li>state BACKUP 备用节点</li>\n<li>interface ens33 网卡名称</li>\n<li>priority 50 权重</li>\n</ul>\n</blockquote>\n<h3 id=\"rs上操作\"> RS上操作</h3>\n<h4 id=\"安装软件\"> 安装软件</h4>\n<div><pre><code>yum <span>install</span> epel-release -y\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"配置脚本\"> 配置脚本</h4>\n<p>编写脚本</p>\n<div><pre><code><span>vim</span> /usr/local/sbin/lvs_dr_rs.sh\n</code></pre>\n<div><span>1</span><br></div></div><p>lvs_dr_rs.sh</p>\n<div><pre><code><span>#! /bin/bash</span>\n\n<span>vip</span><span>=</span><span>192.168</span>.1.100\n\n<span>ifconfig</span> lo:0 <span>$vip</span> broadcast <span>$vip</span> netmask <span>255.255</span>.255.255 up\n\nroute <span>add</span> -host <span>$vip</span> lo:0\n\n<span>echo</span> <span>\"1\"</span> <span>></span>/proc/sys/net/ipv4/conf/lo/arp_ignore\n\n<span>echo</span> <span>\"2\"</span> <span>></span>/proc/sys/net/ipv4/conf/lo/arp_announce\n\n<span>echo</span> <span>\"1\"</span> <span>></span>/proc/sys/net/ipv4/conf/all/arp_ignore\n\n<span>echo</span> <span>\"2\"</span> <span>></span>/proc/sys/net/ipv4/conf/all/arp_announce\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>执行脚本</p>\n<div><pre><code><span>bash</span> /usr/local/sbin/lvs_dr_rs.sh\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"测试\"> 测试</h2>\n<p>启动DR1和DR2的keepalived</p>\n<div><pre><code><span>service</span> keepalived start\n</code></pre>\n<div><span>1</span><br></div></div><p>打开http://192.168.1.100/</p>\n<p>查看ip</p>\n<div><pre><code><span>ip</span> addr\n</code></pre>\n<div><span>1</span><br></div></div><p>vip在DR1机子上。</p>\n<p>手动停止keepalived</p>\n<p>在DR2机子上输入</p>\n<div><pre><code><span>ip</span> addr\n</code></pre>\n<div><span>1</span><br></div></div><p>vip跳到DR2机子上来了</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "LVS的DR模式",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/LVS%E7%9A%84DR%E6%A8%A1%E5%BC%8F%20(copy)/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/LVS%E7%9A%84DR%E6%A8%A1%E5%BC%8F%20(copy)/",
      "content_html": "<h1 id=\"lvs的dr模式\"> LVS的DR模式</h1>\n<h2 id=\"准备资源\"> 准备资源</h2>\n<table>\n<thead>\n<tr>\n<th>主机</th>\n<th>ip</th>\n<th>角色</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>master</td>\n<td>192.168.1.20</td>\n<td>DR</td>\n</tr>\n<tr>\n<td>node1</td>\n<td>192.168.1.21</td>\n<td>RS1</td>\n</tr>\n<tr>\n<td>node2</td>\n<td>192.168.1.22</td>\n<td>RS2</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"搭建步骤\"> 搭建步骤</h2>\n<p>1、 找一台主机作为DR（虚拟服务器），安装ipvsadm</p>\n<p>a) Yum install ipvsadm</p>\n<p>2、 在DR设置两个IP地址：</p>\n<p>a) DIP: 192.168.1.134 ,设置静态ID</p>\n<p>b) VIP:192.168.1.200 , ifconfig eth0:1 192.168.1.200/24</p>\n<p>3、 找多台机器作为RS( apeche或者tomcat )</p>\n<p>a) 两台：静态设置192.168.1.137</p>\n<p>​          192.168.1.138</p>\n<p>b) 修改报文源IP的设置，需要设置内核参数</p>\n<p>i. echo 1 &gt; /proc/sys/net/ipv4/conf/eth0/arp_ignore</p>\n<p>ii. echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore</p>\n<p>iii. echo 2 &gt; /proc/sys/net/ipv4/conf/eth0/arp_announce</p>\n<p>iv. echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce</p>\n<p>c) 在两台机器（RS）上，设置网卡的别名IP：192.168.1.200</p>\n<p>i. ifconfig lo:0 192.168.1.200 netmask 255.255.255.255 broadcast 192.168.1.200</p>\n<p>d) 在两台机器（RS）上，添加一个路由</p>\n<p>i. route add -host 192.168.1.200 dev lo:0</p>\n<p>4、 DR上需要加一个路由设置：route add -host 192.168.1.200 dev eth0:1</p>\n<p>5、 在RS 检查web服务是否正常</p>\n<p>6、 在DR上使用ipvsadm添加集群服务</p>\n<p>a) Ipvsadm –C</p>\n<p>b) ipvsadm -A -t 192.168.1.200:80 -s wlc</p>\n<p>c) ipvsadm -a -t 192.168.1.200:80 -r 192.168.1.137 -g -w 1</p>\n<p>d) ipvsadm -a -t 192.168.1.200:80 -r 192.168.1.138 -g -w 1</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "LVS",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/LVS/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/LVS/",
      "content_html": "<h1 id=\"lvs\"> LVS</h1>\n<p>Linux Virtual Server</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>IP</th>\n<th>软件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DR(Master)</td>\n<td>192.168.1.20<br>vip:192.168.1.100</td>\n<td>keepalived,ipvsadm</td>\n</tr>\n<tr>\n<td>DR(BACKUP)</td>\n<td>192.168.1.20<br>vip:192.168.1.100</td>\n<td>keepalived,ipvsadm</td>\n</tr>\n<tr>\n<td>RS1</td>\n<td>192.168.1.22<br>隐藏vip:192.168.1.100</td>\n<td>nginx</td>\n</tr>\n<tr>\n<td>RS2</td>\n<td>192.168.1.23<br>隐藏vip:192.168.1.100</td>\n<td>nginx</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"配置dr服务器\"> 配置DR服务器</h2>\n<div><pre><code>ifconfig ens33:192.168.1.100/24\nroute add -host 192.168.1.100 dev ens33\nipvsadm -A -t 192.168.1.100:80 -s wlc\nipvsadm -a -t 192.168.1.100:80 -s wlc -r 192.168.1.22 -g -w 1\nipvsadm -a -t 192.168.1.100:80 -s wlc -r 192.168.1.23 -g -w 1\nipvsadm -Ln\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code>route add -host 192.168.1.100 dev ens33\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"配置rs服务器\"> 配置RS服务器</h2>\n<p>在2台RS服务器上操作</p>\n<p>修改内核参数</p>\n<div><pre><code><span>echo</span> <span>1</span> <span>></span> /proc/sys/net/ipv4/conf/ens33/arp_ignore\n<span>echo</span> <span>1</span> <span>></span> /proc/sys/net/ipv4/conf/all/arp_ignore\n<span>echo</span> <span>2</span> <span>></span> /proc/sys/net/ipv4/conf/ens33/arp_announce\n<span>echo</span> <span>2</span> <span>></span> /proc/sys/net/ipv4/conf/all/arp_announce\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在两台机器（RS）上，设置网卡的别名IP：192.168.1.200</p>\n<div><pre><code><span>ifconfig</span> lo:0 <span>192.168</span>.1.100 netmask <span>255.255</span>.255.255 broadcast <span>192.168</span>.1.100\n</code></pre>\n<div><span>1</span><br></div></div><p>在两台机器（RS）上，添加一个路由</p>\n<div><pre><code>route <span>add</span> -host <span>192.168</span>.1.200 dev lo:0\n</code></pre>\n<div><span>1</span><br></div></div><p>DR上需要加一个路由设置</p>\n<div><pre><code>route <span>add</span> -host <span>192.168</span>.1.100 dev ens33\n</code></pre>\n<div><span>1</span><br></div></div><p>在DR上使用ipvsadm添加集群服务</p>\n<div><pre><code>Ipvsadm –C\n\nipvsadm -A -t <span>192.168</span>.1.100:80 -s wlc\n\nipvsadm -a -t <span>192.168</span>.1.100:80 -r <span>192.168</span>.1.21 -g -w <span>1</span>\n\nipvsadm -a -t <span>192.168</span>.1.100:80 -r <span>192.168</span>.1.22 -g -w <span>1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "VMware下安装CentOS7",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux00%20-%20VMware%E4%B8%8B%E5%AE%89%E8%A3%85CentOS7/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux00%20-%20VMware%E4%B8%8B%E5%AE%89%E8%A3%85CentOS7/",
      "content_html": "<h1 id=\"vmware下安装centos7\"> VMware下安装CentOS7</h1>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404074217-775986.png\" alt=\"image-20200404074217273\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404074252-283236.png\" alt=\"image-20200404074252455\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404074332-468638.png\" alt=\"image-20200404074332049\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404075937-468793.png\" alt=\"image-20200404075936874\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404080028-328414.png\" alt=\"image-20200404080028145\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404081456-875860.png\" alt=\"image-20200404081454575\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404081633-580551.png\" alt=\"image-20200404081632823\" /></p>\n<p>开启虚拟机</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404081903-763402.png\" alt=\"image-20200404081903293\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404082133-563310.png\" alt=\"image-20200404082133533\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404082253-871800.png\" alt=\"image-20200404082253703\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404082347-391156.png\" alt=\"image-20200404082347159\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404082520-923770.png\" alt=\"image-20200404082520059\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404082547-791975.png\" alt=\"image-20200404082547181\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404082601-10308.png\" alt=\"image-20200404082601437\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404082704-390824.png\" alt=\"image-20200404082704443\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404082749-871072.png\" alt=\"image-20200404082749718\" /></p>\n<p>等待安装完成</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404084327-377459.png\" alt=\"image-20200404084326576\" /></p>\n<p>登录完成</p>\n<h2 id=\"配置网络\"> 配置网络</h2>\n<p>配置虚拟机</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404084729-841068.png\" alt=\"image-20200404084729244\" /></p>\n<p>进入目录</p>\n<div><pre><code><span>cd</span> /etc/sysconfig/network-scripts\n</code></pre>\n<div><span>1</span><br></div></div><p>查看网卡</p>\n<div><pre><code><span>ls</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>我这里的是ifcfg-ens33</p>\n<p>编辑这个文件</p>\n<div><pre><code><span>vi</span> ifcfg-ens33\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404085550-73601.png\" alt=\"image-20200404085549253\" /></p>\n<p>修改成如下配置</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404090154-572857.png\" alt=\"image-20200404090148572\" /></p>\n<p>保存配置退出</p>\n<p>按esc键 输入<code>:wq</code>，按回车即可</p>\n<blockquote>\n<p>给IPADDR指定ip地址，前面的192.168.1这三位数一定要与本机的ip一样</p>\n<p>打开cmd，输入<code>ipconfig</code>查看本机的ip</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404090441-977429.png\" alt=\"image-20200404090439788\" /></p>\n<p>我本机的ip是192.168.1开头的，所以我给虚拟机分配的ip是192.168.1.6。</p>\n</blockquote>\n<p>重启网络</p>\n<div><pre><code><span>service</span> network restart\n</code></pre>\n<div><span>1</span><br></div></div><p>配置VMware的虚拟网络</p>\n<p>点击VM的“编辑” &gt; “虚拟网络编辑器”</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404084916-506090.png\" alt=\"image-20200404084915876\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404091044-677193.png\" alt=\"image-20200404091044168\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404091321-728122.png\" alt=\"image-20200404091318978\" /></p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404091435-698769.png\" alt=\"image-20200404091435468\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200404074217-775986.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux 简介",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux01%20-%20%E7%AE%80%E4%BB%8B/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux01%20-%20%E7%AE%80%E4%BB%8B/",
      "content_html": "<h1 id=\"linux-简介\"> Linux 简介</h1>\n<h2 id=\"概述\"> 概述</h2>\n<p>Linux 是一种自由和开放源码的类 UNIX 操作系统，使用 Linux 内核。目前存在着许多不同的 Linux 发行版，可安装在各种各样的电脑硬件设备，从手机、平板电脑、路由器和影音游戏控制台，到桌上型电脑，大型电脑和超级电脑。 Linux 是一个领先的操作系统，世界上运算最快的 10 台超级电脑运行的都是 Linux 操作系统。</p>\n<p>Linux 操作系统也是自由软件和开放源代码发展中最著名的例子。只要遵循 GNU 通用公共许可证,任何人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。严格来讲，Linux 这个词本身只表示 Linux 内核，但在实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统 (也被称为 GNU/ Linux)。通常情况下，Linux 被打包成供桌上型电脑和服务器使用的 Linux 发行版本。一些流行的主流 Linux 发行版本，包括 Debian (及其衍生版本 Ubuntu)，Fedora 和 OpenSUSE 等。Kernel + Softwares + Tools 就是 Linux Distribution</p>\n<p>目前市面上较知名的发行版有：<code>Ubuntu</code>、RedHat、<code>CentOS</code>、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。</p>\n",
      "date_published": "2020-01-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "LVS的DR模式",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/LVS%E7%9A%84DR%E6%A8%A1%E5%BC%8F/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/LVS%E7%9A%84DR%E6%A8%A1%E5%BC%8F/",
      "content_html": "<h1 id=\"lvs的dr模式\"> LVS的DR模式</h1>\n<h2 id=\"准备资源\"> 准备资源</h2>\n<table>\n<thead>\n<tr>\n<th>主机</th>\n<th>ip</th>\n<th>角色</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>master</td>\n<td>192.168.1.20</td>\n<td>DR</td>\n</tr>\n<tr>\n<td>node1</td>\n<td>192.168.1.21</td>\n<td>RS1</td>\n</tr>\n<tr>\n<td>node2</td>\n<td>192.168.1.22</td>\n<td>RS2</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"搭建步骤\"> 搭建步骤</h2>\n<h3 id=\"dr服务器上操作\"> DR服务器上操作</h3>\n<h4 id=\"设置临时虚拟ip\"> 设置临时虚拟IP</h4>\n<div><pre><code><span>ip</span> addr  <span>add</span> <span>192.168</span>.1.100/24 dev ens33 label ens33:0\n</code></pre>\n<div><span>1</span><br></div></div><p>重启网络服务</p>\n<div><pre><code><span>service</span> network restart\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"安装ipvsadm\"> 安装ipvsadm</h4>\n<div><pre><code>yum <span>install</span> -y ipvsadm\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"dr上配置脚本\"> DR上配置脚本</h4>\n<p>编写脚本</p>\n<div><pre><code><span>vim</span> /usr/local/sbin/lvs_dr.sh\n</code></pre>\n<div><span>1</span><br></div></div><p>lvs_dr.sh</p>\n<div><pre><code><span>#! /bin/bash</span>\n\n<span>echo</span> <span>1</span> <span>></span> /proc/sys/net/ipv4/ip_forward\n\n<span>ipv</span><span>=</span>/sbin/ipvsadm\n\n<span>vip</span><span>=</span><span>192.168</span>.1.100\n\n<span>rs1</span><span>=</span><span>192.168</span>.1.21\n\n<span>rs2</span><span>=</span><span>192.168</span>.1.22\n\n<span>#设置ds的ip和路由，也可以先手动设置好</span>\n\n<span>ifconfig</span> ens33:0 down\n\n<span>ifconfig</span> ens33:0 <span>$vip</span> broadcast <span>$vip</span> netmask <span>255.255</span>.255.255 up\n\nroute <span>add</span> -host <span>$vip</span> dev ens33:0\n\n<span>$ipv</span> -C\n\n<span>$ipv</span> -A -t <span>$vip</span>:80 -s wlc\n\n<span>$ipv</span> -a -t <span>$vip</span>:80 -r <span>$rs1</span>:80 -g -w <span>1</span>\n\n<span>$ipv</span> -a -t <span>$vip</span>:80 -r <span>$rs2</span>:80 -g -w <span>1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>执行脚本</p>\n<div><pre><code><span>bash</span> /usr/local/sbin/lvs_dr.sh\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"在2台rs服务器上操作\"> 在2台RS服务器上操作</h3>\n<p>编辑脚本</p>\n<div><pre><code><span>vim</span> /usr/local/sbin/lvs_dr_rs.sh\n</code></pre>\n<div><span>1</span><br></div></div><p>lvs_dr_rs.sh</p>\n<div><pre><code><span>#! /bin/bash</span>\n\n<span>vip</span><span>=</span><span>192.168</span>.1.100\n\n<span>ifconfig</span> lo:0 <span>$vip</span> broadcast <span>$vip</span> netmask <span>255.255</span>.255.255 up\n\nroute <span>add</span> -host <span>$vip</span> lo:0\n\n<span>echo</span> <span>\"1\"</span> <span>></span>/proc/sys/net/ipv4/conf/lo/arp_ignore\n\n<span>echo</span> <span>\"2\"</span> <span>></span>/proc/sys/net/ipv4/conf/lo/arp_announce\n\n<span>echo</span> <span>\"1\"</span> <span>></span>/proc/sys/net/ipv4/conf/all/arp_ignore\n\n<span>echo</span> <span>\"2\"</span> <span>></span>/proc/sys/net/ipv4/conf/all/arp_announce\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>执行脚本</p>\n<div><pre><code><span>bash</span> /usr/local/sbin/lvs_dr_rs.sh\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"测试\"> 测试</h2>\n<p>在浏览器输入http://192.168.1.100/</p>\n<p>如果stop掉node1的nginx，就会转发到node2的nginx</p>\n<p>再次访问http://192.168.1.100/</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux 操作文件目录",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux03%20-%20%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux03%20-%20%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/",
      "content_html": "<h1 id=\"linux-操作文件目录\"> Linux 操作文件目录</h1>\n<h2 id=\"概述\"> 概述</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">语法</th>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">参数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ls</td>\n<td style=\"text-align:left\">显示文件和目录列表</td>\n<td style=\"text-align:left\">ls [-alrtAFR] [name...]</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-l</td>\n<td style=\"text-align:left\">列出文件的详细信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-a</td>\n<td style=\"text-align:left\">列出当前目录所有文件，包含隐藏文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">mkdir</td>\n<td style=\"text-align:left\">创建目录</td>\n<td style=\"text-align:left\">mkdir [-p] dirName</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-p</td>\n<td style=\"text-align:left\">父目录不存在情况下先生成父目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">cd</td>\n<td style=\"text-align:left\">切换目录</td>\n<td style=\"text-align:left\">cd [dirName]</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">touch</td>\n<td style=\"text-align:left\">生成一个空文件</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">echo</td>\n<td style=\"text-align:left\">生成一个带内容文件</td>\n<td style=\"text-align:left\">echo abcd &gt; 1.txt，echo 1234 &gt;&gt; 1.txt</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">cat</td>\n<td style=\"text-align:left\">显示文本文件内容</td>\n<td style=\"text-align:left\">cat [-AbeEnstTuv] [--help] [--version] fileName</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">cp</td>\n<td style=\"text-align:left\">复制文件或目录</td>\n<td style=\"text-align:left\">cp [options] source dest</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">rm</td>\n<td style=\"text-align:left\">删除文件</td>\n<td style=\"text-align:left\">rm [options] name...</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-f</td>\n<td style=\"text-align:left\">强制删除文件或目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-r</td>\n<td style=\"text-align:left\">同时删除该目录下的所有文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">mv</td>\n<td style=\"text-align:left\">移动文件或目录</td>\n<td style=\"text-align:left\">mv [options] source dest</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">find</td>\n<td style=\"text-align:left\">在文件系统中查找指定的文件</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-name</td>\n<td style=\"text-align:left\">文件名</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">grep</td>\n<td style=\"text-align:left\">在指定的文本文件中查找指定的字符串</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">tree</td>\n<td style=\"text-align:left\">用于以树状图列出目录的内容</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">pwd</td>\n<td style=\"text-align:left\">显示当前工作目录</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ln</td>\n<td style=\"text-align:left\">建立软链接</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">more</td>\n<td style=\"text-align:left\">分页显示文本文件内容</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">head</td>\n<td style=\"text-align:left\">显示文件开头内容</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">tail</td>\n<td style=\"text-align:left\">显示文件结尾内容</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-f</td>\n<td style=\"text-align:left\">跟踪输出</td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2020-01-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux 的目录结构",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux02%20-%20%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux02%20-%20%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/",
      "content_html": "<h1 id=\"linux-的目录结构\"> Linux 的目录结构</h1>\n<p><img src=\"https://funtl.com/assets/微信截图_20171102134832.png\" alt=\"img\" /></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">目录</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">bin</td>\n<td style=\"text-align:left\">存放二进制可执行文件(ls,cat,mkdir等)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">boot</td>\n<td style=\"text-align:left\">存放用于系统引导时使用的各种文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">dev</td>\n<td style=\"text-align:left\">用于存放设备文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">etc</td>\n<td style=\"text-align:left\">存放系统配置文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">home</td>\n<td style=\"text-align:left\">存放所有用户文件的根目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">lib</td>\n<td style=\"text-align:left\">存放跟文件系统中的程序运行所需要的共享库及内核模块</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">mnt</td>\n<td style=\"text-align:left\">系统管理员安装临时文件系统的安装点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">opt</td>\n<td style=\"text-align:left\">额外安装的可选应用程序包所放置的位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">proc</td>\n<td style=\"text-align:left\">虚拟文件系统，存放当前内存的映射</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">root</td>\n<td style=\"text-align:left\">超级用户目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">sbin</td>\n<td style=\"text-align:left\">存放二进制可执行文件，只有root才能访问</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">tmp</td>\n<td style=\"text-align:left\">用于存放各种临时文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">usr</td>\n<td style=\"text-align:left\">用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">var</td>\n<td style=\"text-align:left\">用于存放运行时需要改变数据的文件</td>\n</tr>\n</tbody>\n</table>\n",
      "image": "https://funtl.com/assets/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171102134832.png",
      "date_published": "2020-01-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux 系统管理命令",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux04%20-%20%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux04%20-%20%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/",
      "content_html": "<h1 id=\"linux-系统管理命令\"> Linux 系统管理命令</h1>\n<h2 id=\"概述\"> 概述</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">stat</td>\n<td style=\"text-align:left\">显示指定文件的相关信息,比ls命令显示内容更多</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">who</td>\n<td style=\"text-align:left\">显示在线登录用户</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">hostname</td>\n<td style=\"text-align:left\">显示主机名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">uname</td>\n<td style=\"text-align:left\">显示系统信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">top</td>\n<td style=\"text-align:left\">显示当前系统中耗费资源最多的进程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ps</td>\n<td style=\"text-align:left\">显示瞬间的进程状态</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">du</td>\n<td style=\"text-align:left\">显示指定的文件（目录）已使用的磁盘空间的总量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">df</td>\n<td style=\"text-align:left\">显示文件系统磁盘空间的使用情况</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">free</td>\n<td style=\"text-align:left\">显示当前内存和交换空间的使用情况</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ifconfig</td>\n<td style=\"text-align:left\">显示网络接口信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ping</td>\n<td style=\"text-align:left\">测试网络的连通性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">netstat</td>\n<td style=\"text-align:left\">显示网络状态信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">clear</td>\n<td style=\"text-align:left\">清屏</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">kill</td>\n<td style=\"text-align:left\">杀死一个进程</td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2020-01-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux 开关机命令",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux05%20-%20%E5%BC%80%E5%85%B3%E6%9C%BA%E5%91%BD%E4%BB%A4/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux05%20-%20%E5%BC%80%E5%85%B3%E6%9C%BA%E5%91%BD%E4%BB%A4/",
      "content_html": "<h1 id=\"linux-开关机命令\"> Linux 开关机命令</h1>\n<p>shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\">语法</th>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">参数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">shutdown</td>\n<td style=\"text-align:left\">shutdown [-t seconds] [-rkhncfF] time [message]</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-t seconds</td>\n<td style=\"text-align:left\">设定在几秒钟之后进行关机程序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-k</td>\n<td style=\"text-align:left\">并不会真的关机，只是将警告讯息传送给所有只用者</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-r</td>\n<td style=\"text-align:left\">关机后重新开机（重启）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-h</td>\n<td style=\"text-align:left\">关机后停机</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-n</td>\n<td style=\"text-align:left\">不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-c</td>\n<td style=\"text-align:left\">取消目前已经进行中的关机动作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-f</td>\n<td style=\"text-align:left\">关机时，不做 fcsk 动作(检查 Linux 档系统)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-F</td>\n<td style=\"text-align:left\">关机时，强迫进行 fsck 动作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">time</td>\n<td style=\"text-align:left\">设定关机的时间</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">message</td>\n<td style=\"text-align:left\">传送给所有使用者的警告讯息</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"重启\"> 重启</h2>\n<ul>\n<li>reboot</li>\n<li>shutdown -r now</li>\n</ul>\n<h2 id=\"关机\"> 关机</h2>\n<ul>\n<li>shutdown -h now</li>\n</ul>\n",
      "date_published": "2020-01-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux 压缩命令",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux06%20-%20%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux06%20-%20%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/",
      "content_html": "<h1 id=\"linux-压缩命令\"> Linux 压缩命令</h1>\n<h2 id=\"tar\"> tar</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\">语法</th>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">参数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">tar</td>\n<td style=\"text-align:left\">tar [-cxzjvf] 压缩打包文档的名称 欲打包目录</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-c</td>\n<td style=\"text-align:left\">建立一个归档文件的参数指令</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-x</td>\n<td style=\"text-align:left\">解开一个归档文件的参数指令</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-z</td>\n<td style=\"text-align:left\">是否需要用 gzip 压缩</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-j</td>\n<td style=\"text-align:left\">是否需要用 bzip2 压缩</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-v</td>\n<td style=\"text-align:left\">压缩的过程中显示文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-f</td>\n<td style=\"text-align:left\">使用档名，在 f 之后要立即接档名</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-tf</td>\n<td style=\"text-align:left\">查看归档文件里面的文件</td>\n</tr>\n</tbody>\n</table>\n<p><strong>例子：</strong></p>\n<ul>\n<li>压缩文件夹：<code>tar -zcvf test.tar.gz test\\</code></li>\n<li>解压文件夹：<code>tar -zxvf test.tar.gz</code></li>\n</ul>\n<h2 id=\"gzip\"> gzip</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\">语法</th>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">参数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">gzip</td>\n<td style=\"text-align:left\">gzip [选项] 压缩（解压缩）的文件名</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-d</td>\n<td style=\"text-align:left\">解压缩</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-l</td>\n<td style=\"text-align:left\">对每个压缩文件，显示压缩文件的大小，未压缩文件的大小，压缩比，未压缩文件的名字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-v</td>\n<td style=\"text-align:left\">对每一个压缩和解压的文件，显示文件名和压缩比</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-num</td>\n<td style=\"text-align:left\">用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6</td>\n</tr>\n</tbody>\n</table>\n<p>说明：压缩文件后缀为 gz</p>\n<h2 id=\"bzip2\"> bzip2</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\">语法</th>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">参数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">bzip2</td>\n<td style=\"text-align:left\">bzip2 [-cdz]</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-d</td>\n<td style=\"text-align:left\">解压缩</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-z</td>\n<td style=\"text-align:left\">压缩参数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">-num</td>\n<td style=\"text-align:left\">用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6</td>\n</tr>\n</tbody>\n</table>\n<p>说明：压缩文件后缀为 bz2</p>\n",
      "date_published": "2020-01-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux 用户和组管理",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux08%20-%20%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux08%20-%20%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/",
      "content_html": "<h1 id=\"linux-用户和组管理\"> Linux 用户和组管理</h1>\n<h2 id=\"概述\"> 概述</h2>\n<p>Linux 操作系统是一个多用户操作系统，它允许多用户同时登录到系统上并使用资源。系统会根据账户来区分每个用户的文件，进程，任务和工作环境，使得每个用户工作都不受干扰。</p>\n<h2 id=\"使用-root-用户\"> 使用 Root 用户</h2>\n<p>在实际生产操作中，我们基本上都是使用超级管理员账户操作 Linux 系统，也就是 Root 用户，Linux 系统默认是关闭 Root 账户的，我们需要为 Root 用户设置一个初始密码以方便我们使用。</p>\n<h3 id=\"设置-root-账户密码\"> 设置 Root 账户密码</h3>\n<div><pre><code>sudo passwd root\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"root\"> Root</h3>\n<div><pre><code>su\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"设置允许远程登录-root\"> 设置允许远程登录 Root</h3>\n<div><pre><code>nano /etc/ssh/sshd_config\n\n# Authentication:\nLoginGraceTime 120\n#PermitRootLogin without-password     //注释此行\nPermitRootLogin yes                             //加入此行\nStrictModes yes\n\n重启服务\nservice ssh restart\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"用户账户说明\"> 用户账户说明</h2>\n<h3 id=\"普通用户\"> 普通用户</h3>\n<p>普通用户在系统上的任务是进行普通操作</p>\n<h3 id=\"超级管理员\"> 超级管理员</h3>\n<p>管理员在系统上的任务是对普通用户和整个系统进行管理。对系统具有绝对的控制权，能够对系统进行一切操作。用 root 表示，root 用户在系统中拥有最高权限，默认下 Ubuntu 用户的 root 用户是不能登录的。</p>\n<h3 id=\"安装时创建的系统用户\"> 安装时创建的系统用户</h3>\n<p>此用户创建时被添加到 admin 组中，在 Ubuntu 中，admin 组中的用户默认是可以使用 <code>sudo</code> 命令来执行只有管理员才能执行的命令的。如果不使用 <code>sudo</code> 就是一个普通用户。</p>\n<h2 id=\"组账户说明\"> 组账户说明</h2>\n<h3 id=\"私有组\"> 私有组</h3>\n<p>当创建一个用户时没有指定属于哪个组，Linux 就会建立一个与用户同名的私有组，此私有组只含有该用户。</p>\n<h3 id=\"标准组\"> 标准组</h3>\n<p>当创建一个用户时可以选定一个标准组，如果一个用户同时属于多个组时，登录后所属的组为主组，其他的为附加组。</p>\n<h2 id=\"账户系统文件说明\"> 账户系统文件说明</h2>\n<h3 id=\"etc-passwd\"> /etc/passwd</h3>\n<p>每一行代表一个账号，众多账号是系统正常运行所必须的，例如 bin，nobody 每行定义一个用户账户，此文件对所有用户可读。每行账户包含如下信息：</p>\n<div><pre><code>root:x:0:0:root:/root:/bin/bash\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li><strong>用户名：</strong> 就是账号，用来对应 UID，root UID 是 0。</li>\n<li><strong>口令：</strong> 密码，早期 UNIX 系统密码存在此字段，由于此文件所有用户都可以读取，密码容易泄露，后来这个字段数据就存放到 /etc/shadow 中，这里只能看到 X。</li>\n<li><strong>用户标示号（UID）：</strong> 系统内唯一，root 用户的 UID 为 0，普通用户从 1000 开始，1-999 是系统的标准账户，500-65536 是可登陆账号。</li>\n<li><strong>组标示号（GID）：</strong> 与 /etc/group 相关用来规定组名和 GID 相对应。</li>\n<li><strong>注释：</strong> 注释账号</li>\n<li><strong>宿主目录（主文件夹）：</strong> 用户登录系统后所进入的目录 root 在 /root/itcast</li>\n<li><strong>命令解释器（shell）：</strong> 指定该用户使用的 shell ，默认的是 /bin/bash</li>\n</ul>\n<h3 id=\"etc-shadow\"> /etc/shadow</h3>\n<p>为了增加系统的安全性，用户口令通常用 shadow passwords 保护。只有 root 可读。每行包含如下信息：</p>\n<div><pre><code>root:$6$Reu571.V$Ci/kd.OTzaSGU.TagZ5KjYx2MLzQv2IkZ24E1.yeTT3Pp4o/yniTjus/rRaJ92Z18MVy6suf1W5uxxurqssel.:17465:0:99999:7:::\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>\n<p><strong>账号名称：</strong> 需要和 /etc/passwd 一致。</p>\n</li>\n<li>\n<p>密码：</p>\n<p>经过加密，虽然加密，但不表示不会被破解，该文件默认权限如下：</p>\n<ul>\n<li>-rw------- 1 root root 1560 Oct 26 17:20 passwd-</li>\n<li>只有root能都读写</li>\n</ul>\n</li>\n<li>\n<p><strong>最近修改密码日期：</strong> 从1970-1-1起，到用户最后一次更改口令的天数</p>\n</li>\n<li>\n<p><strong>密码最小时间间隔：</strong> 从1970-1-1起，到用户可以更改口令的天数</p>\n</li>\n<li>\n<p><strong>密码最大时间间隔：</strong> 从1970-1-1起，必须更改的口令天数</p>\n</li>\n<li>\n<p><strong>密码到期警告时间：</strong> 在口令过期之前几天通知</p>\n</li>\n<li>\n<p><strong>密码到期后账号宽限时间</strong></p>\n</li>\n<li>\n<p><strong>密码到期禁用账户时间：</strong> 在用户口令过期后到禁用账户的天数</p>\n</li>\n<li>\n<p><strong>保留</strong></p>\n</li>\n</ul>\n<h3 id=\"etc-group\"> /etc/group</h3>\n<p>用户组的配置文件</p>\n<div><pre><code>root:x:0:\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li><strong>用户组名称</strong></li>\n<li><strong>用户组密码：</strong> 给用户组管理员使用，通常不用</li>\n<li><strong>GID：</strong> 用户组的ID</li>\n<li><strong>此用户支持的账号名称：</strong> 一个账号可以加入多个用户组，例如想要 itcast 加入 root 这个用户组，将该账号填入该字段即可 root❌0:root, icast 将用户进行分组是 Linux 对用户进行管理及控制访问权限的一种手段。一个中可以有多个用户，一个用户可以同时属于多个组。该文件对所有用户可读。</li>\n</ul>\n<h3 id=\"etc-gshadow\"> /etc/gshadow</h3>\n<p>该文件用户定义用户组口令，组管理员等信息只有root用户可读。</p>\n<div><pre><code>root:\\*::\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li><strong>用户组名</strong></li>\n<li><strong>密码列</strong></li>\n<li><strong>用户组管理员的账号</strong></li>\n<li><strong>用户组所属账号</strong></li>\n</ul>\n<h2 id=\"账户管理常用命令\"> 账户管理常用命令</h2>\n<h3 id=\"增加用户\"> 增加用户</h3>\n<div><pre><code>useradd 用户名\nuseradd -u (UID号)\nuseradd -p (口令)\nuseradd -g (分组)\nuseradd -s (SHELL)\nuseradd -d (用户目录)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如：<code>useradd lusifer</code></p>\n<p>增加用户名为 lusifer 的账户</p>\n<h3 id=\"修改用户\"> 修改用户</h3>\n<div><pre><code>usermod -u (新UID)\nusermod -d (用户目录)\nusermod -g (组名)\nusermod -s (SHELL)\nusermod -p (新口令)\nusermod -l (新登录名)\nusermod -L (锁定用户账号密码)\nusermod -U (解锁用户账号)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>如：<code>usermod -u 1024 -g group2 -G root lusifer</code></p>\n<p>将 lusifer 用户 uid 修改为 1024，默认组改为系统中已经存在的 group2，并且加入到系统管理员组</p>\n<h3 id=\"删除用户\"> 删除用户</h3>\n<div><pre><code>userdel 用户名 (删除用户账号)\nuserdel -r 删除账号时同时删除目录\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>如：<code>userdel -r lusifer</code></p>\n<p>删除用户名为 lusifer 的账户并同时删除 lusifer 的用户目录</p>\n<h3 id=\"组账户维护\"> 组账户维护</h3>\n<div><pre><code>groupadd 组账户名 (创建新组)\ngroupadd -g 指定组GID\ngroupmod -g 更改组的GID\ngroupmod -n 更改组账户名\ngroupdel 组账户名 (删除指定组账户)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"口令维护\"> 口令维护</h3>\n<div><pre><code>passwd 用户账户名 (设置用户口令)\npasswd -l 用户账户名 (锁定用户账户)\npasswd -u 用户账户名 (解锁用户账户)\npasswd -d 用户账户名 (删除账户口令)\ngpasswd -a 用户账户名 组账户名 (将指定用户添加到指定组)\ngpasswd -d 用户账户名 组账户名 (将用户从指定组中删除)\ngpasswd -A 用户账户名 组账户名 (将用户指定为组的管理员)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"用户和组状态\"> 用户和组状态</h3>\n<div><pre><code>su 用户名(切换用户账户)\nid 用户名(显示用户的UID，GID)\nwhoami (显示当前用户名称)\ngroups (显示用户所属组)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>",
      "date_published": "2020-01-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux 文件权限管理",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux09%20-%20%20%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux09%20-%20%20%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/",
      "content_html": "<h1 id=\"linux-文件权限管理\"> Linux 文件权限管理</h1>\n<h2 id=\"查看文件和目录的权限\"> 查看文件和目录的权限</h2>\n<p>ls –al<code>使用 ls 不带参数只显示文件名称，通过</code>ls –al` 可以显示文件或者目录的权限信息。</p>\n<p><code>ls -l 文件名</code> 显示信息包括：文件类型 (<code>d</code> 目录，<code>-</code> 普通文件，<code>l</code> 链接文件)，文件权限，文件的用户，文件的所属组，文件的大小，文件的创建时间，文件的名称</p>\n<div><pre><code>-rw-r--r-- 1 lusifer lusifer 675 Oct 26 17:20 .profile\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li><code>-</code>：普通文件</li>\n<li><code>rw-</code>：说明用户 lusifer 有读写权限，没有运行权限</li>\n<li><code>r--</code>：表示用户组 lusifer 只有读权限，没有写和运行的权限</li>\n<li><code>r--</code>：其他用户只有读权限，没有写权限和运行的权限</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">-rw-r--r--</th>\n<th style=\"text-align:left\">1</th>\n<th style=\"text-align:left\">lusifer</th>\n<th style=\"text-align:left\">lusifer</th>\n<th style=\"text-align:left\">675</th>\n<th style=\"text-align:left\">Oct 26 17:20</th>\n<th style=\"text-align:left\">.profile</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">文档类型及权限</td>\n<td style=\"text-align:left\">连接数</td>\n<td style=\"text-align:left\">文档所属用户</td>\n<td style=\"text-align:left\">文档所属组</td>\n<td style=\"text-align:left\">文档大小</td>\n<td style=\"text-align:left\">文档最后被修改日期</td>\n<td style=\"text-align:left\">文档名称</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">-</th>\n<th style=\"text-align:left\">rw-</th>\n<th style=\"text-align:left\">r--</th>\n<th style=\"text-align:left\">r--</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">文档类型</td>\n<td style=\"text-align:left\">文档所有者权限（user）</td>\n<td style=\"text-align:left\">文档所属用户组权限（group）</td>\n<td style=\"text-align:left\">其他用户权限（other）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"文档类型\"> 文档类型</h3>\n<ul>\n<li><code>d</code> 表示目录</li>\n<li><code>l</code> 表示软连接</li>\n<li><code>–</code> 表示文件</li>\n<li><code>c</code> 表示串行端口字符设备文件</li>\n<li><code>b</code> 表示可供存储的块设备文件</li>\n<li>余下的字符 3 个字符为一组。<code>r</code> 只读，<code>w</code> 可写，<code>x</code> 可执行，<code>-</code> 表示无此权限</li>\n</ul>\n<h3 id=\"连接数\"> 连接数</h3>\n<p>指有多少个文件指向同一个索引节点。</p>\n<h3 id=\"文档所属用户和所属组\"> 文档所属用户和所属组</h3>\n<p>就是文档属于哪个用户和用户组。文件所属用户和组是可以更改的</p>\n<h3 id=\"文档大小\"> 文档大小</h3>\n<p>默认是 bytes</p>\n<h2 id=\"更改操作权限\"> 更改操作权限</h2>\n<h3 id=\"chown\"> chown</h3>\n<p>是 change owner 的意思，主要作用就是改变文件或者目录所有者，所有者包含用户和用户组</p>\n<div><pre><code>chown [-R] 用户名称 文件或者目录\nchown [-R] 用户名称 用户组名称 文件或目录\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>-R：进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限</p>\n<h3 id=\"chmod\"> chmod</h3>\n<p>改变访问权限</p>\n<div><pre><code>chmod [who] [+ | - | =] [mode] 文件名\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"who\"> who</h4>\n<p>表示操作对象可以是以下字母的一个或者组合</p>\n<ul>\n<li>u：用户 user</li>\n<li>g：用户组 group</li>\n<li>o：表示其他用户</li>\n<li>a：表示所有用户是系统默认的</li>\n</ul>\n<h4 id=\"操作符号\"> 操作符号</h4>\n<ul>\n<li>+：表示添加某个权限</li>\n<li>-：表示取消某个权限</li>\n<li>=：赋予给定的权限，取消文档以前的所有权限</li>\n</ul>\n<h4 id=\"mode\"> mode</h4>\n<p>表示可执行的权限，可以是 r、w、x</p>\n<h4 id=\"文件名\"> 文件名</h4>\n<p>文件名可以使空格分开的文件列表</p>\n<h4 id=\"示例\"> 示例</h4>\n<div><pre><code>lusifer@UbuntuBase:~$ ls -al test.txt \n-rw-rw-r-- 1 lusifer lusifer 6 Nov  2 21:47 test.txt\nlusifer@UbuntuBase:~$ chmod u=rwx,g+r,o+r test.txt \nlusifer@UbuntuBase:~$ ls -al test.txt \n-rwxrw-r-- 1 lusifer lusifer 6 Nov  2 21:47 test.txt\nlusifer@UbuntuBase:~$\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"数字设定法\"> 数字设定法</h2>\n<p>数字设定法中数字表示的含义</p>\n<ul>\n<li>0 表示没有任何权限</li>\n<li>1 表示有可执行权限 = <code>x</code></li>\n<li>2 表示有可写权限 = <code>w</code></li>\n<li>4 表示有可读权限 = <code>r</code></li>\n</ul>\n<p>也可以用数字来表示权限如 chmod 755 file_name</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">r w x</th>\n<th style=\"text-align:left\">r – x</th>\n<th style=\"text-align:left\">r - x</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">4 2 1</td>\n<td style=\"text-align:left\">4 - 1</td>\n<td style=\"text-align:left\">4 - 1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">user</td>\n<td style=\"text-align:left\">group</td>\n<td style=\"text-align:left\">others</td>\n</tr>\n</tbody>\n</table>\n<p>若要 rwx 属性则 4+2+1=7</p>\n<p>若要 rw- 属性则 4+2=6</p>\n<p>若要 r-x 属性则 4+1=5</p>\n<div><pre><code>lusifer@UbuntuBase:~$ chmod 777 test.txt \nlusifer@UbuntuBase:~$ ls -al test.txt \n-rwxrwxrwx 1 lusifer lusifer 6 Nov  2 21:47 test.txt\n\nlusifer@UbuntuBase:~$ chmod 770 test.txt \nlusifer@UbuntuBase:~$ ls -al test.txt \n-rwxrwx--- 1 lusifer lusifer 6 Nov  2 21:47 test.txt\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>",
      "date_published": "2020-01-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux 安装 Tomcat",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux11%20-%20%E5%AE%89%E8%A3%85Tomcat/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux11%20-%20%E5%AE%89%E8%A3%85Tomcat/",
      "content_html": "<h1 id=\"linux-安装-tomcat\"> Linux 安装 Tomcat</h1>\n<h2 id=\"概述\"> 概述</h2>\n<p>此处以 Tomcat 8.5.23 为例</p>\n<h2 id=\"下载地址\"> 下载地址</h2>\n<p>https://tomcat.apache.org/</p>\n<h2 id=\"解压缩并移动到指定目录\"> 解压缩并移动到指定目录</h2>\n<h3 id=\"解压缩\"> 解压缩</h3>\n<div><pre><code>tar -zxvf apache-tomcat-8.5.23.tar.gz\n</code></pre>\n<div><span>1</span><br></div></div><p>1</p>\n<h3 id=\"变更目录名\"> 变更目录名</h3>\n<div><pre><code>mv apache-tomcat-8.5.23 tomcat\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"移动目录\"> 移动目录</h3>\n<div><pre><code>mv tomcat/ /usr/local/\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"常用命令\"> 常用命令</h2>\n<h3 id=\"启动\"> 启动</h3>\n<div><pre><code>/usr/local/tomcat/bin/startup.sh\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"停止\"> 停止</h3>\n<div><pre><code>/usr/local/tomcat/bin/shutdown.sh\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"目录内执行脚本\"> 目录内执行脚本</h3>\n<div><pre><code>\n./startup.sh\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>",
      "date_published": "2020-01-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux 编辑器",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux07%20-%20Linux%20%E7%BC%96%E8%BE%91%E5%99%A8/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux07%20-%20Linux%20%E7%BC%96%E8%BE%91%E5%99%A8/",
      "content_html": "<h1 id=\"linux-编辑器\"> Linux 编辑器</h1>\n<h2 id=\"vim\"> vim</h2>\n<h3 id=\"运行模式\"> 运行模式</h3>\n<p>编辑模式：等待编辑命令输入</p>\n<p>插入模式：编辑模式下，输入 <code>i</code> 进入插入模式，插入文本信息</p>\n<p>命令模式：在编辑模式下，输入 <code>:</code> 进行命令模式</p>\n<h3 id=\"命令\"> 命令</h3>\n<p><code>:q</code> 直接退出vi</p>\n<p><code>:wq</code> 保存后退出vi ，并可以新建文件</p>\n<p><code>:q!</code> 强制退出</p>\n<p><code>:w file</code> 将当前内容保存成某个文件</p>\n<p><code>:set number</code> 在编辑文件显示行号</p>\n<p><code>:set nonumber</code> 在编辑文件不显示行号</p>\n<h2 id=\"nano\"> nano</h2>\n<p>nano 是一个字符终端的文本编辑器，有点像 DOS 下的 editor 程序。它比 vi/vim 要简单得多，比较适合 Linux 初学者使用。某些 Linux 发行版的默认编辑器就是 nano。</p>\n<h3 id=\"命令-2\"> 命令</h3>\n<ul>\n<li>保存：ctrl + o</li>\n<li>搜索：ctrl + w</li>\n<li>上一页：ctrl + y</li>\n<li>下一页：ctrl + v</li>\n<li>退出：ctrl + x</li>\n</ul>\n<h2 id=\"快捷键\"> 快捷键</h2>\n<ol>\n<li>拷贝当前行：（正常模式下） <code>yy</code>，拷贝当前向下5行：<code>5yy</code></li>\n<li>删除当前行： （正常模式下）<code>dd</code>，删除当前向下5行：<code>5dd</code></li>\n<li>搜索单词：（正常模式下）输入<code>/关键字</code>，如<code>/hello</code>。按下回车查找，按n下一个</li>\n<li>显示行号：（命令模式下）<code>:set nu</code></li>\n<li>取消显示行号：（命令模式下）<code>:set nonu</code></li>\n<li>转到文档顶部：（正常模式下）<code>G</code></li>\n<li>转到文档底部：（正常模式下）<code>gg</code></li>\n</ol>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200326085518-483348.jpeg\" alt=\"vi和vim快捷键一览图\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200326085518-483348.jpeg",
      "date_published": "2020-01-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux下安装JDK（rpm方式安装）",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux12%20-%20Linux%E4%B8%8B%E5%AE%89%E8%A3%85JDK/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux12%20-%20Linux%E4%B8%8B%E5%AE%89%E8%A3%85JDK/",
      "content_html": "<h1 id=\"linux下安装jdk-rpm方式安装\"> Linux下安装JDK（rpm方式安装）</h1>\n<h3 id=\"_1-上传jdk压缩包到服务器\"> 1. 上传JDK压缩包到服务器</h3>\n<p>创建文件夹opt/package</p>\n<div><pre><code><span>mkdir</span> /opt/package\n</code></pre>\n<div><span>1</span><br></div></div><p>切换到文件夹opt/package</p>\n<div><pre><code><span>cd</span> /opt/package\n</code></pre>\n<div><span>1</span><br></div></div><p>用ftp工具将文件上传至服务器的/opt/package目录下</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200408153342-377241.png\" alt=\"image-20200408153223542\" /></p>\n<h3 id=\"_2-安装jdk\"> 2. 安装JDK</h3>\n<p>执行命令</p>\n<div><pre><code><span>rpm</span> -ivh jdk-7u79-linux-x64.rpm\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_3-配置环境变量\"> 3. 配置环境变量</h3>\n<p>编辑/etc/profile文件</p>\n<div><pre><code><span>vim</span> /etc/profile\n</code></pre>\n<div><span>1</span><br></div></div><p>添加以下代码</p>\n<div><pre><code><span>export</span> <span>JAVA_HOME</span><span>=</span>/usr/java/jdk1.7.0_79\n<span>export</span> <span>CLASSPATH</span><span>=</span>$:CLASSPATH:<span>$JAVA_HOME</span>/lib/\n<span>export</span> <span><span>PATH</span></span><span>=</span><span>$PATH</span><span>:</span><span>$JAVA_HOME</span>/bin\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200408154802-968410.png\" alt=\"image-20200408154759206\" /></p>\n<p>更新配置文件</p>\n<div><pre><code><span>source</span> /etc/peofile\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_4-验证是否安装成功\"> 4. 验证是否安装成功</h3>\n<p>查看JDK版本</p>\n<div><pre><code>java -version\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200408154945-653797.png\" alt=\"image-20200408154945590\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200408153342-377241.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux 安装 Java",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux10%20-%20%E5%AE%89%E8%A3%85Java/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux10%20-%20%E5%AE%89%E8%A3%85Java/",
      "content_html": "<h1 id=\"linux-安装-java\"> Linux 安装 Java</h1>\n<h2 id=\"概述\"> 概述</h2>\n<p>此处以 JDK 1.8.0_152 为例</p>\n<h2 id=\"下载地址\"> 下载地址</h2>\n<p>http://www.oracle.com/technetwork/java/javase/downloads/index.html</p>\n<h2 id=\"解压缩并移动到指定目录\"> 解压缩并移动到指定目录</h2>\n<h3 id=\"解压缩\"> 解压缩</h3>\n<div><pre><code>tar -zxvf jdk-8u152-linux-x64.tar.gz\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"创建目录\"> 创建目录</h3>\n<div><pre><code>mkdir -p /usr/local/java\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"移动安装包\"> 移动安装包</h3>\n<div><pre><code>mv jdk1.8.0_152/ /usr/local/java/\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"设置所有者\"> 设置所有者</h3>\n<div><pre><code>chown -R root:root /usr/local/java/\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"配置环境变量\"> 配置环境变量</h2>\n<h3 id=\"配置系统环境变量\"> 配置系统环境变量</h3>\n<div><pre><code>nano /etc/environment\n</code></pre>\n<div><span>1</span><br></div></div><p>1</p>\n<h3 id=\"添加如下语句\"> <a href=\"https://funtl.com/zh/linux/Linux-%E5%AE%89%E8%A3%85-Java.html#%E6%B7%BB%E5%8A%A0%E5%A6%82%E4%B8%8B%E8%AF%AD%E5%8F%A5\" target=\"_blank\" rel=\"noopener noreferrer\">#</a>添加如下语句</h3>\n<div><pre><code>PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games&quot;\nexport JAVA_HOME=/usr/local/java/jdk1.8.0_152\nexport JRE_HOME=/usr/local/java/jdk1.8.0_152/jre\nexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"配置用户环境变量\"> 配置用户环境变量</h3>\n<div><pre><code>nano /etc/profile\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"添加如下语句-2\"> 添加如下语句</h3>\n<div><pre><code>if [ &quot;$PS1&quot; ]; then\n  if [ &quot;$BASH&quot; ] &amp;amp;&amp;amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then\n    # The file bash.bashrc already sets the default PS1.\n    # PS1=&#39;\\h:\\w\\$ &#39;\n    if [ -f /etc/bash.bashrc ]; then\n      . /etc/bash.bashrc\n    fi\n  else\n    if [ &quot;`id -u`&quot; -eq 0 ]; then\n      PS1=&#39;# &#39;\n    else\n      PS1=&#39;$ &#39;\n    fi\n  fi\nfi\n\nexport JAVA_HOME=/usr/local/java/jdk1.8.0_152\nexport JRE_HOME=/usr/local/java/jdk1.8.0_152/jre\nexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib\nexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOME/bin\n\nif [ -d /etc/profile.d ]; then\n  for i in /etc/profile.d/*.sh; do\n    if [ -r $i ]; then\n      . $i\n    fi\n  done\n  unset i\nfi\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"使用户环境变量生效\"> 使用户环境变量生效</h3>\n<div><pre><code>source /etc/profile\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"测试是否安装成功\"> 测试是否安装成功</h2>\n<div><pre><code>root@UbuntuBase:/usr/local/java# java -version\njava version &quot;1.8.0_152&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_152-b16)\nJava HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"为其他用户更新用户环境变量\"> 为其他用户更新用户环境变量</h2>\n<div><pre><code>su lusifer\nsource /etc/profile\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>",
      "date_published": "2020-01-24T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux下安装tomcat（详细教程）",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux13%20-%20Linux%E4%B8%8B%E5%AE%89%E8%A3%85Tomcat%EF%BC%88%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%EF%BC%89/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux13%20-%20Linux%E4%B8%8B%E5%AE%89%E8%A3%85Tomcat%EF%BC%88%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%EF%BC%89/",
      "content_html": "<h1 id=\"linux下安装tomcat-详细教程\"> Linux下安装tomcat（详细教程）</h1>\n<h3 id=\"_1-将tomcat-tar-gz文件上传到服务器\"> 1. 将tomcat.tar.gz文件上传到服务器</h3>\n<h3 id=\"_2-切换到tomcat压缩包的目录\"> 2. 切换到tomcat压缩包的目录</h3>\n<div><pre><code>cd 你放tomcat的目录\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>示例</p>\n<p>我的tomcat放在/opt/package目录下</p>\n<p>cd /opt/package</p>\n</blockquote>\n<h3 id=\"_3-查看是否有tomcat压缩包\"> 3. 查看是否有tomcat压缩包</h3>\n<div><pre><code>ls\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_4-解压tomcat\"> 4. 解压tomcat</h3>\n<div><pre><code>tar -zxvf apache-tomcat-7.0.61.tar.gz \n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_5-启动tomcat\"> 5. 启动tomcat</h3>\n<p>进入tomcat的bin目录下</p>\n<div><pre><code>cd apache-tomcat-7.0.61/bin\n</code></pre>\n<div><span>1</span><br></div></div><p>启动tomcat</p>\n<div><pre><code>sh startup.sh\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200403154239-482110.png\" alt=\"image-20200403154238915\" /></p>\n<h3 id=\"_6-查看防火墙状态\"> 6. 查看防火墙状态</h3>\n<p>命令</p>\n<div><pre><code>systemctl status firewalld.service\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200403151925-577176.png\" alt=\"image-20200403151456181\" /></p>\n<p>绿色的active(running)表示正在防火墙正在运行，需要关闭防火墙</p>\n<h3 id=\"_7-关闭防火墙\"> 7. 关闭防火墙</h3>\n<div><pre><code>systemctl stop firewalld.service\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200403151532-768536.png\" alt=\"image-20200403151532102\" /></p>\n<h3 id=\"_8-浏览器访问tomcat\"> 8. 浏览器访问tomcat</h3>\n<p>浏览器输入http://192.168.1.5:8080/</p>\n<blockquote>\n<p>把192.168.1.5换成你自己的ip</p>\n</blockquote>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200403154239-482110.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Centos7 卸载rpm安装包",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux15%20-%20Centos7%20%E5%8D%B8%E8%BD%BDrpm%E5%AE%89%E8%A3%85%E5%8C%85/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux15%20-%20Centos7%20%E5%8D%B8%E8%BD%BDrpm%E5%AE%89%E8%A3%85%E5%8C%85/",
      "content_html": "<h1 id=\"centos7-卸载rpm安装包\"> Centos7 卸载rpm安装包</h1>\n<p>查看rpm安装包列表：</p>\n<div><pre><code>rpm -qa|grep mysql\n</code></pre>\n</div><p>正常卸载：</p>\n<div><pre><code>rpm -e mysql-community-client-5.6.44-2.el7.x86_64\n</code></pre>\n</div><p>强制卸载：</p>\n<div><pre><code>rpm -e mysql-community-client-5.6.44-2.el7.x86_64 --nodeps\n</code></pre>\n</div>",
      "date_published": "2020-02-27T00:00:00.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "CentOS7下安装Maven",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux16%20-%20CentOS%E4%B8%8B%E5%AE%89%E8%A3%85Maven/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux16%20-%20CentOS%E4%B8%8B%E5%AE%89%E8%A3%85Maven/",
      "content_html": "<h1 id=\"centos7下安装maven\"> CentOS7下安装Maven</h1>\n<ol>\n<li>\n<p>创建存放maven的目录</p>\n<div><pre><code><span>mkdir</span> /usr/local/maven\n</code></pre>\n<div><span>1</span><br></div></div></li>\n<li>\n<p>切换到maven目录，下载maven</p>\n<div><pre><code><span>cd</span> /usr/local/maven\n\n<span>wget</span> https://zysd-shanghai.oss-cn-shanghai.aliyuncs.com/software/linux/maven/apache-maven-3.6.1-bin.tar.gz\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>\n<li>\n<p>解压压缩包</p>\n<div><pre><code><span>tar</span> -zxvf apache-maven-3.6.1-bin.tar.gz\n</code></pre>\n<div><span>1</span><br></div></div><p>得到一个<code>apache-maven-3.6.1</code>的文件夹</p>\n<p>如果觉得名字长，可以用mv命令重命名一下将名字改为maven3</p>\n<div><pre><code><span>mv</span> apache-maven-3.6.1 maven3\n</code></pre>\n<div><span>1</span><br></div></div></li>\n<li>\n<p>配置环境变量</p>\n<p>编辑profile文件进行配置环境变量</p>\n<div><pre><code><span>vim</span>  /etc/profile \n</code></pre>\n<div><span>1</span><br></div></div><p>配置的内容，在profile 文件最下面添加如下内容</p>\n<div><pre><code><span># set mvn </span>\n<span>export</span> <span>M2_HOME</span><span>=</span>/usr/local/maven3\n<span>export</span> <span><span>PATH</span></span><span>=</span><span>$PATH</span><span>:</span><span>$JAVA_HOME</span>/bin:<span>$M2_HOME</span>/bin\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>重启加载profile让系统文件生效</p>\n<div><pre><code><span>source</span>  /etc/profile \n</code></pre>\n<div><span>1</span><br></div></div><p>验证是否安装成功</p>\n<div><pre><code>mvn -version\n</code></pre>\n<div><span>1</span><br></div></div><p>输出如下内容，则表明安装成功</p>\n</li>\n</ol>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "同步时间",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux17%20-%20%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux17%20-%20%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4/",
      "content_html": "<h1 id=\"同步时间\"> 同步时间</h1>\n<p><strong>检查当前时间</strong></p>\n<div><pre><code>date\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>安装ntpdate工具</strong></p>\n<div><pre><code>yum -y <span>install</span> ntp ntpdate\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>设置系统时间与网络时间同步</strong></p>\n<div><pre><code>ntpdate cn.pool.ntp.org\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>将系统时间写入硬件时间</strong></p>\n<div><pre><code>hwclock --systohc\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux下安装Tengine",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux14%20-%20Linux%E4%B8%8B%E5%AE%89%E8%A3%85Tengine/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux14%20-%20Linux%E4%B8%8B%E5%AE%89%E8%A3%85Tengine/",
      "content_html": "<h1 id=\"linux下安装tengine\"> Linux下安装Tengine</h1>\n<h3 id=\"_1-将安装包上传至服务器\"> 1. 将安装包上传至服务器</h3>\n<h3 id=\"_2-解压安装包\"> 2. 解压安装包</h3>\n<div><pre><code><span>tar</span> -zxvf tengine-2.1.0.tar.gz\n</code></pre>\n<div><span>1</span><br></div></div><p>切换到目录</p>\n<div><pre><code><span>cd</span> tengine-2.1.0\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_3-安装依赖软件\"> 3. 安装依赖软件</h3>\n<h4 id=\"_3-1-安装gcc\"> 3.1 安装gcc</h4>\n<div><pre><code>yum <span>install</span> gcc\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_3-2-预编译tengine\"> 3.2 预编译tengine</h4>\n<div><pre><code>./configure --prefix<span>=</span>/usr/tengine-2.1.0\n</code></pre>\n<div><span>1</span><br></div></div><p>报错，需安装pcre</p>\n<h4 id=\"_3-3-安装pcre\"> 3.3 安装pcre</h4>\n<div><pre><code>yum <span>install</span> pcre pcre-devel\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200408161357-390850.png\" alt=\"image-20200408161356831\" /></p>\n<h4 id=\"_3-4-重新预编译\"> 3.4 重新预编译</h4>\n<div><pre><code>./configure --prefix<span>=</span>/usr/tengine-2.1.0\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200408161512-657368.png\" alt=\"image-20200408161512089\" /></p>\n<p>报错，需安装OpenSSL</p>\n<h4 id=\"_3-5-安装openssl\"> 3.5 安装OpenSSL</h4>\n<div><pre><code>yum <span>install</span> openssl-devel\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200408161703-599793.png\" alt=\"image-20200408161703017\" /></p>\n<h4 id=\"_3-6-重新预编译\"> 3.6 重新预编译</h4>\n<div><pre><code>./configure --prefix<span>=</span>/usr/tengine-2.1.0\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200408161816-850521.png\" alt=\"image-20200408161816294\" /></p>\n<p>出现上图情况说明安装成功。</p>\n<h3 id=\"_4-编译\"> 4. 编译</h3>\n<div><pre><code>make\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_5-编译安装\"> 5. 编译安装</h3>\n<div><pre><code><span>make</span> <span>install</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200408162148-752025.png\" alt=\"image-20200408162146763\" /></p>\n<h3 id=\"_6-进入tengine的安装目录\"> 6. 进入tengine的安装目录</h3>\n<div><pre><code><span>cd</span> /usr/tengine-2.1.0/\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_7-启动nginx\"> 7. 启动nginx</h3>\n<div><pre><code>./sbin/nginx\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_8-关闭防火墙\"> 8. 关闭防火墙</h3>\n<p>查看防火墙状态</p>\n<div><pre><code>systemctl status firewalld.service\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200408162635-962131.png\" alt=\"image-20200408162634944\" /></p>\n<p>如果是active(running)状态，表示开启状态，需关闭</p>\n<p>关闭防火墙</p>\n<div><pre><code>systemctl stop firewalld.service\n</code></pre>\n<div><span>1</span><br></div></div><p>再次查看防火墙状态</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200408162810-444741.png\" alt=\"image-20200408162810389\" /></p>\n<p>上图表示已关闭防火墙</p>\n<h3 id=\"_9-浏览器访问服务器的tengine\"> 9. 浏览器访问服务器的Tengine</h3>\n<p>浏览器输入服务器地址即可</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200408163100-332967.png\" alt=\"image-20200408163100400\" /></p>\n",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200408161357-390850.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "修改主机名",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux18%20-%20%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/Linux18%20-%20%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D/",
      "content_html": "<h1 id=\"修改主机名\"> 修改主机名</h1>\n<p>命令</p>\n<div><pre><code>hostnamectl set-hostname 主机名\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "Linux",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/",
      "content_html": "<h1 id=\"linux\"> Linux</h1>\n<img :src=\"$withBase=('/note_images/linux.jpg')\"/>\n<p>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>\n",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "安装KVM",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/kvm/%E5%AE%89%E8%A3%85KVM/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/kvm/%E5%AE%89%E8%A3%85KVM/",
      "content_html": "<h1 id=\"安装kvm\"> 安装KVM</h1>\n<h5 id=\"_1-cpu检测\"> 1. CPU检测</h5>\n<div><pre><code><span>egrep</span> -c <span>'(vmx|svm)'</span> /proc/cpuinfo\n</code></pre>\n<div><span>1</span><br></div></div><p>命令结果大于0表示cpu支持虚拟化</p>\n<h5 id=\"_2-安装命令kvm\"> 2. 安装命令kvm</h5>\n<div><pre><code>yum <span>install</span> -y qemu-kvm\n</code></pre>\n<div><span>1</span><br></div></div><h5 id=\"_3-安装虚拟化管理工具\"> 3. 安装虚拟化管理工具</h5>\n<div><pre><code>yum <span>install</span> -y virt-manager libvirt libvirt-python python-virtinst bridge-utils\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>libvirt：操作和管理KVM虚机的虚拟化 API，使用 C 语言编写，可以由 Python,Ruby, Perl, PHP, Java 等语言调用。可以操作包括 KVM，vmware，XEN，Hyper-v, LXC 等 Hypervisor。</p>\n<p>Virsh：基于 libvirt 的 命令行工具 （CLI）</p>\n<p>Virt-Manager：基于 libvirt 的 GUI 工具</p>\n</blockquote>\n<h5 id=\"_4-查看kvm-内核模块\"> 4. 查看<strong>kvm</strong> 内核模块</h5>\n<div><pre><code>lsmod <span>|</span> <span>grep</span> kvm\nmodprobe kvm\nmodprobe kvm-intel\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h5 id=\"_5-查看libvirt\"> 5. 查看libvirt</h5>\n<p>关闭防火墙</p>\n<div><pre><code><span>service</span> firewalld stop\n</code></pre>\n<div><span>1</span><br></div></div><p>开启libvirt</p>\n<div><pre><code><span>service</span> libvirtd restart\n<span>chkconfig</span> libvirtd on\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h5 id=\"_6-创建虚拟机硬盘\"> 6. 创建虚拟机硬盘</h5>\n<p>创建文件夹</p>\n<div><pre><code><span>mkdir</span> -p /kvmtest/centos7\n</code></pre>\n<div><span>1</span><br></div></div><p>创建安装盘</p>\n<div><pre><code>qemu-img create -f qcow2 /kvmtest/centos7/centos7.qcow2 10G\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>默认网络配置文件</p>\n<p>/etc/libvirt/qemu/networks</p>\n</blockquote>\n<h5 id=\"_7-创建虚拟机\"> 7. 创建虚拟机</h5>\n<p>下载centos，下载地址：http://mirrors.aliyun.com/centos/7.8.2003/isos/x86_64/</p>\n<p>将iCentOS-7-x86_64-Minimal-2003.iso文件上传到服务器</p>\n<p>创建虚拟机</p>\n<div><pre><code>virt-install --virt-type kvm --name centos7 --ram <span>1024</span> <span>\\</span>\n--vcpus <span>1</span> <span>\\</span>\n--cdrom<span>=</span>/kvmtest/centos7/CentOS-7-x86_64-Minimal-2003.iso <span>\\</span>\n--disk /kvmtest/centos7/centos7.qcow2,format<span>=</span>qcow2 <span>\\</span>\n--network <span>network</span><span>=</span>default <span>\\</span>\n--graphics vnc,listen<span>=</span><span>0.0</span>.0.0 --noautoconsole <span>\\</span>\n--os-type<span>=</span>linux --os-variant<span>=</span>rhel6\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"_8-连接\"> 8. 连接</h5>\n<p>查看端口</p>\n<div><pre><code><span>netstat</span> -natp\n</code></pre>\n<div><span>1</span><br></div></div><h5 id=\"_9-使用vnc软件连接\"> 9.使用vnc软件连接</h5>\n<p>点击ok之后出现centos的安装界面，自己手动安装即可</p>\n<p>安装完之后重启</p>\n<h5 id=\"_10-使用virsh\"> 10. 使用virsh</h5>\n<div><pre><code><span>virsh</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>查看虚拟机</p>\n<div><pre><code>list --all\n</code></pre>\n<div><span>1</span><br></div></div><p>启动虚拟机</p>\n<div><pre><code>start centos7\n</code></pre>\n<div><span>1</span><br></div></div><h5 id=\"_11-打开vnc\"> 11. 打开VNC</h5>\n<p>此时已经启动安装的虚拟机了。</p>\n<h2 id=\"配置桥接网络\"> 配置桥接网络</h2>\n<blockquote>\n<p>在宿主机上操作</p>\n</blockquote>\n<div><pre><code><span>vim</span> ifcfg-ens33\n</code></pre>\n<div><span>1</span><br></div></div><p>内容如下</p>\n<div><pre><code>TYPE=Ethernet\nPROXY_METHOD=none\nBROWSER_ONLY=no\nBOOTPROTO=static\nDEFROUTE=yes\nIPV4_FAILURE_FATAL=no\nIPV6INIT=yes\nIPV6_AUTOCONF=yes\nIPV6_DEFROUTE=yes\nIPV6_FAILURE_FATAL=no\nIPV6_ADDR_GEN_MODE=stable-privacy\nNAME=ens33\nUUID=7adeb72e-13ae-47d8-8bc3-2f8e89701bad\nDEVICE=ens33\n# 添加网桥\nBRIDGE=br0\nONBOOT=yes\nIPADDR=192.168.0.30\nNETMASK=255.255.255.0\nGATEWAY=192.168.0.2\nDNS1=8.8.8.8\nDNS2=114.114.114.114\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>将ifcfg-ens33复制一份文件，用来做网桥的配置文件</p>\n<div><pre><code><span>cp</span> ifcfg-ens33 ifcfg-br0\n</code></pre>\n<div><span>1</span><br></div></div><p>内容如下</p>\n<div><pre><code>TYPE=Bridge\nPROXY_METHOD=none\nBROWSER_ONLY=no\nBOOTPROTO=static\nDEFROUTE=yes\nNAME=ens33\nDEVICE=br0\nONBOOT=yes\nIPADDR=192.168.0.30\nNETMASK=255.255.255.0\nGATEWAY=192.168.0.2\nDNS1=8.8.8.8\nDNS2=114.114.114.114\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>使用virsh</p>\n<div><pre><code><span>virsh</span>\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>net-edit default\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>\nnet-define /etc/libvirt/qemu/networks/default.xml\n\nnet-destroy default\n\nnet-start default\n\n<span># 关闭重启（冷启动）</span>\n<span>shutdown</span> centos7\nstart centos7\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"遇到的问题\"> 遇到的问题</h2>\n<h3 id=\"问题1\"> 问题1</h3>\n<p>-bash: virt-install: command not found</p>\n<p>安装</p>\n<div><pre><code>yum <span>install</span> -y libguestfs-tools\n\nyum <span>install</span> -y virt-install.noarch\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "远程控制KVM",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/kvm/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6KVM/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/kvm/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6KVM/",
      "content_html": "<h1 id=\"远程控制kvm\"> 远程控制KVM</h1>\n<p>编辑文件/etc/sysconfig/libvirtd</p>\n<div><pre><code><span>vim</span> /etc/sysconfig/libvirtd\n</code></pre>\n<div><span>1</span><br></div></div><p>编辑配置文件/etc/libvirt/libvirtd.conf</p>\n<div><pre><code><span>vim</span> /etc/libvirt/libvirtd.conf\n</code></pre>\n<div><span>1</span><br></div></div><p>打开以下注释</p>\n<div><pre><code>listen_tls <span>=</span> <span>0</span>\nlisten_tcp <span>=</span> <span>1</span>\ntcp_port <span>=</span> <span>\"16509\"</span>\nlisten_addr <span>=</span> <span>\"0.0.0.0\"</span>\nauth_tcp <span>=</span> <span>\"none\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>重启libvirtd服务</p>\n<div><pre><code><span>service</span> libvirtd restart \n</code></pre>\n<div><span>1</span><br></div></div><p>使用virsh远程调用</p>\n<div><pre><code><span>virsh</span> -c qemu+tcp://192.168.0.31/system\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"使用程序控制kvm\"> 使用程序控制KVM</h3>\n<p>使用java控制kvm</p>\n<div><pre><code><span>package</span> <span>kvm</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>libvirt<span>.</span></span><span>Connect</span><span>;</span>\n<span>import</span> <span>org<span>.</span>libvirt<span>.</span></span><span>LibvirtExcption</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>TestKvm</span><span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>\n        <span>try</span><span>{</span>\n            <span>Connect</span> conn <span>=</span> <span>new</span> <span>Connect</span><span>(</span><span>\"qemu+tcp://192.168.0.31/system\"</span><span>)</span><span>;</span>\n            <span>// 打开虚拟机</span>\n            conn<span>.</span><span>domainLookupByName</span><span>(</span><span>\"centos7\"</span><span>)</span><span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\n            <span>// 关闭虚拟机</span>\n            conn<span>.</span><span>domainLookupByName</span><span>(</span><span>\"centos7\"</span><span>)</span><span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "虚拟机快照",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/kvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BF%AB%E7%85%A7/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/kvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BF%AB%E7%85%A7/",
      "content_html": "<h1 id=\"虚拟机快照\"> 虚拟机快照</h1>\n<p><strong>创建快照</strong></p>\n<ul>\n<li>\n<p>snapshot-create 虚拟机名字</p>\n<blockquote>\n<p>不指定快照名称</p>\n</blockquote>\n</li>\n<li>\n<p>snapshot-create-as 虚拟机名字</p>\n<blockquote>\n<p>指定快照名称</p>\n</blockquote>\n</li>\n</ul>\n<div><pre><code>snapshot-create centos7\nsnapshot-create-as centos7\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><strong>恢复快照</strong></p>\n<ul>\n<li>snapshot-revert 虚拟机名字  快照名称</li>\n</ul>\n<div><pre><code>snapshot-revert centos7 <span>1593336423</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>查看快照列表</strong></p>\n<ul>\n<li>snapshot-list 虚拟机名字</li>\n</ul>\n<div><pre><code>snapshot-list centos7\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "配置桥接网络",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/kvm/%E9%85%8D%E7%BD%AE%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/kvm/%E9%85%8D%E7%BD%AE%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C/",
      "content_html": "<h1 id=\"配置桥接网络\"> 配置桥接网络</h1>\n<h3 id=\"桥接模式下nat上网\"> 桥接模式下NAT上网</h3>\n<blockquote>\n<p>在宿主机上操作</p>\n</blockquote>\n<div><pre><code><span>vim</span> ifcfg-ens33\n</code></pre>\n<div><span>1</span><br></div></div><p>内容如下</p>\n<div><pre><code>TYPE=Ethernet\nPROXY_METHOD=none\nBROWSER_ONLY=no\nBOOTPROTO=static\nDEFROUTE=yes\nIPV4_FAILURE_FATAL=no\nIPV6INIT=yes\nIPV6_AUTOCONF=yes\nIPV6_DEFROUTE=yes\nIPV6_FAILURE_FATAL=no\nIPV6_ADDR_GEN_MODE=stable-privacy\nNAME=ens33\nUUID=7adeb72e-13ae-47d8-8bc3-2f8e89701bad\nDEVICE=ens33\nONBOOT=yes\nIPADDR=192.168.0.30\nNETMASK=255.255.255.0\nGATEWAY=192.168.0.2\nDNS1=8.8.8.8\nDNS2=114.114.114.114\n\n# 添加网桥\nBRIDGE=br0\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>将ifcfg-ens33复制一份文件，用来做网桥的配置文件</p>\n<div><pre><code><span>cp</span> ifcfg-ens33 ifcfg-br0\n<span>vim</span> ifcfg-br0\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>内容如下</p>\n<div><pre><code>TYPE=Bridge\nPROXY_METHOD=none\nBROWSER_ONLY=no\nBOOTPROTO=static\nDEFROUTE=yes\nNAME=ens33\nDEVICE=br0\nONBOOT=yes\nIPADDR=192.168.0.30\nNETMASK=255.255.255.0\nGATEWAY=192.168.0.2\nDNS1=8.8.8.8\nDNS2=114.114.114.114\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>重启网络</p>\n<div><pre><code><span>service</span> network restart\n</code></pre>\n<div><span>1</span><br></div></div><p>使用virsh</p>\n<div><pre><code><span>virsh</span>\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>net-edit default\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>net-define /etc/libvirt/qemu/networks/default.xml\nnet-destroy default\nnet-start default\n\n<span># 关闭重启（冷启动）</span>\n<span>shutdown</span> centos7\nstart centos7\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"使用桥接模式上网\"> 使用桥接模式上网</h3>\n<div><pre><code>edit centos7\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code><span># 关闭重启（冷启动）</span>\n<span>shutdown</span> centos7\nstart centos7\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "出现的问题",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/",
      "content_html": "<h1 id=\"出现的问题\"> 出现的问题</h1>\n<h2 id=\"问题1\"> 问题1</h2>\n<h3 id=\"问题\"> 问题</h3>\n<p>重启网络时</p>\n<p><img src=\"https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200424182357-313460.png\" alt=\"image-20200424182356781\" /></p>\n<h3 id=\"解决\"> 解决</h3>\n<p>关闭NetworkManager</p>\n<div><pre><code>systemctl stop NetworkManager\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"问题2\"> 问题2</h2>\n<h3 id=\"问题-2\"> 问题</h3>\n<p>Another app is currently holding the yum lock; waiting for it to exit...</p>\n<h3 id=\"解决-2\"> 解决</h3>\n<p>可以通过强制关掉yum进程：</p>\n<div><pre><code><span>rm</span> -f /var/run/yum.pid\n</code></pre>\n<div><span>1</span><br></div></div>",
      "image": "https://alanlee-image-bed.oss-cn-shenzhen.aliyuncs.com/note_images/20200424182357-313460.png",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:28.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "简介",
      "url": "http://blog.alanlee.top/blog-vuepress/server/linux/%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/",
      "id": "http://blog.alanlee.top/blog-vuepress/server/linux/%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/",
      "content_html": "<h2 id=\"简介\"> 简介</h2>\n<p>CentOS，是基于 Red Hat Linux 提供的可自由使用源代码的企业级 Linux 发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台。</p>\n<h2 id=\"配置方法\"> 配置方法</h2>\n<h3 id=\"_1-备份\"> 1. 备份</h3>\n<div><pre><code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-下载新的-centos-base-repo-到-etc-yum-repos-d\"> 2. 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/</h3>\n<p><strong>CentOS 6</strong></p>\n<div><pre><code>wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-6.repo\n</code></pre>\n<div><span>1</span><br></div></div><p>或者</p>\n<div><pre><code>curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-6.repo\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>CentOS 7</strong></p>\n<div><pre><code>wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo\n</code></pre>\n<div><span>1</span><br></div></div><p>或者</p>\n<div><pre><code>curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>CentOS 8</strong></p>\n<div><pre><code>wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo\n</code></pre>\n<div><span>1</span><br></div></div><p>或者</p>\n<div><pre><code>curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_3-运行-yum-makecache-生成缓存\"> 3. 运行 yum makecache 生成缓存</h3>\n<div><pre><code>yum makecache\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_4-其他\"> 4. 其他</h3>\n<p>非阿里云ECS用户会出现 Couldn't resolve host 'mirrors.cloud.aliyuncs.com' 信息，不影响使用。用户也可自行修改相关配置: eg:</p>\n<div><pre><code>sed -i -e &#39;/mirrors.cloud.aliyuncs.com/d&#39; -e &#39;/mirrors.aliyuncs.com/d&#39; /etc/yum.repos.d/CentOS-Base.repo\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2021-10-03T07:08:06.000Z",
      "date_modified": "2021-10-03T07:08:06.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "项目主页",
      "url": "http://blog.alanlee.top/blog-vuepress/zh/home/",
      "id": "http://blog.alanlee.top/blog-vuepress/zh/home/",
      "content_html": "<p>这是普通主页的案例。你可以在这里放置你的主体内容。</p>\n<p>想要使用此布局，你需要在页面 front matter 中设置 <code>home: true</code>。</p>\n<p>配置项的相关说明详见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/layout/home/\" target=\"_blank\" rel=\"noopener noreferrer\">项目主页配置</a>。</p>\n",
      "date_published": "2021-10-03T03:15:29.000Z",
      "date_modified": "2021-10-03T03:15:29.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    },
    {
      "title": "博客主页",
      "url": "http://blog.alanlee.top/blog-vuepress/zh/",
      "id": "http://blog.alanlee.top/blog-vuepress/zh/",
      "content_html": "<p>这是一个博客主页。</p>\n<p>要使用此布局，您应该在页面前端设置 <code>blog: true</code> 和 <code>home: true</code>。</p>\n<p>相关配置文档请见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/blog/home/\" target=\"_blank\" rel=\"noopener noreferrer\">博客主页</a></p>\n",
      "date_published": "2021-10-03T03:15:29.000Z",
      "date_modified": "2021-10-03T03:15:29.000Z",
      "authors": [
        {
          "name": "AlanLee"
        }
      ],
      "tags": []
    }
  ]
}